(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ractiveTransitionsFade = require('ractive-transitions-fade');

var _ractiveTransitionsFade2 = _interopRequireDefault(_ractiveTransitionsFade);

var _ractive = require('ractive');

var _ractive2 = _interopRequireDefault(_ractive);

var _home = require('../pages/home.html');

var _home2 = _interopRequireDefault(_home);

var _header = require('./components/header');

var _header2 = _interopRequireDefault(_header);

var _navbar = require('./components/navbar');

var _navbar2 = _interopRequireDefault(_navbar);

var _newsletterForm = require('./components/newsletter-form');

var _newsletterForm2 = _interopRequireDefault(_newsletterForm);

var _phrases = require('./phrases.json');

var _phrases2 = _interopRequireDefault(_phrases);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// set global fade
_ractive2.default.transitions.fade = _ractiveTransitionsFade2.default;

var createApp = function createApp(config) {
  var el = config.el,
      _config$language = config.language,
      language = _config$language === undefined ? 'nl' : _config$language;


  var app = new _ractive2.default({
    el: el,
    template: _home2.default,
    components: {
      newsletterForm: _newsletterForm2.default,
      header: _header2.default,
      navbar: _navbar2.default
    },
    data: {
      language: language,
      i18n: null,
      newsletterForm: {
        show: false,
        firstName: null,
        lastName: null,
        email: null,
        country: null,
        language: null,
        gender: null
      }
    },
    oninit: function oninit() {
      this.set('i18n', _phrases2.default[this.get('language')]);
      console.log(this.get('i18n'));
    }
  });

  app.on({
    'navbar.showNewsletterForm': function navbarShowNewsletterForm(e) {
      this.set('newsletterForm.show', !this.get('newsletterForm.show'));
    },
    'navbar.setLanguage': function navbarSetLanguage(e) {
      var target = e.original.target;
      var lang = target.options[target.selectedIndex].id;
      this.set('language', lang);
      this.set('i18n', _phrases2.default[lang]);
    }
  });

  return app;
};

exports.default = createApp;

},{"../pages/home.html":306,"./components/header":2,"./components/navbar":3,"./components/newsletter-form":4,"./phrases.json":6,"ractive":304,"ractive-transitions-fade":303}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ractiveTransitionsFade = require('ractive-transitions-fade');

var _ractiveTransitionsFade2 = _interopRequireDefault(_ractiveTransitionsFade);

var _ractive = require('ractive');

var _ractive2 = _interopRequireDefault(_ractive);

var _index = require('../../partials/header/index.html');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var header = _ractive2.default.extend({
  template: _index2.default
});
//import R from 'ramda'
exports.default = header;

},{"../../partials/header/index.html":307,"ractive":304,"ractive-transitions-fade":303}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ractiveTransitionsFade = require('ractive-transitions-fade');

var _ractiveTransitionsFade2 = _interopRequireDefault(_ractiveTransitionsFade);

var _ractive = require('ractive');

var _ractive2 = _interopRequireDefault(_ractive);

var _index = require('../../partials/navbar/index.html');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var header = _ractive2.default.extend({
  template: _index2.default
});
//import R from 'ramda'
exports.default = header;

},{"../../partials/navbar/index.html":308,"ractive":304,"ractive-transitions-fade":303}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ractiveTransitionsFade = require('ractive-transitions-fade');

var _ractiveTransitionsFade2 = _interopRequireDefault(_ractiveTransitionsFade);

var _ractive = require('ractive');

var _ractive2 = _interopRequireDefault(_ractive);

var _index = require('../../partials/newsletter-form/index.html');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var form = _ractive2.default.extend({
  template: _index2.default,
  oninit: function oninit() {
    this.on('validateForm', function () {
      window.alert('to purescript (in due course)');
    });
  }
});
//import R from 'ramda'


form.transitions.fade = _ractiveTransitionsFade2.default;

exports.default = form;

},{"../../partials/newsletter-form/index.html":309,"ractive":304,"ractive-transitions-fade":303}],5:[function(require,module,exports){
'use strict';

require('babel-polyfill');

var _app = require('./app');

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.onload = function () {
  (0, _app2.default)({
    el: '#app',
    language: 'en'
  });
};

},{"./app":1,"babel-polyfill":7}],6:[function(require,module,exports){
module.exports={"en":{"navbar":{"newsletterButton":"Subscribe to our newsletter!"},"header":{"text":"This is a header!"},"newsletterForm":{"header":"Subscribe to our newsletter!","body":"Stay informed about our campains and don't miss out on any promotion! After submitting this form you will receive a confirmation email.","titleEmail":"E-mail Address","titleFirstName":"First name","titleLastName":"Last name","titleLanguage":"Language","languages":{"en":"English (English)","de":"German (Deutsch)","nl":"Dutch (Nederlands)","es":"Spanish (Español)","fr":"French (Français)"},"titleCountry":"Country","titleGender":"Gender","gender":{"m":"Male","f":"Female"},"buttonSubmit":"Submit"}},"nl":{"navbar":{"newsletterButton":"Abonneert u allen op onze nieuwsbrief!"},"header":{"text":"Dit is een header!"},"newsletterForm":{"header":"Meldt u aan voor onze nieuwsbrief!","body":"Blijf op de hoogte van onze campagnes en mis nooit meer een aktie! Na de aanmelding krijgt u een bevestigings email.","titleEmail":"E-mail adres","titleFirstName":"Voornaam","titleLastName":"Achternaam","titleLanguage":"Taal","languages":{"nl":"Nederlands (Nederlands)","de":"Duits (Deutsch)","en":"Engels (English)","es":"Spaans (Español)","fr":"Frans (Français)"},"titleCountry":"Land","titleGender":"Geschlacht","gender":{"m":"Man","f":"Vrouw"},"buttonSubmit":"Verstuur"}},"de":{"navbar":{"newsletterButton":"Abonnieren Sie sich auf unsere Newsletter!"},"header":{"text":"Dies ist ein Köpfer!"},"newsletterForm":{"header":"Melden Sie sich für unseren Newsletter an!","body":"Bleiben Sie auf dem Laufenden mit unseren Kampagnen und verpassen Sie keine unserer Aktionen mehr! Nach der Anmeldung erhalten Sie eine Bestätigung per E-Mail.","titleEmail":"E-mail Adresse","titleFirstName":"Vorname","titleLastName":"Nachname","titleLanguage":"Sprache","languages":{"de":"Deutsch (Deutsch)","en":"Englisch (English)","nl":"Holländisch (Nederlands)","es":"Spanisch (Español)","fr":"Französisch (Français)"},"titleCountry":"Land","titleGender":"Geschlecht","gender":{"m":"Männlich","f":"Weiblich"},"buttonSubmit":"Absenden"}}}
},{}],7:[function(require,module,exports){
(function (global){
"use strict";

require("core-js/shim");

require("regenerator-runtime/runtime");

require("core-js/fn/regexp/escape");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"core-js/fn/regexp/escape":8,"core-js/shim":301,"regenerator-runtime/runtime":305}],8:[function(require,module,exports){
require('../../modules/core.regexp.escape');
module.exports = require('../../modules/_core').RegExp.escape;
},{"../../modules/_core":29,"../../modules/core.regexp.escape":125}],9:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],10:[function(require,module,exports){
var cof = require('./_cof');
module.exports = function(it, msg){
  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
  return +it;
};
},{"./_cof":24}],11:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables')
  , ArrayProto  = Array.prototype;
if(ArrayProto[UNSCOPABLES] == undefined)require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function(key){
  ArrayProto[UNSCOPABLES][key] = true;
};
},{"./_hide":46,"./_wks":123}],12:[function(require,module,exports){
module.exports = function(it, Constructor, name, forbiddenField){
  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};
},{}],13:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":55}],14:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object')
  , toIndex  = require('./_to-index')
  , toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
  var O     = toObject(this)
    , len   = toLength(O.length)
    , to    = toIndex(target, len)
    , from  = toIndex(start, len)
    , end   = arguments.length > 2 ? arguments[2] : undefined
    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
    , inc   = 1;
  if(from < to && to < from + count){
    inc  = -1;
    from += count - 1;
    to   += count - 1;
  }
  while(count-- > 0){
    if(from in O)O[to] = O[from];
    else delete O[to];
    to   += inc;
    from += inc;
  } return O;
};
},{"./_to-index":111,"./_to-length":114,"./_to-object":115}],15:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object')
  , toIndex  = require('./_to-index')
  , toLength = require('./_to-length');
module.exports = function fill(value /*, start = 0, end = @length */){
  var O      = toObject(this)
    , length = toLength(O.length)
    , aLen   = arguments.length
    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
    , end    = aLen > 2 ? arguments[2] : undefined
    , endPos = end === undefined ? length : toIndex(end, length);
  while(endPos > index)O[index++] = value;
  return O;
};
},{"./_to-index":111,"./_to-length":114,"./_to-object":115}],16:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function(iter, ITERATOR){
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":43}],17:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length')
  , toIndex   = require('./_to-index');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};
},{"./_to-index":111,"./_to-iobject":113,"./_to-length":114}],18:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = require('./_ctx')
  , IObject  = require('./_iobject')
  , toObject = require('./_to-object')
  , toLength = require('./_to-length')
  , asc      = require('./_array-species-create');
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
},{"./_array-species-create":21,"./_ctx":31,"./_iobject":51,"./_to-length":114,"./_to-object":115}],19:[function(require,module,exports){
var aFunction = require('./_a-function')
  , toObject  = require('./_to-object')
  , IObject   = require('./_iobject')
  , toLength  = require('./_to-length');

module.exports = function(that, callbackfn, aLen, memo, isRight){
  aFunction(callbackfn);
  var O      = toObject(that)
    , self   = IObject(O)
    , length = toLength(O.length)
    , index  = isRight ? length - 1 : 0
    , i      = isRight ? -1 : 1;
  if(aLen < 2)for(;;){
    if(index in self){
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if(isRight ? index < 0 : length <= index){
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};
},{"./_a-function":9,"./_iobject":51,"./_to-length":114,"./_to-object":115}],20:[function(require,module,exports){
var isObject = require('./_is-object')
  , isArray  = require('./_is-array')
  , SPECIES  = require('./_wks')('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};
},{"./_is-array":53,"./_is-object":55,"./_wks":123}],21:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};
},{"./_array-species-constructor":20}],22:[function(require,module,exports){
'use strict';
var aFunction  = require('./_a-function')
  , isObject   = require('./_is-object')
  , invoke     = require('./_invoke')
  , arraySlice = [].slice
  , factories  = {};

var construct = function(F, len, args){
  if(!(len in factories)){
    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /*, args... */){
  var fn       = aFunction(this)
    , partArgs = arraySlice.call(arguments, 1);
  var bound = function(/* args... */){
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if(isObject(fn.prototype))bound.prototype = fn.prototype;
  return bound;
};
},{"./_a-function":9,"./_invoke":50,"./_is-object":55}],23:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof')
  , TAG = require('./_wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./_cof":24,"./_wks":123}],24:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],25:[function(require,module,exports){
'use strict';
var dP          = require('./_object-dp').f
  , create      = require('./_object-create')
  , redefineAll = require('./_redefine-all')
  , ctx         = require('./_ctx')
  , anInstance  = require('./_an-instance')
  , defined     = require('./_defined')
  , forOf       = require('./_for-of')
  , $iterDefine = require('./_iter-define')
  , step        = require('./_iter-step')
  , setSpecies  = require('./_set-species')
  , DESCRIPTORS = require('./_descriptors')
  , fastKey     = require('./_meta').fastKey
  , SIZE        = DESCRIPTORS ? '_s' : 'size';

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        anInstance(this, C, 'forEach');
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)dP(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};
},{"./_an-instance":12,"./_ctx":31,"./_defined":33,"./_descriptors":34,"./_for-of":43,"./_iter-define":59,"./_iter-step":61,"./_meta":68,"./_object-create":72,"./_object-dp":73,"./_redefine-all":92,"./_set-species":97}],26:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof')
  , from    = require('./_array-from-iterable');
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};
},{"./_array-from-iterable":16,"./_classof":23}],27:[function(require,module,exports){
'use strict';
var redefineAll       = require('./_redefine-all')
  , getWeak           = require('./_meta').getWeak
  , anObject          = require('./_an-object')
  , isObject          = require('./_is-object')
  , anInstance        = require('./_an-instance')
  , forOf             = require('./_for-of')
  , createArrayMethod = require('./_array-methods')
  , $has              = require('./_has')
  , arrayFind         = createArrayMethod(5)
  , arrayFindIndex    = createArrayMethod(6)
  , id                = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function(that){
  return that._l || (that._l = new UncaughtFrozenStore);
};
var UncaughtFrozenStore = function(){
  this.a = [];
};
var findUncaughtFrozen = function(store, key){
  return arrayFind(store.a, function(it){
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function(key){
    var entry = findUncaughtFrozen(this, key);
    if(entry)return entry[1];
  },
  has: function(key){
    return !!findUncaughtFrozen(this, key);
  },
  set: function(key, value){
    var entry = findUncaughtFrozen(this, key);
    if(entry)entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function(key){
    var index = arrayFindIndex(this.a, function(it){
      return it[0] === key;
    });
    if(~index)this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var data = getWeak(anObject(key), true);
    if(data === true)uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};
},{"./_an-instance":12,"./_an-object":13,"./_array-methods":18,"./_for-of":43,"./_has":45,"./_is-object":55,"./_meta":68,"./_redefine-all":92}],28:[function(require,module,exports){
'use strict';
var global            = require('./_global')
  , $export           = require('./_export')
  , redefine          = require('./_redefine')
  , redefineAll       = require('./_redefine-all')
  , meta              = require('./_meta')
  , forOf             = require('./_for-of')
  , anInstance        = require('./_an-instance')
  , isObject          = require('./_is-object')
  , fails             = require('./_fails')
  , $iterDetect       = require('./_iter-detect')
  , setToStringTag    = require('./_set-to-string-tag')
  , inheritIfRequired = require('./_inherit-if-required');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  var fixMethod = function(KEY){
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a){
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance             = new C
      // early implementations not supports chaining
      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
      // most early implementations doesn't supports iterables, most modern - not close it correctly
      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
      // for early implementations -0 and +0 not the same
      , BUGGY_ZERO = !IS_WEAK && fails(function(){
        // V8 ~ Chromium 42- fails only with 5+ elements
        var $instance = new C()
          , index     = 5;
        while(index--)$instance[ADDER](index, index);
        return !$instance.has(-0);
      });
    if(!ACCEPT_ITERABLES){ 
      C = wrapper(function(target, iterable){
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base, target, C);
        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
    // weak collections should not contains .clear method
    if(IS_WEAK && proto.clear)delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./_an-instance":12,"./_export":38,"./_fails":40,"./_for-of":43,"./_global":44,"./_inherit-if-required":49,"./_is-object":55,"./_iter-detect":60,"./_meta":68,"./_redefine":93,"./_redefine-all":92,"./_set-to-string-tag":98}],29:[function(require,module,exports){
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],30:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp')
  , createDesc      = require('./_property-desc');

module.exports = function(object, index, value){
  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};
},{"./_object-dp":73,"./_property-desc":91}],31:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":9}],32:[function(require,module,exports){
'use strict';
var anObject    = require('./_an-object')
  , toPrimitive = require('./_to-primitive')
  , NUMBER      = 'number';

module.exports = function(hint){
  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};
},{"./_an-object":13,"./_to-primitive":116}],33:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],34:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":40}],35:[function(require,module,exports){
var isObject = require('./_is-object')
  , document = require('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":44,"./_is-object":55}],36:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');
},{}],37:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys')
  , gOPS    = require('./_object-gops')
  , pIE     = require('./_object-pie');
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};
},{"./_object-gops":79,"./_object-keys":82,"./_object-pie":83}],38:[function(require,module,exports){
var global    = require('./_global')
  , core      = require('./_core')
  , hide      = require('./_hide')
  , redefine  = require('./_redefine')
  , ctx       = require('./_ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
    , key, own, out, exp;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target)redefine(target, key, out, type & $export.U);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;
},{"./_core":29,"./_ctx":31,"./_global":44,"./_hide":46,"./_redefine":93}],39:[function(require,module,exports){
var MATCH = require('./_wks')('match');
module.exports = function(KEY){
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch(e){
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch(f){ /* empty */ }
  } return true;
};
},{"./_wks":123}],40:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],41:[function(require,module,exports){
'use strict';
var hide     = require('./_hide')
  , redefine = require('./_redefine')
  , fails    = require('./_fails')
  , defined  = require('./_defined')
  , wks      = require('./_wks');

module.exports = function(KEY, length, exec){
  var SYMBOL   = wks(KEY)
    , fns      = exec(defined, SYMBOL, ''[KEY])
    , strfn    = fns[0]
    , rxfn     = fns[1];
  if(fails(function(){
    var O = {};
    O[SYMBOL] = function(){ return 7; };
    return ''[KEY](O) != 7;
  })){
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function(string, arg){ return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function(string){ return rxfn.call(string, this); }
    );
  }
};
},{"./_defined":33,"./_fails":40,"./_hide":46,"./_redefine":93,"./_wks":123}],42:[function(require,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function(){
  var that   = anObject(this)
    , result = '';
  if(that.global)     result += 'g';
  if(that.ignoreCase) result += 'i';
  if(that.multiline)  result += 'm';
  if(that.unicode)    result += 'u';
  if(that.sticky)     result += 'y';
  return result;
};
},{"./_an-object":13}],43:[function(require,module,exports){
var ctx         = require('./_ctx')
  , call        = require('./_iter-call')
  , isArrayIter = require('./_is-array-iter')
  , anObject    = require('./_an-object')
  , toLength    = require('./_to-length')
  , getIterFn   = require('./core.get-iterator-method')
  , BREAK       = {}
  , RETURN      = {};
var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator, result;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if(result === BREAK || result === RETURN)return result;
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    result = call(iterator, f, step.value, entries);
    if(result === BREAK || result === RETURN)return result;
  }
};
exports.BREAK  = BREAK;
exports.RETURN = RETURN;
},{"./_an-object":13,"./_ctx":31,"./_is-array-iter":52,"./_iter-call":57,"./_to-length":114,"./core.get-iterator-method":124}],44:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],45:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],46:[function(require,module,exports){
var dP         = require('./_object-dp')
  , createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":34,"./_object-dp":73,"./_property-desc":91}],47:[function(require,module,exports){
module.exports = require('./_global').document && document.documentElement;
},{"./_global":44}],48:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function(){
  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":34,"./_dom-create":35,"./_fails":40}],49:[function(require,module,exports){
var isObject       = require('./_is-object')
  , setPrototypeOf = require('./_set-proto').set;
module.exports = function(that, target, C){
  var P, S = target.constructor;
  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
    setPrototypeOf(that, P);
  } return that;
};
},{"./_is-object":55,"./_set-proto":96}],50:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],51:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./_cof":24}],52:[function(require,module,exports){
// check on default Array iterator
var Iterators  = require('./_iterators')
  , ITERATOR   = require('./_wks')('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
},{"./_iterators":62,"./_wks":123}],53:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};
},{"./_cof":24}],54:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object')
  , floor    = Math.floor;
module.exports = function isInteger(it){
  return !isObject(it) && isFinite(it) && floor(it) === it;
};
},{"./_is-object":55}],55:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],56:[function(require,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object')
  , cof      = require('./_cof')
  , MATCH    = require('./_wks')('match');
module.exports = function(it){
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};
},{"./_cof":24,"./_is-object":55,"./_wks":123}],57:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./_an-object":13}],58:[function(require,module,exports){
'use strict';
var create         = require('./_object-create')
  , descriptor     = require('./_property-desc')
  , setToStringTag = require('./_set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./_hide":46,"./_object-create":72,"./_property-desc":91,"./_set-to-string-tag":98,"./_wks":123}],59:[function(require,module,exports){
'use strict';
var LIBRARY        = require('./_library')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , hide           = require('./_hide')
  , has            = require('./_has')
  , Iterators      = require('./_iterators')
  , $iterCreate    = require('./_iter-create')
  , setToStringTag = require('./_set-to-string-tag')
  , getPrototypeOf = require('./_object-gpo')
  , ITERATOR       = require('./_wks')('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
},{"./_export":38,"./_has":45,"./_hide":46,"./_iter-create":58,"./_iterators":62,"./_library":64,"./_object-gpo":80,"./_redefine":93,"./_set-to-string-tag":98,"./_wks":123}],60:[function(require,module,exports){
var ITERATOR     = require('./_wks')('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ return {done: safe = true}; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./_wks":123}],61:[function(require,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],62:[function(require,module,exports){
module.exports = {};
},{}],63:[function(require,module,exports){
var getKeys   = require('./_object-keys')
  , toIObject = require('./_to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./_object-keys":82,"./_to-iobject":113}],64:[function(require,module,exports){
module.exports = false;
},{}],65:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x){
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;
},{}],66:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x){
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};
},{}],67:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};
},{}],68:[function(require,module,exports){
var META     = require('./_uid')('meta')
  , isObject = require('./_is-object')
  , has      = require('./_has')
  , setDesc  = require('./_object-dp').f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !require('./_fails')(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};
},{"./_fails":40,"./_has":45,"./_is-object":55,"./_object-dp":73,"./_uid":120}],69:[function(require,module,exports){
var Map     = require('./es6.map')
  , $export = require('./_export')
  , shared  = require('./_shared')('metadata')
  , store   = shared.store || (shared.store = new (require('./es6.weak-map')));

var getOrCreateMetadataMap = function(target, targetKey, create){
  var targetMetadata = store.get(target);
  if(!targetMetadata){
    if(!create)return undefined;
    store.set(target, targetMetadata = new Map);
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if(!keyMetadata){
    if(!create)return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map);
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function(target, targetKey){
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
    , keys        = [];
  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
  return keys;
};
var toMetaKey = function(it){
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function(O){
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};
},{"./_export":38,"./_shared":100,"./es6.map":155,"./es6.weak-map":261}],70:[function(require,module,exports){
var global    = require('./_global')
  , macrotask = require('./_task').set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , Promise   = global.Promise
  , isNode    = require('./_cof')(process) == 'process';

module.exports = function(){
  var head, last, notify;

  var flush = function(){
    var parent, fn;
    if(isNode && (parent = process.domain))parent.exit();
    while(head){
      fn   = head.fn;
      head = head.next;
      try {
        fn();
      } catch(e){
        if(head)notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if(parent)parent.enter();
  };

  // Node.js
  if(isNode){
    notify = function(){
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if(Observer){
    var toggle = true
      , node   = document.createTextNode('');
    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
    notify = function(){
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if(Promise && Promise.resolve){
    var promise = Promise.resolve();
    notify = function(){
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function(){
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function(fn){
    var task = {fn: fn, next: undefined};
    if(last)last.next = task;
    if(!head){
      head = task;
      notify();
    } last = task;
  };
};
},{"./_cof":24,"./_global":44,"./_task":110}],71:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = require('./_object-keys')
  , gOPS     = require('./_object-gops')
  , pIE      = require('./_object-pie')
  , toObject = require('./_to-object')
  , IObject  = require('./_iobject')
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;
},{"./_fails":40,"./_iobject":51,"./_object-gops":79,"./_object-keys":82,"./_object-pie":83,"./_to-object":115}],72:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = require('./_an-object')
  , dPs         = require('./_object-dps')
  , enumBugKeys = require('./_enum-bug-keys')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":13,"./_dom-create":35,"./_enum-bug-keys":36,"./_html":47,"./_object-dps":74,"./_shared-key":99}],73:[function(require,module,exports){
var anObject       = require('./_an-object')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , toPrimitive    = require('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":13,"./_descriptors":34,"./_ie8-dom-define":48,"./_to-primitive":116}],74:[function(require,module,exports){
var dP       = require('./_object-dp')
  , anObject = require('./_an-object')
  , getKeys  = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};
},{"./_an-object":13,"./_descriptors":34,"./_object-dp":73,"./_object-keys":82}],75:[function(require,module,exports){
// Forced replacement prototype accessors methods
module.exports = require('./_library')|| !require('./_fails')(function(){
  var K = Math.random();
  // In FF throws only define methods
  __defineSetter__.call(null, K, function(){ /* empty */});
  delete require('./_global')[K];
});
},{"./_fails":40,"./_global":44,"./_library":64}],76:[function(require,module,exports){
var pIE            = require('./_object-pie')
  , createDesc     = require('./_property-desc')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , has            = require('./_has')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};
},{"./_descriptors":34,"./_has":45,"./_ie8-dom-define":48,"./_object-pie":83,"./_property-desc":91,"./_to-iobject":113,"./_to-primitive":116}],77:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject')
  , gOPN      = require('./_object-gopn').f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":78,"./_to-iobject":113}],78:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = require('./_object-keys-internal')
  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};
},{"./_enum-bug-keys":36,"./_object-keys-internal":81}],79:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;
},{}],80:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = require('./_has')
  , toObject    = require('./_to-object')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};
},{"./_has":45,"./_shared-key":99,"./_to-object":115}],81:[function(require,module,exports){
var has          = require('./_has')
  , toIObject    = require('./_to-iobject')
  , arrayIndexOf = require('./_array-includes')(false)
  , IE_PROTO     = require('./_shared-key')('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};
},{"./_array-includes":17,"./_has":45,"./_shared-key":99,"./_to-iobject":113}],82:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = require('./_object-keys-internal')
  , enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};
},{"./_enum-bug-keys":36,"./_object-keys-internal":81}],83:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;
},{}],84:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export')
  , core    = require('./_core')
  , fails   = require('./_fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./_core":29,"./_export":38,"./_fails":40}],85:[function(require,module,exports){
var getKeys   = require('./_object-keys')
  , toIObject = require('./_to-iobject')
  , isEnum    = require('./_object-pie').f;
module.exports = function(isEntries){
  return function(it){
    var O      = toIObject(it)
      , keys   = getKeys(O)
      , length = keys.length
      , i      = 0
      , result = []
      , key;
    while(length > i)if(isEnum.call(O, key = keys[i++])){
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};
},{"./_object-keys":82,"./_object-pie":83,"./_to-iobject":113}],86:[function(require,module,exports){
// all object keys, includes non-enumerable and symbols
var gOPN     = require('./_object-gopn')
  , gOPS     = require('./_object-gops')
  , anObject = require('./_an-object')
  , Reflect  = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
  var keys       = gOPN.f(anObject(it))
    , getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};
},{"./_an-object":13,"./_global":44,"./_object-gopn":78,"./_object-gops":79}],87:[function(require,module,exports){
var $parseFloat = require('./_global').parseFloat
  , $trim       = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str){
  var string = $trim(String(str), 3)
    , result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;
},{"./_global":44,"./_string-trim":108,"./_string-ws":109}],88:[function(require,module,exports){
var $parseInt = require('./_global').parseInt
  , $trim     = require('./_string-trim').trim
  , ws        = require('./_string-ws')
  , hex       = /^[\-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;
},{"./_global":44,"./_string-trim":108,"./_string-ws":109}],89:[function(require,module,exports){
'use strict';
var path      = require('./_path')
  , invoke    = require('./_invoke')
  , aFunction = require('./_a-function');
module.exports = function(/* ...pargs */){
  var fn     = aFunction(this)
    , length = arguments.length
    , pargs  = Array(length)
    , i      = 0
    , _      = path._
    , holder = false;
  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that = this
      , aLen = arguments.length
      , j = 0, k = 0, args;
    if(!holder && !aLen)return invoke(fn, pargs, that);
    args = pargs.slice();
    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
    while(aLen > k)args.push(arguments[k++]);
    return invoke(fn, args, that);
  };
};
},{"./_a-function":9,"./_invoke":50,"./_path":90}],90:[function(require,module,exports){
module.exports = require('./_global');
},{"./_global":44}],91:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],92:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function(target, src, safe){
  for(var key in src)redefine(target, key, src[key], safe);
  return target;
};
},{"./_redefine":93}],93:[function(require,module,exports){
var global    = require('./_global')
  , hide      = require('./_hide')
  , has       = require('./_has')
  , SRC       = require('./_uid')('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  var isFunction = typeof val == 'function';
  if(isFunction)has(val, 'name') || hide(val, 'name', key);
  if(O[key] === val)return;
  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if(O === global){
    O[key] = val;
  } else {
    if(!safe){
      delete O[key];
      hide(O, key, val);
    } else {
      if(O[key])O[key] = val;
      else hide(O, key, val);
    }
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});
},{"./_core":29,"./_global":44,"./_has":45,"./_hide":46,"./_uid":120}],94:[function(require,module,exports){
module.exports = function(regExp, replace){
  var replacer = replace === Object(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(it).replace(regExp, replacer);
  };
};
},{}],95:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
},{}],96:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object')
  , anObject = require('./_an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./_an-object":13,"./_ctx":31,"./_is-object":55,"./_object-gopd":76}],97:[function(require,module,exports){
'use strict';
var global      = require('./_global')
  , dP          = require('./_object-dp')
  , DESCRIPTORS = require('./_descriptors')
  , SPECIES     = require('./_wks')('species');

module.exports = function(KEY){
  var C = global[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./_descriptors":34,"./_global":44,"./_object-dp":73,"./_wks":123}],98:[function(require,module,exports){
var def = require('./_object-dp').f
  , has = require('./_has')
  , TAG = require('./_wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./_has":45,"./_object-dp":73,"./_wks":123}],99:[function(require,module,exports){
var shared = require('./_shared')('keys')
  , uid    = require('./_uid');
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};
},{"./_shared":100,"./_uid":120}],100:[function(require,module,exports){
var global = require('./_global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./_global":44}],101:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = require('./_an-object')
  , aFunction = require('./_a-function')
  , SPECIES   = require('./_wks')('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};
},{"./_a-function":9,"./_an-object":13,"./_wks":123}],102:[function(require,module,exports){
var fails = require('./_fails');

module.exports = function(method, arg){
  return !!method && fails(function(){
    arg ? method.call(null, function(){}, 1) : method.call(null);
  });
};
},{"./_fails":40}],103:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , defined   = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./_defined":33,"./_to-integer":112}],104:[function(require,module,exports){
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp')
  , defined  = require('./_defined');

module.exports = function(that, searchString, NAME){
  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};
},{"./_defined":33,"./_is-regexp":56}],105:[function(require,module,exports){
var $export = require('./_export')
  , fails   = require('./_fails')
  , defined = require('./_defined')
  , quot    = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function(string, tag, attribute, value) {
  var S  = String(defined(string))
    , p1 = '<' + tag;
  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function(NAME, exec){
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function(){
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};
},{"./_defined":33,"./_export":38,"./_fails":40}],106:[function(require,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length')
  , repeat   = require('./_string-repeat')
  , defined  = require('./_defined');

module.exports = function(that, maxLength, fillString, left){
  var S            = String(defined(that))
    , stringLength = S.length
    , fillStr      = fillString === undefined ? ' ' : String(fillString)
    , intMaxLength = toLength(maxLength);
  if(intMaxLength <= stringLength || fillStr == '')return S;
  var fillLen = intMaxLength - stringLength
    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_defined":33,"./_string-repeat":107,"./_to-length":114}],107:[function(require,module,exports){
'use strict';
var toInteger = require('./_to-integer')
  , defined   = require('./_defined');

module.exports = function repeat(count){
  var str = String(defined(this))
    , res = ''
    , n   = toInteger(count);
  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
  return res;
};
},{"./_defined":33,"./_to-integer":112}],108:[function(require,module,exports){
var $export = require('./_export')
  , defined = require('./_defined')
  , fails   = require('./_fails')
  , spaces  = require('./_string-ws')
  , space   = '[' + spaces + ']'
  , non     = '\u200b\u0085'
  , ltrim   = RegExp('^' + space + space + '*')
  , rtrim   = RegExp(space + space + '*$');

var exporter = function(KEY, exec, ALIAS){
  var exp   = {};
  var FORCE = fails(function(){
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if(ALIAS)exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function(string, TYPE){
  string = String(defined(string));
  if(TYPE & 1)string = string.replace(ltrim, '');
  if(TYPE & 2)string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;
},{"./_defined":33,"./_export":38,"./_fails":40,"./_string-ws":109}],109:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
},{}],110:[function(require,module,exports){
var ctx                = require('./_ctx')
  , invoke             = require('./_invoke')
  , html               = require('./_html')
  , cel                = require('./_dom-create')
  , global             = require('./_global')
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(require('./_cof')(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./_cof":24,"./_ctx":31,"./_dom-create":35,"./_global":44,"./_html":47,"./_invoke":50}],111:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
},{"./_to-integer":112}],112:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],113:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject')
  , defined = require('./_defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./_defined":33,"./_iobject":51}],114:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./_to-integer":112}],115:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./_defined":33}],116:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":55}],117:[function(require,module,exports){
'use strict';
if(require('./_descriptors')){
  var LIBRARY             = require('./_library')
    , global              = require('./_global')
    , fails               = require('./_fails')
    , $export             = require('./_export')
    , $typed              = require('./_typed')
    , $buffer             = require('./_typed-buffer')
    , ctx                 = require('./_ctx')
    , anInstance          = require('./_an-instance')
    , propertyDesc        = require('./_property-desc')
    , hide                = require('./_hide')
    , redefineAll         = require('./_redefine-all')
    , toInteger           = require('./_to-integer')
    , toLength            = require('./_to-length')
    , toIndex             = require('./_to-index')
    , toPrimitive         = require('./_to-primitive')
    , has                 = require('./_has')
    , same                = require('./_same-value')
    , classof             = require('./_classof')
    , isObject            = require('./_is-object')
    , toObject            = require('./_to-object')
    , isArrayIter         = require('./_is-array-iter')
    , create              = require('./_object-create')
    , getPrototypeOf      = require('./_object-gpo')
    , gOPN                = require('./_object-gopn').f
    , getIterFn           = require('./core.get-iterator-method')
    , uid                 = require('./_uid')
    , wks                 = require('./_wks')
    , createArrayMethod   = require('./_array-methods')
    , createArrayIncludes = require('./_array-includes')
    , speciesConstructor  = require('./_species-constructor')
    , ArrayIterators      = require('./es6.array.iterator')
    , Iterators           = require('./_iterators')
    , $iterDetect         = require('./_iter-detect')
    , setSpecies          = require('./_set-species')
    , arrayFill           = require('./_array-fill')
    , arrayCopyWithin     = require('./_array-copy-within')
    , $DP                 = require('./_object-dp')
    , $GOPD               = require('./_object-gopd')
    , dP                  = $DP.f
    , gOPD                = $GOPD.f
    , RangeError          = global.RangeError
    , TypeError           = global.TypeError
    , Uint8Array          = global.Uint8Array
    , ARRAY_BUFFER        = 'ArrayBuffer'
    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
    , PROTOTYPE           = 'prototype'
    , ArrayProto          = Array[PROTOTYPE]
    , $ArrayBuffer        = $buffer.ArrayBuffer
    , $DataView           = $buffer.DataView
    , arrayForEach        = createArrayMethod(0)
    , arrayFilter         = createArrayMethod(2)
    , arraySome           = createArrayMethod(3)
    , arrayEvery          = createArrayMethod(4)
    , arrayFind           = createArrayMethod(5)
    , arrayFindIndex      = createArrayMethod(6)
    , arrayIncludes       = createArrayIncludes(true)
    , arrayIndexOf        = createArrayIncludes(false)
    , arrayValues         = ArrayIterators.values
    , arrayKeys           = ArrayIterators.keys
    , arrayEntries        = ArrayIterators.entries
    , arrayLastIndexOf    = ArrayProto.lastIndexOf
    , arrayReduce         = ArrayProto.reduce
    , arrayReduceRight    = ArrayProto.reduceRight
    , arrayJoin           = ArrayProto.join
    , arraySort           = ArrayProto.sort
    , arraySlice          = ArrayProto.slice
    , arrayToString       = ArrayProto.toString
    , arrayToLocaleString = ArrayProto.toLocaleString
    , ITERATOR            = wks('iterator')
    , TAG                 = wks('toStringTag')
    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
    , DEF_CONSTRUCTOR     = uid('def_constructor')
    , ALL_CONSTRUCTORS    = $typed.CONSTR
    , TYPED_ARRAY         = $typed.TYPED
    , VIEW                = $typed.VIEW
    , WRONG_LENGTH        = 'Wrong length!';

  var $map = createArrayMethod(1, function(O, length){
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function(){
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
    new Uint8Array(1).set({});
  });

  var strictToLength = function(it, SAME){
    if(it === undefined)throw TypeError(WRONG_LENGTH);
    var number = +it
      , length = toLength(it);
    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
    return length;
  };

  var toOffset = function(it, BYTES){
    var offset = toInteger(it);
    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function(it){
    if(isObject(it) && TYPED_ARRAY in it)return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function(C, length){
    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function(O, list){
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function(C, list){
    var index  = 0
      , length = list.length
      , result = allocate(C, length);
    while(length > index)result[index] = list[index++];
    return result;
  };

  var addGetter = function(it, key, internal){
    dP(it, key, {get: function(){ return this._d[internal]; }});
  };

  var $from = function from(source /*, mapfn, thisArg */){
    var O       = toObject(source)
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , iterFn  = getIterFn(O)
      , i, length, values, result, step, iterator;
    if(iterFn != undefined && !isArrayIter(iterFn)){
      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
        values.push(step.value);
      } O = values;
    }
    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/*...items*/){
    var index  = 0
      , length = arguments.length
      , result = allocate(this, length);
    while(length > index)result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString(){
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /*, end */){
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /*, thisArg */){
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /*, thisArg */){
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /*, thisArg */){
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /*, thisArg */){
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /*, thisArg */){
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /*, fromIndex */){
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /*, fromIndex */){
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator){ // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /*, thisArg */){
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse(){
      var that   = this
        , length = validate(that).length
        , middle = Math.floor(length / 2)
        , index  = 0
        , value;
      while(index < middle){
        value         = that[index];
        that[index++] = that[--length];
        that[length]  = value;
      } return that;
    },
    some: function some(callbackfn /*, thisArg */){
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn){
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end){
      var O      = validate(this)
        , length = O.length
        , $begin = toIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end){
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /*, offset */){
    validate(this);
    var offset = toOffset(arguments[1], 1)
      , length = this.length
      , src    = toObject(arrayLike)
      , len    = toLength(src.length)
      , index  = 0;
    if(len + offset > length)throw RangeError(WRONG_LENGTH);
    while(index < len)this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries(){
      return arrayEntries.call(validate(this));
    },
    keys: function keys(){
      return arrayKeys.call(validate(this));
    },
    values: function values(){
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function(target, key){
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key){
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc){
    if(isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ){
      target[key] = desc.value;
      return target;
    } else return dP(target, key, desc);
  };

  if(!ALL_CONSTRUCTORS){
    $GOPD.f = $getDesc;
    $DP.f   = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty:           $setDesc
  });

  if(fails(function(){ arrayToString.call({}); })){
    arrayToString = arrayToLocaleString = function toString(){
      return arrayJoin.call(this);
    }
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice:          $slice,
    set:            $set,
    constructor:    function(){ /* noop */ },
    toString:       arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function(){ return this[TYPED_ARRAY]; }
  });

  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
    CLAMPED = !!CLAMPED;
    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
      , ISNT_UINT8 = NAME != 'Uint8Array'
      , GETTER     = 'get' + KEY
      , SETTER     = 'set' + KEY
      , TypedArray = global[NAME]
      , Base       = TypedArray || {}
      , TAC        = TypedArray && getPrototypeOf(TypedArray)
      , FORCED     = !TypedArray || !$typed.ABV
      , O          = {}
      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function(that, index){
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function(that, index, value){
      var data = that._d;
      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function(that, index){
      dP(that, index, {
        get: function(){
          return getter(this, index);
        },
        set: function(value){
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if(FORCED){
      TypedArray = wrapper(function(that, data, $offset, $length){
        anInstance(that, TypedArray, NAME, '_d');
        var index  = 0
          , offset = 0
          , buffer, byteLength, length, klass;
        if(!isObject(data)){
          length     = strictToLength(data, true)
          byteLength = length * BYTES;
          buffer     = new $ArrayBuffer(byteLength);
        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if($length === undefined){
            if($len % BYTES)throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if(TYPED_ARRAY in data){
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while(index < length)addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if(!$iterDetect(function(iter){
      // V8 works with iterators, but fails in many other cases
      // https://code.google.com/p/v8/issues/detail?id=4552
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)){
      TypedArray = wrapper(function(that, data, $offset, $length){
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
      , $iterator         = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
      dP(TypedArrayPrototype, TAG, {
        get: function(){ return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES,
      from: $from,
      of: $of
    });

    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});

    $export($export.P + $export.F * fails(function(){
      new TypedArray(1).slice();
    }), NAME, {slice: $slice});

    $export($export.P + $export.F * (fails(function(){
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
    }) || !fails(function(){
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, {toLocaleString: $toLocaleString});

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function(){ /* empty */ };
},{"./_an-instance":12,"./_array-copy-within":14,"./_array-fill":15,"./_array-includes":17,"./_array-methods":18,"./_classof":23,"./_ctx":31,"./_descriptors":34,"./_export":38,"./_fails":40,"./_global":44,"./_has":45,"./_hide":46,"./_is-array-iter":52,"./_is-object":55,"./_iter-detect":60,"./_iterators":62,"./_library":64,"./_object-create":72,"./_object-dp":73,"./_object-gopd":76,"./_object-gopn":78,"./_object-gpo":80,"./_property-desc":91,"./_redefine-all":92,"./_same-value":95,"./_set-species":97,"./_species-constructor":101,"./_to-index":111,"./_to-integer":112,"./_to-length":114,"./_to-object":115,"./_to-primitive":116,"./_typed":119,"./_typed-buffer":118,"./_uid":120,"./_wks":123,"./core.get-iterator-method":124,"./es6.array.iterator":136}],118:[function(require,module,exports){
'use strict';
var global         = require('./_global')
  , DESCRIPTORS    = require('./_descriptors')
  , LIBRARY        = require('./_library')
  , $typed         = require('./_typed')
  , hide           = require('./_hide')
  , redefineAll    = require('./_redefine-all')
  , fails          = require('./_fails')
  , anInstance     = require('./_an-instance')
  , toInteger      = require('./_to-integer')
  , toLength       = require('./_to-length')
  , gOPN           = require('./_object-gopn').f
  , dP             = require('./_object-dp').f
  , arrayFill      = require('./_array-fill')
  , setToStringTag = require('./_set-to-string-tag')
  , ARRAY_BUFFER   = 'ArrayBuffer'
  , DATA_VIEW      = 'DataView'
  , PROTOTYPE      = 'prototype'
  , WRONG_LENGTH   = 'Wrong length!'
  , WRONG_INDEX    = 'Wrong index!'
  , $ArrayBuffer   = global[ARRAY_BUFFER]
  , $DataView      = global[DATA_VIEW]
  , Math           = global.Math
  , RangeError     = global.RangeError
  , Infinity       = global.Infinity
  , BaseBuffer     = $ArrayBuffer
  , abs            = Math.abs
  , pow            = Math.pow
  , floor          = Math.floor
  , log            = Math.log
  , LN2            = Math.LN2
  , BUFFER         = 'buffer'
  , BYTE_LENGTH    = 'byteLength'
  , BYTE_OFFSET    = 'byteOffset'
  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
var packIEEE754 = function(value, mLen, nBytes){
  var buffer = Array(nBytes)
    , eLen   = nBytes * 8 - mLen - 1
    , eMax   = (1 << eLen) - 1
    , eBias  = eMax >> 1
    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
    , i      = 0
    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
    , e, m, c;
  value = abs(value)
  if(value != value || value === Infinity){
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if(value * (c = pow(2, -e)) < 1){
      e--;
      c *= 2;
    }
    if(e + eBias >= 1){
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if(value * c >= 2){
      e++;
      c /= 2;
    }
    if(e + eBias >= eMax){
      m = 0;
      e = eMax;
    } else if(e + eBias >= 1){
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
};
var unpackIEEE754 = function(buffer, mLen, nBytes){
  var eLen  = nBytes * 8 - mLen - 1
    , eMax  = (1 << eLen) - 1
    , eBias = eMax >> 1
    , nBits = eLen - 7
    , i     = nBytes - 1
    , s     = buffer[i--]
    , e     = s & 127
    , m;
  s >>= 7;
  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if(e === 0){
    e = 1 - eBias;
  } else if(e === eMax){
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
};

var unpackI32 = function(bytes){
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
};
var packI8 = function(it){
  return [it & 0xff];
};
var packI16 = function(it){
  return [it & 0xff, it >> 8 & 0xff];
};
var packI32 = function(it){
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
};
var packF64 = function(it){
  return packIEEE754(it, 52, 8);
};
var packF32 = function(it){
  return packIEEE754(it, 23, 4);
};

var addGetter = function(C, key, internal){
  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
};

var get = function(view, bytes, index, isLittleEndian){
  var numIndex = +index
    , intIndex = toInteger(numIndex);
  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b
    , start = intIndex + view[$OFFSET]
    , pack  = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
};
var set = function(view, bytes, index, conversion, value, isLittleEndian){
  var numIndex = +index
    , intIndex = toInteger(numIndex);
  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b
    , start = intIndex + view[$OFFSET]
    , pack  = conversion(+value);
  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
};

var validateArrayBufferArguments = function(that, length){
  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
  var numberLength = +length
    , byteLength   = toLength(numberLength);
  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
  return byteLength;
};

if(!$typed.ABV){
  $ArrayBuffer = function ArrayBuffer(length){
    var byteLength = validateArrayBufferArguments(this, length);
    this._b       = arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength){
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH]
      , offset       = toInteger(byteOffset);
    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if(DESCRIPTORS){
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset){
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset){
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /*, littleEndian */){
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /*, littleEndian */){
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /*, littleEndian */){
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /*, littleEndian */){
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value){
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value){
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if(!fails(function(){
    new $ArrayBuffer;     // eslint-disable-line no-new
  }) || !fails(function(){
    new $ArrayBuffer(.5); // eslint-disable-line no-new
  })){
    $ArrayBuffer = function ArrayBuffer(length){
      return new BaseBuffer(validateArrayBufferArguments(this, length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
    };
    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2))
    , $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value){
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value){
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;
},{"./_an-instance":12,"./_array-fill":15,"./_descriptors":34,"./_fails":40,"./_global":44,"./_hide":46,"./_library":64,"./_object-dp":73,"./_object-gopn":78,"./_redefine-all":92,"./_set-to-string-tag":98,"./_to-integer":112,"./_to-length":114,"./_typed":119}],119:[function(require,module,exports){
var global = require('./_global')
  , hide   = require('./_hide')
  , uid    = require('./_uid')
  , TYPED  = uid('typed_array')
  , VIEW   = uid('view')
  , ABV    = !!(global.ArrayBuffer && global.DataView)
  , CONSTR = ABV
  , i = 0, l = 9, Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while(i < l){
  if(Typed = global[TypedArrayConstructors[i++]]){
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV:    ABV,
  CONSTR: CONSTR,
  TYPED:  TYPED,
  VIEW:   VIEW
};
},{"./_global":44,"./_hide":46,"./_uid":120}],120:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],121:[function(require,module,exports){
var global         = require('./_global')
  , core           = require('./_core')
  , LIBRARY        = require('./_library')
  , wksExt         = require('./_wks-ext')
  , defineProperty = require('./_object-dp').f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};
},{"./_core":29,"./_global":44,"./_library":64,"./_object-dp":73,"./_wks-ext":122}],122:[function(require,module,exports){
exports.f = require('./_wks');
},{"./_wks":123}],123:[function(require,module,exports){
var store      = require('./_shared')('wks')
  , uid        = require('./_uid')
  , Symbol     = require('./_global').Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
},{"./_global":44,"./_shared":100,"./_uid":120}],124:[function(require,module,exports){
var classof   = require('./_classof')
  , ITERATOR  = require('./_wks')('iterator')
  , Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./_classof":23,"./_core":29,"./_iterators":62,"./_wks":123}],125:[function(require,module,exports){
// https://github.com/benjamingr/RexExp.escape
var $export = require('./_export')
  , $re     = require('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});

},{"./_export":38,"./_replacer":94}],126:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', {copyWithin: require('./_array-copy-within')});

require('./_add-to-unscopables')('copyWithin');
},{"./_add-to-unscopables":11,"./_array-copy-within":14,"./_export":38}],127:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $every  = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */){
    return $every(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":18,"./_export":38,"./_strict-method":102}],128:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', {fill: require('./_array-fill')});

require('./_add-to-unscopables')('fill');
},{"./_add-to-unscopables":11,"./_array-fill":15,"./_export":38}],129:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */){
    return $filter(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":18,"./_export":38,"./_strict-method":102}],130:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export')
  , $find   = require('./_array-methods')(6)
  , KEY     = 'findIndex'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);
},{"./_add-to-unscopables":11,"./_array-methods":18,"./_export":38}],131:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export')
  , $find   = require('./_array-methods')(5)
  , KEY     = 'find'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);
},{"./_add-to-unscopables":11,"./_array-methods":18,"./_export":38}],132:[function(require,module,exports){
'use strict';
var $export  = require('./_export')
  , $forEach = require('./_array-methods')(0)
  , STRICT   = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */){
    return $forEach(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":18,"./_export":38,"./_strict-method":102}],133:[function(require,module,exports){
'use strict';
var ctx            = require('./_ctx')
  , $export        = require('./_export')
  , toObject       = require('./_to-object')
  , call           = require('./_iter-call')
  , isArrayIter    = require('./_is-array-iter')
  , toLength       = require('./_to-length')
  , createProperty = require('./_create-property')
  , getIterFn      = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":30,"./_ctx":31,"./_export":38,"./_is-array-iter":52,"./_iter-call":57,"./_iter-detect":60,"./_to-length":114,"./_to-object":115,"./core.get-iterator-method":124}],134:[function(require,module,exports){
'use strict';
var $export       = require('./_export')
  , $indexOf      = require('./_array-includes')(false)
  , $native       = [].indexOf
  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});
},{"./_array-includes":17,"./_export":38,"./_strict-method":102}],135:[function(require,module,exports){
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', {isArray: require('./_is-array')});
},{"./_export":38,"./_is-array":53}],136:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables')
  , step             = require('./_iter-step')
  , Iterators        = require('./_iterators')
  , toIObject        = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
},{"./_add-to-unscopables":11,"./_iter-define":59,"./_iter-step":61,"./_iterators":62,"./_to-iobject":113}],137:[function(require,module,exports){
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export   = require('./_export')
  , toIObject = require('./_to-iobject')
  , arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator){
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});
},{"./_export":38,"./_iobject":51,"./_strict-method":102,"./_to-iobject":113}],138:[function(require,module,exports){
'use strict';
var $export       = require('./_export')
  , toIObject     = require('./_to-iobject')
  , toInteger     = require('./_to-integer')
  , toLength      = require('./_to-length')
  , $native       = [].lastIndexOf
  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
    // convert -0 to +0
    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
    var O      = toIObject(this)
      , length = toLength(O.length)
      , index  = length - 1;
    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
    if(index < 0)index = length + index;
    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
    return -1;
  }
});
},{"./_export":38,"./_strict-method":102,"./_to-integer":112,"./_to-iobject":113,"./_to-length":114}],139:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $map    = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */){
    return $map(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":18,"./_export":38,"./_strict-method":102}],140:[function(require,module,exports){
'use strict';
var $export        = require('./_export')
  , createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function(){
  function F(){}
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */){
    var index  = 0
      , aLen   = arguments.length
      , result = new (typeof this == 'function' ? this : Array)(aLen);
    while(aLen > index)createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});
},{"./_create-property":30,"./_export":38,"./_fails":40}],141:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});
},{"./_array-reduce":19,"./_export":38,"./_strict-method":102}],142:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});
},{"./_array-reduce":19,"./_export":38,"./_strict-method":102}],143:[function(require,module,exports){
'use strict';
var $export    = require('./_export')
  , html       = require('./_html')
  , cof        = require('./_cof')
  , toIndex    = require('./_to-index')
  , toLength   = require('./_to-length')
  , arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function(){
  if(html)arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end){
    var len   = toLength(this.length)
      , klass = cof(this);
    end = end === undefined ? len : end;
    if(klass == 'Array')return arraySlice.call(this, begin, end);
    var start  = toIndex(begin, len)
      , upTo   = toIndex(end, len)
      , size   = toLength(upTo - start)
      , cloned = Array(size)
      , i      = 0;
    for(; i < size; i++)cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});
},{"./_cof":24,"./_export":38,"./_fails":40,"./_html":47,"./_to-index":111,"./_to-length":114}],144:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $some   = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */){
    return $some(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":18,"./_export":38,"./_strict-method":102}],145:[function(require,module,exports){
'use strict';
var $export   = require('./_export')
  , aFunction = require('./_a-function')
  , toObject  = require('./_to-object')
  , fails     = require('./_fails')
  , $sort     = [].sort
  , test      = [1, 2, 3];

$export($export.P + $export.F * (fails(function(){
  // IE8-
  test.sort(undefined);
}) || !fails(function(){
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn){
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});
},{"./_a-function":9,"./_export":38,"./_fails":40,"./_strict-method":102,"./_to-object":115}],146:[function(require,module,exports){
require('./_set-species')('Array');
},{"./_set-species":97}],147:[function(require,module,exports){
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});
},{"./_export":38}],148:[function(require,module,exports){
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export')
  , fails   = require('./_fails')
  , getTime = Date.prototype.getTime;

var lz = function(num){
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (fails(function(){
  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
}) || !fails(function(){
  new Date(NaN).toISOString();
})), 'Date', {
  toISOString: function toISOString(){
    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
    var d = this
      , y = d.getUTCFullYear()
      , m = d.getUTCMilliseconds()
      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
  }
});
},{"./_export":38,"./_fails":40}],149:[function(require,module,exports){
'use strict';
var $export     = require('./_export')
  , toObject    = require('./_to-object')
  , toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function(){
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
}), 'Date', {
  toJSON: function toJSON(key){
    var O  = toObject(this)
      , pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});
},{"./_export":38,"./_fails":40,"./_to-object":115,"./_to-primitive":116}],150:[function(require,module,exports){
var TO_PRIMITIVE = require('./_wks')('toPrimitive')
  , proto        = Date.prototype;

if(!(TO_PRIMITIVE in proto))require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));
},{"./_date-to-primitive":32,"./_hide":46,"./_wks":123}],151:[function(require,module,exports){
var DateProto    = Date.prototype
  , INVALID_DATE = 'Invalid Date'
  , TO_STRING    = 'toString'
  , $toString    = DateProto[TO_STRING]
  , getTime      = DateProto.getTime;
if(new Date(NaN) + '' != INVALID_DATE){
  require('./_redefine')(DateProto, TO_STRING, function toString(){
    var value = getTime.call(this);
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}
},{"./_redefine":93}],152:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', {bind: require('./_bind')});
},{"./_bind":22,"./_export":38}],153:[function(require,module,exports){
'use strict';
var isObject       = require('./_is-object')
  , getPrototypeOf = require('./_object-gpo')
  , HAS_INSTANCE   = require('./_wks')('hasInstance')
  , FunctionProto  = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if(!(HAS_INSTANCE in FunctionProto))require('./_object-dp').f(FunctionProto, HAS_INSTANCE, {value: function(O){
  if(typeof this != 'function' || !isObject(O))return false;
  if(!isObject(this.prototype))return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
  return false;
}});
},{"./_is-object":55,"./_object-dp":73,"./_object-gpo":80,"./_wks":123}],154:[function(require,module,exports){
var dP         = require('./_object-dp').f
  , createDesc = require('./_property-desc')
  , has        = require('./_has')
  , FProto     = Function.prototype
  , nameRE     = /^\s*function ([^ (]*)/
  , NAME       = 'name';

var isExtensible = Object.isExtensible || function(){
  return true;
};

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function(){
    try {
      var that = this
        , name = ('' + that).match(nameRE)[1];
      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
      return name;
    } catch(e){
      return '';
    }
  }
});
},{"./_descriptors":34,"./_has":45,"./_object-dp":73,"./_property-desc":91}],155:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');

// 23.1 Map Objects
module.exports = require('./_collection')('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
},{"./_collection":28,"./_collection-strong":25}],156:[function(require,module,exports){
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export')
  , log1p   = require('./_math-log1p')
  , sqrt    = Math.sqrt
  , $acosh  = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN 
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x){
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});
},{"./_export":38,"./_math-log1p":66}],157:[function(require,module,exports){
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export')
  , $asinh  = Math.asinh;

function asinh(x){
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0 
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});
},{"./_export":38}],158:[function(require,module,exports){
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export')
  , $atanh  = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0 
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x){
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});
},{"./_export":38}],159:[function(require,module,exports){
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export')
  , sign    = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x){
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});
},{"./_export":38,"./_math-sign":67}],160:[function(require,module,exports){
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x){
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});
},{"./_export":38}],161:[function(require,module,exports){
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export')
  , exp     = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x){
    return (exp(x = +x) + exp(-x)) / 2;
  }
});
},{"./_export":38}],162:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export')
  , $expm1  = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});
},{"./_export":38,"./_math-expm1":65}],163:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var $export   = require('./_export')
  , sign      = require('./_math-sign')
  , pow       = Math.pow
  , EPSILON   = pow(2, -52)
  , EPSILON32 = pow(2, -23)
  , MAX32     = pow(2, 127) * (2 - EPSILON32)
  , MIN32     = pow(2, -126);

var roundTiesToEven = function(n){
  return n + 1 / EPSILON - 1 / EPSILON;
};


$export($export.S, 'Math', {
  fround: function fround(x){
    var $abs  = Math.abs(x)
      , $sign = sign(x)
      , a, result;
    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    if(result > MAX32 || result != result)return $sign * Infinity;
    return $sign * result;
  }
});
},{"./_export":38,"./_math-sign":67}],164:[function(require,module,exports){
// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = require('./_export')
  , abs     = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
    var sum  = 0
      , i    = 0
      , aLen = arguments.length
      , larg = 0
      , arg, div;
    while(i < aLen){
      arg = abs(arguments[i++]);
      if(larg < arg){
        div  = larg / arg;
        sum  = sum * div * div + 1;
        larg = arg;
      } else if(arg > 0){
        div  = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});
},{"./_export":38}],165:[function(require,module,exports){
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export')
  , $imul   = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function(){
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y){
    var UINT16 = 0xffff
      , xn = +x
      , yn = +y
      , xl = UINT16 & xn
      , yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});
},{"./_export":38,"./_fails":40}],166:[function(require,module,exports){
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x){
    return Math.log(x) / Math.LN10;
  }
});
},{"./_export":38}],167:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', {log1p: require('./_math-log1p')});
},{"./_export":38,"./_math-log1p":66}],168:[function(require,module,exports){
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x){
    return Math.log(x) / Math.LN2;
  }
});
},{"./_export":38}],169:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', {sign: require('./_math-sign')});
},{"./_export":38,"./_math-sign":67}],170:[function(require,module,exports){
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export')
  , expm1   = require('./_math-expm1')
  , exp     = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function(){
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x){
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});
},{"./_export":38,"./_fails":40,"./_math-expm1":65}],171:[function(require,module,exports){
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export')
  , expm1   = require('./_math-expm1')
  , exp     = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x){
    var a = expm1(x = +x)
      , b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});
},{"./_export":38,"./_math-expm1":65}],172:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it){
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});
},{"./_export":38}],173:[function(require,module,exports){
'use strict';
var global            = require('./_global')
  , has               = require('./_has')
  , cof               = require('./_cof')
  , inheritIfRequired = require('./_inherit-if-required')
  , toPrimitive       = require('./_to-primitive')
  , fails             = require('./_fails')
  , gOPN              = require('./_object-gopn').f
  , gOPD              = require('./_object-gopd').f
  , dP                = require('./_object-dp').f
  , $trim             = require('./_string-trim').trim
  , NUMBER            = 'Number'
  , $Number           = global[NUMBER]
  , Base              = $Number
  , proto             = $Number.prototype
  // Opera ~12 has broken Object#toString
  , BROKEN_COF        = cof(require('./_object-create')(proto)) == NUMBER
  , TRIM              = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function(argument){
  var it = toPrimitive(argument, false);
  if(typeof it == 'string' && it.length > 2){
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0)
      , third, radix, maxCode;
    if(first === 43 || first === 45){
      third = it.charCodeAt(2);
      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if(first === 48){
      switch(it.charCodeAt(1)){
        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default : return +it;
      }
      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if(code < 48 || code > maxCode)return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
  $Number = function Number(value){
    var it = arguments.length < 1 ? 0 : value
      , that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for(var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++){
    if(has(Base, key = keys[j]) && !has($Number, key)){
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}
},{"./_cof":24,"./_descriptors":34,"./_fails":40,"./_global":44,"./_has":45,"./_inherit-if-required":49,"./_object-create":72,"./_object-dp":73,"./_object-gopd":76,"./_object-gopn":78,"./_redefine":93,"./_string-trim":108,"./_to-primitive":116}],174:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});
},{"./_export":38}],175:[function(require,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $export   = require('./_export')
  , _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it){
    return typeof it == 'number' && _isFinite(it);
  }
});
},{"./_export":38,"./_global":44}],176:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', {isInteger: require('./_is-integer')});
},{"./_export":38,"./_is-integer":54}],177:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number){
    return number != number;
  }
});
},{"./_export":38}],178:[function(require,module,exports){
// 20.1.2.5 Number.isSafeInteger(number)
var $export   = require('./_export')
  , isInteger = require('./_is-integer')
  , abs       = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number){
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});
},{"./_export":38,"./_is-integer":54}],179:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});
},{"./_export":38}],180:[function(require,module,exports){
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});
},{"./_export":38}],181:[function(require,module,exports){
var $export     = require('./_export')
  , $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});
},{"./_export":38,"./_parse-float":87}],182:[function(require,module,exports){
var $export   = require('./_export')
  , $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});
},{"./_export":38,"./_parse-int":88}],183:[function(require,module,exports){
'use strict';
var $export      = require('./_export')
  , toInteger    = require('./_to-integer')
  , aNumberValue = require('./_a-number-value')
  , repeat       = require('./_string-repeat')
  , $toFixed     = 1..toFixed
  , floor        = Math.floor
  , data         = [0, 0, 0, 0, 0, 0]
  , ERROR        = 'Number.toFixed: incorrect invocation!'
  , ZERO         = '0';

var multiply = function(n, c){
  var i  = -1
    , c2 = c;
  while(++i < 6){
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function(n){
  var i = 6
    , c = 0;
  while(--i >= 0){
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function(){
  var i = 6
    , s = '';
  while(--i >= 0){
    if(s !== '' || i === 0 || data[i] !== 0){
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function(x, n, acc){
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function(x){
  var n  = 0
    , x2 = x;
  while(x2 >= 4096){
    n += 12;
    x2 /= 4096;
  }
  while(x2 >= 2){
    n  += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128..toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function(){
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits){
    var x = aNumberValue(this, ERROR)
      , f = toInteger(fractionDigits)
      , s = ''
      , m = ZERO
      , e, z, j, k;
    if(f < 0 || f > 20)throw RangeError(ERROR);
    if(x != x)return 'NaN';
    if(x <= -1e21 || x >= 1e21)return String(x);
    if(x < 0){
      s = '-';
      x = -x;
    }
    if(x > 1e-21){
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if(e > 0){
        multiply(0, z);
        j = f;
        while(j >= 7){
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while(j >= 23){
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if(f > 0){
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});
},{"./_a-number-value":10,"./_export":38,"./_fails":40,"./_string-repeat":107,"./_to-integer":112}],184:[function(require,module,exports){
'use strict';
var $export      = require('./_export')
  , $fails       = require('./_fails')
  , aNumberValue = require('./_a-number-value')
  , $toPrecision = 1..toPrecision;

$export($export.P + $export.F * ($fails(function(){
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function(){
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision){
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); 
  }
});
},{"./_a-number-value":10,"./_export":38,"./_fails":40}],185:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});
},{"./_export":38,"./_object-assign":71}],186:[function(require,module,exports){
var $export = require('./_export')
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: require('./_object-create')});
},{"./_export":38,"./_object-create":72}],187:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperties: require('./_object-dps')});
},{"./_descriptors":34,"./_export":38,"./_object-dps":74}],188:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});
},{"./_descriptors":34,"./_export":38,"./_object-dp":73}],189:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object')
  , meta     = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function($freeze){
  return function freeze(it){
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});
},{"./_is-object":55,"./_meta":68,"./_object-sap":84}],190:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject                 = require('./_to-iobject')
  , $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function(){
  return function getOwnPropertyDescriptor(it, key){
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});
},{"./_object-gopd":76,"./_object-sap":84,"./_to-iobject":113}],191:[function(require,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function(){
  return require('./_object-gopn-ext').f;
});
},{"./_object-gopn-ext":77,"./_object-sap":84}],192:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject        = require('./_to-object')
  , $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function(){
  return function getPrototypeOf(it){
    return $getPrototypeOf(toObject(it));
  };
});
},{"./_object-gpo":80,"./_object-sap":84,"./_to-object":115}],193:[function(require,module,exports){
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function($isExtensible){
  return function isExtensible(it){
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});
},{"./_is-object":55,"./_object-sap":84}],194:[function(require,module,exports){
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function($isFrozen){
  return function isFrozen(it){
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});
},{"./_is-object":55,"./_object-sap":84}],195:[function(require,module,exports){
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function($isSealed){
  return function isSealed(it){
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});
},{"./_is-object":55,"./_object-sap":84}],196:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', {is: require('./_same-value')});
},{"./_export":38,"./_same-value":95}],197:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object')
  , $keys    = require('./_object-keys');

require('./_object-sap')('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./_object-keys":82,"./_object-sap":84,"./_to-object":115}],198:[function(require,module,exports){
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object')
  , meta     = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function($preventExtensions){
  return function preventExtensions(it){
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});
},{"./_is-object":55,"./_meta":68,"./_object-sap":84}],199:[function(require,module,exports){
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object')
  , meta     = require('./_meta').onFreeze;

require('./_object-sap')('seal', function($seal){
  return function seal(it){
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});
},{"./_is-object":55,"./_meta":68,"./_object-sap":84}],200:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', {setPrototypeOf: require('./_set-proto').set});
},{"./_export":38,"./_set-proto":96}],201:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof')
  , test    = {};
test[require('./_wks')('toStringTag')] = 'z';
if(test + '' != '[object z]'){
  require('./_redefine')(Object.prototype, 'toString', function toString(){
    return '[object ' + classof(this) + ']';
  }, true);
}
},{"./_classof":23,"./_redefine":93,"./_wks":123}],202:[function(require,module,exports){
var $export     = require('./_export')
  , $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});
},{"./_export":38,"./_parse-float":87}],203:[function(require,module,exports){
var $export   = require('./_export')
  , $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});
},{"./_export":38,"./_parse-int":88}],204:[function(require,module,exports){
'use strict';
var LIBRARY            = require('./_library')
  , global             = require('./_global')
  , ctx                = require('./_ctx')
  , classof            = require('./_classof')
  , $export            = require('./_export')
  , isObject           = require('./_is-object')
  , aFunction          = require('./_a-function')
  , anInstance         = require('./_an-instance')
  , forOf              = require('./_for-of')
  , speciesConstructor = require('./_species-constructor')
  , task               = require('./_task').set
  , microtask          = require('./_microtask')()
  , PROMISE            = 'Promise'
  , TypeError          = global.TypeError
  , process            = global.process
  , $Promise           = global[PROMISE]
  , process            = global.process
  , isNode             = classof(process) == 'process'
  , empty              = function(){ /* empty */ }
  , Internal, GenericPromiseCapability, Wrapper;

var USE_NATIVE = !!function(){
  try {
    // correct subclassing with @@species support
    var promise     = $Promise.resolve(1)
      , FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function(exec){ exec(empty, empty); };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch(e){ /* empty */ }
}();

// helpers
var sameConstructor = function(a, b){
  // with library wrapper special case
  return a === b || a === $Promise && b === Wrapper;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var newPromiseCapability = function(C){
  return sameConstructor($Promise, C)
    ? new PromiseCapability(C)
    : new GenericPromiseCapability(C);
};
var PromiseCapability = GenericPromiseCapability = function(C){
  var resolve, reject;
  this.promise = new C(function($$resolve, $$reject){
    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject  = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject  = aFunction(reject);
};
var perform = function(exec){
  try {
    exec();
  } catch(e){
    return {error: e};
  }
};
var notify = function(promise, isReject){
  if(promise._n)return;
  promise._n = true;
  var chain = promise._c;
  microtask(function(){
    var value = promise._v
      , ok    = promise._s == 1
      , i     = 0;
    var run = function(reaction){
      var handler = ok ? reaction.ok : reaction.fail
        , resolve = reaction.resolve
        , reject  = reaction.reject
        , domain  = reaction.domain
        , result, then;
      try {
        if(handler){
          if(!ok){
            if(promise._h == 2)onHandleUnhandled(promise);
            promise._h = 1;
          }
          if(handler === true)result = value;
          else {
            if(domain)domain.enter();
            result = handler(value);
            if(domain)domain.exit();
          }
          if(result === reaction.promise){
            reject(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(result)){
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch(e){
        reject(e);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if(isReject && !promise._h)onUnhandled(promise);
  });
};
var onUnhandled = function(promise){
  task.call(global, function(){
    var value = promise._v
      , abrupt, handler, console;
    if(isUnhandled(promise)){
      abrupt = perform(function(){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if(abrupt)throw abrupt.error;
  });
};
var isUnhandled = function(promise){
  if(promise._h == 1)return false;
  var chain = promise._a || promise._c
    , i     = 0
    , reaction;
  while(chain.length > i){
    reaction = chain[i++];
    if(reaction.fail || !isUnhandled(reaction.promise))return false;
  } return true;
};
var onHandleUnhandled = function(promise){
  task.call(global, function(){
    var handler;
    if(isNode){
      process.emit('rejectionHandled', promise);
    } else if(handler = global.onrejectionhandled){
      handler({promise: promise, reason: promise._v});
    }
  });
};
var $reject = function(value){
  var promise = this;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if(!promise._a)promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function(value){
  var promise = this
    , then;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if(promise === value)throw TypeError("Promise can't be resolved itself");
    if(then = isThenable(value)){
      microtask(function(){
        var wrapper = {_w: promise, _d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch(e){
    $reject.call({_w: promise, _d: false}, e); // wrap
  }
};

// constructor polyfill
if(!USE_NATIVE){
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor){
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch(err){
      $reject.call(this, err);
    }
  };
  Internal = function Promise(executor){
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail   = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if(this._a)this._a.push(reaction);
      if(this._s)notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
  PromiseCapability = function(){
    var promise  = new Internal;
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject  = ctx($reject, promise, 1);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    var capability = newPromiseCapability(this)
      , $$reject   = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
    var capability = newPromiseCapability(this)
      , $$resolve  = capability.resolve;
    $$resolve(x);
    return capability.promise;
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function(iter){
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , resolve    = capability.resolve
      , reject     = capability.reject;
    var abrupt = perform(function(){
      var values    = []
        , index     = 0
        , remaining = 1;
      forOf(iterable, false, function(promise){
        var $index        = index++
          , alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function(value){
          if(alreadyCalled)return;
          alreadyCalled  = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , reject     = capability.reject;
    var abrupt = perform(function(){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  }
});
},{"./_a-function":9,"./_an-instance":12,"./_classof":23,"./_core":29,"./_ctx":31,"./_export":38,"./_for-of":43,"./_global":44,"./_is-object":55,"./_iter-detect":60,"./_library":64,"./_microtask":70,"./_redefine-all":92,"./_set-species":97,"./_set-to-string-tag":98,"./_species-constructor":101,"./_task":110,"./_wks":123}],205:[function(require,module,exports){
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export   = require('./_export')
  , aFunction = require('./_a-function')
  , anObject  = require('./_an-object')
  , rApply    = (require('./_global').Reflect || {}).apply
  , fApply    = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function(){
  rApply(function(){});
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList){
    var T = aFunction(target)
      , L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});
},{"./_a-function":9,"./_an-object":13,"./_export":38,"./_fails":40,"./_global":44}],206:[function(require,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export    = require('./_export')
  , create     = require('./_object-create')
  , aFunction  = require('./_a-function')
  , anObject   = require('./_an-object')
  , isObject   = require('./_is-object')
  , fails      = require('./_fails')
  , bind       = require('./_bind')
  , rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function(){
  function F(){}
  return !(rConstruct(function(){}, [], F) instanceof F);
});
var ARGS_BUG = !fails(function(){
  rConstruct(function(){});
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /*, newTarget*/){
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);
    if(Target == newTarget){
      // w/o altered newTarget, optimization for 0-4 arguments
      switch(args.length){
        case 0: return new Target;
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args));
    }
    // with altered newTarget, not support built-in constructors
    var proto    = newTarget.prototype
      , instance = create(isObject(proto) ? proto : Object.prototype)
      , result   = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});
},{"./_a-function":9,"./_an-object":13,"./_bind":22,"./_export":38,"./_fails":40,"./_global":44,"./_is-object":55,"./_object-create":72}],207:[function(require,module,exports){
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP          = require('./_object-dp')
  , $export     = require('./_export')
  , anObject    = require('./_an-object')
  , toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function(){
  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes){
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./_an-object":13,"./_export":38,"./_fails":40,"./_object-dp":73,"./_to-primitive":116}],208:[function(require,module,exports){
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export  = require('./_export')
  , gOPD     = require('./_object-gopd').f
  , anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey){
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});
},{"./_an-object":13,"./_export":38,"./_object-gopd":76}],209:[function(require,module,exports){
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export  = require('./_export')
  , anObject = require('./_an-object');
var Enumerate = function(iterated){
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = []       // keys
    , key;
  for(key in iterated)keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function(){
  var that = this
    , keys = that._k
    , key;
  do {
    if(that._i >= keys.length)return {value: undefined, done: true};
  } while(!((key = keys[that._i++]) in that._t));
  return {value: key, done: false};
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target){
    return new Enumerate(target);
  }
});
},{"./_an-object":13,"./_export":38,"./_iter-create":58}],210:[function(require,module,exports){
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD     = require('./_object-gopd')
  , $export  = require('./_export')
  , anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
    return gOPD.f(anObject(target), propertyKey);
  }
});
},{"./_an-object":13,"./_export":38,"./_object-gopd":76}],211:[function(require,module,exports){
// 26.1.8 Reflect.getPrototypeOf(target)
var $export  = require('./_export')
  , getProto = require('./_object-gpo')
  , anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target){
    return getProto(anObject(target));
  }
});
},{"./_an-object":13,"./_export":38,"./_object-gpo":80}],212:[function(require,module,exports){
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD           = require('./_object-gopd')
  , getPrototypeOf = require('./_object-gpo')
  , has            = require('./_has')
  , $export        = require('./_export')
  , isObject       = require('./_is-object')
  , anObject       = require('./_an-object');

function get(target, propertyKey/*, receiver*/){
  var receiver = arguments.length < 3 ? target : arguments[2]
    , desc, proto;
  if(anObject(target) === receiver)return target[propertyKey];
  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', {get: get});
},{"./_an-object":13,"./_export":38,"./_has":45,"./_is-object":55,"./_object-gopd":76,"./_object-gpo":80}],213:[function(require,module,exports){
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey){
    return propertyKey in target;
  }
});
},{"./_export":38}],214:[function(require,module,exports){
// 26.1.10 Reflect.isExtensible(target)
var $export       = require('./_export')
  , anObject      = require('./_an-object')
  , $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target){
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});
},{"./_an-object":13,"./_export":38}],215:[function(require,module,exports){
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', {ownKeys: require('./_own-keys')});
},{"./_export":38,"./_own-keys":86}],216:[function(require,module,exports){
// 26.1.12 Reflect.preventExtensions(target)
var $export            = require('./_export')
  , anObject           = require('./_an-object')
  , $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target){
    anObject(target);
    try {
      if($preventExtensions)$preventExtensions(target);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./_an-object":13,"./_export":38}],217:[function(require,module,exports){
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export  = require('./_export')
  , setProto = require('./_set-proto');

if(setProto)$export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto){
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./_export":38,"./_set-proto":96}],218:[function(require,module,exports){
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP             = require('./_object-dp')
  , gOPD           = require('./_object-gopd')
  , getPrototypeOf = require('./_object-gpo')
  , has            = require('./_has')
  , $export        = require('./_export')
  , createDesc     = require('./_property-desc')
  , anObject       = require('./_an-object')
  , isObject       = require('./_is-object');

function set(target, propertyKey, V/*, receiver*/){
  var receiver = arguments.length < 4 ? target : arguments[3]
    , ownDesc  = gOPD.f(anObject(target), propertyKey)
    , existingDescriptor, proto;
  if(!ownDesc){
    if(isObject(proto = getPrototypeOf(target))){
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if(has(ownDesc, 'value')){
    if(ownDesc.writable === false || !isObject(receiver))return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', {set: set});
},{"./_an-object":13,"./_export":38,"./_has":45,"./_is-object":55,"./_object-dp":73,"./_object-gopd":76,"./_object-gpo":80,"./_property-desc":91}],219:[function(require,module,exports){
var global            = require('./_global')
  , inheritIfRequired = require('./_inherit-if-required')
  , dP                = require('./_object-dp').f
  , gOPN              = require('./_object-gopn').f
  , isRegExp          = require('./_is-regexp')
  , $flags            = require('./_flags')
  , $RegExp           = global.RegExp
  , Base              = $RegExp
  , proto             = $RegExp.prototype
  , re1               = /a/g
  , re2               = /a/g
  // "new" creates a new object, old webkit buggy here
  , CORRECT_NEW       = new $RegExp(re1) !== re1;

if(require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function(){
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))){
  $RegExp = function RegExp(p, f){
    var tiRE = this instanceof $RegExp
      , piRE = isRegExp(p)
      , fiU  = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function(key){
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function(){ return Base[key]; },
      set: function(it){ Base[key] = it; }
    });
  };
  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');
},{"./_descriptors":34,"./_fails":40,"./_flags":42,"./_global":44,"./_inherit-if-required":49,"./_is-regexp":56,"./_object-dp":73,"./_object-gopn":78,"./_redefine":93,"./_set-species":97,"./_wks":123}],220:[function(require,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
if(require('./_descriptors') && /./g.flags != 'g')require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});
},{"./_descriptors":34,"./_flags":42,"./_object-dp":73}],221:[function(require,module,exports){
// @@match logic
require('./_fix-re-wks')('match', 1, function(defined, MATCH, $match){
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});
},{"./_fix-re-wks":41}],222:[function(require,module,exports){
// @@replace logic
require('./_fix-re-wks')('replace', 2, function(defined, REPLACE, $replace){
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue){
    'use strict';
    var O  = defined(this)
      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});
},{"./_fix-re-wks":41}],223:[function(require,module,exports){
// @@search logic
require('./_fix-re-wks')('search', 1, function(defined, SEARCH, $search){
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});
},{"./_fix-re-wks":41}],224:[function(require,module,exports){
// @@split logic
require('./_fix-re-wks')('split', 2, function(defined, SPLIT, $split){
  'use strict';
  var isRegExp   = require('./_is-regexp')
    , _split     = $split
    , $push      = [].push
    , $SPLIT     = 'split'
    , LENGTH     = 'length'
    , LAST_INDEX = 'lastIndex';
  if(
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ){
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function(separator, limit){
      var string = String(this);
      if(separator === undefined && limit === 0)return [];
      // If `separator` is not a regex, use native split
      if(!isRegExp(separator))return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while(match = separatorCopy.exec(string)){
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if(lastIndex > lastLastIndex){
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
          });
          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if(output[LENGTH] >= splitLimit)break;
        }
        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if(lastLastIndex === string[LENGTH]){
        if(lastLength || !separatorCopy.test(''))output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
    $split = function(separator, limit){
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit){
    var O  = defined(this)
      , fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});
},{"./_fix-re-wks":41,"./_is-regexp":56}],225:[function(require,module,exports){
'use strict';
require('./es6.regexp.flags');
var anObject    = require('./_an-object')
  , $flags      = require('./_flags')
  , DESCRIPTORS = require('./_descriptors')
  , TO_STRING   = 'toString'
  , $toString   = /./[TO_STRING];

var define = function(fn){
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if(require('./_fails')(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
  define(function toString(){
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if($toString.name != TO_STRING){
  define(function toString(){
    return $toString.call(this);
  });
}
},{"./_an-object":13,"./_descriptors":34,"./_fails":40,"./_flags":42,"./_redefine":93,"./es6.regexp.flags":220}],226:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');

// 23.2 Set Objects
module.exports = require('./_collection')('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./_collection":28,"./_collection-strong":25}],227:[function(require,module,exports){
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function(createHTML){
  return function anchor(name){
    return createHTML(this, 'a', 'name', name);
  }
});
},{"./_string-html":105}],228:[function(require,module,exports){
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function(createHTML){
  return function big(){
    return createHTML(this, 'big', '', '');
  }
});
},{"./_string-html":105}],229:[function(require,module,exports){
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function(createHTML){
  return function blink(){
    return createHTML(this, 'blink', '', '');
  }
});
},{"./_string-html":105}],230:[function(require,module,exports){
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function(createHTML){
  return function bold(){
    return createHTML(this, 'b', '', '');
  }
});
},{"./_string-html":105}],231:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $at     = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos){
    return $at(this, pos);
  }
});
},{"./_export":38,"./_string-at":103}],232:[function(require,module,exports){
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export   = require('./_export')
  , toLength  = require('./_to-length')
  , context   = require('./_string-context')
  , ENDS_WITH = 'endsWith'
  , $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /*, endPosition = @length */){
    var that = context(this, searchString, ENDS_WITH)
      , endPosition = arguments.length > 1 ? arguments[1] : undefined
      , len    = toLength(that.length)
      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
      , search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});
},{"./_export":38,"./_fails-is-regexp":39,"./_string-context":104,"./_to-length":114}],233:[function(require,module,exports){
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function(createHTML){
  return function fixed(){
    return createHTML(this, 'tt', '', '');
  }
});
},{"./_string-html":105}],234:[function(require,module,exports){
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function(createHTML){
  return function fontcolor(color){
    return createHTML(this, 'font', 'color', color);
  }
});
},{"./_string-html":105}],235:[function(require,module,exports){
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function(createHTML){
  return function fontsize(size){
    return createHTML(this, 'font', 'size', size);
  }
});
},{"./_string-html":105}],236:[function(require,module,exports){
var $export        = require('./_export')
  , toIndex        = require('./_to-index')
  , fromCharCode   = String.fromCharCode
  , $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
    var res  = []
      , aLen = arguments.length
      , i    = 0
      , code;
    while(aLen > i){
      code = +arguments[i++];
      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});
},{"./_export":38,"./_to-index":111}],237:[function(require,module,exports){
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export  = require('./_export')
  , context  = require('./_string-context')
  , INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /*, position = 0 */){
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});
},{"./_export":38,"./_fails-is-regexp":39,"./_string-context":104}],238:[function(require,module,exports){
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function(createHTML){
  return function italics(){
    return createHTML(this, 'i', '', '');
  }
});
},{"./_string-html":105}],239:[function(require,module,exports){
'use strict';
var $at  = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./_iter-define":59,"./_string-at":103}],240:[function(require,module,exports){
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function(createHTML){
  return function link(url){
    return createHTML(this, 'a', 'href', url);
  }
});
},{"./_string-html":105}],241:[function(require,module,exports){
var $export   = require('./_export')
  , toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite){
    var tpl  = toIObject(callSite.raw)
      , len  = toLength(tpl.length)
      , aLen = arguments.length
      , res  = []
      , i    = 0;
    while(len > i){
      res.push(String(tpl[i++]));
      if(i < aLen)res.push(String(arguments[i]));
    } return res.join('');
  }
});
},{"./_export":38,"./_to-iobject":113,"./_to-length":114}],242:[function(require,module,exports){
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});
},{"./_export":38,"./_string-repeat":107}],243:[function(require,module,exports){
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function(createHTML){
  return function small(){
    return createHTML(this, 'small', '', '');
  }
});
},{"./_string-html":105}],244:[function(require,module,exports){
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export     = require('./_export')
  , toLength    = require('./_to-length')
  , context     = require('./_string-context')
  , STARTS_WITH = 'startsWith'
  , $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /*, position = 0 */){
    var that   = context(this, searchString, STARTS_WITH)
      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
      , search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});
},{"./_export":38,"./_fails-is-regexp":39,"./_string-context":104,"./_to-length":114}],245:[function(require,module,exports){
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function(createHTML){
  return function strike(){
    return createHTML(this, 'strike', '', '');
  }
});
},{"./_string-html":105}],246:[function(require,module,exports){
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function(createHTML){
  return function sub(){
    return createHTML(this, 'sub', '', '');
  }
});
},{"./_string-html":105}],247:[function(require,module,exports){
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function(createHTML){
  return function sup(){
    return createHTML(this, 'sup', '', '');
  }
});
},{"./_string-html":105}],248:[function(require,module,exports){
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function($trim){
  return function trim(){
    return $trim(this, 3);
  };
});
},{"./_string-trim":108}],249:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global         = require('./_global')
  , has            = require('./_has')
  , DESCRIPTORS    = require('./_descriptors')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , META           = require('./_meta').KEY
  , $fails         = require('./_fails')
  , shared         = require('./_shared')
  , setToStringTag = require('./_set-to-string-tag')
  , uid            = require('./_uid')
  , wks            = require('./_wks')
  , wksExt         = require('./_wks-ext')
  , wksDefine      = require('./_wks-define')
  , keyOf          = require('./_keyof')
  , enumKeys       = require('./_enum-keys')
  , isArray        = require('./_is-array')
  , anObject       = require('./_an-object')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , createDesc     = require('./_property-desc')
  , _create        = require('./_object-create')
  , gOPNExt        = require('./_object-gopn-ext')
  , $GOPD          = require('./_object-gopd')
  , $DP            = require('./_object-dp')
  , $keys          = require('./_object-keys')
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f  = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !require('./_library')){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);
},{"./_an-object":13,"./_descriptors":34,"./_enum-keys":37,"./_export":38,"./_fails":40,"./_global":44,"./_has":45,"./_hide":46,"./_is-array":53,"./_keyof":63,"./_library":64,"./_meta":68,"./_object-create":72,"./_object-dp":73,"./_object-gopd":76,"./_object-gopn":78,"./_object-gopn-ext":77,"./_object-gops":79,"./_object-keys":82,"./_object-pie":83,"./_property-desc":91,"./_redefine":93,"./_set-to-string-tag":98,"./_shared":100,"./_to-iobject":113,"./_to-primitive":116,"./_uid":120,"./_wks":123,"./_wks-define":121,"./_wks-ext":122}],250:[function(require,module,exports){
'use strict';
var $export      = require('./_export')
  , $typed       = require('./_typed')
  , buffer       = require('./_typed-buffer')
  , anObject     = require('./_an-object')
  , toIndex      = require('./_to-index')
  , toLength     = require('./_to-length')
  , isObject     = require('./_is-object')
  , ArrayBuffer  = require('./_global').ArrayBuffer
  , speciesConstructor = require('./_species-constructor')
  , $ArrayBuffer = buffer.ArrayBuffer
  , $DataView    = buffer.DataView
  , $isView      = $typed.ABV && ArrayBuffer.isView
  , $slice       = $ArrayBuffer.prototype.slice
  , VIEW         = $typed.VIEW
  , ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it){
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function(){
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end){
    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
    var len    = anObject(this).byteLength
      , first  = toIndex(start, len)
      , final  = toIndex(end === undefined ? len : end, len)
      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
      , viewS  = new $DataView(this)
      , viewT  = new $DataView(result)
      , index  = 0;
    while(first < final){
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);
},{"./_an-object":13,"./_export":38,"./_fails":40,"./_global":44,"./_is-object":55,"./_set-species":97,"./_species-constructor":101,"./_to-index":111,"./_to-length":114,"./_typed":119,"./_typed-buffer":118}],251:[function(require,module,exports){
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});
},{"./_export":38,"./_typed":119,"./_typed-buffer":118}],252:[function(require,module,exports){
require('./_typed-array')('Float32', 4, function(init){
  return function Float32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":117}],253:[function(require,module,exports){
require('./_typed-array')('Float64', 8, function(init){
  return function Float64Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":117}],254:[function(require,module,exports){
require('./_typed-array')('Int16', 2, function(init){
  return function Int16Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":117}],255:[function(require,module,exports){
require('./_typed-array')('Int32', 4, function(init){
  return function Int32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":117}],256:[function(require,module,exports){
require('./_typed-array')('Int8', 1, function(init){
  return function Int8Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":117}],257:[function(require,module,exports){
require('./_typed-array')('Uint16', 2, function(init){
  return function Uint16Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":117}],258:[function(require,module,exports){
require('./_typed-array')('Uint32', 4, function(init){
  return function Uint32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":117}],259:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function(init){
  return function Uint8Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":117}],260:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function(init){
  return function Uint8ClampedArray(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
}, true);
},{"./_typed-array":117}],261:[function(require,module,exports){
'use strict';
var each         = require('./_array-methods')(0)
  , redefine     = require('./_redefine')
  , meta         = require('./_meta')
  , assign       = require('./_object-assign')
  , weak         = require('./_collection-weak')
  , isObject     = require('./_is-object')
  , getWeak      = meta.getWeak
  , isExtensible = Object.isExtensible
  , uncaughtFrozenStore = weak.ufstore
  , tmp          = {}
  , InternalMap;

var wrapper = function(get){
  return function WeakMap(){
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key){
    if(isObject(key)){
      var data = getWeak(key);
      if(data === true)return uncaughtFrozenStore(this).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value){
    return weak.def(this, key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')('WeakMap', wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
  InternalMap = weak.getConstructor(wrapper);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function(key){
    var proto  = $WeakMap.prototype
      , method = proto[key];
    redefine(proto, key, function(a, b){
      // store frozen objects on internal weakmap shim
      if(isObject(a) && !isExtensible(a)){
        if(!this._f)this._f = new InternalMap;
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}
},{"./_array-methods":18,"./_collection":28,"./_collection-weak":27,"./_is-object":55,"./_meta":68,"./_object-assign":71,"./_redefine":93}],262:[function(require,module,exports){
'use strict';
var weak = require('./_collection-weak');

// 23.4 WeakSet Objects
require('./_collection')('WeakSet', function(get){
  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value){
    return weak.def(this, value, true);
  }
}, weak, false, true);
},{"./_collection":28,"./_collection-weak":27}],263:[function(require,module,exports){
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export   = require('./_export')
  , $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /*, fromIndex = 0 */){
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');
},{"./_add-to-unscopables":11,"./_array-includes":17,"./_export":38}],264:[function(require,module,exports){
// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export   = require('./_export')
  , microtask = require('./_microtask')()
  , process   = require('./_global').process
  , isNode    = require('./_cof')(process) == 'process';

$export($export.G, {
  asap: function asap(fn){
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});
},{"./_cof":24,"./_export":38,"./_global":44,"./_microtask":70}],265:[function(require,module,exports){
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export')
  , cof     = require('./_cof');

$export($export.S, 'Error', {
  isError: function isError(it){
    return cof(it) === 'Error';
  }
});
},{"./_cof":24,"./_export":38}],266:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./_export');

$export($export.P + $export.R, 'Map', {toJSON: require('./_collection-to-json')('Map')});
},{"./_collection-to-json":26,"./_export":38}],267:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1){
    var $x0 = x0 >>> 0
      , $x1 = x1 >>> 0
      , $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});
},{"./_export":38}],268:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  imulh: function imulh(u, v){
    var UINT16 = 0xffff
      , $u = +u
      , $v = +v
      , u0 = $u & UINT16
      , v0 = $v & UINT16
      , u1 = $u >> 16
      , v1 = $v >> 16
      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});
},{"./_export":38}],269:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1){
    var $x0 = x0 >>> 0
      , $x1 = x1 >>> 0
      , $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});
},{"./_export":38}],270:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  umulh: function umulh(u, v){
    var UINT16 = 0xffff
      , $u = +u
      , $v = +v
      , u0 = $u & UINT16
      , v0 = $v & UINT16
      , u1 = $u >>> 16
      , v1 = $v >>> 16
      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});
},{"./_export":38}],271:[function(require,module,exports){
'use strict';
var $export         = require('./_export')
  , toObject        = require('./_to-object')
  , aFunction       = require('./_a-function')
  , $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter){
    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
  }
});
},{"./_a-function":9,"./_descriptors":34,"./_export":38,"./_object-dp":73,"./_object-forced-pam":75,"./_to-object":115}],272:[function(require,module,exports){
'use strict';
var $export         = require('./_export')
  , toObject        = require('./_to-object')
  , aFunction       = require('./_a-function')
  , $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter){
    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
  }
});
},{"./_a-function":9,"./_descriptors":34,"./_export":38,"./_object-dp":73,"./_object-forced-pam":75,"./_to-object":115}],273:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export  = require('./_export')
  , $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it){
    return $entries(it);
  }
});
},{"./_export":38,"./_object-to-array":85}],274:[function(require,module,exports){
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export        = require('./_export')
  , ownKeys        = require('./_own-keys')
  , toIObject      = require('./_to-iobject')
  , gOPD           = require('./_object-gopd')
  , createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
    var O       = toIObject(object)
      , getDesc = gOPD.f
      , keys    = ownKeys(O)
      , result  = {}
      , i       = 0
      , key;
    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
    return result;
  }
});
},{"./_create-property":30,"./_export":38,"./_object-gopd":76,"./_own-keys":86,"./_to-iobject":113}],275:[function(require,module,exports){
'use strict';
var $export                  = require('./_export')
  , toObject                 = require('./_to-object')
  , toPrimitive              = require('./_to-primitive')
  , getPrototypeOf           = require('./_object-gpo')
  , getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P){
    var O = toObject(this)
      , K = toPrimitive(P, true)
      , D;
    do {
      if(D = getOwnPropertyDescriptor(O, K))return D.get;
    } while(O = getPrototypeOf(O));
  }
});
},{"./_descriptors":34,"./_export":38,"./_object-forced-pam":75,"./_object-gopd":76,"./_object-gpo":80,"./_to-object":115,"./_to-primitive":116}],276:[function(require,module,exports){
'use strict';
var $export                  = require('./_export')
  , toObject                 = require('./_to-object')
  , toPrimitive              = require('./_to-primitive')
  , getPrototypeOf           = require('./_object-gpo')
  , getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P){
    var O = toObject(this)
      , K = toPrimitive(P, true)
      , D;
    do {
      if(D = getOwnPropertyDescriptor(O, K))return D.set;
    } while(O = getPrototypeOf(O));
  }
});
},{"./_descriptors":34,"./_export":38,"./_object-forced-pam":75,"./_object-gopd":76,"./_object-gpo":80,"./_to-object":115,"./_to-primitive":116}],277:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export')
  , $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it){
    return $values(it);
  }
});
},{"./_export":38,"./_object-to-array":85}],278:[function(require,module,exports){
'use strict';
// https://github.com/zenparsing/es-observable
var $export     = require('./_export')
  , global      = require('./_global')
  , core        = require('./_core')
  , microtask   = require('./_microtask')()
  , OBSERVABLE  = require('./_wks')('observable')
  , aFunction   = require('./_a-function')
  , anObject    = require('./_an-object')
  , anInstance  = require('./_an-instance')
  , redefineAll = require('./_redefine-all')
  , hide        = require('./_hide')
  , forOf       = require('./_for-of')
  , RETURN      = forOf.RETURN;

var getMethod = function(fn){
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function(subscription){
  var cleanup = subscription._c;
  if(cleanup){
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function(subscription){
  return subscription._o === undefined;
};

var closeSubscription = function(subscription){
  if(!subscriptionClosed(subscription)){
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function(observer, subscriber){
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup      = subscriber(observer)
      , subscription = cleanup;
    if(cleanup != null){
      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch(e){
    observer.error(e);
    return;
  } if(subscriptionClosed(this))cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe(){ closeSubscription(this); }
});

var SubscriptionObserver = function(subscription){
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value){
    var subscription = this._s;
    if(!subscriptionClosed(subscription)){
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if(m)return m.call(observer, value);
      } catch(e){
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value){
    var subscription = this._s;
    if(subscriptionClosed(subscription))throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if(!m)throw value;
      value = m.call(observer, value);
    } catch(e){
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value){
    var subscription = this._s;
    if(!subscriptionClosed(subscription)){
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch(e){
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber){
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer){
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn){
    var that = this;
    return new (core.Promise || global.Promise)(function(resolve, reject){
      aFunction(fn);
      var subscription = that.subscribe({
        next : function(value){
          try {
            return fn(value);
          } catch(e){
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x){
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if(method){
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function(observer){
        return observable.subscribe(observer);
      });
    }
    return new C(function(observer){
      var done = false;
      microtask(function(){
        if(!done){
          try {
            if(forOf(x, false, function(it){
              observer.next(it);
              if(done)return RETURN;
            }) === RETURN)return;
          } catch(e){
            if(done)throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function(){ done = true; };
    });
  },
  of: function of(){
    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function(observer){
      var done = false;
      microtask(function(){
        if(!done){
          for(var i = 0; i < items.length; ++i){
            observer.next(items[i]);
            if(done)return;
          } observer.complete();
        }
      });
      return function(){ done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function(){ return this; });

$export($export.G, {Observable: $Observable});

require('./_set-species')('Observable');
},{"./_a-function":9,"./_an-instance":12,"./_an-object":13,"./_core":29,"./_export":38,"./_for-of":43,"./_global":44,"./_hide":46,"./_microtask":70,"./_redefine-all":92,"./_set-species":97,"./_wks":123}],279:[function(require,module,exports){
var metadata                  = require('./_metadata')
  , anObject                  = require('./_an-object')
  , toMetaKey                 = metadata.key
  , ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
}});
},{"./_an-object":13,"./_metadata":69}],280:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , toMetaKey              = metadata.key
  , getOrCreateMetadataMap = metadata.map
  , store                  = metadata.store;

metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
  if(metadataMap.size)return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
}});
},{"./_an-object":13,"./_metadata":69}],281:[function(require,module,exports){
var Set                     = require('./es6.set')
  , from                    = require('./_array-from-iterable')
  , metadata                = require('./_metadata')
  , anObject                = require('./_an-object')
  , getPrototypeOf          = require('./_object-gpo')
  , ordinaryOwnMetadataKeys = metadata.keys
  , toMetaKey               = metadata.key;

var ordinaryMetadataKeys = function(O, P){
  var oKeys  = ordinaryOwnMetadataKeys(O, P)
    , parent = getPrototypeOf(O);
  if(parent === null)return oKeys;
  var pKeys  = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
}});
},{"./_an-object":13,"./_array-from-iterable":16,"./_metadata":69,"./_object-gpo":80,"./es6.set":226}],282:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , getPrototypeOf         = require('./_object-gpo')
  , ordinaryHasOwnMetadata = metadata.has
  , ordinaryGetOwnMetadata = metadata.get
  , toMetaKey              = metadata.key;

var ordinaryGetMetadata = function(MetadataKey, O, P){
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":13,"./_metadata":69,"./_object-gpo":80}],283:[function(require,module,exports){
var metadata                = require('./_metadata')
  , anObject                = require('./_an-object')
  , ordinaryOwnMetadataKeys = metadata.keys
  , toMetaKey               = metadata.key;

metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
}});
},{"./_an-object":13,"./_metadata":69}],284:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , ordinaryGetOwnMetadata = metadata.get
  , toMetaKey              = metadata.key;

metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":13,"./_metadata":69}],285:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , getPrototypeOf         = require('./_object-gpo')
  , ordinaryHasOwnMetadata = metadata.has
  , toMetaKey              = metadata.key;

var ordinaryHasMetadata = function(MetadataKey, O, P){
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if(hasOwn)return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":13,"./_metadata":69,"./_object-gpo":80}],286:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , ordinaryHasOwnMetadata = metadata.has
  , toMetaKey              = metadata.key;

metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":13,"./_metadata":69}],287:[function(require,module,exports){
var metadata                  = require('./_metadata')
  , anObject                  = require('./_an-object')
  , aFunction                 = require('./_a-function')
  , toMetaKey                 = metadata.key
  , ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({metadata: function metadata(metadataKey, metadataValue){
  return function decorator(target, targetKey){
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
}});
},{"./_a-function":9,"./_an-object":13,"./_metadata":69}],288:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./_export');

$export($export.P + $export.R, 'Set', {toJSON: require('./_collection-to-json')('Set')});
},{"./_collection-to-json":26,"./_export":38}],289:[function(require,module,exports){
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export')
  , $at     = require('./_string-at')(true);

$export($export.P, 'String', {
  at: function at(pos){
    return $at(this, pos);
  }
});
},{"./_export":38,"./_string-at":103}],290:[function(require,module,exports){
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export     = require('./_export')
  , defined     = require('./_defined')
  , toLength    = require('./_to-length')
  , isRegExp    = require('./_is-regexp')
  , getFlags    = require('./_flags')
  , RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function(regexp, string){
  this._r = regexp;
  this._s = string;
};

require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next(){
  var match = this._r.exec(this._s);
  return {value: match, done: match === null};
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp){
    defined(this);
    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
    var S     = String(this)
      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});
},{"./_defined":33,"./_export":38,"./_flags":42,"./_is-regexp":56,"./_iter-create":58,"./_to-length":114}],291:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export')
  , $pad    = require('./_string-pad');

$export($export.P, 'String', {
  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});
},{"./_export":38,"./_string-pad":106}],292:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export')
  , $pad    = require('./_string-pad');

$export($export.P, 'String', {
  padStart: function padStart(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});
},{"./_export":38,"./_string-pad":106}],293:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function($trim){
  return function trimLeft(){
    return $trim(this, 1);
  };
}, 'trimStart');
},{"./_string-trim":108}],294:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function($trim){
  return function trimRight(){
    return $trim(this, 2);
  };
}, 'trimEnd');
},{"./_string-trim":108}],295:[function(require,module,exports){
require('./_wks-define')('asyncIterator');
},{"./_wks-define":121}],296:[function(require,module,exports){
require('./_wks-define')('observable');
},{"./_wks-define":121}],297:[function(require,module,exports){
// https://github.com/ljharb/proposal-global
var $export = require('./_export');

$export($export.S, 'System', {global: require('./_global')});
},{"./_export":38,"./_global":44}],298:[function(require,module,exports){
var $iterators    = require('./es6.array.iterator')
  , redefine      = require('./_redefine')
  , global        = require('./_global')
  , hide          = require('./_hide')
  , Iterators     = require('./_iterators')
  , wks           = require('./_wks')
  , ITERATOR      = wks('iterator')
  , TO_STRING_TAG = wks('toStringTag')
  , ArrayValues   = Iterators.Array;

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype
    , key;
  if(proto){
    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
  }
}
},{"./_global":44,"./_hide":46,"./_iterators":62,"./_redefine":93,"./_wks":123,"./es6.array.iterator":136}],299:[function(require,module,exports){
var $export = require('./_export')
  , $task   = require('./_task');
$export($export.G + $export.B, {
  setImmediate:   $task.set,
  clearImmediate: $task.clear
});
},{"./_export":38,"./_task":110}],300:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var global     = require('./_global')
  , $export    = require('./_export')
  , invoke     = require('./_invoke')
  , partial    = require('./_partial')
  , navigator  = global.navigator
  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
var wrap = function(set){
  return MSIE ? function(fn, time /*, ...args */){
    return set(invoke(
      partial,
      [].slice.call(arguments, 2),
      typeof fn == 'function' ? fn : Function(fn)
    ), time);
  } : set;
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout:  wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});
},{"./_export":38,"./_global":44,"./_invoke":50,"./_partial":89}],301:[function(require,module,exports){
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.umulh');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');
},{"./modules/_core":29,"./modules/es6.array.copy-within":126,"./modules/es6.array.every":127,"./modules/es6.array.fill":128,"./modules/es6.array.filter":129,"./modules/es6.array.find":131,"./modules/es6.array.find-index":130,"./modules/es6.array.for-each":132,"./modules/es6.array.from":133,"./modules/es6.array.index-of":134,"./modules/es6.array.is-array":135,"./modules/es6.array.iterator":136,"./modules/es6.array.join":137,"./modules/es6.array.last-index-of":138,"./modules/es6.array.map":139,"./modules/es6.array.of":140,"./modules/es6.array.reduce":142,"./modules/es6.array.reduce-right":141,"./modules/es6.array.slice":143,"./modules/es6.array.some":144,"./modules/es6.array.sort":145,"./modules/es6.array.species":146,"./modules/es6.date.now":147,"./modules/es6.date.to-iso-string":148,"./modules/es6.date.to-json":149,"./modules/es6.date.to-primitive":150,"./modules/es6.date.to-string":151,"./modules/es6.function.bind":152,"./modules/es6.function.has-instance":153,"./modules/es6.function.name":154,"./modules/es6.map":155,"./modules/es6.math.acosh":156,"./modules/es6.math.asinh":157,"./modules/es6.math.atanh":158,"./modules/es6.math.cbrt":159,"./modules/es6.math.clz32":160,"./modules/es6.math.cosh":161,"./modules/es6.math.expm1":162,"./modules/es6.math.fround":163,"./modules/es6.math.hypot":164,"./modules/es6.math.imul":165,"./modules/es6.math.log10":166,"./modules/es6.math.log1p":167,"./modules/es6.math.log2":168,"./modules/es6.math.sign":169,"./modules/es6.math.sinh":170,"./modules/es6.math.tanh":171,"./modules/es6.math.trunc":172,"./modules/es6.number.constructor":173,"./modules/es6.number.epsilon":174,"./modules/es6.number.is-finite":175,"./modules/es6.number.is-integer":176,"./modules/es6.number.is-nan":177,"./modules/es6.number.is-safe-integer":178,"./modules/es6.number.max-safe-integer":179,"./modules/es6.number.min-safe-integer":180,"./modules/es6.number.parse-float":181,"./modules/es6.number.parse-int":182,"./modules/es6.number.to-fixed":183,"./modules/es6.number.to-precision":184,"./modules/es6.object.assign":185,"./modules/es6.object.create":186,"./modules/es6.object.define-properties":187,"./modules/es6.object.define-property":188,"./modules/es6.object.freeze":189,"./modules/es6.object.get-own-property-descriptor":190,"./modules/es6.object.get-own-property-names":191,"./modules/es6.object.get-prototype-of":192,"./modules/es6.object.is":196,"./modules/es6.object.is-extensible":193,"./modules/es6.object.is-frozen":194,"./modules/es6.object.is-sealed":195,"./modules/es6.object.keys":197,"./modules/es6.object.prevent-extensions":198,"./modules/es6.object.seal":199,"./modules/es6.object.set-prototype-of":200,"./modules/es6.object.to-string":201,"./modules/es6.parse-float":202,"./modules/es6.parse-int":203,"./modules/es6.promise":204,"./modules/es6.reflect.apply":205,"./modules/es6.reflect.construct":206,"./modules/es6.reflect.define-property":207,"./modules/es6.reflect.delete-property":208,"./modules/es6.reflect.enumerate":209,"./modules/es6.reflect.get":212,"./modules/es6.reflect.get-own-property-descriptor":210,"./modules/es6.reflect.get-prototype-of":211,"./modules/es6.reflect.has":213,"./modules/es6.reflect.is-extensible":214,"./modules/es6.reflect.own-keys":215,"./modules/es6.reflect.prevent-extensions":216,"./modules/es6.reflect.set":218,"./modules/es6.reflect.set-prototype-of":217,"./modules/es6.regexp.constructor":219,"./modules/es6.regexp.flags":220,"./modules/es6.regexp.match":221,"./modules/es6.regexp.replace":222,"./modules/es6.regexp.search":223,"./modules/es6.regexp.split":224,"./modules/es6.regexp.to-string":225,"./modules/es6.set":226,"./modules/es6.string.anchor":227,"./modules/es6.string.big":228,"./modules/es6.string.blink":229,"./modules/es6.string.bold":230,"./modules/es6.string.code-point-at":231,"./modules/es6.string.ends-with":232,"./modules/es6.string.fixed":233,"./modules/es6.string.fontcolor":234,"./modules/es6.string.fontsize":235,"./modules/es6.string.from-code-point":236,"./modules/es6.string.includes":237,"./modules/es6.string.italics":238,"./modules/es6.string.iterator":239,"./modules/es6.string.link":240,"./modules/es6.string.raw":241,"./modules/es6.string.repeat":242,"./modules/es6.string.small":243,"./modules/es6.string.starts-with":244,"./modules/es6.string.strike":245,"./modules/es6.string.sub":246,"./modules/es6.string.sup":247,"./modules/es6.string.trim":248,"./modules/es6.symbol":249,"./modules/es6.typed.array-buffer":250,"./modules/es6.typed.data-view":251,"./modules/es6.typed.float32-array":252,"./modules/es6.typed.float64-array":253,"./modules/es6.typed.int16-array":254,"./modules/es6.typed.int32-array":255,"./modules/es6.typed.int8-array":256,"./modules/es6.typed.uint16-array":257,"./modules/es6.typed.uint32-array":258,"./modules/es6.typed.uint8-array":259,"./modules/es6.typed.uint8-clamped-array":260,"./modules/es6.weak-map":261,"./modules/es6.weak-set":262,"./modules/es7.array.includes":263,"./modules/es7.asap":264,"./modules/es7.error.is-error":265,"./modules/es7.map.to-json":266,"./modules/es7.math.iaddh":267,"./modules/es7.math.imulh":268,"./modules/es7.math.isubh":269,"./modules/es7.math.umulh":270,"./modules/es7.object.define-getter":271,"./modules/es7.object.define-setter":272,"./modules/es7.object.entries":273,"./modules/es7.object.get-own-property-descriptors":274,"./modules/es7.object.lookup-getter":275,"./modules/es7.object.lookup-setter":276,"./modules/es7.object.values":277,"./modules/es7.observable":278,"./modules/es7.reflect.define-metadata":279,"./modules/es7.reflect.delete-metadata":280,"./modules/es7.reflect.get-metadata":282,"./modules/es7.reflect.get-metadata-keys":281,"./modules/es7.reflect.get-own-metadata":284,"./modules/es7.reflect.get-own-metadata-keys":283,"./modules/es7.reflect.has-metadata":285,"./modules/es7.reflect.has-own-metadata":286,"./modules/es7.reflect.metadata":287,"./modules/es7.set.to-json":288,"./modules/es7.string.at":289,"./modules/es7.string.match-all":290,"./modules/es7.string.pad-end":291,"./modules/es7.string.pad-start":292,"./modules/es7.string.trim-left":293,"./modules/es7.string.trim-right":294,"./modules/es7.symbol.async-iterator":295,"./modules/es7.symbol.observable":296,"./modules/es7.system.global":297,"./modules/web.dom.iterable":298,"./modules/web.immediate":299,"./modules/web.timers":300}],302:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],303:[function(require,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	global.Ractive.transitions.fade = factory();
}(this, function () { 'use strict';

	var DEFAULTS = {
		delay: 0,
		duration: 300,
		easing: 'linear'
	};

	function fade(t, params) {
		var targetOpacity;

		params = t.processParams(params, DEFAULTS);

		if (t.isIntro) {
			targetOpacity = t.getStyle('opacity');
			t.setStyle('opacity', 0);
		} else {
			targetOpacity = 0;
		}

		t.animateStyle('opacity', targetOpacity, params).then(t.complete);
	}

	return fade;

}));
},{}],304:[function(require,module,exports){
(function (global){
/*
	Ractive.js v0.8.5
	Sun Nov 13 2016 17:56:27 GMT+0000 (UTC) - commit d533d91f155a4f042c1acc87136459141c2c8af9

	http://ractivejs.org
	http://twitter.com/RactiveJS

	Released under the MIT License.
*/


(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  ((function() { var current = global.Ractive; var next = factory(); next.noConflict = function() { global.Ractive = current; return next; }; return global.Ractive = next; })());
}(this, function () { 'use strict';

  var defaults = {
  	// render placement:
  	el:                     void 0,
  	append:				    false,

  	// template:
  	template:               null,

  	// parse:
  	delimiters:             [ '{{', '}}' ],
  	tripleDelimiters:       [ '{{{', '}}}' ],
  	staticDelimiters:       [ '[[', ']]' ],
  	staticTripleDelimiters: [ '[[[', ']]]' ],
  	csp: 					true,
  	interpolate:            false,
  	preserveWhitespace:     false,
  	sanitize:               false,
  	stripComments:          true,
  	contextLines:           0,

  	// data & binding:
  	data:                   {},
  	computed:               {},
  	magic:                  false,
  	modifyArrays:           false,
  	adapt:                  [],
  	isolated:               false,
  	twoway:                 true,
  	lazy:                   false,

  	// transitions:
  	noIntro:                false,
  	transitionsEnabled:     true,
  	complete:               void 0,

  	// css:
  	css:                    null,
  	noCssTransform:         false
  };

  // These are a subset of the easing equations found at
  // https://raw.github.com/danro/easing-js - license info
  // follows:

  // --------------------------------------------------
  // easing.js v0.5.4
  // Generic set of easing functions with AMD support
  // https://github.com/danro/easing-js
  // This code may be freely distributed under the MIT license
  // http://danro.mit-license.org/
  // --------------------------------------------------
  // All functions adapted from Thomas Fuchs & Jeremy Kahn
  // Easing Equations (c) 2003 Robert Penner, BSD license
  // https://raw.github.com/danro/easing-js/master/LICENSE
  // --------------------------------------------------

  // In that library, the functions named easeIn, easeOut, and
  // easeInOut below are named easeInCubic, easeOutCubic, and
  // (you guessed it) easeInOutCubic.
  //
  // You can add additional easing functions to this list, and they
  // will be globally available.


  var easing = {
  	linear: function ( pos ) { return pos; },
  	easeIn: function ( pos ) { return Math.pow( pos, 3 ); },
  	easeOut: function ( pos ) { return ( Math.pow( ( pos - 1 ), 3 ) + 1 ); },
  	easeInOut: function ( pos ) {
  		if ( ( pos /= 0.5 ) < 1 ) { return ( 0.5 * Math.pow( pos, 3 ) ); }
  		return ( 0.5 * ( Math.pow( ( pos - 2 ), 3 ) + 2 ) );
  	}
  };

  var legacy = null;

  /*global console, navigator */

  var win = typeof window !== 'undefined' ? window : null;
  var doc = win ? document : null;

  var isClient = !!doc;
  var isJsdom = ( typeof navigator !== 'undefined' && /jsDom/.test( navigator.appName ) );
  var hasConsole = ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' );

  var magicSupported;
  try {
  	Object.defineProperty({}, 'test', { value: 0 });
  	magicSupported = true;
  } catch ( e ) {
  	magicSupported = false;
  }

  var svg = doc ?
  	doc.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' ) :
  	false;

  var vendors = [ 'o', 'ms', 'moz', 'webkit' ];

  var html   = 'http://www.w3.org/1999/xhtml';
  var mathml = 'http://www.w3.org/1998/Math/MathML';
  var svg$1    = 'http://www.w3.org/2000/svg';
  var xlink  = 'http://www.w3.org/1999/xlink';
  var xml    = 'http://www.w3.org/XML/1998/namespace';
  var xmlns  = 'http://www.w3.org/2000/xmlns';

  var namespaces = { html: html, mathml: mathml, svg: svg$1, xlink: xlink, xml: xml, xmlns: xmlns };

  var createElement;
  var matches;
  var div;
  var methodNames;
  var unprefixed;
  var prefixed;
  var i;
  var j;
  var makeFunction;
  // Test for SVG support
  if ( !svg ) {
  	createElement = function ( type, ns, extend ) {
  		if ( ns && ns !== html ) {
  			throw 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';
  		}

  		return extend ?
  			doc.createElement( type, extend ) :
  			doc.createElement( type );
  	};
  } else {
  	createElement = function ( type, ns, extend ) {
  		if ( !ns || ns === html ) {
  			return extend ?
  				doc.createElement( type, extend ) :
  				doc.createElement( type );
  		}

  		return extend ?
  			doc.createElementNS( ns, type, extend ) :
  			doc.createElementNS( ns, type );
  	};
  }

  function createDocumentFragment () {
  	return doc.createDocumentFragment();
  }

  function getElement ( input ) {
  	var output;

  	if ( !input || typeof input === 'boolean' ) { return; }

  	if ( !win || !doc || !input ) {
  		return null;
  	}

  	// We already have a DOM node - no work to do. (Duck typing alert!)
  	if ( input.nodeType ) {
  		return input;
  	}

  	// Get node from string
  	if ( typeof input === 'string' ) {
  		// try ID first
  		output = doc.getElementById( input );

  		// then as selector, if possible
  		if ( !output && doc.querySelector ) {
  			output = doc.querySelector( input );
  		}

  		// did it work?
  		if ( output && output.nodeType ) {
  			return output;
  		}
  	}

  	// If we've been given a collection (jQuery, Zepto etc), extract the first item
  	if ( input[0] && input[0].nodeType ) {
  		return input[0];
  	}

  	return null;
  }

  if ( !isClient ) {
  	matches = null;
  } else {
  	div = createElement( 'div' );
  	methodNames = [ 'matches', 'matchesSelector' ];

  	makeFunction = function ( methodName ) {
  		return function ( node, selector ) {
  			return node[ methodName ]( selector );
  		};
  	};

  	i = methodNames.length;

  	while ( i-- && !matches ) {
  		unprefixed = methodNames[i];

  		if ( div[ unprefixed ] ) {
  			matches = makeFunction( unprefixed );
  		} else {
  			j = vendors.length;
  			while ( j-- ) {
  				prefixed = vendors[i] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );

  				if ( div[ prefixed ] ) {
  					matches = makeFunction( prefixed );
  					break;
  				}
  			}
  		}
  	}

  	// IE8...
  	if ( !matches ) {
  		matches = function ( node, selector ) {
  			var nodes, parentNode, i;

  			parentNode = node.parentNode;

  			if ( !parentNode ) {
  				// empty dummy <div>
  				div.innerHTML = '';

  				parentNode = div;
  				node = node.cloneNode();

  				div.appendChild( node );
  			}

  			nodes = parentNode.querySelectorAll( selector );

  			i = nodes.length;
  			while ( i-- ) {
  				if ( nodes[i] === node ) {
  					return true;
  				}
  			}

  			return false;
  		};
  	}
  }

  function detachNode ( node ) {
  	if ( node && typeof node.parentNode !== 'unknown' && node.parentNode ) {
  		node.parentNode.removeChild( node );
  	}

  	return node;
  }

  function safeToStringValue ( value ) {
  	return ( value == null || !value.toString ) ? '' : '' + value;
  }

  function safeAttributeString ( string ) {
  	return safeToStringValue( string )
  		.replace( /&/g, '&amp;' )
  		.replace( /"/g, '&quot;' )
  		.replace( /'/g, '&#39;' );
  }

  var camel = /(-.)/g;
  function camelize ( string ) {
  	return string.replace( camel, function ( s ) { return s.charAt( 1 ).toUpperCase(); } );
  }

  var decamel = /[A-Z]/g;
  function decamelize ( string ) {
  	return string.replace( decamel, function ( s ) { return ("-" + (s.toLowerCase())); } );
  }

  var create;
  var defineProperty;
  var defineProperties;
  try {
  	Object.defineProperty({}, 'test', { get: function() {}, set: function() {} });

  	if ( doc ) {
  		Object.defineProperty( createElement( 'div' ), 'test', { value: 0 });
  	}

  	defineProperty = Object.defineProperty;
  } catch ( err ) {
  	// Object.defineProperty doesn't exist, or we're in IE8 where you can
  	// only use it with DOM objects (what were you smoking, MSFT?)
  	defineProperty = function ( obj, prop, desc ) {
  		if ( desc.get ) obj[ prop ] = desc.get();
  		else obj[ prop ] = desc.value;
  	};
  }

  try {
  	try {
  		Object.defineProperties({}, { test: { value: 0 } });
  	} catch ( err ) {
  		// TODO how do we account for this? noMagic = true;
  		throw err;
  	}

  	if ( doc ) {
  		Object.defineProperties( createElement( 'div' ), { test: { value: 0 } });
  	}

  	defineProperties = Object.defineProperties;
  } catch ( err ) {
  	defineProperties = function ( obj, props ) {
  		var prop;

  		for ( prop in props ) {
  			if ( props.hasOwnProperty( prop ) ) {
  				defineProperty( obj, prop, props[ prop ] );
  			}
  		}
  	};
  }

  try {
  	Object.create( null );

  	create = Object.create;
  } catch ( err ) {
  	// sigh
  	create = (function () {
  		var F = function () {};

  		return function ( proto, props ) {
  			var obj;

  			if ( proto === null ) {
  				return {};
  			}

  			F.prototype = proto;
  			obj = new F();

  			if ( props ) {
  				Object.defineProperties( obj, props );
  			}

  			return obj;
  		};
  	}());
  }

  function extendObj ( target ) {
  	var sources = [], len = arguments.length - 1;
  	while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

  	var prop;

  	sources.forEach( function ( source ) {
  		for ( prop in source ) {
  			if ( hasOwn.call( source, prop ) ) {
  				target[ prop ] = source[ prop ];
  			}
  		}
  	});

  	return target;
  }

  function fillGaps ( target ) {
  	var sources = [], len = arguments.length - 1;
  	while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

  	sources.forEach( function ( s ) {
  		for ( var key in s ) {
  			if ( hasOwn.call( s, key ) && !( key in target ) ) {
  				target[ key ] = s[ key ];
  			}
  		}
  	});

  	return target;
  }

  var hasOwn = Object.prototype.hasOwnProperty;

  var toString = Object.prototype.toString;
  // thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
  function isArray ( thing ) {
  	return toString.call( thing ) === '[object Array]';
  }

  function isEqual ( a, b ) {
  	if ( a === null && b === null ) {
  		return true;
  	}

  	if ( typeof a === 'object' || typeof b === 'object' ) {
  		return false;
  	}

  	return a === b;
  }

  // http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric
  function isNumeric ( thing ) {
  	return !isNaN( parseFloat( thing ) ) && isFinite( thing );
  }

  function isObject ( thing ) {
  	return ( thing && toString.call( thing ) === '[object Object]' );
  }

  function noop () {}

  var alreadyWarned = {};
  var log;
  var printWarning;
  var welcome;
  if ( hasConsole ) {
  	var welcomeIntro = [
  		("%cRactive.js %c0.8.5 %cin debug mode, %cmore..."),
  		'color: rgb(114, 157, 52); font-weight: normal;',
  		'color: rgb(85, 85, 85); font-weight: normal;',
  		'color: rgb(85, 85, 85); font-weight: normal;',
  		'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;'
  	];
  	var welcomeMessage = "You're running Ractive 0.8.5 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\n\nTo disable debug mode, add this line at the start of your app:\n  Ractive.DEBUG = false;\n\nTo disable debug mode when your app is minified, add this snippet:\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\n\nGet help and support:\n  http://docs.ractivejs.org\n  http://stackoverflow.com/questions/tagged/ractivejs\n  http://groups.google.com/forum/#!forum/ractive-js\n  http://twitter.com/ractivejs\n\nFound a bug? Raise an issue:\n  https://github.com/ractivejs/ractive/issues\n\n";

  	welcome = function () {
  		if ( Ractive.WELCOME_MESSAGE === false ) {
  			welcome = noop;
  			return;
  		}
  		var message = 'WELCOME_MESSAGE' in Ractive ? Ractive.WELCOME_MESSAGE : welcomeMessage;
  		var hasGroup = !!console.groupCollapsed;
  		if ( hasGroup ) console.groupCollapsed.apply( console, welcomeIntro );
  		console.log( message );
  		if ( hasGroup ) {
  			console.groupEnd( welcomeIntro );
  		}

  		welcome = noop;
  	};

  	printWarning = function ( message, args ) {
  		welcome();

  		// extract information about the instance this message pertains to, if applicable
  		if ( typeof args[ args.length - 1 ] === 'object' ) {
  			var options = args.pop();
  			var ractive = options ? options.ractive : null;

  			if ( ractive ) {
  				// if this is an instance of a component that we know the name of, add
  				// it to the message
  				var name;
  				if ( ractive.component && ( name = ractive.component.name ) ) {
  					message = "<" + name + "> " + message;
  				}

  				var node;
  				if ( node = ( options.node || ( ractive.fragment && ractive.fragment.rendered && ractive.find( '*' ) ) ) ) {
  					args.push( node );
  				}
  			}
  		}

  		console.warn.apply( console, [ '%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);' ].concat( args ) );
  	};

  	log = function () {
  		console.log.apply( console, arguments );
  	};
  } else {
  	printWarning = log = welcome = noop;
  }

  function format ( message, args ) {
  	return message.replace( /%s/g, function () { return args.shift(); } );
  }

  function fatal ( message ) {
  	var args = [], len = arguments.length - 1;
  	while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

  	message = format( message, args );
  	throw new Error( message );
  }

  function logIfDebug () {
  	if ( Ractive.DEBUG ) {
  		log.apply( null, arguments );
  	}
  }

  function warn ( message ) {
  	var args = [], len = arguments.length - 1;
  	while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

  	message = format( message, args );
  	printWarning( message, args );
  }

  function warnOnce ( message ) {
  	var args = [], len = arguments.length - 1;
  	while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

  	message = format( message, args );

  	if ( alreadyWarned[ message ] ) {
  		return;
  	}

  	alreadyWarned[ message ] = true;
  	printWarning( message, args );
  }

  function warnIfDebug () {
  	if ( Ractive.DEBUG ) {
  		warn.apply( null, arguments );
  	}
  }

  function warnOnceIfDebug () {
  	if ( Ractive.DEBUG ) {
  		warnOnce.apply( null, arguments );
  	}
  }

  // Error messages that are used (or could be) in multiple places
  var badArguments = 'Bad arguments';
  var noRegistryFunctionReturn = 'A function was specified for "%s" %s, but no %s was returned';
  var missingPlugin = function ( name, type ) { return ("Missing \"" + name + "\" " + type + " plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#" + type + "s"); };

  function findInViewHierarchy ( registryName, ractive, name ) {
  	var instance = findInstance( registryName, ractive, name );
  	return instance ? instance[ registryName ][ name ] : null;
  }

  function findInstance ( registryName, ractive, name ) {
  	while ( ractive ) {
  		if ( name in ractive[ registryName ] ) {
  			return ractive;
  		}

  		if ( ractive.isolated ) {
  			return null;
  		}

  		ractive = ractive.parent;
  	}
  }

  function interpolate ( from, to, ractive, type ) {
  	if ( from === to ) return null;

  	if ( type ) {
  		var interpol = findInViewHierarchy( 'interpolators', ractive, type );
  		if ( interpol ) return interpol( from, to ) || null;

  		fatal( missingPlugin( type, 'interpolator' ) );
  	}

  	return interpolators.number( from, to ) ||
  	       interpolators.array( from, to ) ||
  	       interpolators.object( from, to ) ||
  	       null;
  }

  function snap ( to ) {
  	return function () { return to; };
  }

  var interpolators = {
  	number: function ( from, to ) {
  		var delta;

  		if ( !isNumeric( from ) || !isNumeric( to ) ) {
  			return null;
  		}

  		from = +from;
  		to = +to;

  		delta = to - from;

  		if ( !delta ) {
  			return function () { return from; };
  		}

  		return function ( t ) {
  			return from + ( t * delta );
  		};
  	},

  	array: function ( from, to ) {
  		var intermediate, interpolators, len, i;

  		if ( !isArray( from ) || !isArray( to ) ) {
  			return null;
  		}

  		intermediate = [];
  		interpolators = [];

  		i = len = Math.min( from.length, to.length );
  		while ( i-- ) {
  			interpolators[i] = interpolate( from[i], to[i] );
  		}

  		// surplus values - don't interpolate, but don't exclude them either
  		for ( i=len; i<from.length; i+=1 ) {
  			intermediate[i] = from[i];
  		}

  		for ( i=len; i<to.length; i+=1 ) {
  			intermediate[i] = to[i];
  		}

  		return function ( t ) {
  			var i = len;

  			while ( i-- ) {
  				intermediate[i] = interpolators[i]( t );
  			}

  			return intermediate;
  		};
  	},

  	object: function ( from, to ) {
  		var properties, len, interpolators, intermediate, prop;

  		if ( !isObject( from ) || !isObject( to ) ) {
  			return null;
  		}

  		properties = [];
  		intermediate = {};
  		interpolators = {};

  		for ( prop in from ) {
  			if ( hasOwn.call( from, prop ) ) {
  				if ( hasOwn.call( to, prop ) ) {
  					properties.push( prop );
  					interpolators[ prop ] = interpolate( from[ prop ], to[ prop ] ) || snap( to[ prop ] );
  				}

  				else {
  					intermediate[ prop ] = from[ prop ];
  				}
  			}
  		}

  		for ( prop in to ) {
  			if ( hasOwn.call( to, prop ) && !hasOwn.call( from, prop ) ) {
  				intermediate[ prop ] = to[ prop ];
  			}
  		}

  		len = properties.length;

  		return function ( t ) {
  			var i = len, prop;

  			while ( i-- ) {
  				prop = properties[i];

  				intermediate[ prop ] = interpolators[ prop ]( t );
  			}

  			return intermediate;
  		};
  	}
  };

  // TODO: deprecate in future release
  var deprecations = {
  	construct: {
  		deprecated: 'beforeInit',
  		replacement: 'onconstruct'
  	},
  	render: {
  		deprecated: 'init',
  		message: 'The "init" method has been deprecated ' +
  			'and will likely be removed in a future release. ' +
  			'You can either use the "oninit" method which will fire ' +
  			'only once prior to, and regardless of, any eventual ractive ' +
  			'instance being rendered, or if you need to access the ' +
  			'rendered DOM, use "onrender" instead. ' +
  			'See http://docs.ractivejs.org/latest/migrating for more information.'
  	},
  	complete: {
  		deprecated: 'complete',
  		replacement: 'oncomplete'
  	}
  };

  var Hook = function Hook ( event ) {
  	this.event = event;
  	this.method = 'on' + event;
  	this.deprecate = deprecations[ event ];
  };

  Hook.prototype.call = function call ( method, ractive, arg ) {
  	if ( ractive[ method ] ) {
  		arg ? ractive[ method ]( arg ) : ractive[ method ]();
  		return true;
  	}
  };

  Hook.prototype.fire = function fire ( ractive, arg ) {
  	this.call( this.method, ractive, arg );

  	// handle deprecations
  	if ( !ractive[ this.method ] && this.deprecate && this.call( this.deprecate.deprecated, ractive, arg ) ) {
  		if ( this.deprecate.message ) {
  			warnIfDebug( this.deprecate.message );
  		} else {
  			warnIfDebug( 'The method "%s" has been deprecated in favor of "%s" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.', this.deprecate.deprecated, this.deprecate.replacement );
  		}
  	}

  	// TODO should probably use internal method, in case ractive.fire was overwritten
  	arg ? ractive.fire( this.event, arg ) : ractive.fire( this.event );
  };

  function addToArray ( array, value ) {
  	var index = array.indexOf( value );

  	if ( index === -1 ) {
  		array.push( value );
  	}
  }

  function arrayContains ( array, value ) {
  	for ( var i = 0, c = array.length; i < c; i++ ) {
  		if ( array[i] == value ) {
  			return true;
  		}
  	}

  	return false;
  }

  function arrayContentsMatch ( a, b ) {
  	var i;

  	if ( !isArray( a ) || !isArray( b ) ) {
  		return false;
  	}

  	if ( a.length !== b.length ) {
  		return false;
  	}

  	i = a.length;
  	while ( i-- ) {
  		if ( a[i] !== b[i] ) {
  			return false;
  		}
  	}

  	return true;
  }

  function ensureArray ( x ) {
  	if ( typeof x === 'string' ) {
  		return [ x ];
  	}

  	if ( x === undefined ) {
  		return [];
  	}

  	return x;
  }

  function lastItem ( array ) {
  	return array[ array.length - 1 ];
  }

  function removeFromArray ( array, member ) {
  	if ( !array ) {
  		return;
  	}

  	var index = array.indexOf( member );

  	if ( index !== -1 ) {
  		array.splice( index, 1 );
  	}
  }

  function toArray ( arrayLike ) {
  	var array = [], i = arrayLike.length;
  	while ( i-- ) {
  		array[i] = arrayLike[i];
  	}

  	return array;
  }

  var _Promise;
  var PENDING = {};
  var FULFILLED = {};
  var REJECTED = {};
  if ( typeof Promise === 'function' ) {
  	// use native Promise
  	_Promise = Promise;
  } else {
  	_Promise = function ( callback ) {
  		var fulfilledHandlers = [],
  			rejectedHandlers = [],
  			state = PENDING,

  			result,
  			dispatchHandlers,
  			makeResolver,
  			fulfil,
  			reject,

  			promise;

  		makeResolver = function ( newState ) {
  			return function ( value ) {
  				if ( state !== PENDING ) {
  					return;
  				}

  				result = value;
  				state = newState;

  				dispatchHandlers = makeDispatcher( ( state === FULFILLED ? fulfilledHandlers : rejectedHandlers ), result );

  				// dispatch onFulfilled and onRejected handlers asynchronously
  				wait( dispatchHandlers );
  			};
  		};

  		fulfil = makeResolver( FULFILLED );
  		reject = makeResolver( REJECTED );

  		try {
  			callback( fulfil, reject );
  		} catch ( err ) {
  			reject( err );
  		}

  		promise = {
  			// `then()` returns a Promise - 2.2.7
  			then: function ( onFulfilled, onRejected ) {
  				var promise2 = new _Promise( function ( fulfil, reject ) {

  					var processResolutionHandler = function ( handler, handlers, forward ) {

  						// 2.2.1.1
  						if ( typeof handler === 'function' ) {
  							handlers.push( function ( p1result ) {
  								var x;

  								try {
  									x = handler( p1result );
  									resolve( promise2, x, fulfil, reject );
  								} catch ( err ) {
  									reject( err );
  								}
  							});
  						} else {
  							// Forward the result of promise1 to promise2, if resolution handlers
  							// are not given
  							handlers.push( forward );
  						}
  					};

  					// 2.2
  					processResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );
  					processResolutionHandler( onRejected, rejectedHandlers, reject );

  					if ( state !== PENDING ) {
  						// If the promise has resolved already, dispatch the appropriate handlers asynchronously
  						wait( dispatchHandlers );
  					}

  				});

  				return promise2;
  			}
  		};

  		promise[ 'catch' ] = function ( onRejected ) {
  			return this.then( null, onRejected );
  		};

  		return promise;
  	};

  	_Promise.all = function ( promises ) {
  		return new _Promise( function ( fulfil, reject ) {
  			var result = [], pending, i, processPromise;

  			if ( !promises.length ) {
  				fulfil( result );
  				return;
  			}

  			processPromise = function ( promise, i ) {
  				if ( promise && typeof promise.then === 'function' ) {
  					promise.then( function ( value ) {
  						result[i] = value;
  						--pending || fulfil( result );
  					}, reject );
  				}

  				else {
  					result[i] = promise;
  					--pending || fulfil( result );
  				}
  			};

  			pending = i = promises.length;
  			while ( i-- ) {
  				processPromise( promises[i], i );
  			}
  		});
  	};

  	_Promise.resolve = function ( value ) {
  		return new _Promise( function ( fulfil ) {
  			fulfil( value );
  		});
  	};

  	_Promise.reject = function ( reason ) {
  		return new _Promise( function ( fulfil, reject ) {
  			reject( reason );
  		});
  	};
  }

  var Promise$1 = _Promise;

  // TODO use MutationObservers or something to simulate setImmediate
  function wait ( callback ) {
  	setTimeout( callback, 0 );
  }

  function makeDispatcher ( handlers, result ) {
  	return function () {
  		var handler;

  		while ( handler = handlers.shift() ) {
  			handler( result );
  		}
  	};
  }

  function resolve ( promise, x, fulfil, reject ) {
  	// Promise Resolution Procedure
  	var then;

  	// 2.3.1
  	if ( x === promise ) {
  		throw new TypeError( 'A promise\'s fulfillment handler cannot return the same promise' );
  	}

  	// 2.3.2
  	if ( x instanceof _Promise ) {
  		x.then( fulfil, reject );
  	}

  	// 2.3.3
  	else if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {
  		try {
  			then = x.then; // 2.3.3.1
  		} catch ( e ) {
  			reject( e ); // 2.3.3.2
  			return;
  		}

  		// 2.3.3.3
  		if ( typeof then === 'function' ) {
  			var called, resolvePromise, rejectPromise;

  			resolvePromise = function ( y ) {
  				if ( called ) {
  					return;
  				}
  				called = true;
  				resolve( promise, y, fulfil, reject );
  			};

  			rejectPromise = function ( r ) {
  				if ( called ) {
  					return;
  				}
  				called = true;
  				reject( r );
  			};

  			try {
  				then.call( x, resolvePromise, rejectPromise );
  			} catch ( e ) {
  				if ( !called ) { // 2.3.3.3.4.1
  					reject( e ); // 2.3.3.3.4.2
  					called = true;
  					return;
  				}
  			}
  		}

  		else {
  			fulfil( x );
  		}
  	}

  	else {
  		fulfil( x );
  	}
  }

  var TransitionManager = function TransitionManager ( callback, parent ) {
  	this.callback = callback;
  	this.parent = parent;

  	this.intros = [];
  	this.outros = [];

  	this.children = [];
  	this.totalChildren = this.outroChildren = 0;

  	this.detachQueue = [];
  	this.outrosComplete = false;

  	if ( parent ) {
  		parent.addChild( this );
  	}
  };

  TransitionManager.prototype.add = function add ( transition ) {
  	var list = transition.isIntro ? this.intros : this.outros;
  	list.push( transition );
  };

  TransitionManager.prototype.addChild = function addChild ( child ) {
  	this.children.push( child );

  	this.totalChildren += 1;
  	this.outroChildren += 1;
  };

  TransitionManager.prototype.decrementOutros = function decrementOutros () {
  	this.outroChildren -= 1;
  	check( this );
  };

  TransitionManager.prototype.decrementTotal = function decrementTotal () {
  	this.totalChildren -= 1;
  	check( this );
  };

  TransitionManager.prototype.detachNodes = function detachNodes () {
  	this.detachQueue.forEach( detach );
  	this.children.forEach( _detachNodes );
  };

  TransitionManager.prototype.ready = function ready () {
  	detachImmediate( this );
  };

  TransitionManager.prototype.remove = function remove ( transition ) {
  	var list = transition.isIntro ? this.intros : this.outros;
  	removeFromArray( list, transition );
  	check( this );
  };

  TransitionManager.prototype.start = function start () {
  	this.children.forEach( function ( c ) { return c.start(); } );
  	this.intros.concat( this.outros ).forEach( function ( t ) { return t.start(); } );
  	this.ready = true;
  	check( this );
  };

  function detach ( element ) {
  	element.detach();
  }

  function _detachNodes ( tm ) { // _ to avoid transpiler quirk
  	tm.detachNodes();
  }

  function check ( tm ) {
  	if ( !tm.ready || tm.outros.length || tm.outroChildren ) return;

  	// If all outros are complete, and we haven't already done this,
  	// we notify the parent if there is one, otherwise
  	// start detaching nodes
  	if ( !tm.outrosComplete ) {
  		tm.outrosComplete = true;

  		if ( tm.parent && !tm.parent.outrosComplete ) {
  			tm.parent.decrementOutros( tm );
  		} else {
  			tm.detachNodes();
  		}
  	}

  	// Once everything is done, we can notify parent transition
  	// manager and call the callback
  	if ( !tm.intros.length && !tm.totalChildren ) {
  		if ( typeof tm.callback === 'function' ) {
  			tm.callback();
  		}

  		if ( tm.parent && !tm.notifiedTotal ) {
  			tm.notifiedTotal = true;
  			tm.parent.decrementTotal();
  		}
  	}
  }

  // check through the detach queue to see if a node is up or downstream from a
  // transition and if not, go ahead and detach it
  function detachImmediate ( manager ) {
  	var queue = manager.detachQueue;
  	var outros = collectAllOutros( manager );

  	var i = queue.length, j = 0, node, trans;
  	start: while ( i-- ) {
  		node = queue[i].node;
  		j = outros.length;
  		while ( j-- ) {
  			trans = outros[j].element.node;
  			// check to see if the node is, contains, or is contained by the transitioning node
  			if ( trans === node || trans.contains( node ) || node.contains( trans ) ) continue start;
  		}

  		// no match, we can drop it
  		queue[i].detach();
  		queue.splice( i, 1 );
  	}
  }

  function collectAllOutros ( manager, list ) {
  	if ( !list ) {
  		list = [];
  		var parent = manager;
  		while ( parent.parent ) parent = parent.parent;
  		return collectAllOutros( parent, list );
  	} else {
  		var i = manager.children.length;
  		while ( i-- ) {
  			list = collectAllOutros( manager.children[i], list );
  		}
  		list = list.concat( manager.outros );
  		return list;
  	}
  }

  var changeHook = new Hook( 'change' );

  var batch;

  var runloop = {
  	start: function ( instance, returnPromise ) {
  		var promise, fulfilPromise;

  		if ( returnPromise ) {
  			promise = new Promise$1( function ( f ) { return ( fulfilPromise = f ); } );
  		}

  		batch = {
  			previousBatch: batch,
  			transitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),
  			fragments: [],
  			tasks: [],
  			immediateObservers: [],
  			deferredObservers: [],
  			ractives: [],
  			instance: instance
  		};

  		return promise;
  	},

  	end: function () {
  		flushChanges();

  		if ( !batch.previousBatch ) batch.transitionManager.start();

  		batch = batch.previousBatch;
  	},

  	addFragment: function ( fragment ) {
  		addToArray( batch.fragments, fragment );
  	},

  	// TODO: come up with a better way to handle fragments that trigger their own update
  	addFragmentToRoot: function ( fragment ) {
  		if ( !batch ) return;

  		var b = batch;
  		while ( b.previousBatch ) {
  			b = b.previousBatch;
  		}

  		addToArray( b.fragments, fragment );
  	},

  	addInstance: function ( instance ) {
  		if ( batch ) addToArray( batch.ractives, instance );
  	},

  	addObserver: function ( observer, defer ) {
  		addToArray( defer ? batch.deferredObservers : batch.immediateObservers, observer );
  	},

  	registerTransition: function ( transition ) {
  		transition._manager = batch.transitionManager;
  		batch.transitionManager.add( transition );
  	},

  	// synchronise node detachments with transition ends
  	detachWhenReady: function ( thing ) {
  		batch.transitionManager.detachQueue.push( thing );
  	},

  	scheduleTask: function ( task, postRender ) {
  		var _batch;

  		if ( !batch ) {
  			task();
  		} else {
  			_batch = batch;
  			while ( postRender && _batch.previousBatch ) {
  				// this can't happen until the DOM has been fully updated
  				// otherwise in some situations (with components inside elements)
  				// transitions and decorators will initialise prematurely
  				_batch = _batch.previousBatch;
  			}

  			_batch.tasks.push( task );
  		}
  	}
  };

  function dispatch ( observer ) {
  	observer.dispatch();
  }

  function flushChanges () {
  	var which = batch.immediateObservers;
  	batch.immediateObservers = [];
  	which.forEach( dispatch );

  	// Now that changes have been fully propagated, we can update the DOM
  	// and complete other tasks
  	var i = batch.fragments.length;
  	var fragment;

  	which = batch.fragments;
  	batch.fragments = [];
  	var ractives = batch.ractives;
  	batch.ractives = [];

  	while ( i-- ) {
  		fragment = which[i];

  		// TODO deprecate this. It's annoying and serves no useful function
  		var ractive = fragment.ractive;
  		if ( Object.keys( ractive.viewmodel.changes ).length ) {
  			changeHook.fire( ractive, ractive.viewmodel.changes );
  		}
  		ractive.viewmodel.changes = {};
  		removeFromArray( ractives, ractive );

  		fragment.update();
  	}

  	i = ractives.length;
  	while ( i-- ) {
  		var ractive$1 = ractives[i];
  		changeHook.fire( ractive$1, ractive$1.viewmodel.changes );
  		ractive$1.viewmodel.changes = {};
  	}

  	batch.transitionManager.ready();

  	which = batch.deferredObservers;
  	batch.deferredObservers = [];
  	which.forEach( dispatch );

  	var tasks = batch.tasks;
  	batch.tasks = [];

  	for ( i = 0; i < tasks.length; i += 1 ) {
  		tasks[i]();
  	}

  	// If updating the view caused some model blowback - e.g. a triple
  	// containing <option> elements caused the binding on the <select>
  	// to update - then we start over
  	if ( batch.fragments.length || batch.immediateObservers.length || batch.deferredObservers.length || batch.ractives.length || batch.tasks.length ) return flushChanges();
  }

  var refPattern = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
  var splitPattern = /([^\\](?:\\\\)*)\./;
  var escapeKeyPattern = /\\|\./g;
  var unescapeKeyPattern = /((?:\\)+)\1|\\(\.)/g;

  function escapeKey ( key ) {
  	if ( typeof key === 'string' ) {
  		return key.replace( escapeKeyPattern, '\\$&' );
  	}

  	return key;
  }

  function normalise ( ref ) {
  	return ref ? ref.replace( refPattern, '.$1' ) : '';
  }

  function splitKeypathI ( keypath ) {
  	var result = [],
  		match;

  	keypath = normalise( keypath );

  	while ( match = splitPattern.exec( keypath ) ) {
  		var index = match.index + match[1].length;
  		result.push( keypath.substr( 0, index ) );
  		keypath = keypath.substr( index + 1 );
  	}

  	result.push(keypath);

  	return result;
  }

  function unescapeKey ( key ) {
  	if ( typeof key === 'string' ) {
  		return key.replace( unescapeKeyPattern, '$1$2' );
  	}

  	return key;
  }

  function bind ( fn, context ) {
  	if ( !/this/.test( fn.toString() ) ) return fn;

  	var bound = fn.bind( context );
  	for ( var prop in fn ) bound[ prop ] = fn[ prop ];

  	return bound;
  }

  function set ( ractive, pairs ) {
  	var promise = runloop.start( ractive, true );

  	var i = pairs.length;
  	while ( i-- ) {
  		var ref = pairs[i], model = ref[0], value = ref[1];
  		if ( typeof value === 'function' ) value = bind( value, ractive );
  		model.set( value );
  	}

  	runloop.end();

  	return promise;
  }

  var star = /\*/;
  function gather ( ractive, keypath, base ) {
  	if ( base === void 0 ) base = ractive.viewmodel;

  	if ( star.test( keypath ) ) {
  		return base.findMatches( splitKeypathI( keypath ) );
  	} else {
  		return [ base.joinAll( splitKeypathI( keypath ) ) ];
  	}
  }

  function build ( ractive, keypath, value ) {
  	var sets = [];

  	// set multiple keypaths in one go
  	if ( isObject( keypath ) ) {
  		var loop = function ( k ) {
  			if ( keypath.hasOwnProperty( k ) ) {
  				sets.push.apply( sets, gather( ractive, k ).map( function ( m ) { return [ m, keypath[k] ]; } ) );
  			}
  		};

  		for ( var k in keypath ) loop( k );

  	}
  	// set a single keypath
  	else {
  		sets.push.apply( sets, gather( ractive, keypath ).map( function ( m ) { return [ m, value ]; } ) );
  	}

  	return sets;
  }

  var errorMessage = 'Cannot add to a non-numeric value';

  function add ( ractive, keypath, d ) {
  	if ( typeof keypath !== 'string' || !isNumeric( d ) ) {
  		throw new Error( 'Bad arguments' );
  	}

  	var sets = build( ractive, keypath, d );

  	return set( ractive, sets.map( function ( pair ) {
  		var model = pair[0], add = pair[1], value = model.get();
  		if ( !isNumeric( add ) || !isNumeric( value ) ) throw new Error( errorMessage );
  		return [ model, value + add ];
  	}));
  }

  function Ractive$add ( keypath, d ) {
  	return add( this, keypath, ( d === undefined ? 1 : +d ) );
  }

  var noAnimation = Promise$1.resolve();
  defineProperty( noAnimation, 'stop', { value: noop });

  var linear = easing.linear;

  function getOptions ( options, instance ) {
  	options = options || {};

  	var easing;
  	if ( options.easing ) {
  		easing = typeof options.easing === 'function' ?
  			options.easing :
  			instance.easing[ options.easing ];
  	}

  	return {
  		easing: easing || linear,
  		duration: 'duration' in options ? options.duration : 400,
  		complete: options.complete || noop,
  		step: options.step || noop
  	};
  }

  function protoAnimate ( ractive, model, to, options ) {
  	options = getOptions( options, ractive );
  	var from = model.get();

  	// don't bother animating values that stay the same
  	if ( isEqual( from, to ) ) {
  		options.complete( options.to );
  		return noAnimation; // TODO should this have .then and .catch methods?
  	}

  	var interpolator = interpolate( from, to, ractive, options.interpolator );

  	// if we can't interpolate the value, set it immediately
  	if ( !interpolator ) {
  		runloop.start();
  		model.set( to );
  		runloop.end();

  		return noAnimation;
  	}

  	return model.animate( from, to, options, interpolator );
  }

  function Ractive$animate ( keypath, to, options ) {
  	if ( typeof keypath === 'object' ) {
  		var keys = Object.keys( keypath );

  		throw new Error( ("ractive.animate(...) no longer supports objects. Instead of ractive.animate({\n  " + (keys.map( function ( key ) { return ("'" + key + "': " + (keypath[ key ])); } ).join( '\n  ' )) + "\n}, {...}), do\n\n" + (keys.map( function ( key ) { return ("ractive.animate('" + key + "', " + (keypath[ key ]) + ", {...});"); } ).join( '\n' )) + "\n") );
  	}


  	return protoAnimate( this, this.viewmodel.joinAll( splitKeypathI( keypath ) ), to, options );
  }

  var detachHook = new Hook( 'detach' );

  function Ractive$detach () {
  	if ( this.isDetached ) {
  		return this.el;
  	}

  	if ( this.el ) {
  		removeFromArray( this.el.__ractive_instances__, this );
  	}

  	this.el = this.fragment.detach();
  	this.isDetached = true;

  	detachHook.fire( this );
  	return this.el;
  }

  function Ractive$find ( selector ) {
  	if ( !this.el ) throw new Error( ("Cannot call ractive.find('" + selector + "') unless instance is rendered to the DOM") );

  	return this.fragment.find( selector );
  }

  function sortByDocumentPosition ( node, otherNode ) {
  	if ( node.compareDocumentPosition ) {
  		var bitmask = node.compareDocumentPosition( otherNode );
  		return ( bitmask & 2 ) ? 1 : -1;
  	}

  	// In old IE, we can piggy back on the mechanism for
  	// comparing component positions
  	return sortByItemPosition( node, otherNode );
  }

  function sortByItemPosition ( a, b ) {
  	var ancestryA = getAncestry( a.component || a._ractive.proxy );
  	var ancestryB = getAncestry( b.component || b._ractive.proxy );

  	var oldestA = lastItem( ancestryA );
  	var oldestB = lastItem( ancestryB );
  	var mutualAncestor;

  	// remove items from the end of both ancestries as long as they are identical
  	// - the final one removed is the closest mutual ancestor
  	while ( oldestA && ( oldestA === oldestB ) ) {
  		ancestryA.pop();
  		ancestryB.pop();

  		mutualAncestor = oldestA;

  		oldestA = lastItem( ancestryA );
  		oldestB = lastItem( ancestryB );
  	}

  	// now that we have the mutual ancestor, we can find which is earliest
  	oldestA = oldestA.component || oldestA;
  	oldestB = oldestB.component || oldestB;

  	var fragmentA = oldestA.parentFragment;
  	var fragmentB = oldestB.parentFragment;

  	// if both items share a parent fragment, our job is easy
  	if ( fragmentA === fragmentB ) {
  		var indexA = fragmentA.items.indexOf( oldestA );
  		var indexB = fragmentB.items.indexOf( oldestB );

  		// if it's the same index, it means one contains the other,
  		// so we see which has the longest ancestry
  		return ( indexA - indexB ) || ancestryA.length - ancestryB.length;
  	}

  	// if mutual ancestor is a section, we first test to see which section
  	// fragment comes first
  	var fragments = mutualAncestor.iterations;
  	if ( fragments ) {
  		var indexA$1 = fragments.indexOf( fragmentA );
  		var indexB$1 = fragments.indexOf( fragmentB );

  		return ( indexA$1 - indexB$1 ) || ancestryA.length - ancestryB.length;
  	}

  	throw new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/ractivejs/ractive/issues - thanks!' );
  }

  function getParent ( item ) {
  	var parentFragment = item.parentFragment;

  	if ( parentFragment ) return parentFragment.owner;

  	if ( item.component && ( parentFragment = item.component.parentFragment ) ) {
  		return parentFragment.owner;
  	}
  }

  function getAncestry ( item ) {
  	var ancestry = [ item ];
  	var ancestor = getParent( item );

  	while ( ancestor ) {
  		ancestry.push( ancestor );
  		ancestor = getParent( ancestor );
  	}

  	return ancestry;
  }


  var Query = function Query ( ractive, selector, live, isComponentQuery ) {
  	this.ractive = ractive;
  	this.selector = selector;
  	this.live = live;
  	this.isComponentQuery = isComponentQuery;

  	this.result = [];

  	this.dirty = true;
  };

  Query.prototype.add = function add ( item ) {
  	this.result.push( item );
  	this.makeDirty();
  };

  Query.prototype.cancel = function cancel () {
  	var liveQueries = this._root[ this.isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];
  	var selector = this.selector;

  	var index = liveQueries.indexOf( selector );

  	if ( index !== -1 ) {
  		liveQueries.splice( index, 1 );
  		liveQueries[ selector ] = null;
  	}
  };

  Query.prototype.init = function init () {
  	this.dirty = false;
  };

  Query.prototype.makeDirty = function makeDirty () {
  	var this$1 = this;

  		if ( !this.dirty ) {
  		this.dirty = true;

  		// Once the DOM has been updated, ensure the query
  		// is correctly ordered
  		runloop.scheduleTask( function () { return this$1.update(); } );
  	}
  };

  Query.prototype.remove = function remove ( nodeOrComponent ) {
  	var index = this.result.indexOf( this.isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );
  	if ( index !== -1 ) this.result.splice( index, 1 );
  };

  Query.prototype.update = function update () {
  	this.result.sort( this.isComponentQuery ? sortByItemPosition : sortByDocumentPosition );
  	this.dirty = false;
  };

  Query.prototype.test = function test ( item ) {
  	return this.isComponentQuery ?
  		( !this.selector || item.name === this.selector ) :
  		( item ? matches( item, this.selector ) : null );
  };

  function Ractive$findAll ( selector, options ) {
  	if ( !this.el ) throw new Error( ("Cannot call ractive.findAll('" + selector + "', ...) unless instance is rendered to the DOM") );

  	options = options || {};
  	var liveQueries = this._liveQueries;

  	// Shortcut: if we're maintaining a live query with this
  	// selector, we don't need to traverse the parallel DOM
  	var query = liveQueries[ selector ];
  	if ( query ) {
  		// Either return the exact same query, or (if not live) a snapshot
  		return ( options && options.live ) ? query : query.slice();
  	}

  	query = new Query( this, selector, !!options.live, false );

  	// Add this to the list of live queries Ractive needs to maintain,
  	// if applicable
  	if ( query.live ) {
  		liveQueries.push( selector );
  		liveQueries[ '_' + selector ] = query;
  	}

  	this.fragment.findAll( selector, query );

  	query.init();
  	return query.result;
  }

  function Ractive$findAllComponents ( selector, options ) {
  	options = options || {};
  	var liveQueries = this._liveComponentQueries;

  	// Shortcut: if we're maintaining a live query with this
  	// selector, we don't need to traverse the parallel DOM
  	var query = liveQueries[ selector ];
  	if ( query ) {
  		// Either return the exact same query, or (if not live) a snapshot
  		return ( options && options.live ) ? query : query.slice();
  	}

  	query = new Query( this, selector, !!options.live, true );

  	// Add this to the list of live queries Ractive needs to maintain,
  	// if applicable
  	if ( query.live ) {
  		liveQueries.push( selector );
  		liveQueries[ '_' + selector ] = query;
  	}

  	this.fragment.findAllComponents( selector, query );

  	query.init();
  	return query.result;
  }

  function Ractive$findComponent ( selector ) {
  	return this.fragment.findComponent( selector );
  }

  function Ractive$findContainer ( selector ) {
  	if ( this.container ) {
  		if ( this.container.component && this.container.component.name === selector ) {
  			return this.container;
  		} else {
  			return this.container.findContainer( selector );
  		}
  	}

  	return null;
  }

  function Ractive$findParent ( selector ) {

  	if ( this.parent ) {
  		if ( this.parent.component && this.parent.component.name === selector ) {
  			return this.parent;
  		} else {
  			return this.parent.findParent ( selector );
  		}
  	}

  	return null;
  }

  function enqueue ( ractive, event ) {
  	if ( ractive.event ) {
  		ractive._eventQueue.push( ractive.event );
  	}

  	ractive.event = event;
  }

  function dequeue ( ractive ) {
  	if ( ractive._eventQueue.length ) {
  		ractive.event = ractive._eventQueue.pop();
  	} else {
  		ractive.event = null;
  	}
  }

  var starMaps = {};

  // This function takes a keypath such as 'foo.bar.baz', and returns
  // all the variants of that keypath that include a wildcard in place
  // of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
  // These are then checked against the dependants map (ractive.viewmodel.depsMap)
  // to see if any pattern observers are downstream of one or more of
  // these wildcard keypaths (e.g. 'foo.bar.*.status')
  function getPotentialWildcardMatches ( keypath ) {
  	var keys, starMap, mapper, i, result, wildcardKeypath;

  	keys = splitKeypathI( keypath );
  	if( !( starMap = starMaps[ keys.length ]) ) {
  		starMap = getStarMap( keys.length );
  	}

  	result = [];

  	mapper = function ( star, i ) {
  		return star ? '*' : keys[i];
  	};

  	i = starMap.length;
  	while ( i-- ) {
  		wildcardKeypath = starMap[i].map( mapper ).join( '.' );

  		if ( !result.hasOwnProperty( wildcardKeypath ) ) {
  			result.push( wildcardKeypath );
  			result[ wildcardKeypath ] = true;
  		}
  	}

  	return result;
  }

  // This function returns all the possible true/false combinations for
  // a given number - e.g. for two, the possible combinations are
  // [ true, true ], [ true, false ], [ false, true ], [ false, false ].
  // It does so by getting all the binary values between 0 and e.g. 11
  function getStarMap ( num ) {
  	var ones = '', max, binary, starMap, mapper, i, j, l, map;

  	if ( !starMaps[ num ] ) {
  		starMap = [];

  		while ( ones.length < num ) {
  			ones += 1;
  		}

  		max = parseInt( ones, 2 );

  		mapper = function ( digit ) {
  			return digit === '1';
  		};

  		for ( i = 0; i <= max; i += 1 ) {
  			binary = i.toString( 2 );
  			while ( binary.length < num ) {
  				binary = '0' + binary;
  			}

  			map = [];
  			l = binary.length;
  			for (j = 0; j < l; j++) {
  				map.push( mapper( binary[j] ) );
  			}
  			starMap[i] = map;
  		}

  		starMaps[ num ] = starMap;
  	}

  	return starMaps[ num ];
  }

  var wildcardCache = {};

  function fireEvent ( ractive, eventName, options ) {
  	if ( options === void 0 ) options = {};

  	if ( !eventName ) { return; }

  	if ( !options.event ) {
  		options.event = {
  			name: eventName,
  			// until event not included as argument default
  			_noArg: true
  		};
  	} else {
  		options.event.name = eventName;
  	}

  	var eventNames = getWildcardNames( eventName );

  	return fireEventAs( ractive, eventNames, options.event, options.args, true );
  }

  function getWildcardNames ( eventName ) {
  	if ( wildcardCache.hasOwnProperty( eventName ) ) {
  		return wildcardCache[ eventName ];
  	} else {
  		return wildcardCache[ eventName ] = getPotentialWildcardMatches( eventName );
  	}
  }

  function fireEventAs  ( ractive, eventNames, event, args, initialFire ) {

  	if ( initialFire === void 0 ) initialFire = false;

  	var subscribers, i, bubble = true;

  	enqueue( ractive, event );

  	for ( i = eventNames.length; i >= 0; i-- ) {
  		subscribers = ractive._subs[ eventNames[ i ] ];

  		if ( subscribers ) {
  			bubble = notifySubscribers( ractive, subscribers, event, args ) && bubble;
  		}
  	}

  	dequeue( ractive );

  	if ( ractive.parent && bubble ) {

  		if ( initialFire && ractive.component ) {
  			var fullName = ractive.component.name + '.' + eventNames[ eventNames.length-1 ];
  			eventNames = getWildcardNames( fullName );

  			if( event && !event.component ) {
  				event.component = ractive;
  			}
  		}

  		fireEventAs( ractive.parent, eventNames, event, args );
  	}

  	return bubble;
  }

  function notifySubscribers ( ractive, subscribers, event, args ) {
  	var originalEvent = null, stopEvent = false;

  	if ( event && !event._noArg ) {
  		args = [ event ].concat( args );
  	}

  	// subscribers can be modified inflight, e.g. "once" functionality
  	// so we need to copy to make sure everyone gets called
  	subscribers = subscribers.slice();

  	for ( var i = 0, len = subscribers.length; i < len; i += 1 ) {
  		if ( !subscribers[ i ].off && subscribers[ i ].apply( ractive, args ) === false ) {
  			stopEvent = true;
  		}
  	}

  	if ( event && !event._noArg && stopEvent && ( originalEvent = event.original ) ) {
  		originalEvent.preventDefault && originalEvent.preventDefault();
  		originalEvent.stopPropagation && originalEvent.stopPropagation();
  	}

  	return !stopEvent;
  }

  function Ractive$fire ( eventName ) {
  	var args = [], len = arguments.length - 1;
  	while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

  	return fireEvent( this, eventName, { args: args });
  }

  function badReference ( key ) {
  	throw new Error( ("An index or key reference (" + key + ") cannot have child properties") );
  }

  function resolveAmbiguousReference ( fragment, ref ) {
  	var localViewmodel = fragment.findContext().root;
  	var keys = splitKeypathI( ref );
  	var key = keys[0];

  	var hasContextChain;
  	var crossedComponentBoundary;
  	var aliases;

  	while ( fragment ) {
  		// repeated fragments
  		if ( fragment.isIteration ) {
  			if ( key === fragment.parent.keyRef ) {
  				if ( keys.length > 1 ) badReference( key );
  				return fragment.context.getKeyModel( fragment.key );
  			}

  			if ( key === fragment.parent.indexRef ) {
  				if ( keys.length > 1 ) badReference( key );
  				return fragment.context.getKeyModel( fragment.index );
  			}
  		}

  		// alias node or iteration
  		if ( ( ( aliases = fragment.owner.aliases ) || ( aliases = fragment.aliases ) ) && aliases.hasOwnProperty( key ) ) {
  			var model = aliases[ key ];

  			if ( keys.length === 1 ) return model;
  			else if ( typeof model.joinAll === 'function' ) {
  				return model.joinAll( keys.slice( 1 ) );
  			}
  		}

  		if ( fragment.context ) {
  			// TODO better encapsulate the component check
  			if ( !fragment.isRoot || fragment.ractive.component ) hasContextChain = true;

  			if ( fragment.context.has( key ) ) {
  				if ( crossedComponentBoundary ) {
  					return localViewmodel.createLink( key, fragment.context.joinKey( keys.shift() ), key ).joinAll( keys );
  				}

  				return fragment.context.joinAll( keys );
  			}
  		}

  		if ( fragment.componentParent && !fragment.ractive.isolated ) {
  			// ascend through component boundary
  			fragment = fragment.componentParent;
  			crossedComponentBoundary = true;
  		} else {
  			fragment = fragment.parent;
  		}
  	}

  	if ( !hasContextChain ) {
  		return localViewmodel.joinAll( keys );
  	}
  }

  var stack = [];
  var captureGroup;

  function startCapturing () {
  	stack.push( captureGroup = [] );
  }

  function stopCapturing () {
  	var dependencies = stack.pop();
  	captureGroup = stack[ stack.length - 1 ];
  	return dependencies;
  }

  function capture ( model ) {
  	if ( captureGroup ) {
  		captureGroup.push( model );
  	}
  }

  var KeyModel = function KeyModel ( key, parent ) {
  	this.value = key;
  	this.isReadonly = this.isKey = true;
  	this.deps = [];
  	this.links = [];
  	this.parent = parent;
  };

  KeyModel.prototype.get = function get ( shouldCapture ) {
  	if ( shouldCapture ) capture( this );
  	return unescapeKey( this.value );
  };

  KeyModel.prototype.getKeypath = function getKeypath () {
  	return unescapeKey( this.value );
  };

  KeyModel.prototype.rebinding = function rebinding ( next, previous ) {
  	var this$1 = this;

  		var i = this.deps.length;
  	while ( i-- ) this$1.deps[i].rebinding( next, previous, false );

  	i = this.links.length;
  	while ( i-- ) this$1.links[i].rebinding( next, previous, false );
  };

  KeyModel.prototype.register = function register ( dependant ) {
  	this.deps.push( dependant );
  };

  KeyModel.prototype.registerLink = function registerLink ( link ) {
  	addToArray( this.links, link );
  };

  KeyModel.prototype.unregister = function unregister ( dependant ) {
  	removeFromArray( this.deps, dependant );
  };

  KeyModel.prototype.unregisterLink = function unregisterLink ( link ) {
  	removeFromArray( this.links, link );
  };

  function bind$1               ( x ) { x.bind(); }
  function cancel             ( x ) { x.cancel(); }
  function handleChange       ( x ) { x.handleChange(); }
  function mark               ( x ) { x.mark(); }
  function marked             ( x ) { x.marked(); }
  function notifiedUpstream   ( x ) { x.notifiedUpstream(); }
  function render             ( x ) { x.render(); }
  function teardown           ( x ) { x.teardown(); }
  function unbind             ( x ) { x.unbind(); }
  function unrender           ( x ) { x.unrender(); }
  function unrenderAndDestroy ( x ) { x.unrender( true ); }
  function update             ( x ) { x.update(); }
  function toString$1           ( x ) { return x.toString(); }
  function toEscapedString    ( x ) { return x.toString( true ); }

  var KeypathModel = function KeypathModel ( parent, ractive ) {
  	this.parent = parent;
  	this.ractive = ractive;
  	this.value = ractive ? parent.getKeypath( ractive ) : parent.getKeypath();
  	this.deps = [];
  	this.children = {};
  	this.isReadonly = this.isKeypath = true;
  };

  KeypathModel.prototype.get = function get ( shouldCapture ) {
  	if ( shouldCapture ) capture( this );
  	return this.value;
  };

  KeypathModel.prototype.getChild = function getChild ( ractive ) {
  	if ( !( ractive._guid in this.children ) ) {
  		var model = new KeypathModel( this.parent, ractive );
  		this.children[ ractive._guid ] = model;
  		model.owner = this;
  	}
  	return this.children[ ractive._guid ];
  };

  KeypathModel.prototype.getKeypath = function getKeypath () {
  	return this.value;
  };

  KeypathModel.prototype.handleChange = function handleChange$1 () {
  	var this$1 = this;

  		var keys = Object.keys( this.children );
  	var i = keys.length;
  	while ( i-- ) {
  		this$1.children[ keys[i] ].handleChange();
  	}

  	this.deps.forEach( handleChange );
  };

  KeypathModel.prototype.rebindChildren = function rebindChildren ( next ) {
  	var this$1 = this;

  		var keys = Object.keys( this.children );
  	var i = keys.length;
  	while ( i-- ) {
  		var child = this$1.children[keys[i]];
  		child.value = next.getKeypath( child.ractive );
  		child.handleChange();
  	}
  };

  KeypathModel.prototype.rebinding = function rebinding ( next, previous ) {
  	var this$1 = this;

  		var model = next ? next.getKeypathModel( this.ractive ) : undefined;

  	var keys = Object.keys( this.children );
  	var i = keys.length;
  	while ( i-- ) {
  		this$1.children[ keys[i] ].rebinding( next, previous, false );
  	}

  	i = this.deps.length;
  	while ( i-- ) {
  		this$1.deps[i].rebinding( model, this$1, false );
  	}
  };

  KeypathModel.prototype.register = function register ( dep ) {
  	this.deps.push( dep );
  };

  KeypathModel.prototype.removeChild = function removeChild( model ) {
  	if ( model.ractive ) delete this.children[ model.ractive._guid ];
  };

  KeypathModel.prototype.teardown = function teardown () {
  	var this$1 = this;

  		if ( this.owner ) this.owner.removeChild( this );

  	var keys = Object.keys( this.children );
  	var i = keys.length;
  	while ( i-- ) {
  		this$1.children[ keys[i] ].teardown();
  	}
  };

  KeypathModel.prototype.unregister = function unregister ( dep ) {
  	removeFromArray( this.deps, dep );
  	if ( !this.deps.length ) this.teardown();
  };

  var hasProp = Object.prototype.hasOwnProperty;

  var shuffleTasks = { early: [], mark: [] };
  var registerQueue = { early: [], mark: [] };

  var ModelBase = function ModelBase ( parent ) {
  	this.deps = [];

  	this.children = [];
  	this.childByKey = {};
  	this.links = [];

  	this.keyModels = {};

  	this.unresolved = [];
  	this.unresolvedByKey = {};

  	this.bindings = [];
  	this.patternObservers = [];

  	if ( parent ) {
  		this.parent = parent;
  		this.root = parent.root;
  	}
  };

  ModelBase.prototype.addUnresolved = function addUnresolved ( key, resolver ) {
  	if ( !this.unresolvedByKey[ key ] ) {
  		this.unresolved.push( key );
  		this.unresolvedByKey[ key ] = [];
  	}

  	this.unresolvedByKey[ key ].push( resolver );
  };

  ModelBase.prototype.addShuffleTask = function addShuffleTask ( task, stage ) { if ( stage === void 0 ) stage = 'early';

  	shuffleTasks[stage].push( task ); };
  ModelBase.prototype.addShuffleRegister = function addShuffleRegister ( item, stage ) { if ( stage === void 0 ) stage = 'early';

  	registerQueue[stage].push({ model: this, item: item }); };

  ModelBase.prototype.clearUnresolveds = function clearUnresolveds ( specificKey ) {
  	var this$1 = this;

  		var i = this.unresolved.length;

  	while ( i-- ) {
  		var key = this$1.unresolved[i];

  		if ( specificKey && key !== specificKey ) continue;

  		var resolvers = this$1.unresolvedByKey[ key ];
  		var hasKey = this$1.has( key );

  		var j = resolvers.length;
  		while ( j-- ) {
  			if ( hasKey ) resolvers[j].attemptResolution();
  			if ( resolvers[j].resolved ) resolvers.splice( j, 1 );
  		}

  		if ( !resolvers.length ) {
  			this$1.unresolved.splice( i, 1 );
  			this$1.unresolvedByKey[ key ] = null;
  		}
  	}
  };

  ModelBase.prototype.findMatches = function findMatches ( keys ) {
  	var len = keys.length;

  	var existingMatches = [ this ];
  	var matches;
  	var i;

  	var loop = function (  ) {
  		var key = keys[i];

  		if ( key === '*' ) {
  			matches = [];
  			existingMatches.forEach( function ( model ) {
  				matches.push.apply( matches, model.getValueChildren( model.get() ) );
  			});
  		} else {
  			matches = existingMatches.map( function ( model ) { return model.joinKey( key ); } );
  		}

  		existingMatches = matches;
  	};

  		for ( i = 0; i < len; i += 1 ) loop(  );

  	return matches;
  };

  ModelBase.prototype.getKeyModel = function getKeyModel ( key, skip ) {
  	if ( key !== undefined && !skip ) return this.parent.getKeyModel( key, true );

  	if ( !( key in this.keyModels ) ) this.keyModels[ key ] = new KeyModel( escapeKey( key ), this );

  	return this.keyModels[ key ];
  };

  ModelBase.prototype.getKeypath = function getKeypath ( ractive ) {
  	if ( ractive !== this.ractive && this._link ) return this._link.target.getKeypath( ractive );

  	if ( !this.keypath ) {
  		this.keypath = this.parent.isRoot ? this.key : ("" + (this.parent.getKeypath( ractive )) + "." + (escapeKey( this.key )));
  	}

  	return this.keypath;
  };

  ModelBase.prototype.getValueChildren = function getValueChildren ( value ) {
  	var this$1 = this;

  		var children;
  	if ( isArray( value ) ) {
  		children = [];
  		if ( 'length' in this && this.length !== value.length ) {
  			children.push( this.joinKey( 'length' ) );
  		}
  		value.forEach( function ( m, i ) {
  			children.push( this$1.joinKey( i ) );
  		});
  	}

  	else if ( isObject( value ) || typeof value === 'function' ) {
  		children = Object.keys( value ).map( function ( key ) { return this$1.joinKey( key ); } );
  	}

  	else if ( value != null ) {
  		return [];
  	}

  	return children;
  };

  ModelBase.prototype.getVirtual = function getVirtual ( shouldCapture ) {
  	var this$1 = this;

  		var value = this.get( shouldCapture, { virtual: false } );
  	if ( isObject( value ) ) {
  		var result = isArray( value ) ? [] : {};

  		var keys = Object.keys( value );
  		var i = keys.length;
  		while ( i-- ) {
  			var child = this$1.childByKey[ keys[i] ];
  			if ( !child ) result[ keys[i] ] = value[ keys[i] ];
  			else if ( child._link ) result[ keys[i] ] = child._link.getVirtual();
  			else result[ keys[i] ] = child.getVirtual();
  		}

  		i = this.children.length;
  		while ( i-- ) {
  			var child$1 = this$1.children[i];
  			if ( !( child$1.key in result ) && child$1._link ) {
  				result[ child$1.key ] = child$1._link.getVirtual();
  			}
  		}

  		return result;
  	} else return value;
  };

  ModelBase.prototype.has = function has ( key ) {
  	if ( this._link ) return this._link.has( key );

  	var value = this.get();
  	if ( !value ) return false;

  	key = unescapeKey( key );
  	if ( hasProp.call( value, key ) ) return true;

  	// We climb up the constructor chain to find if one of them contains the key
  	var constructor = value.constructor;
  	while ( constructor !== Function && constructor !== Array && constructor !== Object ) {
  		if ( hasProp.call( constructor.prototype, key ) ) return true;
  		constructor = constructor.constructor;
  	}

  	return false;
  };

  ModelBase.prototype.joinAll = function joinAll ( keys, opts ) {
  	var model = this;
  	for ( var i = 0; i < keys.length; i += 1 ) {
  		if ( opts && opts.lastLink === false && i + 1 === keys.length && model.childByKey[keys[i]] && model.childByKey[keys[i]]._link ) return model.childByKey[keys[i]];
  		model = model.joinKey( keys[i], opts );
  	}

  	return model;
  };

  ModelBase.prototype.notifyUpstream = function notifyUpstream () {
  	var parent = this.parent, path = [ this.key ];
  	while ( parent ) {
  		if ( parent.patternObservers.length ) parent.patternObservers.forEach( function ( o ) { return o.notify( path.slice() ); } );
  		path.unshift( parent.key );
  		parent.links.forEach( notifiedUpstream );
  		parent.deps.forEach( handleChange );
  		parent = parent.parent;
  	}
  };

  ModelBase.prototype.rebinding = function rebinding ( next, previous, safe ) {
  	// tell the deps to move to the new target
  	var this$1 = this;

  		var i = this.deps.length;
  	while ( i-- ) {
  		if ( this$1.deps[i].rebinding ) this$1.deps[i].rebinding( next, previous, safe );
  	}

  	i = this.links.length;
  	while ( i-- ) {
  		var link = this$1.links[i];
  		// only relink the root of the link tree
  		if ( link.owner._link ) link.relinking( next, true, safe );
  	}

  	i = this.children.length;
  	while ( i-- ) {
  		var child = this$1.children[i];
  		child.rebinding( next ? next.joinKey( child.key ) : undefined, child, safe );
  	}

  	i = this.unresolved.length;
  	while ( i-- ) {
  		var unresolved = this$1.unresolvedByKey[ this$1.unresolved[i] ];
  		var c = unresolved.length;
  		while ( c-- ) {
  			unresolved[c].rebinding( next, previous );
  		}
  	}

  	if ( this.keypathModel ) this.keypathModel.rebinding( next, previous, false );

  	i = this.bindings.length;
  	while ( i-- ) {
  		this$1.bindings[i].rebinding( next, previous, safe );
  	}
  };

  ModelBase.prototype.register = function register ( dep ) {
  	this.deps.push( dep );
  };

  ModelBase.prototype.registerChange = function registerChange ( key, value ) {
  	if ( !this.isRoot ) {
  		this.root.registerChange( key, value );
  	} else {
  		this.changes[ key ] = value;
  		runloop.addInstance( this.root.ractive );
  	}
  };

  ModelBase.prototype.registerLink = function registerLink ( link ) {
  	addToArray( this.links, link );
  };

  ModelBase.prototype.registerPatternObserver = function registerPatternObserver ( observer ) {
  	this.patternObservers.push( observer );
  	this.register( observer );
  };

  ModelBase.prototype.registerTwowayBinding = function registerTwowayBinding ( binding ) {
  	this.bindings.push( binding );
  };

  ModelBase.prototype.removeUnresolved = function removeUnresolved ( key, resolver ) {
  	var resolvers = this.unresolvedByKey[ key ];

  	if ( resolvers ) {
  		removeFromArray( resolvers, resolver );
  	}
  };

  ModelBase.prototype.shuffled = function shuffled () {
  	var this$1 = this;

  		var i = this.children.length;
  	while ( i-- ) {
  		this$1.children[i].shuffled();
  	}
  	if ( this.wrapper ) {
  		this.wrapper.teardown();
  		this.wrapper = null;
  		this.rewrap = true;
  	}
  };

  ModelBase.prototype.unregister = function unregister ( dependant ) {
  	removeFromArray( this.deps, dependant );
  };

  ModelBase.prototype.unregisterLink = function unregisterLink ( link ) {
  	removeFromArray( this.links, link );
  };

  ModelBase.prototype.unregisterPatternObserver = function unregisterPatternObserver ( observer ) {
  	removeFromArray( this.patternObservers, observer );
  	this.unregister( observer );
  };

  ModelBase.prototype.unregisterTwowayBinding = function unregisterTwowayBinding ( binding ) {
  	removeFromArray( this.bindings, binding );
  };

  ModelBase.prototype.updateFromBindings = function updateFromBindings$1 ( cascade ) {
  	var this$1 = this;

  		var i = this.bindings.length;
  	while ( i-- ) {
  		var value = this$1.bindings[i].getValue();
  		if ( value !== this$1.value ) this$1.set( value );
  	}

  	// check for one-way bindings if there are no two-ways
  	if ( !this.bindings.length ) {
  		var oneway = findBoundValue( this.deps );
  		if ( oneway && oneway.value !== this.value ) this.set( oneway.value );
  	}

  	if ( cascade ) {
  		this.children.forEach( updateFromBindings );
  		this.links.forEach( updateFromBindings );
  		if ( this._link ) this._link.updateFromBindings( cascade );
  	}
  };

  function updateFromBindings ( model ) {
  	model.updateFromBindings( true );
  }

  function findBoundValue( list ) {
  	var i = list.length;
  	while ( i-- ) {
  		if ( list[i].bound ) {
  			var owner = list[i].owner;
  			if ( owner ) {
  				var value = owner.name === 'checked' ?
  					owner.node.checked :
  					owner.node.value;
  				return { value: value };
  			}
  		}
  	}
  }

  function fireShuffleTasks ( stage ) {
  	if ( !stage ) {
  		fireShuffleTasks( 'early' );
  		fireShuffleTasks( 'mark' );
  	} else {
  		var tasks = shuffleTasks[stage];
  		shuffleTasks[stage] = [];
  		var i = tasks.length;
  		while ( i-- ) tasks[i]();

  		var register = registerQueue[stage];
  		registerQueue[stage] = [];
  		i = register.length;
  		while ( i-- ) register[i].model.register( register[i].item );
  	}
  }

  KeyModel.prototype.addShuffleTask = ModelBase.prototype.addShuffleTask;
  KeyModel.prototype.addShuffleRegister = ModelBase.prototype.addShuffleRegister;
  KeypathModel.prototype.addShuffleTask = ModelBase.prototype.addShuffleTask;
  KeypathModel.prototype.addShuffleRegister = ModelBase.prototype.addShuffleRegister;

  // this is the dry method of checking to see if a rebind applies to
  // a particular keypath because in some cases, a dep may be bound
  // directly to a particular keypath e.g. foo.bars.0.baz and need
  // to avoid getting kicked to foo.bars.1.baz if foo.bars is unshifted
  function rebindMatch ( template, next, previous ) {
  	var keypath = template.r || template;

  	// no valid keypath, go with next
  	if ( !keypath || typeof keypath !== 'string' ) return next;

  	// completely contextual ref, go with next
  	if ( keypath === '.' || keypath[0] === '@' || (next || previous).isKey || (next || previous).isKeypath ) return next;

  	var parts = keypath.split( '/' );
  	var keys = splitKeypathI( parts[ parts.length - 1 ] );

  	// check the keypath against the model keypath to see if it matches
  	var model = next || previous;
  	var i = keys.length;
  	var match = true, shuffling = false;

  	while ( model && i-- ) {
  		if ( model.shuffling ) shuffling = true;
  		// non-strict comparison to account for indices in keypaths
  		if ( keys[i] != model.key ) match = false;
  		model = model.parent;
  	}

  	// next is undefined, but keypath is shuffling and previous matches
  	if ( !next && match && shuffling ) return previous;
  	// next is defined, but doesn't match the keypath
  	else if ( next && !match && shuffling ) return previous;
  	else return next;
  }

  var LinkModel = (function (ModelBase) {
  	function LinkModel ( parent, owner, target, key ) {
  		ModelBase.call( this, parent );

  		this.owner = owner;
  		this.target = target;
  		this.key = key === undefined ? owner.key : key;
  		if ( owner.isLink ) this.sourcePath = "" + (owner.sourcePath) + "." + (this.key);

  		target.registerLink( this );

  		this.isReadonly = parent.isReadonly;

  		this.isLink = true;
  	}

  	LinkModel.prototype = Object.create( ModelBase && ModelBase.prototype );
  	LinkModel.prototype.constructor = LinkModel;

  	LinkModel.prototype.animate = function animate ( from, to, options, interpolator ) {
  		this.target.animate( from, to, options, interpolator );
  	};

  	LinkModel.prototype.applyValue = function applyValue ( value ) {
  		this.target.applyValue( value );
  	};

  	LinkModel.prototype.get = function get ( shouldCapture, opts ) {
  		if ( shouldCapture ) {
  			capture( this );

  			// may need to tell the target to unwrap
  			opts = opts || {};
  			opts.unwrap = true;
  		}

  		return this.target.get( false, opts );
  	};

  	LinkModel.prototype.getKeypath = function getKeypath ( ractive ) {
  		if ( ractive && ractive !== this.root.ractive ) return this.target.getKeypath( ractive );

  		return ModelBase.prototype.getKeypath.call( this, ractive );
  	};

  	LinkModel.prototype.getKeypathModel = function getKeypathModel ( ractive ) {
  		if ( !this.keypathModel ) this.keypathModel = new KeypathModel( this );
  		if ( ractive && ractive !== this.root.ractive ) return this.keypathModel.getChild( ractive );
  		return this.keypathModel;
  	};

  	LinkModel.prototype.handleChange = function handleChange$1 () {
  		this.deps.forEach( handleChange );
  		this.links.forEach( handleChange );
  		this.notifyUpstream();
  	};

  	LinkModel.prototype.joinKey = function joinKey ( key ) {
  		// TODO: handle nested links
  		if ( key === undefined || key === '' ) return this;

  		if ( !this.childByKey.hasOwnProperty( key ) ) {
  			var child = new LinkModel( this, this, this.target.joinKey( key ), key );
  			this.children.push( child );
  			this.childByKey[ key ] = child;
  		}

  		return this.childByKey[ key ];
  	};

  	LinkModel.prototype.mark = function mark () {
  		this.target.mark();
  	};

  	LinkModel.prototype.marked = function marked$1 () {
  		this.links.forEach( marked );

  		this.deps.forEach( handleChange );
  		this.clearUnresolveds();
  	};

  	LinkModel.prototype.notifiedUpstream = function notifiedUpstream$1 () {
  		this.links.forEach( notifiedUpstream );
  		this.deps.forEach( handleChange );
  	};

  	LinkModel.prototype.relinked = function relinked () {
  		this.target.registerLink( this );
  		this.children.forEach( function ( c ) { return c.relinked(); } );
  	};

  	LinkModel.prototype.relinking = function relinking ( target, root, safe ) {
  		var this$1 = this;

  		if ( root && this.sourcePath ) target = rebindMatch( this.sourcePath, target, this.target );
  		if ( !target || this.target === target ) return;

  		this.target.unregisterLink( this );
  		if ( this.keypathModel ) this.keypathModel.rebindChildren( target );

  		this.target = target;
  		this.children.forEach( function ( c ) {
  			c.relinking( target.joinKey( c.key ), false, safe );
  		});

  		if ( root ) this.addShuffleTask( function () {
  			this$1.relinked();
  			if ( !safe ) this$1.notifyUpstream();
  		});
  	};

  	LinkModel.prototype.set = function set ( value ) {
  		this.target.set( value );
  	};

  	LinkModel.prototype.shuffle = function shuffle ( newIndices ) {
  		// watch for extra shuffles caused by a shuffle in a downstream link
  		var this$1 = this;

  		if ( this.shuffling ) return;

  		// let the real model handle firing off shuffles
  		if ( !this.target.shuffling ) {
  			this.target.shuffle( newIndices );
  		} else {
  			this.shuffling = true;

  			var i = newIndices.length;
  			while ( i-- ) {
  				var idx = newIndices[ i ];
  				// nothing is actually changing, so move in the index and roll on
  				if ( i === idx ) {
  					continue;
  				}

  				// rebind the children on i to idx
  				if ( i in this$1.childByKey ) this$1.childByKey[ i ].rebinding( !~idx ? undefined : this$1.joinKey( idx ), this$1.childByKey[ i ], true );

  				if ( !~idx && this$1.keyModels[ i ] ) {
  					this$1.keyModels[i].rebinding( undefined, this$1.keyModels[i], false );
  				} else if ( ~idx && this$1.keyModels[ i ] ) {
  					if ( !this$1.keyModels[ idx ] ) this$1.childByKey[ idx ].getKeyModel( idx );
  					this$1.keyModels[i].rebinding( this$1.keyModels[ idx ], this$1.keyModels[i], false );
  				}
  			}

  			var upstream = this.source().length !== this.source().value.length;

  			this.links.forEach( function ( l ) { return l.shuffle( newIndices ); } );

  			i = this.deps.length;
  			while ( i-- ) {
  				if ( this$1.deps[i].shuffle ) this$1.deps[i].shuffle( newIndices );
  			}

  			this.marked();

  			if ( upstream ) this.notifyUpstream();

  			this.shuffling = false;
  		}

  	};

  	LinkModel.prototype.source = function source () {
  		if ( this.target.source ) return this.target.source();
  		else return this.target;
  	};

  	LinkModel.prototype.teardown = function teardown$1 () {
  		if ( this._link ) this._link.teardown();
  		this.children.forEach( teardown );
  	};

  	return LinkModel;
  }(ModelBase));

  ModelBase.prototype.link = function link ( model, keypath ) {
  	var lnk = this._link || new LinkModel( this.parent, this, model, this.key );
  	lnk.sourcePath = keypath;
  	if ( this._link ) this._link.relinking( model, true, false );
  	this.rebinding( lnk, this, false );
  	fireShuffleTasks();

  	var unresolved = !this._link;
  	this._link = lnk;
  	if ( unresolved ) this.parent.clearUnresolveds();
  	lnk.marked();
  	return lnk;
  };

  ModelBase.prototype.unlink = function unlink () {
  	if ( this._link ) {
  		var ln = this._link;
  		this._link = undefined;
  		ln.rebinding( this, this._link );
  		fireShuffleTasks();
  		ln.teardown();
  	}
  };

  var requestAnimationFrame;

  // If window doesn't exist, we don't need requestAnimationFrame
  if ( !win ) {
  	requestAnimationFrame = null;
  } else {
  	// https://gist.github.com/paulirish/1579671
  	(function(vendors, lastTime, win) {

  		var x, setTimeout;

  		if ( win.requestAnimationFrame ) {
  			return;
  		}

  		for ( x = 0; x < vendors.length && !win.requestAnimationFrame; ++x ) {
  			win.requestAnimationFrame = win[vendors[x]+'RequestAnimationFrame'];
  		}

  		if ( !win.requestAnimationFrame ) {
  			setTimeout = win.setTimeout;

  			win.requestAnimationFrame = function(callback) {
  				var currTime, timeToCall, id;

  				currTime = Date.now();
  				timeToCall = Math.max( 0, 16 - (currTime - lastTime ) );
  				id = setTimeout( function() { callback(currTime + timeToCall); }, timeToCall );

  				lastTime = currTime + timeToCall;
  				return id;
  			};
  		}

  	}( vendors, 0, win ));

  	requestAnimationFrame = win.requestAnimationFrame;
  }

  var rAF = requestAnimationFrame;

  var getTime = ( win && win.performance && typeof win.performance.now === 'function' ) ?
  	function () { return win.performance.now(); } :
  	function () { return Date.now(); };

  // TODO what happens if a transition is aborted?

  var tickers = [];
  var running = false;

  function tick () {
  	runloop.start();

  	var now = getTime();

  	var i;
  	var ticker;

  	for ( i = 0; i < tickers.length; i += 1 ) {
  		ticker = tickers[i];

  		if ( !ticker.tick( now ) ) {
  			// ticker is complete, remove it from the stack, and decrement i so we don't miss one
  			tickers.splice( i--, 1 );
  		}
  	}

  	runloop.end();

  	if ( tickers.length ) {
  		rAF( tick );
  	} else {
  		running = false;
  	}
  }

  var Ticker = function Ticker ( options ) {
  	this.duration = options.duration;
  	this.step = options.step;
  	this.complete = options.complete;
  	this.easing = options.easing;

  	this.start = getTime();
  	this.end = this.start + this.duration;

  	this.running = true;

  	tickers.push( this );
  	if ( !running ) rAF( tick );
  };

  Ticker.prototype.tick = function tick$1 ( now ) {
  	if ( !this.running ) return false;

  	if ( now > this.end ) {
  		if ( this.step ) this.step( 1 );
  		if ( this.complete ) this.complete( 1 );

  		return false;
  	}

  	var elapsed = now - this.start;
  	var eased = this.easing( elapsed / this.duration );

  	if ( this.step ) this.step( eased );

  	return true;
  };

  Ticker.prototype.stop = function stop () {
  	if ( this.abort ) this.abort();
  	this.running = false;
  };

  var prefixers = {};

  // TODO this is legacy. sooner we can replace the old adaptor API the better
  function prefixKeypath ( obj, prefix ) {
  	var prefixed = {}, key;

  	if ( !prefix ) {
  		return obj;
  	}

  	prefix += '.';

  	for ( key in obj ) {
  		if ( obj.hasOwnProperty( key ) ) {
  			prefixed[ prefix + key ] = obj[ key ];
  		}
  	}

  	return prefixed;
  }

  function getPrefixer ( rootKeypath ) {
  	var rootDot;

  	if ( !prefixers[ rootKeypath ] ) {
  		rootDot = rootKeypath ? rootKeypath + '.' : '';

  		prefixers[ rootKeypath ] = function ( relativeKeypath, value ) {
  			var obj;

  			if ( typeof relativeKeypath === 'string' ) {
  				obj = {};
  				obj[ rootDot + relativeKeypath ] = value;
  				return obj;
  			}

  			if ( typeof relativeKeypath === 'object' ) {
  				// 'relativeKeypath' is in fact a hash, not a keypath
  				return rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;
  			}
  		};
  	}

  	return prefixers[ rootKeypath ];
  }

  var Model = (function (ModelBase) {
  	function Model ( parent, key ) {
  		ModelBase.call( this, parent );

  		this.ticker = null;

  		if ( parent ) {
  			this.key = unescapeKey( key );
  			this.isReadonly = parent.isReadonly;

  			if ( parent.value ) {
  				this.value = parent.value[ this.key ];
  				if ( isArray( this.value ) ) this.length = this.value.length;
  				this.adapt();
  			}
  		}
  	}

  	Model.prototype = Object.create( ModelBase && ModelBase.prototype );
  	Model.prototype.constructor = Model;

  	Model.prototype.adapt = function adapt () {
  		var this$1 = this;

  		var adaptors = this.root.adaptors;
  		var len = adaptors.length;

  		this.rewrap = false;

  		// Exit early if no adaptors
  		if ( len === 0 ) return;

  		var value = this.wrapper ? ( 'newWrapperValue' in this ? this.newWrapperValue : this.wrapperValue ) : this.value;

  		// TODO remove this legacy nonsense
  		var ractive = this.root.ractive;
  		var keypath = this.getKeypath();

  		// tear previous adaptor down if present
  		if ( this.wrapper ) {
  			var shouldTeardown = this.wrapperValue === value ? false : !this.wrapper.reset || this.wrapper.reset( value ) === false;

  			if ( shouldTeardown ) {
  				this.wrapper.teardown();
  				this.wrapper = null;

  				// don't branch for undefined values
  				if ( this.value !== undefined ) {
  					var parentValue = this.parent.value || this.parent.createBranch( this.key );
  					if ( parentValue[ this.key ] !== value ) parentValue[ this.key ] = value;
  				}
  			} else {
  				delete this.newWrapperValue;
  				this.wrapperValue = value;
  				this.value = this.wrapper.get();
  				return;
  			}
  		}

  		var i;

  		for ( i = 0; i < len; i += 1 ) {
  			var adaptor = adaptors[i];
  			if ( adaptor.filter( value, keypath, ractive ) ) {
  				this$1.wrapper = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );
  				this$1.wrapperValue = value;
  				this$1.wrapper.__model = this$1; // massive temporary hack to enable array adaptor

  				this$1.value = this$1.wrapper.get();

  				break;
  			}
  		}
  	};

  	Model.prototype.animate = function animate ( from, to, options, interpolator ) {
  		var this$1 = this;

  		if ( this.ticker ) this.ticker.stop();

  		var fulfilPromise;
  		var promise = new Promise$1( function ( fulfil ) { return fulfilPromise = fulfil; } );

  		this.ticker = new Ticker({
  			duration: options.duration,
  			easing: options.easing,
  			step: function ( t ) {
  				var value = interpolator( t );
  				this$1.applyValue( value );
  				if ( options.step ) options.step( t, value );
  			},
  			complete: function () {
  				this$1.applyValue( to );
  				if ( options.complete ) options.complete( to );

  				this$1.ticker = null;
  				fulfilPromise();
  			}
  		});

  		promise.stop = this.ticker.stop;
  		return promise;
  	};

  	Model.prototype.applyValue = function applyValue ( value ) {
  		if ( isEqual( value, this.value ) ) return;

  		// TODO deprecate this nonsense
  		this.registerChange( this.getKeypath(), value );

  		if ( this.parent.wrapper && this.parent.wrapper.set ) {
  			this.parent.wrapper.set( this.key, value );
  			this.parent.value = this.parent.wrapper.get();

  			this.value = this.parent.value[ this.key ];
  			if ( this.wrapper ) this.newWrapperValue = this.value;
  			this.adapt();
  		} else if ( this.wrapper ) {
  			this.newWrapperValue = value;
  			this.adapt();
  		} else {
  			var parentValue = this.parent.value || this.parent.createBranch( this.key );
  			parentValue[ this.key ] = value;

  			this.value = value;
  			this.adapt();
  		}

  		this.parent.clearUnresolveds();
  		this.clearUnresolveds();

  		// keep track of array length
  		if ( isArray( value ) ) this.length = value.length;

  		// notify dependants
  		this.links.forEach( handleChange );
  		this.children.forEach( mark );
  		this.deps.forEach( handleChange );

  		this.notifyUpstream();

  		if ( this.key === 'length' && isArray( this.parent.value ) ) this.parent.length = this.parent.value.length;
  	};

  	Model.prototype.createBranch = function createBranch ( key ) {
  		var branch = isNumeric( key ) ? [] : {};
  		this.set( branch );

  		return branch;
  	};

  	Model.prototype.get = function get ( shouldCapture, opts ) {
  		if ( this._link ) return this._link.get( shouldCapture, opts );
  		if ( shouldCapture ) capture( this );
  		// if capturing, this value needs to be unwrapped because it's for external use
  		if ( opts && opts.virtual ) return this.getVirtual( false );
  		return ( shouldCapture || ( opts && opts.unwrap ) ) && this.wrapper ? this.wrapperValue : this.value;
  	};

  	Model.prototype.getKeypathModel = function getKeypathModel ( ractive ) {
  		if ( !this.keypathModel ) this.keypathModel = new KeypathModel( this );
  		return this.keypathModel;
  	};

  	Model.prototype.joinKey = function joinKey ( key, opts ) {
  		if ( this._link ) {
  			if ( opts && !opts.lastLink === false && ( key === undefined || key === '' ) ) return this;
  			return this._link.joinKey( key );
  		}

  		if ( key === undefined || key === '' ) return this;


  		if ( !this.childByKey.hasOwnProperty( key ) ) {
  			var child = new Model( this, key );
  			this.children.push( child );
  			this.childByKey[ key ] = child;
  		}

  		if ( this.childByKey[ key ]._link ) return this.childByKey[ key ]._link;
  		return this.childByKey[ key ];
  	};

  	Model.prototype.mark = function mark$1 () {
  		if ( this._link ) return this._link.mark();

  		var value = this.retrieve();

  		if ( !isEqual( value, this.value ) ) {
  			var old = this.value;
  			this.value = value;

  			// make sure the wrapper stays in sync
  			if ( old !== value || this.rewrap ) {
  				if ( this.wrapper ) this.newWrapperValue = value;
  				this.adapt();
  			}

  			// keep track of array lengths
  			if ( isArray( value ) ) this.length = value.length;

  			this.children.forEach( mark );
  			this.links.forEach( marked );

  			this.deps.forEach( handleChange );
  			this.clearUnresolveds();
  		}
  	};

  	Model.prototype.merge = function merge ( array, comparator ) {
  		var oldArray = this.value, newArray = array;
  		if ( oldArray === newArray ) oldArray = recreateArray( this );
  		if ( comparator ) {
  			oldArray = oldArray.map( comparator );
  			newArray = newArray.map( comparator );
  		}

  		var oldLength = oldArray.length;

  		var usedIndices = {};
  		var firstUnusedIndex = 0;

  		var newIndices = oldArray.map( function ( item ) {
  			var index;
  			var start = firstUnusedIndex;

  			do {
  				index = newArray.indexOf( item, start );

  				if ( index === -1 ) {
  					return -1;
  				}

  				start = index + 1;
  			} while ( ( usedIndices[ index ] === true ) && start < oldLength );

  			// keep track of the first unused index, so we don't search
  			// the whole of newArray for each item in oldArray unnecessarily
  			if ( index === firstUnusedIndex ) {
  				firstUnusedIndex += 1;
  			}
  			// allow next instance of next "equal" to be found item
  			usedIndices[ index ] = true;
  			return index;
  		});

  		this.parent.value[ this.key ] = array;
  		this.shuffle( newIndices );
  	};

  	Model.prototype.retrieve = function retrieve () {
  		return this.parent.value ? this.parent.value[ this.key ] : undefined;
  	};

  	Model.prototype.set = function set ( value ) {
  		if ( this.ticker ) this.ticker.stop();
  		this.applyValue( value );
  	};

  	Model.prototype.shuffle = function shuffle ( newIndices ) {
  		var this$1 = this;

  		this.shuffling = true;
  		var i = newIndices.length;
  		while ( i-- ) {
  			var idx = newIndices[ i ];
  			// nothing is actually changing, so move in the index and roll on
  			if ( i === idx ) {
  				continue;
  			}

  			// rebind the children on i to idx
  			if ( i in this$1.childByKey ) this$1.childByKey[ i ].rebinding( !~idx ? undefined : this$1.joinKey( idx ), this$1.childByKey[ i ], true );

  			if ( !~idx && this$1.keyModels[ i ] ) {
  				this$1.keyModels[i].rebinding( undefined, this$1.keyModels[i], false );
  			} else if ( ~idx && this$1.keyModels[ i ] ) {
  				if ( !this$1.keyModels[ idx ] ) this$1.childByKey[ idx ].getKeyModel( idx );
  				this$1.keyModels[i].rebinding( this$1.keyModels[ idx ], this$1.keyModels[i], false );
  			}
  		}

  		var upstream = this.length !== this.value.length;

  		this.links.forEach( function ( l ) { return l.shuffle( newIndices ); } );
  		fireShuffleTasks( 'early' );

  		i = this.deps.length;
  		while ( i-- ) {
  			if ( this$1.deps[i].shuffle ) this$1.deps[i].shuffle( newIndices );
  		}

  		this.mark();
  		fireShuffleTasks( 'mark' );

  		if ( upstream ) this.notifyUpstream();
  		this.shuffling = false;
  	};

  	Model.prototype.teardown = function teardown$1 () {
  		if ( this._link ) this._link.teardown();
  		this.children.forEach( teardown );
  		if ( this.wrapper ) this.wrapper.teardown();
  		if ( this.keypathModel ) this.keypathModel.teardown();
  	};

  	return Model;
  }(ModelBase));

  function recreateArray( model ) {
  	var array = [];

  	for ( var i = 0; i < model.length; i++ ) {
  		array[ i ] = (model.childByKey[i] || {}).value;
  	}

  	return array;
  }

  var GlobalModel = (function (Model) {
  	function GlobalModel ( ) {
  		Model.call( this, null, '@global' );
  		this.value = typeof global !== 'undefined' ? global : window;
  		this.isRoot = true;
  		this.root = this;
  		this.adaptors = [];
  	}

  	GlobalModel.prototype = Object.create( Model && Model.prototype );
  	GlobalModel.prototype.constructor = GlobalModel;

  	GlobalModel.prototype.getKeypath = function getKeypath() {
  		return '@global';
  	};

  	// global model doesn't contribute changes events because it has no instance
  	GlobalModel.prototype.registerChange = function registerChange () {};

  	return GlobalModel;
  }(Model));

  var GlobalModel$1 = new GlobalModel();

  var keypathExpr = /^@[^\(]+\(([^\)]+)\)/;

  function resolveReference ( fragment, ref ) {
  	var context = fragment.findContext();

  	// special references
  	// TODO does `this` become `.` at parse time?
  	if ( ref === '.' || ref === 'this' ) return context;
  	if ( ref.indexOf( '@keypath' ) === 0 ) {
  		var match = keypathExpr.exec( ref );
  		if ( match && match[1] ) {
  			var model = resolveReference( fragment, match[1] );
  			if ( model ) return model.getKeypathModel();
  		}
  		return context.getKeypathModel();
  	}
  	if ( ref.indexOf( '@rootpath' ) === 0 ) {
  		// check to see if this is an empty component root
  		while ( context.isRoot && context.ractive.component ) {
  			context = context.ractive.component.parentFragment.findContext();
  		}

  		var match$1 = keypathExpr.exec( ref );
  		if ( match$1 && match$1[1] ) {
  			var model$1 = resolveReference( fragment, match$1[1] );
  			if ( model$1 ) return model$1.getKeypathModel( fragment.ractive.root );
  		}
  		return context.getKeypathModel( fragment.ractive.root );
  	}
  	if ( ref === '@index' || ref === '@key' ) {
  		var repeater = fragment.findRepeatingFragment();
  		// make sure the found fragment is actually an iteration
  		if ( !repeater.isIteration ) return;
  		return repeater.context.getKeyModel( repeater[ ref[1] === 'i' ? 'index' : 'key' ] );
  	}
  	if ( ref === '@this' ) {
  		return fragment.ractive.viewmodel.getRactiveModel();
  	}
  	if ( ref === '@global' ) {
  		return GlobalModel$1;
  	}

  	// ancestor references
  	if ( ref[0] === '~' ) return fragment.ractive.viewmodel.joinAll( splitKeypathI( ref.slice( 2 ) ) );
  	if ( ref[0] === '.' ) {
  		var parts = ref.split( '/' );

  		while ( parts[0] === '.' || parts[0] === '..' ) {
  			var part = parts.shift();

  			if ( part === '..' ) {
  				context = context.parent;
  			}
  		}

  		ref = parts.join( '/' );

  		// special case - `{{.foo}}` means the same as `{{./foo}}`
  		if ( ref[0] === '.' ) ref = ref.slice( 1 );
  		return context.joinAll( splitKeypathI( ref ) );
  	}

  	return resolveAmbiguousReference( fragment, ref );
  }

  function Ractive$get ( keypath, opts ) {
  	if ( typeof keypath !== 'string' ) return this.viewmodel.get( true, keypath );

  	var keys = splitKeypathI( keypath );
  	var key = keys[0];

  	var model;

  	if ( !this.viewmodel.has( key ) ) {
  		// if this is an inline component, we may need to create
  		// an implicit mapping
  		if ( this.component && !this.isolated ) {
  			model = resolveReference( this.component.parentFragment, key );

  			if ( model ) {
  				this.viewmodel.map( key, model );
  			}
  		}
  	}

  	model = this.viewmodel.joinAll( keys );
  	return model.get( true, opts );
  }

  function gatherRefs( fragment ) {
  	var key = {}, index = {};

  	// walk up the template gather refs as we go
  	while ( fragment ) {
  		if ( fragment.parent && ( fragment.parent.indexRef || fragment.parent.keyRef ) ) {
  			var ref = fragment.parent.indexRef;
  			if ( ref && !( ref in index ) ) index[ref] = fragment.index;
  			ref = fragment.parent.keyRef;
  			if ( ref && !( ref in key ) ) key[ref] = fragment.key;
  		}

  		if ( fragment.componentParent && !fragment.ractive.isolated ) {
  			fragment = fragment.componentParent;
  		} else {
  			fragment = fragment.parent;
  		}
  	}

  	return { key: key, index: index };
  }

  // This function takes an array, the name of a mutator method, and the
  // arguments to call that mutator method with, and returns an array that
  // maps the old indices to their new indices.

  // So if you had something like this...
  //
  //     array = [ 'a', 'b', 'c', 'd' ];
  //     array.push( 'e' );
  //
  // ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices
  // have changed. If you then did this...
  //
  //     array.unshift( 'z' );
  //
  // ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved
  // one higher to make room for the 'z'. If you removed an item, the new index
  // would be -1...
  //
  //     array.splice( 2, 2 );
  //
  // ...this would result in [ 0, 1, -1, -1, 2, 3 ].
  //
  // This information is used to enable fast, non-destructive shuffling of list
  // sections when you do e.g. `ractive.splice( 'items', 2, 2 );

  function getNewIndices ( length, methodName, args ) {
  	var spliceArguments, newIndices = [], removeStart, removeEnd, balance, i;

  	spliceArguments = getSpliceEquivalent( length, methodName, args );

  	if ( !spliceArguments ) {
  		return null; // TODO support reverse and sort?
  	}

  	balance = ( spliceArguments.length - 2 ) - spliceArguments[1];

  	removeStart = Math.min( length, spliceArguments[0] );
  	removeEnd = removeStart + spliceArguments[1];
  	newIndices.startIndex = removeStart;

  	for ( i = 0; i < removeStart; i += 1 ) {
  		newIndices.push( i );
  	}

  	for ( ; i < removeEnd; i += 1 ) {
  		newIndices.push( -1 );
  	}

  	for ( ; i < length; i += 1 ) {
  		newIndices.push( i + balance );
  	}

  	// there is a net shift for the rest of the array starting with index + balance
  	if ( balance !== 0 ) {
  		newIndices.touchedFrom = spliceArguments[0];
  	} else {
  		newIndices.touchedFrom = length;
  	}

  	return newIndices;
  }


  // The pop, push, shift an unshift methods can all be represented
  // as an equivalent splice
  function getSpliceEquivalent ( length, methodName, args ) {
  	switch ( methodName ) {
  		case 'splice':
  			if ( args[0] !== undefined && args[0] < 0 ) {
  				args[0] = length + Math.max( args[0], -length );
  			}

  			if ( args[0] === undefined ) args[0] = 0;

  			while ( args.length < 2 ) {
  				args.push( length - args[0] );
  			}

  			if ( typeof args[1] !== 'number' ) {
  				args[1] = length - args[0];
  			}

  			// ensure we only remove elements that exist
  			args[1] = Math.min( args[1], length - args[0] );

  			return args;

  		case 'sort':
  		case 'reverse':
  			return null;

  		case 'pop':
  			if ( length ) {
  				return [ length - 1, 1 ];
  			}
  			return [ 0, 0 ];

  		case 'push':
  			return [ length, 0 ].concat( args );

  		case 'shift':
  			return [ 0, length ? 1 : 0 ];

  		case 'unshift':
  			return [ 0, 0 ].concat( args );
  	}
  }

  var arrayProto = Array.prototype;

  function makeArrayMethod ( methodName ) {
  	function path ( keypath ) {
  		var args = [], len = arguments.length - 1;
  		while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

  		return model( this.viewmodel.joinAll( splitKeypathI( keypath ) ), args );
  	}

  	function model ( mdl, args ) {
  		var array = mdl.get();

  		if ( !isArray( array ) ) {
  			if ( array === undefined ) {
  				array = [];
  				var result$1 = arrayProto[ methodName ].apply( array, args );
  				var promise$1 = runloop.start( this, true ).then( function () { return result$1; } );
  				mdl.set( array );
  				runloop.end();
  				return promise$1;
  			} else {
  				throw new Error( ("shuffle array method " + methodName + " called on non-array at " + (mdl.getKeypath())) );
  			}
  		}

  		var newIndices = getNewIndices( array.length, methodName, args );
  		var result = arrayProto[ methodName ].apply( array, args );

  		var promise = runloop.start( this, true ).then( function () { return result; } );
  		promise.result = result;

  		if ( newIndices ) {
  			mdl.shuffle( newIndices );
  		} else {
  			mdl.set( result );
  		}

  		runloop.end();

  		return promise;
  	}

  	return { path: path, model: model };
  }

  var comparators = {};

  function getComparator ( option ) {
  	if ( !option ) return null; // use existing arrays
  	if ( option === true ) return JSON.stringify;
  	if ( typeof option === 'function' ) return option;

  	if ( typeof option === 'string' ) {
  		return comparators[ option ] || ( comparators[ option ] = function ( thing ) { return thing[ option ]; } );
  	}

  	throw new Error( 'If supplied, options.compare must be a string, function, or `true`' ); // TODO link to docs
  }

  function merge$1 ( ractive, model, array, options ) {
  	var promise = runloop.start( ractive, true );
  	var value = model.get();

  	if ( !isArray( value ) || !isArray( array ) ) {
  		throw new Error( 'You cannot merge an array with a non-array' );
  	}

  	var comparator = getComparator( options && options.compare );
  	model.merge( array, comparator );

  	runloop.end();
  	return promise;
  }

  function thisRactive$merge ( keypath, array, options ) {
  	return merge$1( this, this.viewmodel.joinAll( splitKeypathI( keypath ) ), array, options );
  }

  var updateHook = new Hook( 'update' );

  function update$2 ( ractive, model ) {
  	// if the parent is wrapped, the adaptor will need to be updated before
  	// updating on this keypath
  	if ( model.parent && model.parent.wrapper ) {
  		model.parent.adapt();
  	}

  	var promise = runloop.start( ractive, true );

  	model.mark();
  	model.registerChange( model.getKeypath(), model.get() );

  	if ( !model.isRoot ) {
  		// there may be unresolved refs that are now resolvable up the context tree
  		var parent = model.parent, key = model.key;
  		while ( parent && !parent.isRoot ) {
  			if ( parent.clearUnresolveds ) parent.clearUnresolveds( key );
  			key = parent.key;
  			parent = parent.parent;
  		}
  	}

  	// notify upstream of changes
  	model.notifyUpstream();

  	runloop.end();

  	updateHook.fire( ractive, model );

  	return promise;
  }

  function Ractive$update ( keypath ) {
  	if ( keypath ) keypath = splitKeypathI( keypath );

  	return update$2( this, keypath ? this.viewmodel.joinAll( keypath ) : this.viewmodel );
  }

  var modelPush = makeArrayMethod( 'push' ).model;
  var modelPop = makeArrayMethod( 'pop' ).model;
  var modelShift = makeArrayMethod( 'shift' ).model;
  var modelUnshift = makeArrayMethod( 'unshift' ).model;
  var modelSort = makeArrayMethod( 'sort' ).model;
  var modelSplice = makeArrayMethod( 'splice' ).model;
  var modelReverse = makeArrayMethod( 'reverse' ).model;

  // TODO: at some point perhaps this could support relative * keypaths?
  function build$1 ( el, keypath, value ) {
  	var sets = [];

  	// set multiple keypaths in one go
  	if ( isObject( keypath ) ) {
  		for ( var k in keypath ) {
  			if ( keypath.hasOwnProperty( k ) ) {
  				sets.push( [ findModel( el, k ).model, keypath[k] ] );
  			}
  		}

  	}
  	// set a single keypath
  	else {
  		sets.push( [ findModel( el, keypath ).model, value ] );
  	}

  	return sets;
  }

  // get relative keypaths and values
  function get ( keypath ) {
  	if ( !keypath ) return this._element.parentFragment.findContext().get( true );

  	var model = resolveReference( this._element.parentFragment, keypath );

  	return model ? model.get( true ) : undefined;
  }

  function resolve$1 ( path, ractive ) {
  	var ref = findModel( this, path ), model = ref.model, instance = ref.instance;
  	return model ? model.getKeypath( ractive || instance ) : path;
  }

  function findModel ( el, path ) {
  	var frag = el._element.parentFragment;

  	if ( typeof path !== 'string' ) {
  		return { model: frag.findContext(), instance: path };
  	}

  	return { model: resolveReference( frag, path ), instance: frag.ractive };
  }

  // the usual mutation suspects
  function add$1 ( keypath, value ) {
  	if ( value === undefined ) value = 1;
  	if ( !isNumeric( value ) ) throw new Error( 'Bad arguments' );
  	return set( this.ractive, build$1( this, keypath, value ).map( function ( pair ) {
  		var model = pair[0], val = pair[1], value = model.get();
  		if ( !isNumeric( val ) || !isNumeric( value ) ) throw new Error( 'Cannot add non-numeric value' );
  		return [ model, value + val ];
  	}) );
  }

  function animate ( keypath, value, options ) {
  	var model = findModel( this, keypath ).model;
  	return protoAnimate( this.ractive, model, value, options );
  }

  function link ( source, dest ) {
  	var there = findModel( this, source ).model, here = findModel( this, dest ).model;
  	var promise = runloop.start( this.ractive, true );
  	here.link( there, source );
  	runloop.end();
  	return promise;
  }

  function merge ( keypath, array, options ) {
  	return merge$1( this.ractive, findModel( this, keypath ).model, array, options );
  }

  function pop ( keypath ) {
  	return modelPop( findModel( this, keypath ).model, [] );
  }

  function push ( keypath ) {
  	var values = [], len = arguments.length - 1;
  	while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];

  	return modelPush( findModel( this, keypath ).model, values );
  }

  function reverse ( keypath ) {
  	return modelReverse( findModel( this, keypath ).model, [] );
  }

  function set$1 ( keypath, value ) {
  	return set( this.ractive, build$1( this, keypath, value ) );
  }

  function shift ( keypath ) {
  	return modelShift( findModel( this, keypath ).model, [] );
  }

  function splice ( keypath, index, drop ) {
  	var add = [], len = arguments.length - 3;
  	while ( len-- > 0 ) add[ len ] = arguments[ len + 3 ];

  	add.unshift( index, drop );
  	return modelSplice( findModel( this, keypath ).model, add );
  }

  function sort ( keypath ) {
  	return modelSort( findModel( this, keypath ).model, [] );
  }

  function subtract ( keypath, value ) {
  	if ( value === undefined ) value = 1;
  	if ( !isNumeric( value ) ) throw new Error( 'Bad arguments' );
  	return set( this.ractive, build$1( this, keypath, value ).map( function ( pair ) {
  		var model = pair[0], val = pair[1], value = model.get();
  		if ( !isNumeric( val ) || !isNumeric( value ) ) throw new Error( 'Cannot add non-numeric value' );
  		return [ model, value - val ];
  	}) );
  }

  function toggle ( keypath ) {
  	var ref = findModel( this, keypath ), model = ref.model;
  	return set( this.ractive, [ [ model, !model.get() ] ] );
  }

  function unlink ( dest ) {
  	var here = findModel( this, dest ).model;
  	var promise = runloop.start( this.ractive, true );
  	if ( here.owner && here.owner._link ) here.owner.unlink();
  	runloop.end();
  	return promise;
  }

  function unshift ( keypath ) {
  	var add = [], len = arguments.length - 1;
  	while ( len-- > 0 ) add[ len ] = arguments[ len + 1 ];

  	return modelUnshift( findModel( this, keypath ).model, add );
  }

  function update$1 ( keypath ) {
  	return update$2( this.ractive, findModel( this, keypath ).model );
  }

  function updateModel ( keypath, cascade ) {
  	var ref = findModel( this, keypath ), model = ref.model;
  	var promise = runloop.start( this.ractive, true );
  	model.updateFromBindings( cascade );
  	runloop.end();
  	return promise;
  }

  // two-way binding related helpers
  function isBound () {
  	var ref = getBindingModel( this ), model = ref.model;
  	return !!model;
  }

  function getBindingPath ( ractive ) {
  	var ref = getBindingModel( this ), model = ref.model, instance = ref.instance;
  	if ( model ) return model.getKeypath( ractive || instance );
  }

  function getBinding () {
  	var ref = getBindingModel( this ), model = ref.model;
  	if ( model ) return model.get( true );
  }

  function getBindingModel ( ctx ) {
  	var el = ctx._element;
  	return { model: el.binding && el.binding.model, instance: el.parentFragment.ractive };
  }

  function setBinding ( value ) {
  	var ref = getBindingModel( this ), model = ref.model;
  	return set( this.ractive, [ [ model, value ] ] );
  }

  // deprecated getters
  function keypath () {
  	warnOnceIfDebug( ("Object property keypath is deprecated, please use resolve() instead.") );
  	return this.resolve();
  }

  function rootpath () {
  	warnOnceIfDebug( ("Object property rootpath is deprecated, please use resolve( ractive.root ) instead.") );
  	return this.resolve( this.ractive.root );
  }

  function context () {
  	warnOnceIfDebug( ("Object property context is deprecated, please use get() instead.") );
  	return this.get();
  }

  function index () {
  	warnOnceIfDebug( ("Object property index is deprecated, you can use get( \"indexName\" ) instead.") );
  	return gatherRefs( this._element.parentFragment ).index;
  }

  function key () {
  	warnOnceIfDebug( ("Object property key is deprecated, you can use get( \"keyName\" ) instead.") );
  	return gatherRefs( this._element.parentFragment ).key;
  }

  function addHelpers ( obj, element ) {
  	defineProperties( obj, {
  		_element: { value: element },
  		ractive: { value: element.parentFragment.ractive },
  		resolve: { value: resolve$1 },
  		get: { value: get },

  		add: { value: add$1 },
  		animate: { value: animate },
  		link: { value: link },
  		merge: { value: merge },
  		pop: { value: pop },
  		push: { value: push },
  		reverse: { value: reverse },
  		set: { value: set$1 },
  		shift: { value: shift },
  		sort: { value: sort },
  		splice: { value: splice },
  		subtract: { value: subtract },
  		toggle: { value: toggle },
  		unlink: { value: unlink },
  		unshift: { value: unshift },
  		update: { value: update$1 },
  		updateModel: { value: updateModel },

  		isBound: { value: isBound },
  		getBindingPath: { value: getBindingPath },
  		getBinding: { value: getBinding },
  		setBinding: { value: setBinding },

  		keypath: { get: keypath },
  		rootpath: { get: rootpath },
  		context: { get: context },
  		index: { get: index },
  		key: { get: key }
  	});

  	return obj;
  }

  var query = doc && doc.querySelector;

  function staticInfo( node ) {
  	if ( typeof node === 'string' && query ) {
  		node = query.call( document, node );
  	}

  	if ( !node || !node._ractive ) return {};

  	var storage = node._ractive;

  	return addHelpers( {}, storage.proxy );
  }

  function getNodeInfo( node ) {
  	if ( typeof node === 'string' ) {
  		node = this.find( node );
  	}

  	return staticInfo( node );
  }

  var insertHook = new Hook( 'insert' );

  function Ractive$insert ( target, anchor ) {
  	if ( !this.fragment.rendered ) {
  		// TODO create, and link to, documentation explaining this
  		throw new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );
  	}

  	target = getElement( target );
  	anchor = getElement( anchor ) || null;

  	if ( !target ) {
  		throw new Error( 'You must specify a valid target to insert into' );
  	}

  	target.insertBefore( this.detach(), anchor );
  	this.el = target;

  	( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );
  	this.isDetached = false;

  	fireInsertHook( this );
  }

  function fireInsertHook( ractive ) {
  	insertHook.fire( ractive );

  	ractive.findAllComponents('*').forEach( function ( child ) {
  		fireInsertHook( child.instance );
  	});
  }

  function link$1( there, here ) {
  	if ( here === there || (there + '.').indexOf( here + '.' ) === 0 || (here + '.').indexOf( there + '.' ) === 0 ) {
  		throw new Error( 'A keypath cannot be linked to itself.' );
  	}

  	var promise = runloop.start();
  	var model;

  	// may need to allow a mapping to resolve implicitly
  	var sourcePath = splitKeypathI( there );
  	if ( !this.viewmodel.has( sourcePath[0] ) && this.component ) {
  		model = resolveReference( this.component.parentFragment, sourcePath[0] );
  		model = model.joinAll( sourcePath.slice( 1 ) );
  	}

  	this.viewmodel.joinAll( splitKeypathI( here ) ).link( model || this.viewmodel.joinAll( sourcePath ), there );

  	runloop.end();

  	return promise;
  }

  var ReferenceResolver = function ReferenceResolver ( fragment, reference, callback ) {
  	var this$1 = this;

  		this.fragment = fragment;
  	this.reference = normalise( reference );
  	this.callback = callback;

  	this.keys = splitKeypathI( reference );
  	this.resolved = false;

  	this.contexts = [];

  	// TODO the consumer should take care of addUnresolved
  	// we attach to all the contexts between here and the root
  	// - whenever their values change, they can quickly
  	// check to see if we can resolve
  	while ( fragment ) {
  		if ( fragment.context ) {
  			fragment.context.addUnresolved( this$1.keys[0], this$1 );
  			this$1.contexts.push( fragment.context );
  		}

  		fragment = fragment.componentParent || fragment.parent;
  	}
  };

  ReferenceResolver.prototype.attemptResolution = function attemptResolution () {
  	if ( this.resolved ) return;

  	var model = resolveAmbiguousReference( this.fragment, this.reference );

  	if ( model ) {
  		this.resolved = true;
  		this.callback( model );
  	}
  };

  ReferenceResolver.prototype.forceResolution = function forceResolution () {
  	if ( this.resolved ) return;

  	var model = this.fragment.findContext().joinAll( this.keys );
  	this.callback( model );
  	this.resolved = true;
  };

  ReferenceResolver.prototype.rebinding = function rebinding ( next, previous ) {
  	var this$1 = this;

  		if ( previous ) previous.removeUnresolved( this.keys[0], this );
  	if ( next ) runloop.scheduleTask( function () { return next.addUnresolved( this$1.keys[0], this$1 ); } );
  };

  ReferenceResolver.prototype.unbind = function unbind () {
  	var this$1 = this;

  		if ( this.fragment ) removeFromArray( this.fragment.unresolved, this );

  	if ( this.resolved ) return;

  	this.contexts.forEach( function ( c ) { return c.removeUnresolved( this$1.keys[0], this$1 ); } );
  };

  function observe ( keypath, callback, options ) {
  	var this$1 = this;

  	var observers = [];
  	var map;

  	if ( isObject( keypath ) ) {
  		map = keypath;
  		options = callback || {};

  		Object.keys( map ).forEach( function ( keypath ) {
  			var callback = map[ keypath ];

  			var keypaths = keypath.split( ' ' );
  			if ( keypaths.length > 1 ) keypaths = keypaths.filter( function ( k ) { return k; } );

  			keypaths.forEach( function ( keypath ) {
  				observers.push( createObserver( this$1, keypath, callback, options ) );
  			});
  		});
  	}

  	else {
  		var keypaths;

  		if ( typeof keypath === 'function' ) {
  			options = callback;
  			callback = keypath;
  			keypaths = [ '' ];
  		} else {
  			keypaths = keypath.split( ' ' );
  		}

  		if ( keypaths.length > 1 ) keypaths = keypaths.filter( function ( k ) { return k; } );

  		keypaths.forEach( function ( keypath ) {
  			observers.push( createObserver( this$1, keypath, callback, options || {} ) );
  		});
  	}

  	// add observers to the Ractive instance, so they can be
  	// cancelled on ractive.teardown()
  	this._observers.push.apply( this._observers, observers );

  	return {
  		cancel: function () {
  			observers.forEach( function ( observer ) {
  				removeFromArray ( this$1._observers, observer );
  				observer.cancel();
  			} );
  		}
  	};
  }

  function createObserver ( ractive, keypath, callback, options ) {
  	var viewmodel = ractive.viewmodel;

  	var keys = splitKeypathI( keypath );
  	var wildcardIndex = keys.indexOf( '*' );
  	options.keypath = keypath;

  	// normal keypath - no wildcards
  	if ( !~wildcardIndex ) {
  		var key = keys[0];
  		var model;

  		// if not the root model itself, check if viewmodel has key.
  		if ( key !== '' && !viewmodel.has( key ) ) {
  			// if this is an inline component, we may need to create an implicit mapping
  			if ( ractive.component && !ractive.isolated ) {
  				model = resolveReference( ractive.component.parentFragment, key );
  				if ( model ) {
  					viewmodel.map( key, model );
  					model = viewmodel.joinAll( keys );
  				}
  			}
  		} else {
  			model = viewmodel.joinAll( keys );
  		}

  		return new Observer( ractive, model, callback, options );
  	}

  	// pattern observers - more complex case
  	var baseModel = wildcardIndex === 0 ?
  		viewmodel :
  		viewmodel.joinAll( keys.slice( 0, wildcardIndex ) );

  	return new PatternObserver( ractive, baseModel, keys.splice( wildcardIndex ), callback, options );
  }

  var Observer = function Observer ( ractive, model, callback, options ) {
  	var this$1 = this;

  		this.context = options.context || ractive;
  	this.callback = callback;
  	this.ractive = ractive;

  	if ( model ) this.resolved( model );
  	else {
  		this.keypath = options.keypath;
  		this.resolver = new ReferenceResolver( ractive.fragment, options.keypath, function ( model ) {
  			this$1.resolved( model );
  		});
  	}

  	if ( options.init !== false ) {
  		this.dirty = true;
  		this.dispatch();
  	} else {
  		this.oldValue = this.newValue;
  	}

  	this.defer = options.defer;
  	this.once = options.once;
  	this.strict = options.strict;

  	this.dirty = false;
  };

  Observer.prototype.cancel = function cancel () {
  	this.cancelled = true;
  	if ( this.model ) {
  		this.model.unregister( this );
  	} else {
  		this.resolver.unbind();
  	}
  };

  Observer.prototype.dispatch = function dispatch () {
  	if ( !this.cancelled ) {
  		this.callback.call( this.context, this.newValue, this.oldValue, this.keypath );
  		this.oldValue = this.model ? this.model.get() : this.newValue;
  		this.dirty = false;
  	}
  };

  Observer.prototype.handleChange = function handleChange () {
  	var this$1 = this;

  		if ( !this.dirty ) {
  		var newValue = this.model.get();
  		if ( isEqual( newValue, this.oldValue ) ) return;

  		this.newValue = newValue;

  		if ( this.strict && this.newValue === this.oldValue ) return;

  		runloop.addObserver( this, this.defer );
  		this.dirty = true;

  		if ( this.once ) runloop.scheduleTask( function () { return this$1.cancel(); } );
  	}
  };

  Observer.prototype.rebinding = function rebinding ( next, previous ) {
  	var this$1 = this;

  		next = rebindMatch( this.keypath, next, previous );
  	// TODO: set up a resolver if next is undefined?
  	if ( next === this.model ) return false;

  	if ( this.model ) this.model.unregister( this );
  	if ( next ) next.addShuffleTask( function () { return this$1.resolved( next ); } );
  };

  Observer.prototype.resolved = function resolved ( model ) {
  	this.model = model;
  	this.keypath = model.getKeypath( this.ractive );

  	this.oldValue = undefined;
  	this.newValue = model.get();

  	model.register( this );
  };

  var PatternObserver = function PatternObserver ( ractive, baseModel, keys, callback, options ) {
  	var this$1 = this;

  		this.context = options.context || ractive;
  	this.ractive = ractive;
  	this.baseModel = baseModel;
  	this.keys = keys;
  	this.callback = callback;

  	var pattern = keys.join( '\\.' ).replace( /\*/g, '(.+)' );
  	var baseKeypath = baseModel.getKeypath( ractive );
  	this.pattern = new RegExp( ("^" + (baseKeypath ? baseKeypath + '\\.' : '') + "" + pattern + "$") );

  	this.oldValues = {};
  	this.newValues = {};

  	this.defer = options.defer;
  	this.once = options.once;
  	this.strict = options.strict;

  	this.dirty = false;
  	this.changed = [];
  	this.partial = false;

  	var models = baseModel.findMatches( this.keys );

  	models.forEach( function ( model ) {
  		this$1.newValues[ model.getKeypath( this$1.ractive ) ] = model.get();
  	});

  	if ( options.init !== false ) {
  		this.dispatch();
  	} else {
  		this.oldValues = this.newValues;
  	}

  	baseModel.registerPatternObserver( this );
  };

  PatternObserver.prototype.cancel = function cancel () {
  	this.baseModel.unregisterPatternObserver( this );
  };

  PatternObserver.prototype.dispatch = function dispatch () {
  	var this$1 = this;

  		Object.keys( this.newValues ).forEach( function ( keypath ) {
  		if ( this$1.newKeys && !this$1.newKeys[ keypath ] ) return;

  		var newValue = this$1.newValues[ keypath ];
  		var oldValue = this$1.oldValues[ keypath ];

  		if ( this$1.strict && newValue === oldValue ) return;
  		if ( isEqual( newValue, oldValue ) ) return;

  		var args = [ newValue, oldValue, keypath ];
  		if ( keypath ) {
  			var wildcards = this$1.pattern.exec( keypath );
  			if ( wildcards ) {
  				args = args.concat( wildcards.slice( 1 ) );
  			}
  		}

  		this$1.callback.apply( this$1.context, args );
  	});

  	if ( this.partial ) {
  		for ( var k in this.newValues ) {
  			this.oldValues[k] = this.newValues[k];
  		}
  	} else {
  		this.oldValues = this.newValues;
  	}

  	this.newKeys = null;
  	this.dirty = false;
  };

  PatternObserver.prototype.notify = function notify ( key ) {
  	this.changed.push( key );
  };

  PatternObserver.prototype.shuffle = function shuffle ( newIndices ) {
  	var this$1 = this;

  		if ( !isArray( this.baseModel.value ) ) return;

  	var base = this.baseModel.getKeypath( this.ractive );
  	var max = this.baseModel.value.length;
  	var suffix = this.keys.length > 1 ? '.' + this.keys.slice( 1 ).join( '.' ) : '';

  	this.newKeys = {};
  	for ( var i = 0; i < newIndices.length; i++ ) {
  		if ( newIndices[ i ] === -1 || newIndices[ i ] === i ) continue;
  		this$1.newKeys[ ("" + base + "." + i + "" + suffix) ] = true;
  	}

  	for ( var i$1 = newIndices.touchedFrom; i$1 < max; i$1++ ) {
  		this$1.newKeys[ ("" + base + "." + i$1 + "" + suffix) ] = true;
  	}
  };

  PatternObserver.prototype.handleChange = function handleChange () {
  	var this$1 = this;

  		if ( !this.dirty || this.changed.length ) {
  		if ( !this.dirty ) this.newValues = {};

  		// handle case where previously extant keypath no longer exists -
  		// observer should still fire, with undefined as new value
  		// TODO huh. according to the test suite that's not the case...
  		// NOTE: I don't think this will work with partial updates
  		// Object.keys( this.oldValues ).forEach( keypath => {
  		// this.newValues[ keypath ] = undefined;
  		// });

  		if ( !this.changed.length ) {
  			this.baseModel.findMatches( this.keys ).forEach( function ( model ) {
  				var keypath = model.getKeypath( this$1.ractive );
  				this$1.newValues[ keypath ] = model.get();
  			});
  			this.partial = false;
  		} else {
  			var count = 0;
  			var ok = this.baseModel.isRoot ?
  				this.changed.map( function ( keys ) { return keys.map( escapeKey ).join( '.' ); } ) :
  				this.changed.map( function ( keys ) { return this$1.baseModel.getKeypath( this$1.ractive ) + '.' + keys.map( escapeKey ).join( '.' ); } );

  			this.baseModel.findMatches( this.keys ).forEach( function ( model ) {
  				var keypath = model.getKeypath( this$1.ractive );
  				// is this model on a changed keypath?
  				if ( ok.filter( function ( k ) { return keypath.indexOf( k ) === 0 || k.indexOf( keypath ) === 0; } ).length ) {
  					count++;
  					this$1.newValues[ keypath ] = model.get();
  				}
  			});

  			// no valid change triggered, so bail to avoid breakage
  			if ( !count ) return;

  			this.partial = true;
  		}

  		runloop.addObserver( this, this.defer );
  		this.dirty = true;
  		this.changed.length = 0;

  		if ( this.once ) this.cancel();
  	}
  };

  function observeList ( keypath, callback, options ) {
  	if ( typeof keypath !== 'string' ) {
  		throw new Error( 'ractive.observeList() must be passed a string as its first argument' );
  	}

  	var model = this.viewmodel.joinAll( splitKeypathI( keypath ) );
  	var observer = new ListObserver( this, model, callback, options || {} );

  	// add observer to the Ractive instance, so it can be
  	// cancelled on ractive.teardown()
  	this._observers.push( observer );

  	return {
  		cancel: function () {
  			observer.cancel();
  		}
  	};
  }

  function negativeOne () {
  	return -1;
  }

  var ListObserver = function ListObserver ( context, model, callback, options ) {
  	this.context = context;
  	this.model = model;
  	this.keypath = model.getKeypath();
  	this.callback = callback;

  	this.pending = null;

  	model.register( this );

  	if ( options.init !== false ) {
  		this.sliced = [];
  		this.shuffle([]);
  		this.handleChange();
  	} else {
  		this.sliced = this.slice();
  	}
  };

  ListObserver.prototype.handleChange = function handleChange () {
  	if ( this.pending ) {
  		// post-shuffle
  		this.callback( this.pending );
  		this.pending = null;
  	}

  	else {
  		// entire array changed
  		this.shuffle( this.sliced.map( negativeOne ) );
  		this.handleChange();
  	}
  };

  ListObserver.prototype.shuffle = function shuffle ( newIndices ) {
  	var this$1 = this;

  		var newValue = this.slice();

  	var inserted = [];
  	var deleted = [];
  	var start;

  	var hadIndex = {};

  	newIndices.forEach( function ( newIndex, oldIndex ) {
  		hadIndex[ newIndex ] = true;

  		if ( newIndex !== oldIndex && start === undefined ) {
  			start = oldIndex;
  		}

  		if ( newIndex === -1 ) {
  			deleted.push( this$1.sliced[ oldIndex ] );
  		}
  	});

  	if ( start === undefined ) start = newIndices.length;

  	var len = newValue.length;
  	for ( var i = 0; i < len; i += 1 ) {
  		if ( !hadIndex[i] ) inserted.push( newValue[i] );
  	}

  	this.pending = { inserted: inserted, deleted: deleted, start: start };
  	this.sliced = newValue;
  };

  ListObserver.prototype.slice = function slice () {
  	var value = this.model.get();
  	return isArray( value ) ? value.slice() : [];
  };

  var onceOptions = { init: false, once: true };

  function observeOnce ( keypath, callback, options ) {
  	if ( isObject( keypath ) || typeof keypath === 'function' ) {
  		options = extendObj( callback || {}, onceOptions );
  		return this.observe( keypath, options );
  	}

  	options = extendObj( options || {}, onceOptions );
  	return this.observe( keypath, callback, options );
  }

  function trim ( str ) { return str.trim(); };

  function notEmptyString ( str ) { return str !== ''; };

  function Ractive$off ( eventName, callback ) {
  	// if no arguments specified, remove all callbacks
  	var this$1 = this;

  	if ( !eventName ) {
  		// TODO use this code instead, once the following issue has been resolved
  		// in PhantomJS (tests are unpassable otherwise!)
  		// https://github.com/ariya/phantomjs/issues/11856
  		// defineProperty( this, '_subs', { value: create( null ), configurable: true });
  		for ( eventName in this._subs ) {
  			delete this._subs[ eventName ];
  		}
  	}

  	else {
  		// Handle multiple space-separated event names
  		var eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );

  		eventNames.forEach( function ( eventName ) {
  			var subscribers = this$1._subs[ eventName ];

  			// If we have subscribers for this event...
  			if ( subscribers ) {
  				// ...if a callback was specified, only remove that
  				if ( callback ) {
  					// flag this callback as off so that any in-flight firings don't call
  					// a cancelled handler - this is _slightly_ hacky
  					callback.off = true;
  					var index = subscribers.indexOf( callback );
  					if ( index !== -1 ) {
  						subscribers.splice( index, 1 );
  					}
  				}

  				// ...otherwise remove all callbacks
  				else {
  					this$1._subs[ eventName ] = [];
  				}
  			}
  		});
  	}

  	return this;
  }

  function Ractive$on ( eventName, callback ) {
  	// allow multiple listeners to be bound in one go
  	var this$1 = this;

  	if ( typeof eventName === 'object' ) {
  		var listeners = [];
  		var n;

  		for ( n in eventName ) {
  			if ( eventName.hasOwnProperty( n ) ) {
  				listeners.push( this.on( n, eventName[ n ] ) );
  			}
  		}

  		return {
  			cancel: function () {
  				var listener;
  				while ( listener = listeners.pop() ) listener.cancel();
  			}
  		};
  	}

  	// Handle multiple space-separated event names
  	var eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );

  	eventNames.forEach( function ( eventName ) {
  		( this$1._subs[ eventName ] || ( this$1._subs[ eventName ] = [] ) ).push( callback );
  	});

  	return {
  		cancel: function () { return this$1.off( eventName, callback ); }
  	};
  }

  function Ractive$once ( eventName, handler ) {
  	var listener = this.on( eventName, function () {
  		handler.apply( this, arguments );
  		listener.cancel();
  	});

  	// so we can still do listener.cancel() manually
  	return listener;
  }

  var pop$1 = makeArrayMethod( 'pop' ).path;

  var push$1 = makeArrayMethod( 'push' ).path;

  var PREFIX = '/* Ractive.js component styles */';

  // Holds current definitions of styles.
  var styleDefinitions = [];

  // Flag to tell if we need to update the CSS
  var isDirty = false;

  // These only make sense on the browser. See additional setup below.
  var styleElement = null;
  var useCssText = null;

  function addCSS( styleDefinition ) {
  	styleDefinitions.push( styleDefinition );
  	isDirty = true;
  }

  function applyCSS() {

  	// Apply only seems to make sense when we're in the DOM. Server-side renders
  	// can call toCSS to get the updated CSS.
  	if ( !doc || !isDirty ) return;

  	if ( useCssText ) {
  		styleElement.styleSheet.cssText = getCSS( null );
  	} else {
  		styleElement.innerHTML = getCSS( null );
  	}

  	isDirty = false;
  }

  function getCSS( cssIds ) {

  	var filteredStyleDefinitions = cssIds ? styleDefinitions.filter( function ( style ) { return ~cssIds.indexOf( style.id ); } ) : styleDefinitions;

  	return filteredStyleDefinitions.reduce( function ( styles, style ) { return ("" + styles + "\n\n/* {" + (style.id) + "} */\n" + (style.styles)); }, PREFIX );

  }

  // If we're on the browser, additional setup needed.
  if ( doc && ( !styleElement || !styleElement.parentNode ) ) {

  	styleElement = doc.createElement( 'style' );
  	styleElement.type = 'text/css';

  	doc.getElementsByTagName( 'head' )[ 0 ].appendChild( styleElement );

  	useCssText = !!styleElement.styleSheet;
  }

  var renderHook = new Hook( 'render' );
  var completeHook = new Hook( 'complete' );

  function render$1 ( ractive, target, anchor, occupants ) {
  	// if `noIntro` is `true`, temporarily disable transitions
  	var transitionsEnabled = ractive.transitionsEnabled;
  	if ( ractive.noIntro ) ractive.transitionsEnabled = false;

  	var promise = runloop.start( ractive, true );
  	runloop.scheduleTask( function () { return renderHook.fire( ractive ); }, true );

  	if ( ractive.fragment.rendered ) {
  		throw new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );
  	}

  	anchor = getElement( anchor ) || ractive.anchor;

  	ractive.el = target;
  	ractive.anchor = anchor;

  	// ensure encapsulated CSS is up-to-date
  	if ( ractive.cssId ) applyCSS();

  	if ( target ) {
  		( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( ractive );

  		if ( anchor ) {
  			var docFrag = doc.createDocumentFragment();
  			ractive.fragment.render( docFrag );
  			target.insertBefore( docFrag, anchor );
  		} else {
  			ractive.fragment.render( target, occupants );
  		}
  	}

  	runloop.end();
  	ractive.transitionsEnabled = transitionsEnabled;

  	return promise.then( function () { return completeHook.fire( ractive ); } );
  }

  function Ractive$render ( target, anchor ) {
  	if ( this.torndown ) {
  		warnIfDebug( 'ractive.render() was called on a Ractive instance that was already torn down' );
  		return Promise.resolve();
  	}

  	target = getElement( target ) || this.el;

  	if ( !this.append && target ) {
  		// Teardown any existing instances *before* trying to set up the new one -
  		// avoids certain weird bugs
  		var others = target.__ractive_instances__;
  		if ( others ) others.forEach( teardown );

  		// make sure we are the only occupants
  		if ( !this.enhance ) {
  			target.innerHTML = ''; // TODO is this quicker than removeChild? Initial research inconclusive
  		}
  	}

  	var occupants = this.enhance ? toArray( target.childNodes ) : null;
  	var promise = render$1( this, target, anchor, occupants );

  	if ( occupants ) {
  		while ( occupants.length ) target.removeChild( occupants.pop() );
  	}

  	return promise;
  }

  var adaptConfigurator = {
  	extend: function ( Parent, proto, options ) {
  		proto.adapt = combine( proto.adapt, ensureArray( options.adapt ) );
  	},

  	init: function () {}
  };

  function combine ( a, b ) {
  	var c = a.slice();
  	var i = b.length;

  	while ( i-- ) {
  		if ( !~c.indexOf( b[i] ) ) {
  			c.push( b[i] );
  		}
  	}

  	return c;
  }

  var selectorsPattern = /(?:^|\})?\s*([^\{\}]+)\s*\{/g;
  var commentsPattern = /\/\*[\s\S]*?\*\//g;
  var selectorUnitPattern = /((?:(?:\[[^\]+]\])|(?:[^\s\+\>~:]))+)((?:::?[^\s\+\>\~\(:]+(?:\([^\)]+\))?)*\s*[\s\+\>\~]?)\s*/g;
  var excludePattern = /^(?:@|\d+%)/;
  var dataRvcGuidPattern = /\[data-ractive-css~="\{[a-z0-9-]+\}"]/g;

  function trim$1 ( str ) {
  	return str.trim();
  }

  function extractString ( unit ) {
  	return unit.str;
  }

  function transformSelector ( selector, parent ) {
  	var selectorUnits = [];
  	var match;

  	while ( match = selectorUnitPattern.exec( selector ) ) {
  		selectorUnits.push({
  			str: match[0],
  			base: match[1],
  			modifiers: match[2]
  		});
  	}

  	// For each simple selector within the selector, we need to create a version
  	// that a) combines with the id, and b) is inside the id
  	var base = selectorUnits.map( extractString );

  	var transformed = [];
  	var i = selectorUnits.length;

  	while ( i-- ) {
  		var appended = base.slice();

  		// Pseudo-selectors should go after the attribute selector
  		var unit = selectorUnits[i];
  		appended[i] = unit.base + parent + unit.modifiers || '';

  		var prepended = base.slice();
  		prepended[i] = parent + ' ' + prepended[i];

  		transformed.push( appended.join( ' ' ), prepended.join( ' ' ) );
  	}

  	return transformed.join( ', ' );
  }

  function transformCss ( css, id ) {
  	var dataAttr = "[data-ractive-css~=\"{" + id + "}\"]";

  	var transformed;

  	if ( dataRvcGuidPattern.test( css ) ) {
  		transformed = css.replace( dataRvcGuidPattern, dataAttr );
  	} else {
  		transformed = css
  		.replace( commentsPattern, '' )
  		.replace( selectorsPattern, function ( match, $1 ) {
  			// don't transform at-rules and keyframe declarations
  			if ( excludePattern.test( $1 ) ) return match;

  			var selectors = $1.split( ',' ).map( trim$1 );
  			var transformed = selectors
  				.map( function ( selector ) { return transformSelector( selector, dataAttr ); } )
  				.join( ', ' ) + ' ';

  			return match.replace( $1, transformed );
  		});
  	}

  	return transformed;
  }

  function s4() {
  	return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
  }

  function uuid() {
  	return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
  }

  var cssConfigurator = {
  	name: 'css',

  	// Called when creating a new component definition
  	extend: function ( Parent, proto, options ) {
  		if ( !options.css ) return;

  		var id = uuid();
  		var styles = options.noCssTransform ? options.css : transformCss( options.css, id );

  		proto.cssId = id;

  		addCSS( { id: id, styles: styles } );

  	},

  	// Called when creating a new component instance
  	init: function ( Parent, target, options ) {
  		if ( !options.css ) return;

  		warnIfDebug( ("\nThe css option is currently not supported on a per-instance basis and will be discarded. Instead, we recommend instantiating from a component definition with a css option.\n\nconst Component = Ractive.extend({\n\t...\n\tcss: '/* your css */',\n\t...\n});\n\nconst componentInstance = new Component({ ... })\n\t\t") );
  	}

  };

  function validate ( data ) {
  	// Warn if userOptions.data is a non-POJO
  	if ( data && data.constructor !== Object ) {
  		if ( typeof data === 'function' ) {
  			// TODO do we need to support this in the new Ractive() case?
  		} else if ( typeof data !== 'object' ) {
  			fatal( ("data option must be an object or a function, `" + data + "` is not valid") );
  		} else {
  			warnIfDebug( 'If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged' );
  		}
  	}
  }

  var dataConfigurator = {
  	name: 'data',

  	extend: function ( Parent, proto, options ) {
  		var key;
  		var value;

  		// check for non-primitives, which could cause mutation-related bugs
  		if ( options.data && isObject( options.data ) ) {
  			for ( key in options.data ) {
  				value = options.data[ key ];

  				if ( value && typeof value === 'object' ) {
  					if ( isObject( value ) || isArray( value ) ) {
  						warnIfDebug( ("Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\n\n  // this...\n  data: function () {\n    return {\n      myObject: {}\n    };\n  })\n\n  // instead of this:\n  data: {\n    myObject: {}\n  }") );
  					}
  				}
  			}
  		}

  		proto.data = combine$1( proto.data, options.data );
  	},

  	init: function ( Parent, ractive, options ) {
  		var result = combine$1( Parent.prototype.data, options.data );

  		if ( typeof result === 'function' ) result = result.call( ractive );

  		// bind functions to the ractive instance at the top level,
  		// unless it's a non-POJO (in which case alarm bells should ring)
  		if ( result && result.constructor === Object ) {
  			for ( var prop in result ) {
  				if ( typeof result[ prop ] === 'function' ) result[ prop ] = bind( result[ prop ], ractive );
  			}
  		}

  		return result || {};
  	},

  	reset: function ( ractive ) {
  		var result = this.init( ractive.constructor, ractive, ractive.viewmodel );
  		ractive.viewmodel.root.set( result );
  		return true;
  	}
  };

  function combine$1 ( parentValue, childValue ) {
  	validate( childValue );

  	var parentIsFn = typeof parentValue === 'function';
  	var childIsFn = typeof childValue === 'function';

  	// Very important, otherwise child instance can become
  	// the default data object on Ractive or a component.
  	// then ractive.set() ends up setting on the prototype!
  	if ( !childValue && !parentIsFn ) {
  		childValue = {};
  	}

  	// Fast path, where we just need to copy properties from
  	// parent to child
  	if ( !parentIsFn && !childIsFn ) {
  		return fromProperties( childValue, parentValue );
  	}

  	return function () {
  		var child = childIsFn ? callDataFunction( childValue, this ) : childValue;
  		var parent = parentIsFn ? callDataFunction( parentValue, this ) : parentValue;

  		return fromProperties( child, parent );
  	};
  }

  function callDataFunction ( fn, context ) {
  	var data = fn.call( context );

  	if ( !data ) return;

  	if ( typeof data !== 'object' ) {
  		fatal( 'Data function must return an object' );
  	}

  	if ( data.constructor !== Object ) {
  		warnOnceIfDebug( 'Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged' );
  	}

  	return data;
  }

  function fromProperties ( primary, secondary ) {
  	if ( primary && secondary ) {
  		for ( var key in secondary ) {
  			if ( !( key in primary ) ) {
  				primary[ key ] = secondary[ key ];
  			}
  		}

  		return primary;
  	}

  	return primary || secondary;
  }

  var TEMPLATE_VERSION = 4;

  var pattern = /\$\{([^\}]+)\}/g;

  function fromExpression ( body, length ) {
  	if ( length === void 0 ) length = 0;

  	var args = new Array( length );

  	while ( length-- ) {
  		args[length] = "_" + length;
  	}

  	// Functions created directly with new Function() look like this:
  	//     function anonymous (_0 /**/) { return _0*2 }
  	//
  	// With this workaround, we get a little more compact:
  	//     function (_0){return _0*2}
  	return new Function( [], ("return function (" + (args.join(',')) + "){return(" + body + ");};") )();
  }

  function fromComputationString ( str, bindTo ) {
  	var hasThis;

  	var functionBody = 'return (' + str.replace( pattern, function ( match, keypath ) {
  		hasThis = true;
  		return ("__ractive.get(\"" + keypath + "\")");
  	}) + ');';

  	if ( hasThis ) functionBody = "var __ractive = this; " + functionBody;
  	var fn = new Function( functionBody );
  	return hasThis ? fn.bind( bindTo ) : fn;
  }

  var functions = create( null );

  function getFunction ( str, i ) {
  	if ( functions[ str ] ) return functions[ str ];
  	return functions[ str ] = createFunction( str, i );
  }

  function addFunctions( template ) {
  	if ( !template ) return;

  	var exp = template.e;

  	if ( !exp ) return;

  	Object.keys( exp ).forEach( function ( str ) {
  		if ( functions[ str ] ) return;
  		functions[ str ] = exp[ str ];
  	});
  }

  var Parser;
  var ParseError;
  var leadingWhitespace = /^\s+/;
  ParseError = function ( message ) {
  	this.name = 'ParseError';
  	this.message = message;
  	try {
  		throw new Error(message);
  	} catch (e) {
  		this.stack = e.stack;
  	}
  };

  ParseError.prototype = Error.prototype;

  Parser = function ( str, options ) {
  	var this$1 = this;

  	var items, item, lineStart = 0;

  	this.str = str;
  	this.options = options || {};
  	this.pos = 0;

  	this.lines = this.str.split( '\n' );
  	this.lineEnds = this.lines.map( function ( line ) {
  		var lineEnd = lineStart + line.length + 1; // +1 for the newline

  		lineStart = lineEnd;
  		return lineEnd;
  	}, 0 );

  	// Custom init logic
  	if ( this.init ) this.init( str, options );

  	items = [];

  	while ( ( this$1.pos < this$1.str.length ) && ( item = this$1.read() ) ) {
  		items.push( item );
  	}

  	this.leftover = this.remaining();
  	this.result = this.postProcess ? this.postProcess( items, options ) : items;
  };

  Parser.prototype = {
  	read: function ( converters ) {
  		var this$1 = this;

  		var pos, i, len, item;

  		if ( !converters ) converters = this.converters;

  		pos = this.pos;

  		len = converters.length;
  		for ( i = 0; i < len; i += 1 ) {
  			this$1.pos = pos; // reset for each attempt

  			if ( item = converters[i]( this$1 ) ) {
  				return item;
  			}
  		}

  		return null;
  	},

  	getContextMessage: function ( pos, message ) {
  		var ref = this.getLinePos( pos ), lineNum = ref[0], columnNum = ref[1];
  		if ( this.options.contextLines === -1 ) {
  			return [ lineNum, columnNum, ("" + message + " at line " + lineNum + " character " + columnNum) ];
  		}

  		var line = this.lines[ lineNum - 1 ];

  		var contextUp = '';
  		var contextDown = '';
  		if ( this.options.contextLines ) {
  			var start = lineNum - 1 - this.options.contextLines < 0 ? 0 : lineNum - 1 - this.options.contextLines;
  			contextUp = this.lines.slice( start, lineNum - 1 - start ).join( '\n' ).replace( /\t/g, '  ' );
  			contextDown = this.lines.slice( lineNum, lineNum + this.options.contextLines ).join( '\n' ).replace( /\t/g, '  ' );
  			if ( contextUp ) {
  				contextUp += '\n';
  			}
  			if ( contextDown ) {
  				contextDown = '\n' + contextDown;
  			}
  		}

  		var numTabs = 0;
  		var annotation = contextUp + line.replace( /\t/g, function ( match, char ) {
  			if ( char < columnNum ) {
  				numTabs += 1;
  			}

  			return '  ';
  		}) + '\n' + new Array( columnNum + numTabs ).join( ' ' ) + '^----' + contextDown;

  		return [ lineNum, columnNum, ("" + message + " at line " + lineNum + " character " + columnNum + ":\n" + annotation) ];
  	},

  	getLinePos: function ( char ) {
  		var this$1 = this;

  		var lineNum = 0, lineStart = 0, columnNum;

  		while ( char >= this$1.lineEnds[ lineNum ] ) {
  			lineStart = this$1.lineEnds[ lineNum ];
  			lineNum += 1;
  		}

  		columnNum = char - lineStart;
  		return [ lineNum + 1, columnNum + 1, char ]; // line/col should be one-based, not zero-based!
  	},

  	error: function ( message ) {
  		var ref = this.getContextMessage( this.pos, message ), lineNum = ref[0], columnNum = ref[1], msg = ref[2];

  		var error = new ParseError( msg );

  		error.line = lineNum;
  		error.character = columnNum;
  		error.shortMessage = message;

  		throw error;
  	},

  	matchString: function ( string ) {
  		if ( this.str.substr( this.pos, string.length ) === string ) {
  			this.pos += string.length;
  			return string;
  		}
  	},

  	matchPattern: function ( pattern ) {
  		var match;

  		if ( match = pattern.exec( this.remaining() ) ) {
  			this.pos += match[0].length;
  			return match[1] || match[0];
  		}
  	},

  	allowWhitespace: function () {
  		this.matchPattern( leadingWhitespace );
  	},

  	remaining: function () {
  		return this.str.substring( this.pos );
  	},

  	nextChar: function () {
  		return this.str.charAt( this.pos );
  	}
  };

  Parser.extend = function ( proto ) {
  	var Parent = this, Child, key;

  	Child = function ( str, options ) {
  		Parser.call( this, str, options );
  	};

  	Child.prototype = create( Parent.prototype );

  	for ( key in proto ) {
  		if ( hasOwn.call( proto, key ) ) {
  			Child.prototype[ key ] = proto[ key ];
  		}
  	}

  	Child.extend = Parser.extend;
  	return Child;
  };

  var Parser$1 = Parser;

  var TEXT              = 1;
  var INTERPOLATOR      = 2;
  var TRIPLE            = 3;
  var SECTION           = 4;
  var INVERTED          = 5;
  var CLOSING           = 6;
  var ELEMENT           = 7;
  var PARTIAL           = 8;
  var COMMENT           = 9;
  var DELIMCHANGE       = 10;
  var ATTRIBUTE         = 13;
  var CLOSING_TAG       = 14;
  var COMPONENT         = 15;
  var YIELDER           = 16;
  var INLINE_PARTIAL    = 17;
  var DOCTYPE           = 18;
  var ALIAS             = 19;

  var NUMBER_LITERAL    = 20;
  var STRING_LITERAL    = 21;
  var ARRAY_LITERAL     = 22;
  var OBJECT_LITERAL    = 23;
  var BOOLEAN_LITERAL   = 24;
  var REGEXP_LITERAL    = 25;

  var GLOBAL            = 26;
  var KEY_VALUE_PAIR    = 27;


  var REFERENCE         = 30;
  var REFINEMENT        = 31;
  var MEMBER            = 32;
  var PREFIX_OPERATOR   = 33;
  var BRACKETED         = 34;
  var CONDITIONAL       = 35;
  var INFIX_OPERATOR    = 36;

  var INVOCATION        = 40;

  var SECTION_IF        = 50;
  var SECTION_UNLESS    = 51;
  var SECTION_EACH      = 52;
  var SECTION_WITH      = 53;
  var SECTION_IF_WITH   = 54;

  var ELSE              = 60;
  var ELSEIF            = 61;

  var EVENT             = 70;
  var DECORATOR         = 71;
  var TRANSITION        = 72;
  var BINDING_FLAG      = 73;

  var delimiterChangePattern = /^[^\s=]+/;
  var whitespacePattern = /^\s+/;
  function readDelimiterChange ( parser ) {
  	var start, opening, closing;

  	if ( !parser.matchString( '=' ) ) {
  		return null;
  	}

  	start = parser.pos;

  	// allow whitespace before new opening delimiter
  	parser.allowWhitespace();

  	opening = parser.matchPattern( delimiterChangePattern );
  	if ( !opening ) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace (in fact, it's necessary...)
  	if ( !parser.matchPattern( whitespacePattern ) ) {
  		return null;
  	}

  	closing = parser.matchPattern( delimiterChangePattern );
  	if ( !closing ) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace before closing '='
  	parser.allowWhitespace();

  	if ( !parser.matchString( '=' ) ) {
  		parser.pos = start;
  		return null;
  	}

  	return [ opening, closing ];
  }

  var regexpPattern = /^(\/(?:[^\n\r\u2028\u2029/\\[]|\\.|\[(?:[^\n\r\u2028\u2029\]\\]|\\.)*])+\/(?:([gimuy])(?![a-z]*\2))*(?![a-zA-Z_$0-9]))/;

  function readNumberLiteral ( parser ) {
  	var result;

  	if ( result = parser.matchPattern( regexpPattern ) ) {
  		return {
  			t: REGEXP_LITERAL,
  			v: result
  		};
  	}

  	return null;
  }

  var pattern$1 = /[-/\\^$*+?.()|[\]{}]/g;

  function escapeRegExp ( str ) {
  	return str.replace( pattern$1, '\\$&' );
  }

  var regExpCache = {};

  function getLowestIndex ( haystack, needles ) {
  	return haystack.search( regExpCache[needles.join()] || ( regExpCache[needles.join()] = new RegExp( needles.map( escapeRegExp ).join( '|' ) ) ) );
  }

  // https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316
  var booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;
  var voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;

  var htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, 'int': 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830	};
  var controlCharacters = [ 8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376 ];
  var entityPattern = new RegExp( '&(#?(?:x[\\w\\d]+|\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );
  var codePointSupport = typeof String.fromCodePoint === 'function';
  var codeToChar = codePointSupport ? String.fromCodePoint : String.fromCharCode;

  function decodeCharacterReferences ( html ) {
  	return html.replace( entityPattern, function ( match, entity ) {
  		var code;

  		// Handle named entities
  		if ( entity[0] !== '#' ) {
  			code = htmlEntities[ entity ];
  		} else if ( entity[1] === 'x' ) {
  			code = parseInt( entity.substring( 2 ), 16 );
  		} else {
  			code = parseInt( entity.substring( 1 ), 10 );
  		}

  		if ( !code ) {
  			return match;
  		}

  		return codeToChar( validateCode( code ) );
  	});
  }

  var lessThan = /</g;
  var greaterThan = />/g;
  var amp = /&/g;
  var invalid = 65533;

  function escapeHtml ( str ) {
  	return str
  		.replace( amp, '&amp;' )
  		.replace( lessThan, '&lt;' )
  		.replace( greaterThan, '&gt;' );
  }

  // some code points are verboten. If we were inserting HTML, the browser would replace the illegal
  // code points with alternatives in some cases - since we're bypassing that mechanism, we need
  // to replace them ourselves
  //
  // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
  function validateCode ( code ) {
  	if ( !code ) {
  		return invalid;
  	}

  	// line feed becomes generic whitespace
  	if ( code === 10 ) {
  		return 32;
  	}

  	// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
  	if ( code < 128 ) {
  		return code;
  	}

  	// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
  	// to correct the mistake or we'll end up with missing € signs and so on
  	if ( code <= 159 ) {
  		return controlCharacters[ code - 128 ];
  	}

  	// basic multilingual plane
  	if ( code < 55296 ) {
  		return code;
  	}

  	// UTF-16 surrogate halves
  	if ( code <= 57343 ) {
  		return invalid;
  	}

  	// rest of the basic multilingual plane
  	if ( code <= 65535 ) {
  		return code;
  	} else if ( !codePointSupport ) {
  		return invalid;
  	}

  	// supplementary multilingual plane 0x10000 - 0x1ffff
  	if ( code >= 65536 && code <= 131071 ) {
  		return code;
  	}

  	// supplementary ideographic plane 0x20000 - 0x2ffff
  	if ( code >= 131072 && code <= 196607 ) {
  		return code;
  	}

  	return invalid;
  }

  var expectedExpression = 'Expected a JavaScript expression';
  var expectedParen = 'Expected closing paren';

  // bulletproof number regex from https://gist.github.com/Rich-Harris/7544330
  var numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;

  function readNumberLiteral$1 ( parser ) {
  	var result;

  	if ( result = parser.matchPattern( numberPattern ) ) {
  		return {
  			t: NUMBER_LITERAL,
  			v: result
  		};
  	}

  	return null;
  }

  function readBooleanLiteral ( parser ) {
  	var remaining = parser.remaining();

  	if ( remaining.substr( 0, 4 ) === 'true' ) {
  		parser.pos += 4;
  		return {
  			t: BOOLEAN_LITERAL,
  			v: 'true'
  		};
  	}

  	if ( remaining.substr( 0, 5 ) === 'false' ) {
  		parser.pos += 5;
  		return {
  			t: BOOLEAN_LITERAL,
  			v: 'false'
  		};
  	}

  	return null;
  }

  var stringMiddlePattern;
  var escapeSequencePattern;
  var lineContinuationPattern;
  // Match one or more characters until: ", ', \, or EOL/EOF.
  // EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
  stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;

  // Match one escape sequence, including the backslash.
  escapeSequencePattern = /^\\(?:['"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;

  // Match one ES5 line continuation (backslash + line terminator).
  lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;

  // Helper for defining getDoubleQuotedString and getSingleQuotedString.
  function makeQuotedStringMatcher ( okQuote ) {
  	return function ( parser ) {
  		var literal = '"';
  		var done = false;
  		var next;

  		while ( !done ) {
  			next = ( parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) ||
  				parser.matchString( okQuote ) );
  			if ( next ) {
  				if ( next === ("\"") ) {
  					literal += "\\\"";
  				} else if ( next === ("\\'") ) {
  					literal += "'";
  				} else {
  					literal += next;
  				}
  			} else {
  				next = parser.matchPattern( lineContinuationPattern );
  				if ( next ) {
  					// convert \(newline-like) into a \u escape, which is allowed in JSON
  					literal += '\\u' + ( '000' + next.charCodeAt(1).toString(16) ).slice( -4 );
  				} else {
  					done = true;
  				}
  			}
  		}

  		literal += '"';

  		// use JSON.parse to interpret escapes
  		return JSON.parse( literal );
  	};
  }

  var getSingleQuotedString = makeQuotedStringMatcher( ("\"") );
  var getDoubleQuotedString = makeQuotedStringMatcher( ("'") );

  function readStringLiteral ( parser ) {
  	var start, string;

  	start = parser.pos;

  	if ( parser.matchString( '"' ) ) {
  		string = getDoubleQuotedString( parser );

  		if ( !parser.matchString( '"' ) ) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: STRING_LITERAL,
  			v: string
  		};
  	}

  	if ( parser.matchString( ("'") ) ) {
  		string = getSingleQuotedString( parser );

  		if ( !parser.matchString( ("'") ) ) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: STRING_LITERAL,
  			v: string
  		};
  	}

  	return null;
  }

  var namePattern = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;

  var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;

  // http://mathiasbynens.be/notes/javascript-properties
  // can be any name, string literal, or number literal
  function readKey ( parser ) {
  	var token;

  	if ( token = readStringLiteral( parser ) ) {
  		return identifier.test( token.v ) ? token.v : '"' + token.v.replace( /"/g, '\\"' ) + '"';
  	}

  	if ( token = readNumberLiteral$1( parser ) ) {
  		return token.v;
  	}

  	if ( token = parser.matchPattern( namePattern ) ) {
  		return token;
  	}

  	return null;
  }

  function readKeyValuePair ( parser ) {
  	var start, key, value;

  	start = parser.pos;

  	// allow whitespace between '{' and key
  	parser.allowWhitespace();

  	var refKey = parser.nextChar() !== '\'' && parser.nextChar() !== '"';

  	key = readKey( parser );
  	if ( key === null ) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace between key and ':'
  	parser.allowWhitespace();

  	// es2015 shorthand property
  	if ( refKey && ( parser.nextChar() === ',' || parser.nextChar() === '}' ) ) {
  		if ( !namePattern.test( key ) ) {
  			parser.error( ("Expected a valid reference, but found '" + key + "' instead.") );
  		}

  		return {
  			t: KEY_VALUE_PAIR,
  			k: key,
  			v: {
  				t: REFERENCE,
  				n: key
  			}
  		};
  	}

  	// next character must be ':'
  	if ( !parser.matchString( ':' ) ) {
  		parser.pos = start;
  		return null;
  	}

  	// allow whitespace between ':' and value
  	parser.allowWhitespace();

  	// next expression must be a, well... expression
  	value = readExpression( parser );
  	if ( value === null ) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: KEY_VALUE_PAIR,
  		k: key,
  		v: value
  	};
  }

  function readKeyValuePairs ( parser ) {
  	var start, pairs, pair, keyValuePairs;

  	start = parser.pos;

  	pair = readKeyValuePair( parser );
  	if ( pair === null ) {
  		return null;
  	}

  	pairs = [ pair ];

  	if ( parser.matchString( ',' ) ) {
  		keyValuePairs = readKeyValuePairs( parser );

  		if ( !keyValuePairs ) {
  			parser.pos = start;
  			return null;
  		}

  		return pairs.concat( keyValuePairs );
  	}

  	return pairs;
  }

  function readObjectLiteral ( parser ) {
  	var start, keyValuePairs;

  	start = parser.pos;

  	// allow whitespace
  	parser.allowWhitespace();

  	if ( !parser.matchString( '{' ) ) {
  		parser.pos = start;
  		return null;
  	}

  	keyValuePairs = readKeyValuePairs( parser );

  	// allow whitespace between final value and '}'
  	parser.allowWhitespace();

  	if ( !parser.matchString( '}' ) ) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: OBJECT_LITERAL,
  		m: keyValuePairs
  	};
  }

  function readExpressionList ( parser ) {
  	parser.allowWhitespace();

  	var expr = readExpression( parser );

  	if ( expr === null ) return null;

  	var expressions = [ expr ];

  	// allow whitespace between expression and ','
  	parser.allowWhitespace();

  	if ( parser.matchString( ',' ) ) {
  		var next = readExpressionList( parser );
  		if ( next === null ) parser.error( expectedExpression );

  		expressions.push.apply( expressions, next );
  	}

  	return expressions;
  }

  function readArrayLiteral ( parser ) {
  	var start, expressionList;

  	start = parser.pos;

  	// allow whitespace before '['
  	parser.allowWhitespace();

  	if ( !parser.matchString( '[' ) ) {
  		parser.pos = start;
  		return null;
  	}

  	expressionList = readExpressionList( parser );

  	if ( !parser.matchString( ']' ) ) {
  		parser.pos = start;
  		return null;
  	}

  	return {
  		t: ARRAY_LITERAL,
  		m: expressionList
  	};
  }

  function readLiteral ( parser ) {
  	return readNumberLiteral$1( parser )  ||
  	       readBooleanLiteral( parser ) ||
  	       readStringLiteral( parser )  ||
  	       readObjectLiteral( parser )  ||
  	       readArrayLiteral( parser )   ||
  	       readNumberLiteral( parser );
  }

  var prefixPattern = /^(?:~\/|(?:\.\.\/)+|\.\/(?:\.\.\/)*|\.)/;
  var globals;
  var keywords;
  // if a reference is a browser global, we don't deference it later, so it needs special treatment
  globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null|Object|Number|String|Boolean)\b/;

  // keywords are not valid references, with the exception of `this`
  keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;

  var legalReference = /^(?:[a-zA-Z$_0-9]|\\\.)+(?:(?:\.(?:[a-zA-Z$_0-9]|\\\.)+)|(?:\[[0-9]+\]))*/;
  var relaxedName = /^[a-zA-Z_$][-\/a-zA-Z_$0-9]*/;
  var specials = /^@(?:keypath|rootpath|index|key|this|global)/;
  var specialCall = /^\s*\(/;
  var spreadPattern = /^\s*\.{3}/;

  function readReference ( parser ) {
  	var startPos, prefix, name, global, reference, fullLength, lastDotIndex, spread;

  	startPos = parser.pos;

  	name = parser.matchPattern( specials );

  	if ( name === '@keypath' || name === '@rootpath' ) {
  		if ( parser.matchPattern( specialCall ) ) {
  			var ref = readReference( parser );
  			if ( !ref ) parser.error( ("Expected a valid reference for a keypath expression") );

  			parser.allowWhitespace();

  			if ( !parser.matchString( ')' ) ) parser.error( ("Unclosed keypath expression") );
  			name += "(" + (ref.n) + ")";
  		}
  	}

  	spread = !name && parser.spreadArgs && parser.matchPattern( spreadPattern );

  	if ( !name ) {
  		prefix = parser.matchPattern( prefixPattern ) || '';
  		name = ( !prefix && parser.relaxedNames && parser.matchPattern( relaxedName ) ) ||
  		       parser.matchPattern( legalReference );

  		if ( !name && prefix === '.' ) {
  			prefix = '';
  			name = '.';
  		} else if ( !name && prefix ) {
  			name = prefix;
  			prefix = '';
  		}
  	}

  	if ( !name ) {
  		return null;
  	}

  	// bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)
  	if ( !prefix && !parser.relaxedNames && keywords.test( name ) ) {
  		parser.pos = startPos;
  		return null;
  	}

  	// if this is a browser global, stop here
  	if ( !prefix && globals.test( name ) ) {
  		global = globals.exec( name )[0];
  		parser.pos = startPos + global.length;

  		return {
  			t: GLOBAL,
  			v: ( spread ? '...' : '' ) + global
  		};
  	}

  	fullLength = ( spread ? 3 : 0 ) + ( prefix || '' ).length + name.length;
  	reference = ( prefix || '' ) + normalise( name );

  	if ( parser.matchString( '(' ) ) {
  		// if this is a method invocation (as opposed to a function) we need
  		// to strip the method name from the reference combo, else the context
  		// will be wrong
  		// but only if the reference was actually a member and not a refinement
  		lastDotIndex = reference.lastIndexOf( '.' );
  		if ( lastDotIndex !== -1 && name[ name.length - 1 ] !== ']' ) {
  			var refLength = reference.length;
  			reference = reference.substr( 0, lastDotIndex );
  			parser.pos = startPos + (fullLength - ( refLength - lastDotIndex ) );
  		} else {
  			parser.pos -= 1;
  		}
  	}

  	return {
  		t: REFERENCE,
  		n: ( spread ? '...' : '' ) + reference.replace( /^this\./, './' ).replace( /^this$/, '.' )
  	};
  }

  function readBracketedExpression ( parser ) {
  	if ( !parser.matchString( '(' ) ) return null;

  	parser.allowWhitespace();

  	var expr = readExpression( parser );

  	if ( !expr ) parser.error( expectedExpression );

  	parser.allowWhitespace();

  	if ( !parser.matchString( ')' ) ) parser.error( expectedParen );

  	return {
  		t: BRACKETED,
  		x: expr
  	};
  }

  function readPrimary ( parser ) {
  	return readLiteral( parser )
  		|| readReference( parser )
  		|| readBracketedExpression( parser );
  }

  function readRefinement ( parser ) {
  	// some things call for strict refinement (partial names), meaning no space between reference and refinement
  	if ( !parser.strictRefinement ) {
  		parser.allowWhitespace();
  	}

  	// "." name
  	if ( parser.matchString( '.' ) ) {
  		parser.allowWhitespace();

  		var name = parser.matchPattern( namePattern );
  		if ( name ) {
  			return {
  				t: REFINEMENT,
  				n: name
  			};
  		}

  		parser.error( 'Expected a property name' );
  	}

  	// "[" expression "]"
  	if ( parser.matchString( '[' ) ) {
  		parser.allowWhitespace();

  		var expr = readExpression( parser );
  		if ( !expr ) parser.error( expectedExpression );

  		parser.allowWhitespace();

  		if ( !parser.matchString( ']' ) ) parser.error( ("Expected ']'") );

  		return {
  			t: REFINEMENT,
  			x: expr
  		};
  	}

  	return null;
  }

  function readMemberOrInvocation ( parser ) {
  	var expression = readPrimary( parser );

  	if ( !expression ) return null;

  	while ( expression ) {
  		var refinement = readRefinement( parser );
  		if ( refinement ) {
  			expression = {
  				t: MEMBER,
  				x: expression,
  				r: refinement
  			};
  		}

  		else if ( parser.matchString( '(' ) ) {
  			parser.allowWhitespace();
  			var start = parser.spreadArgs;
  			parser.spreadArgs = true;
  			var expressionList = readExpressionList( parser );
  			parser.spreadArgs = start;

  			parser.allowWhitespace();

  			if ( !parser.matchString( ')' ) ) {
  				parser.error( expectedParen );
  			}

  			expression = {
  				t: INVOCATION,
  				x: expression
  			};

  			if ( expressionList ) expression.o = expressionList;
  		}

  		else {
  			break;
  		}
  	}

  	return expression;
  }

  var readTypeOf;
  var makePrefixSequenceMatcher;
  makePrefixSequenceMatcher = function ( symbol, fallthrough ) {
  	return function ( parser ) {
  		var expression;

  		if ( expression = fallthrough( parser ) ) {
  			return expression;
  		}

  		if ( !parser.matchString( symbol ) ) {
  			return null;
  		}

  		parser.allowWhitespace();

  		expression = readExpression( parser );
  		if ( !expression ) {
  			parser.error( expectedExpression );
  		}

  		return {
  			s: symbol,
  			o: expression,
  			t: PREFIX_OPERATOR
  		};
  	};
  };

  // create all prefix sequence matchers, return readTypeOf
  (function() {
  	var i, len, matcher, prefixOperators, fallthrough;

  	prefixOperators = '! ~ + - typeof'.split( ' ' );

  	fallthrough = readMemberOrInvocation;
  	for ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {
  		matcher = makePrefixSequenceMatcher( prefixOperators[i], fallthrough );
  		fallthrough = matcher;
  	}

  	// typeof operator is higher precedence than multiplication, so provides the
  	// fallthrough for the multiplication sequence matcher we're about to create
  	// (we're skipping void and delete)
  	readTypeOf = fallthrough;
  }());

  var readTypeof = readTypeOf;

  var readLogicalOr;
  var makeInfixSequenceMatcher;
  makeInfixSequenceMatcher = function ( symbol, fallthrough ) {
  	return function ( parser ) {
  		var start, left, right;

  		left = fallthrough( parser );
  		if ( !left ) {
  			return null;
  		}

  		// Loop to handle left-recursion in a case like `a * b * c` and produce
  		// left association, i.e. `(a * b) * c`.  The matcher can't call itself
  		// to parse `left` because that would be infinite regress.
  		while ( true ) {
  			start = parser.pos;

  			parser.allowWhitespace();

  			if ( !parser.matchString( symbol ) ) {
  				parser.pos = start;
  				return left;
  			}

  			// special case - in operator must not be followed by [a-zA-Z_$0-9]
  			if ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {
  				parser.pos = start;
  				return left;
  			}

  			parser.allowWhitespace();

  			// right operand must also consist of only higher-precedence operators
  			right = fallthrough( parser );
  			if ( !right ) {
  				parser.pos = start;
  				return left;
  			}

  			left = {
  				t: INFIX_OPERATOR,
  				s: symbol,
  				o: [ left, right ]
  			};

  			// Loop back around.  If we don't see another occurrence of the symbol,
  			// we'll return left.
  		}
  	};
  };

  // create all infix sequence matchers, and return readLogicalOr
  (function() {
  	var i, len, matcher, infixOperators, fallthrough;

  	// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)
  	// Each sequence matcher will initially fall through to its higher precedence
  	// neighbour, and only attempt to match if one of the higher precedence operators
  	// (or, ultimately, a literal, reference, or bracketed expression) already matched
  	infixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );

  	// A typeof operator is higher precedence than multiplication
  	fallthrough = readTypeof;
  	for ( i = 0, len = infixOperators.length; i < len; i += 1 ) {
  		matcher = makeInfixSequenceMatcher( infixOperators[i], fallthrough );
  		fallthrough = matcher;
  	}

  	// Logical OR is the fallthrough for the conditional matcher
  	readLogicalOr = fallthrough;
  }());

  var readLogicalOr$1 = readLogicalOr;

  // The conditional operator is the lowest precedence operator, so we start here
  function getConditional ( parser ) {
  	var start, expression, ifTrue, ifFalse;

  	expression = readLogicalOr$1( parser );
  	if ( !expression ) {
  		return null;
  	}

  	start = parser.pos;

  	parser.allowWhitespace();

  	if ( !parser.matchString( '?' ) ) {
  		parser.pos = start;
  		return expression;
  	}

  	parser.allowWhitespace();

  	ifTrue = readExpression( parser );
  	if ( !ifTrue ) {
  		parser.error( expectedExpression );
  	}

  	parser.allowWhitespace();

  	if ( !parser.matchString( ':' ) ) {
  		parser.error( 'Expected ":"' );
  	}

  	parser.allowWhitespace();

  	ifFalse = readExpression( parser );
  	if ( !ifFalse ) {
  		parser.error( expectedExpression );
  	}

  	return {
  		t: CONDITIONAL,
  		o: [ expression, ifTrue, ifFalse ]
  	};
  }

  function readExpression ( parser ) {
  	// The conditional operator is the lowest precedence operator (except yield,
  	// assignment operators, and commas, none of which are supported), so we
  	// start there. If it doesn't match, it 'falls through' to progressively
  	// higher precedence operators, until it eventually matches (or fails to
  	// match) a 'primary' - a literal or a reference. This way, the abstract syntax
  	// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
  	return getConditional( parser );
  }

  function flattenExpression ( expression ) {
  	var refs, count = 0, stringified;

  	extractRefs( expression, refs = [] );
  	stringified = stringify( expression );

  	refs = refs.map( function ( r ) { return r.indexOf( '...' ) === 0 ? r.substr( 3 ) : r; } );

  	return {
  		r: refs,
  		s: getVars(stringified)
  	};

  	function getVars(expr) {
  		var vars = [];
  		for ( var i = count - 1; i >= 0; i-- ) {
  			vars.push( ("spread$" + i) );
  		}
  		return vars.length ? ("(function(){var " + (vars.join(',')) + ";return(" + expr + ");})()") : expr;
  	}

  	function stringify ( node ) {
  		switch ( node.t ) {
  			case BOOLEAN_LITERAL:
  			case GLOBAL:
  			case NUMBER_LITERAL:
  			case REGEXP_LITERAL:
  				return node.v;

  			case STRING_LITERAL:
  				return JSON.stringify( String( node.v ) );

  			case ARRAY_LITERAL:
  				return '[' + ( node.m ? node.m.map( stringify ).join( ',' ) : '' ) + ']';

  			case OBJECT_LITERAL:
  				return '{' + ( node.m ? node.m.map( stringify ).join( ',' ) : '' ) + '}';

  			case KEY_VALUE_PAIR:
  				return node.k + ':' + stringify( node.v );

  			case PREFIX_OPERATOR:
  				return ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( node.o );

  			case INFIX_OPERATOR:
  				return stringify( node.o[0] ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( node.o[1] );

  			case INVOCATION:
  				if ( node.spread ) {
  					var id = count++;
  					return ("(spread$" + id + " = " + (stringify(node.x)) + ").apply(spread$" + id + ", [].concat(" + (node.o ? node.o.map( function ( a ) { return a.n && a.n.indexOf( '...' ) === 0 ? stringify( a ) : '[' + stringify(a) + ']'; } ).join( ',' ) : '') + ") )");
  				} else {
  					return stringify( node.x ) + '(' + ( node.o ? node.o.map( stringify ).join( ',' ) : '' ) + ')';
  				}

  			case BRACKETED:
  				return '(' + stringify( node.x ) + ')';

  			case MEMBER:
  				return stringify( node.x ) + stringify( node.r );

  			case REFINEMENT:
  				return ( node.n ? '.' + node.n : '[' + stringify( node.x ) + ']' );

  			case CONDITIONAL:
  				return stringify( node.o[0] ) + '?' + stringify( node.o[1] ) + ':' + stringify( node.o[2] );

  			case REFERENCE:
  				return '_' + refs.indexOf( node.n );

  			default:
  				throw new Error( 'Expected legal JavaScript' );
  		}
  	}
  }

  // TODO maybe refactor this?
  function extractRefs ( node, refs ) {
  	var i, list;

  	if ( node.t === REFERENCE ) {
  		if ( refs.indexOf( node.n ) === -1 ) {
  			refs.unshift( node.n );
  		}
  	}

  	list = node.o || node.m;
  	if ( list ) {
  		if ( isObject( list ) ) {
  			extractRefs( list, refs );
  		} else {
  			i = list.length;
  			while ( i-- ) {
  				if ( list[i].n && list[i].n.indexOf('...') === 0 ) {
  					node.spread = true;
  				}
  				extractRefs( list[i], refs );
  			}
  		}
  	}

  	if ( node.x ) {
  		extractRefs( node.x, refs );
  	}

  	if ( node.r ) {
  		extractRefs( node.r, refs );
  	}

  	if ( node.v ) {
  		extractRefs( node.v, refs );
  	}
  }

  // simple JSON parser, without the restrictions of JSON parse
  // (i.e. having to double-quote keys).
  //
  // If passed a hash of values as the second argument, ${placeholders}
  // will be replaced with those values

  var specials$1 = {
  	'true': true,
  	'false': false,
  	'null': null,
  	undefined: undefined
  };

  var specialsPattern = new RegExp( '^(?:' + Object.keys( specials$1 ).join( '|' ) + ')' );
  var numberPattern$1 = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
  var placeholderPattern = /\$\{([^\}]+)\}/g;
  var placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
  var onlyWhitespace = /^\s*$/;

  var JsonParser = Parser$1.extend({
  	init: function ( str, options ) {
  		this.values = options.values;
  		this.allowWhitespace();
  	},

  	postProcess: function ( result ) {
  		if ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {
  			return null;
  		}

  		return { value: result[0].v };
  	},

  	converters: [
  		function getPlaceholder ( parser ) {
  			if ( !parser.values ) return null;

  			var placeholder = parser.matchPattern( placeholderAtStartPattern );

  			if ( placeholder && ( parser.values.hasOwnProperty( placeholder ) ) ) {
  				return { v: parser.values[ placeholder ] };
  			}
  		},

  		function getSpecial ( parser ) {
  			var special = parser.matchPattern( specialsPattern );
  			if ( special ) return { v: specials$1[ special ] };
  		},

  		function getNumber ( parser ) {
  			var number = parser.matchPattern( numberPattern$1 );
  			if ( number ) return { v: +number };
  		},

  		function getString ( parser ) {
  			var stringLiteral = readStringLiteral( parser );
  			var values = parser.values;

  			if ( stringLiteral && values ) {
  				return {
  					v: stringLiteral.v.replace( placeholderPattern, function ( match, $1 ) { return ( $1 in values ? values[ $1 ] : $1 ); } )
  				};
  			}

  			return stringLiteral;
  		},

  		function getObject ( parser ) {
  			if ( !parser.matchString( '{' ) ) return null;

  			var result = {};

  			parser.allowWhitespace();

  			if ( parser.matchString( '}' ) ) {
  				return { v: result };
  			}

  			var pair;
  			while ( pair = getKeyValuePair( parser ) ) {
  				result[ pair.key ] = pair.value;

  				parser.allowWhitespace();

  				if ( parser.matchString( '}' ) ) {
  					return { v: result };
  				}

  				if ( !parser.matchString( ',' ) ) {
  					return null;
  				}
  			}

  			return null;
  		},

  		function getArray ( parser ) {
  			if ( !parser.matchString( '[' ) ) return null;

  			var result = [];

  			parser.allowWhitespace();

  			if ( parser.matchString( ']' ) ) {
  				return { v: result };
  			}

  			var valueToken;
  			while ( valueToken = parser.read() ) {
  				result.push( valueToken.v );

  				parser.allowWhitespace();

  				if ( parser.matchString( ']' ) ) {
  					return { v: result };
  				}

  				if ( !parser.matchString( ',' ) ) {
  					return null;
  				}

  				parser.allowWhitespace();
  			}

  			return null;
  		}
  	]
  });

  function getKeyValuePair ( parser ) {
  	parser.allowWhitespace();

  	var key = readKey( parser );

  	if ( !key ) return null;

  	var pair = { key: key };

  	parser.allowWhitespace();
  	if ( !parser.matchString( ':' ) ) {
  		return null;
  	}
  	parser.allowWhitespace();

  	var valueToken = parser.read();

  	if ( !valueToken ) return null;

  	pair.value = valueToken.v;
  	return pair;
  }

  function parseJSON ( str, values ) {
  	var parser = new JsonParser( str, { values: values });
  	return parser.result;
  }

  var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\(.*\)\s*$/;
  var ExpressionParser;
  ExpressionParser = Parser$1.extend({
  	converters: [ readExpression ],
  	spreadArgs: true
  });

  // TODO clean this up, it's shocking
  function processDirective ( tokens, parentParser, type ) {
  	var result,
  		match,
  		token,
  		colonIndex,
  		directiveName,
  		directiveArgs,
  		parsed;

  	if ( typeof tokens === 'string' ) {
  		var pos = parentParser.pos - tokens.length;
  		if ( type === DECORATOR || type === TRANSITION ) {
  			var parser = new ExpressionParser( ("[" + tokens + "]") );
  			return { a: flattenExpression( parser.result[0] ) };
  		}

  		if ( type === EVENT && ( match = methodCallPattern.exec( tokens ) ) ) {
  			warnIfDebug( parentParser.getContextMessage( pos, ("Unqualified method events are deprecated. Prefix methods with '@this.' to call methods on the current Ractive instance.") )[2] );
  			tokens = "@this." + (match[1]) + "" + (tokens.substr(match[1].length));
  		}

  		if ( type === EVENT && ~tokens.indexOf( '(' ) ) {
  			var parser$1 = new ExpressionParser( '[' + tokens + ']' );
  			if ( parser$1.result && parser$1.result[0] ) {
  				if ( parser$1.remaining().length ) {
  					parentParser.pos = pos + tokens.length - parser$1.remaining().length;
  					parentParser.error( ("Invalid input after event expression '" + (parser$1.remaining()) + "'") );
  				}
  				return { x: flattenExpression( parser$1.result[0] ) };
  			}

  			if ( tokens.indexOf( ':' ) > tokens.indexOf( '(' ) || !~tokens.indexOf( ':' ) ) {
  				parentParser.pos = pos;
  				parentParser.error( ("Invalid input in event expression '" + tokens + "'") );
  			}

  		}

  		if ( tokens.indexOf( ':' ) === -1 ) {
  			return tokens.trim();
  		}

  		tokens = [ tokens ];
  	}

  	result = {};

  	directiveName = [];
  	directiveArgs = [];

  	if ( tokens ) {
  		while ( tokens.length ) {
  			token = tokens.shift();

  			if ( typeof token === 'string' ) {
  				colonIndex = token.indexOf( ':' );

  				if ( colonIndex === -1 ) {
  					directiveName.push( token );
  				} else {
  					// is the colon the first character?
  					if ( colonIndex ) {
  						// no
  						directiveName.push( token.substr( 0, colonIndex ) );
  					}

  					// if there is anything after the colon in this token, treat
  					// it as the first token of the directiveArgs fragment
  					if ( token.length > colonIndex + 1 ) {
  						directiveArgs[0] = token.substring( colonIndex + 1 );
  					}

  					break;
  				}
  			}

  			else {
  				directiveName.push( token );
  			}
  		}

  		directiveArgs = directiveArgs.concat( tokens );
  	}

  	if ( !directiveName.length ) {
  		result = '';
  	} else if ( directiveArgs.length || typeof directiveName !== 'string' ) {
  		result = {
  			// TODO is this really necessary? just use the array
  			n: ( directiveName.length === 1 && typeof directiveName[0] === 'string' ? directiveName[0] : directiveName )
  		};

  		if ( directiveArgs.length === 1 && typeof directiveArgs[0] === 'string' ) {
  			parsed = parseJSON( '[' + directiveArgs[0] + ']' );
  			result.a = parsed ? parsed.value : [ directiveArgs[0].trim() ];
  		}

  		else {
  			result.d = directiveArgs;
  		}
  	} else {
  		result = directiveName;
  	}

  	if ( directiveArgs.length && type ) {
  		warnIfDebug( parentParser.getContextMessage( parentParser.pos, ("Proxy events with arguments are deprecated. You can fire events with arguments using \"@this.fire('eventName', arg1, arg2, ...)\".") )[2] );
  	}

  	return result;
  }

  var attributeNamePattern = /^[^\s"'>\/=]+/;
  var onPattern = /^on/;
  var proxyEventPattern = /^on-([a-zA-Z\\*\\.$_][a-zA-Z\\*\\.$_0-9\-]+)$/;
  var reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/;
  var decoratorPattern = /^as-([a-z-A-Z][-a-zA-Z_0-9]*)$/;
  var transitionPattern = /^([a-zA-Z](?:(?!-in-out)[-a-zA-Z_0-9])*)-(in|out|in-out)$/;
  var directives = {
  				   'intro-outro': { t: TRANSITION, v: 't0' },
  				   intro: { t: TRANSITION, v: 't1' },
  				   outro: { t: TRANSITION, v: 't2' },
  				   lazy: { t: BINDING_FLAG, v: 'l' },
  				   twoway: { t: BINDING_FLAG, v: 't' },
  				   decorator: { t: DECORATOR }
  				 };
  var unquotedAttributeValueTextPattern = /^[^\s"'=<>`]+/;
  function readAttribute ( parser ) {
  	var attr, name, value, i, nearest, idx;

  	parser.allowWhitespace();

  	name = parser.matchPattern( attributeNamePattern );
  	if ( !name ) {
  		return null;
  	}

  	// check for accidental delimiter consumption e.g. <tag bool{{>attrs}} />
  	nearest = name.length;
  	for ( i = 0; i < parser.tags.length; i++ ) {
  		if ( ~( idx = name.indexOf( parser.tags[ i ].open ) ) ) {
  			if ( idx < nearest ) nearest = idx;
  		}
  	}
  	if ( nearest < name.length ) {
  		parser.pos -= name.length - nearest;
  		name = name.substr( 0, nearest );
  		return { n: name };
  	}

  	attr = { n: name };

  	value = readAttributeValue( parser );
  	if ( value != null ) { // not null/undefined
  		attr.f = value;
  	}

  	return attr;
  }

  function readAttributeValue ( parser ) {
  	var start, valueStart, startDepth, value;

  	start = parser.pos;

  	// next character must be `=`, `/`, `>` or whitespace
  	if ( !/[=\/>\s]/.test( parser.nextChar() ) ) {
  		parser.error( 'Expected `=`, `/`, `>` or whitespace' );
  	}

  	parser.allowWhitespace();

  	if ( !parser.matchString( '=' ) ) {
  		parser.pos = start;
  		return null;
  	}

  	parser.allowWhitespace();

  	valueStart = parser.pos;
  	startDepth = parser.sectionDepth;

  	value = readQuotedAttributeValue( parser, ("'") ) ||
  			readQuotedAttributeValue( parser, ("\"") ) ||
  			readUnquotedAttributeValue( parser );

  	if ( value === null ) {
  		parser.error( 'Expected valid attribute value' );
  	}

  	if ( parser.sectionDepth !== startDepth ) {
  		parser.pos = valueStart;
  		parser.error( 'An attribute value must contain as many opening section tags as closing section tags' );
  	}

  	if ( !value.length ) {
  		return '';
  	}

  	if ( value.length === 1 && typeof value[0] === 'string' ) {
  		return decodeCharacterReferences( value[0] );
  	}

  	return value;
  }

  function readUnquotedAttributeValueToken ( parser ) {
  	var start, text, haystack, needles, index;

  	start = parser.pos;

  	text = parser.matchPattern( unquotedAttributeValueTextPattern );

  	if ( !text ) {
  		return null;
  	}

  	haystack = text;
  	needles = parser.tags.map( function ( t ) { return t.open; } ); // TODO refactor... we do this in readText.js as well

  	if ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {
  		text = text.substr( 0, index );
  		parser.pos = start + text.length;
  	}

  	return text;
  }

  function readUnquotedAttributeValue ( parser ) {
  	var tokens, token;

  	parser.inAttribute = true;

  	tokens = [];

  	token = readMustache( parser ) || readUnquotedAttributeValueToken( parser );
  	while ( token ) {
  		tokens.push( token );
  		token = readMustache( parser ) || readUnquotedAttributeValueToken( parser );
  	}

  	if ( !tokens.length ) {
  		return null;
  	}

  	parser.inAttribute = false;
  	return tokens;
  }

  function readQuotedAttributeValue ( parser, quoteMark ) {
  	var start, tokens, token;

  	start = parser.pos;

  	if ( !parser.matchString( quoteMark ) ) {
  		return null;
  	}

  	parser.inAttribute = quoteMark;

  	tokens = [];

  	token = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );
  	while ( token !== null ) {
  		tokens.push( token );
  		token = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );
  	}

  	if ( !parser.matchString( quoteMark ) ) {
  		parser.pos = start;
  		return null;
  	}

  	parser.inAttribute = false;

  	return tokens;
  }

  function readQuotedStringToken ( parser, quoteMark ) {
  	var haystack = parser.remaining();

  	var needles = parser.tags.map( function ( t ) { return t.open; } ); // TODO refactor... we do this in readText.js as well
  	needles.push( quoteMark );

  	var index = getLowestIndex( haystack, needles );

  	if ( index === -1 ) {
  		parser.error( 'Quoted attribute value must have a closing quote' );
  	}

  	if ( !index ) {
  		return null;
  	}

  	parser.pos += index;
  	return haystack.substr( 0, index );
  }

  function readAttributeOrDirective ( parser ) {
  		var match,
  			attribute,
  		    directive;

  		attribute = readAttribute( parser );

  		if ( !attribute ) return null;

  		// intro, outro, decorator
  		if ( directive = directives[ attribute.n ] ) {
  			attribute.t = directive.t;
  			if ( directive.v ) attribute.v = directive.v;
  			delete attribute.n; // no name necessary

  			if ( directive.t === TRANSITION || directive.t === DECORATOR ) attribute.f = processDirective( attribute.f, parser );

  			if ( directive.t === TRANSITION ) {
  				warnOnceIfDebug( ("" + (directive.v === 't0' ? 'intro-outro' : directive.v === 't1' ? 'intro' : 'outro') + " is deprecated. To specify tranisitions, use the transition name suffixed with '-in', '-out', or '-in-out' as an attribute. Arguments can be specified in the attribute value as a simple list of expressions without mustaches.") );
  			} else if ( directive.t === DECORATOR ) {
  				warnOnceIfDebug( ("decorator is deprecated. To specify decorators, use the decorator name prefixed with 'as-' as an attribute. Arguments can be specified in the attribute value as a simple list of expressions without mustaches.") );
  			}
  		}

  		// decorators
  		else if ( match = decoratorPattern.exec( attribute.n ) ) {
  			delete attribute.n;
  			attribute.t = DECORATOR;
  			attribute.f = processDirective( attribute.f, parser, DECORATOR );
  			if ( typeof attribute.f === 'object' ) attribute.f.n = match[1];
  			else attribute.f = match[1];
  		}

  		// transitions
  		else if ( match = transitionPattern.exec( attribute.n ) ) {
  			delete attribute.n;
  			attribute.t = TRANSITION;
  			attribute.f = processDirective( attribute.f, parser, TRANSITION );
  			if ( typeof attribute.f === 'object' ) attribute.f.n = match[1];
  			else attribute.f = match[1];
  			attribute.v = match[2] === 'in-out' ? 't0' : match[2] === 'in' ? 't1' : 't2';
  		}

  		// on-click etc
  		else if ( match = proxyEventPattern.exec( attribute.n ) ) {
  			attribute.n = match[1];
  			attribute.t = EVENT;
  			attribute.f = processDirective( attribute.f, parser, EVENT );

  			if ( reservedEventNames.test( attribute.f.n || attribute.f ) ) {
  				parser.pos -= ( attribute.f.n || attribute.f ).length;
  				parser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)' );
  			}
  		}

  		else {
  			if ( parser.sanitizeEventAttributes && onPattern.test( attribute.n ) ) {
  				return { exclude: true };
  			} else {
  				attribute.f = attribute.f || ( attribute.f === '' ? '' : 0 );
  				attribute.t = ATTRIBUTE;
  			}
  		}

  		return attribute;
  }

  var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };

  function readMustache ( parser ) {
  	var mustache, i;

  	// If we're inside a <script> or <style> tag, and we're not
  	// interpolating, bug out
  	if ( parser.interpolate[ parser.inside ] === false ) {
  		return null;
  	}

  	for ( i = 0; i < parser.tags.length; i += 1 ) {
  		if ( mustache = readMustacheOfType( parser, parser.tags[i] ) ) {
  			return mustache;
  		}
  	}

  	if ( parser.inTag && !parser.inAttribute ) {
  		mustache = readAttributeOrDirective( parser );
  		if ( mustache ) {
  			parser.allowWhitespace();
  			return mustache;
  		}
  	}
  }

  function readMustacheOfType ( parser, tag ) {
  	var start, mustache, reader, i;

  	start = parser.pos;

  	if ( parser.matchString( '\\' + tag.open ) ) {
  		if ( start === 0 || parser.str[ start - 1 ] !== '\\' ) {
  			return tag.open;
  		}
  	} else if ( !parser.matchString( tag.open ) ) {
  		return null;
  	}

  	// delimiter change?
  	if ( mustache = readDelimiterChange( parser ) ) {
  		// find closing delimiter or abort...
  		if ( !parser.matchString( tag.close ) ) {
  			return null;
  		}

  		// ...then make the switch
  		tag.open = mustache[0];
  		tag.close = mustache[1];
  		parser.sortMustacheTags();

  		return delimiterChangeToken;
  	}

  	parser.allowWhitespace();

  	// illegal section closer
  	if ( parser.matchString( '/' ) ) {
  		parser.pos -= 1;
  		var rewind = parser.pos;
  		if ( !readNumberLiteral( parser ) ) {
  			parser.pos = rewind - ( tag.close.length );
  			if ( parser.inAttribute ) {
  				parser.pos = start;
  				return null;
  			} else {
  				parser.error( 'Attempted to close a section that wasn\'t open' );
  			}
  		} else {
  			parser.pos = rewind;
  		}
  	}

  	for ( i = 0; i < tag.readers.length; i += 1 ) {
  		reader = tag.readers[i];

  		if ( mustache = reader( parser, tag ) ) {
  			if ( tag.isStatic ) {
  				mustache.s = true; // TODO make this `1` instead - more compact
  			}

  			if ( parser.includeLinePositions ) {
  				mustache.p = parser.getLinePos( start );
  			}

  			return mustache;
  		}
  	}

  	parser.pos = start;
  	return null;
  }

  function refineExpression ( expression, mustache ) {
  	var referenceExpression;

  	if ( expression ) {
  		while ( expression.t === BRACKETED && expression.x ) {
  			expression = expression.x;
  		}

  		if ( expression.t === REFERENCE ) {
  			mustache.r = expression.n;
  		} else {
  			if ( referenceExpression = getReferenceExpression( expression ) ) {
  				mustache.rx = referenceExpression;
  			} else {
  				mustache.x = flattenExpression( expression );
  			}
  		}

  		return mustache;
  	}
  }

  // TODO refactor this! it's bewildering
  function getReferenceExpression ( expression ) {
  	var members = [], refinement;

  	while ( expression.t === MEMBER && expression.r.t === REFINEMENT ) {
  		refinement = expression.r;

  		if ( refinement.x ) {
  			if ( refinement.x.t === REFERENCE ) {
  				members.unshift( refinement.x );
  			} else {
  				members.unshift( flattenExpression( refinement.x ) );
  			}
  		} else {
  			members.unshift( refinement.n );
  		}

  		expression = expression.x;
  	}

  	if ( expression.t !== REFERENCE ) {
  		return null;
  	}

  	return {
  		r: expression.n,
  		m: members
  	};
  }

  function readTriple ( parser, tag ) {
  	var expression = readExpression( parser ), triple;

  	if ( !expression ) {
  		return null;
  	}

  	if ( !parser.matchString( tag.close ) ) {
  		parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );
  	}

  	triple = { t: TRIPLE };
  	refineExpression( expression, triple ); // TODO handle this differently - it's mysterious

  	return triple;
  }

  function readUnescaped ( parser, tag ) {
  	var expression, triple;

  	if ( !parser.matchString( '&' ) ) {
  		return null;
  	}

  	parser.allowWhitespace();

  	expression = readExpression( parser );

  	if ( !expression ) {
  		return null;
  	}

  	if ( !parser.matchString( tag.close ) ) {
  		parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );
  	}

  	triple = { t: TRIPLE };
  	refineExpression( expression, triple ); // TODO handle this differently - it's mysterious

  	return triple;
  }

  var legalAlias = /^(?:[a-zA-Z$_0-9]|\\\.)+(?:(?:(?:[a-zA-Z$_0-9]|\\\.)+)|(?:\[[0-9]+\]))*/;
  var asRE = /^as/i;

  function readAliases( parser ) {
  	var aliases = [], alias, start = parser.pos;

  	parser.allowWhitespace();

  	alias = readAlias( parser );

  	if ( alias ) {
  		alias.x = refineExpression( alias.x, {} );
  		aliases.push( alias );

  		parser.allowWhitespace();

  		while ( parser.matchString(',') ) {
  			alias = readAlias( parser );

  			if ( !alias ) {
  				parser.error( 'Expected another alias.' );
  			}

  			alias.x = refineExpression( alias.x, {} );
  			aliases.push( alias );

  			parser.allowWhitespace();
  		}

  		return aliases;
  	}

  	parser.pos = start;
  	return null;
  }

  function readAlias( parser ) {
  	var expr, alias, start = parser.pos;

  	parser.allowWhitespace();

  	expr = readExpression( parser, [] );

  	if ( !expr ) {
  		parser.pos = start;
  		return null;
  	}

  	parser.allowWhitespace();

  	if ( !parser.matchPattern( asRE ) ) {
  		parser.pos = start;
  		return null;
  	}

  	parser.allowWhitespace();

  	alias = parser.matchPattern( legalAlias );

  	if ( !alias ) {
  		parser.error( 'Expected a legal alias name.' );
  	}

  	return { n: alias, x: expr };
  }

  function readPartial ( parser, tag ) {
  	if ( !parser.matchString( '>' ) ) return null;

  	parser.allowWhitespace();

  	// Partial names can include hyphens, so we can't use readExpression
  	// blindly. Instead, we use the `relaxedNames` flag to indicate that
  	// `foo-bar` should be read as a single name, rather than 'subtract
  	// bar from foo'
  	parser.relaxedNames = parser.strictRefinement = true;
  	var expression = readExpression( parser );
  	parser.relaxedNames = parser.strictRefinement = false;

  	if ( !expression ) return null;

  	var partial = { t: PARTIAL };
  	refineExpression( expression, partial ); // TODO...

  	parser.allowWhitespace();

  	// check for alias context e.g. `{{>foo bar as bat, bip as bop}}` then
  	// turn it into `{{#with bar as bat, bip as bop}}{{>foo}}{{/with}}`
  	var aliases = readAliases( parser );
  	if ( aliases ) {
  		partial = {
  			t: ALIAS,
  			z: aliases,
  			f: [ partial ]
  		};
  	}

  	// otherwise check for literal context e.g. `{{>foo bar}}` then
  	// turn it into `{{#with bar}}{{>foo}}{{/with}}`
  	else {
  		var context = readExpression( parser );
  		if ( context) {
  			partial = {
  				t: SECTION,
  				n: SECTION_WITH,
  				f: [ partial ]
  			};

  			refineExpression( context, partial );
  		}
  	}

  	parser.allowWhitespace();

  	if ( !parser.matchString( tag.close ) ) {
  		parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );
  	}

  	return partial;
  }

  function readComment ( parser, tag ) {
  	var index;

  	if ( !parser.matchString( '!' ) ) {
  		return null;
  	}

  	index = parser.remaining().indexOf( tag.close );

  	if ( index !== -1 ) {
  		parser.pos += index + tag.close.length;
  		return { t: COMMENT };
  	}
  }

  function readExpressionOrReference ( parser, expectedFollowers ) {
  	var start, expression, i;

  	start = parser.pos;
  	expression = readExpression( parser );

  	if ( !expression ) {
  		// valid reference but invalid expression e.g. `{{new}}`?
  		var ref = parser.matchPattern( /^(\w+)/ );
  		if ( ref ) {
  			return {
  				t: REFERENCE,
  				n: ref
  			};
  		}

  		return null;
  	}

  	for ( i = 0; i < expectedFollowers.length; i += 1 ) {
  		if ( parser.remaining().substr( 0, expectedFollowers[i].length ) === expectedFollowers[i] ) {
  			return expression;
  		}
  	}

  	parser.pos = start;
  	return readReference( parser );
  }

  function readInterpolator ( parser, tag ) {
  	var start, expression, interpolator, err;

  	start = parser.pos;

  	// TODO would be good for perf if we could do away with the try-catch
  	try {
  		expression = readExpressionOrReference( parser, [ tag.close ]);
  	} catch ( e ) {
  		err = e;
  	}

  	if ( !expression ) {
  		if ( parser.str.charAt( start ) === '!' ) {
  			// special case - comment
  			parser.pos = start;
  			return null;
  		}

  		if ( err ) {
  			throw err;
  		}
  	}

  	if ( !parser.matchString( tag.close ) ) {
  		parser.error( ("Expected closing delimiter '" + (tag.close) + "' after reference") );

  		if ( !expression ) {
  			// special case - comment
  			if ( parser.nextChar() === '!' ) {
  				return null;
  			}

  			parser.error( ("Expected expression or legal reference") );
  		}
  	}

  	interpolator = { t: INTERPOLATOR };
  	refineExpression( expression, interpolator ); // TODO handle this differently - it's mysterious

  	return interpolator;
  }

  var yieldPattern = /^yield\s*/;

  function readYielder ( parser, tag ) {
  	if ( !parser.matchPattern( yieldPattern ) ) return null;

  	var name = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\-]*/ );

  	parser.allowWhitespace();

  	if ( !parser.matchString( tag.close ) ) {
  		parser.error( ("expected legal partial name") );
  	}

  	var yielder = { t: YIELDER };
  	if ( name ) yielder.n = name;

  	return yielder;
  }

  function readClosing ( parser, tag ) {
  	var start, remaining, index, closing;

  	start = parser.pos;

  	if ( !parser.matchString( tag.open ) ) {
  		return null;
  	}

  	parser.allowWhitespace();

  	if ( !parser.matchString( '/' ) ) {
  		parser.pos = start;
  		return null;
  	}

  	parser.allowWhitespace();

  	remaining = parser.remaining();
  	index = remaining.indexOf( tag.close );

  	if ( index !== -1 ) {
  		closing = {
  			t: CLOSING,
  			r: remaining.substr( 0, index ).split( ' ' )[0]
  		};

  		parser.pos += index;

  		if ( !parser.matchString( tag.close ) ) {
  			parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );
  		}

  		return closing;
  	}

  	parser.pos = start;
  	return null;
  }

  var elsePattern = /^\s*else\s*/;

  function readElse ( parser, tag ) {
  	var start = parser.pos;

  	if ( !parser.matchString( tag.open ) ) {
  		return null;
  	}

  	if ( !parser.matchPattern( elsePattern ) ) {
  		parser.pos = start;
  		return null;
  	}

  	if ( !parser.matchString( tag.close ) ) {
  		parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );
  	}

  	return {
  		t: ELSE
  	};
  }

  var elsePattern$1 = /^\s*elseif\s+/;

  function readElseIf ( parser, tag ) {
  	var start = parser.pos;

  	if ( !parser.matchString( tag.open ) ) {
  		return null;
  	}

  	if ( !parser.matchPattern( elsePattern$1 ) ) {
  		parser.pos = start;
  		return null;
  	}

  	var expression = readExpression( parser );

  	if ( !parser.matchString( tag.close ) ) {
  		parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );
  	}

  	return {
  		t: ELSEIF,
  		x: expression
  	};
  }

  var handlebarsBlockCodes = {
  	'each':    SECTION_EACH,
  	'if':      SECTION_IF,
  	'with':    SECTION_IF_WITH,
  	'unless':  SECTION_UNLESS
  };

  var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;
  var keyIndexRefPattern = /^\s*,\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;
  var handlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\b' );
  function readSection ( parser, tag ) {
  	var start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose, aliasOnly = false;

  	start = parser.pos;

  	if ( parser.matchString( '^' ) ) {
  		section = { t: SECTION, f: [], n: SECTION_UNLESS };
  	} else if ( parser.matchString( '#' ) ) {
  		section = { t: SECTION, f: [] };

  		if ( parser.matchString( 'partial' ) ) {
  			parser.pos = start - parser.standardDelimiters[0].length;
  			parser.error( 'Partial definitions can only be at the top level of the template, or immediately inside components' );
  		}

  		if ( block = parser.matchPattern( handlebarsBlockPattern ) ) {
  			expectedClose = block;
  			section.n = handlebarsBlockCodes[ block ];
  		}
  	} else {
  		return null;
  	}

  	parser.allowWhitespace();

  	if ( block === 'with' ) {
  		var aliases = readAliases( parser );
  		if ( aliases ) {
  			aliasOnly = true;
  			section.z = aliases;
  			section.t = ALIAS;
  		}
  	} else if ( block === 'each' ) {
  		var alias = readAlias( parser );
  		if ( alias ) {
  			section.z = [ { n: alias.n, x: { r: '.' } } ];
  			expression = alias.x;
  		}
  	}

  	if ( !aliasOnly ) {
  		if ( !expression ) expression = readExpression( parser );

  		if ( !expression ) {
  			parser.error( 'Expected expression' );
  		}

  		// optional index and key references
  		if ( i = parser.matchPattern( indexRefPattern ) ) {
  			var extra;

  			if ( extra = parser.matchPattern( keyIndexRefPattern ) ) {
  				section.i = i + ',' + extra;
  			} else {
  				section.i = i;
  			}
  		}
  	}

  	parser.allowWhitespace();

  	if ( !parser.matchString( tag.close ) ) {
  		parser.error( ("Expected closing delimiter '" + (tag.close) + "'") );
  	}

  	parser.sectionDepth += 1;
  	children = section.f;

  	conditions = [];

  	var pos;
  	do {
  		pos = parser.pos;
  		if ( child = readClosing( parser, tag ) ) {
  			if ( expectedClose && child.r !== expectedClose ) {
  				parser.pos = pos;
  				parser.error( ("Expected " + (tag.open) + "/" + expectedClose + "" + (tag.close)) );
  			}

  			parser.sectionDepth -= 1;
  			closed = true;
  		}

  		else if ( !aliasOnly && ( child = readElseIf( parser, tag ) ) ) {
  			if ( section.n === SECTION_UNLESS ) {
  				parser.error( '{{else}} not allowed in {{#unless}}' );
  			}

  			if ( hasElse ) {
  				parser.error( 'illegal {{elseif...}} after {{else}}' );
  			}

  			if ( !unlessBlock ) {
  				unlessBlock = [];
  			}

  			var mustache = {
  				t: SECTION,
  				n: SECTION_IF,
  				f: children = []
  			};
  			refineExpression( child.x, mustache );

  			unlessBlock.push( mustache );
  		}

  		else if ( !aliasOnly && ( child = readElse( parser, tag ) ) ) {
  			if ( section.n === SECTION_UNLESS ) {
  				parser.error( '{{else}} not allowed in {{#unless}}' );
  			}

  			if ( hasElse ) {
  				parser.error( 'there can only be one {{else}} block, at the end of a section' );
  			}

  			hasElse = true;

  			// use an unless block if there's no elseif
  			if ( !unlessBlock ) {
  				unlessBlock = [];
  			}

  			unlessBlock.push({
  				t: SECTION,
  				n: SECTION_UNLESS,
  				f: children = []
  			});
  		}

  		else {
  			child = parser.read( READERS );

  			if ( !child ) {
  				break;
  			}

  			children.push( child );
  		}
  	} while ( !closed );

  	if ( unlessBlock ) {
  		section.l = unlessBlock;
  	}

  	if ( !aliasOnly ) {
  		refineExpression( expression, section );
  	}

  	// TODO if a section is empty it should be discarded. Don't do
  	// that here though - we need to clean everything up first, as
  	// it may contain removeable whitespace. As a temporary measure,
  	// to pass the existing tests, remove empty `f` arrays
  	if ( !section.f.length ) {
  		delete section.f;
  	}

  	return section;
  }

  var OPEN_COMMENT = '<!--';
  var CLOSE_COMMENT = '-->';
  function readHtmlComment ( parser ) {
  	var start, content, remaining, endIndex, comment;

  	start = parser.pos;

  	if ( parser.textOnlyMode || !parser.matchString( OPEN_COMMENT ) ) {
  		return null;
  	}

  	remaining = parser.remaining();
  	endIndex = remaining.indexOf( CLOSE_COMMENT );

  	if ( endIndex === -1 ) {
  		parser.error( 'Illegal HTML - expected closing comment sequence (\'-->\')' );
  	}

  	content = remaining.substr( 0, endIndex );
  	parser.pos += endIndex + 3;

  	comment = {
  		t: COMMENT,
  		c: content
  	};

  	if ( parser.includeLinePositions ) {
  		comment.p = parser.getLinePos( start );
  	}

  	return comment;
  }

  var leadingLinebreak = /^[ \t\f\r\n]*\r?\n/;
  var trailingLinebreak = /\r?\n[ \t\f\r\n]*$/;
  function stripStandalones ( items ) {
  	var i, current, backOne, backTwo, lastSectionItem;

  	for ( i=1; i<items.length; i+=1 ) {
  		current = items[i];
  		backOne = items[i-1];
  		backTwo = items[i-2];

  		// if we're at the end of a [text][comment][text] sequence...
  		if ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {

  			// ... and the comment is a standalone (i.e. line breaks either side)...
  			if ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {

  				// ... then we want to remove the whitespace after the first line break
  				items[i-2] = backTwo.replace( trailingLinebreak, '\n' );

  				// and the leading line break of the second text token
  				items[i] = current.replace( leadingLinebreak, '' );
  			}
  		}

  		// if the current item is a section, and it is preceded by a linebreak, and
  		// its first item is a linebreak...
  		if ( isSection( current ) && isString( backOne ) ) {
  			if ( trailingLinebreak.test( backOne ) && isString( current.f[0] ) && leadingLinebreak.test( current.f[0] ) ) {
  				items[i-1] = backOne.replace( trailingLinebreak, '\n' );
  				current.f[0] = current.f[0].replace( leadingLinebreak, '' );
  			}
  		}

  		// if the last item was a section, and it is followed by a linebreak, and
  		// its last item is a linebreak...
  		if ( isString( current ) && isSection( backOne ) ) {
  			lastSectionItem = lastItem( backOne.f );

  			if ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {
  				backOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\n' );
  				items[i] = current.replace( leadingLinebreak, '' );
  			}
  		}
  	}

  	return items;
  }

  function isString ( item ) {
  	return typeof item === 'string';
  }

  function isComment ( item ) {
  	return item.t === COMMENT || item.t === DELIMCHANGE;
  }

  function isSection ( item ) {
  	return ( item.t === SECTION || item.t === INVERTED ) && item.f;
  }

  function trimWhitespace ( items, leadingPattern, trailingPattern ) {
  	var item;

  	if ( leadingPattern ) {
  		item = items[0];
  		if ( typeof item === 'string' ) {
  			item = item.replace( leadingPattern, '' );

  			if ( !item ) {
  				items.shift();
  			} else {
  				items[0] = item;
  			}
  		}
  	}

  	if ( trailingPattern ) {
  		item = lastItem( items );
  		if ( typeof item === 'string' ) {
  			item = item.replace( trailingPattern, '' );

  			if ( !item ) {
  				items.pop();
  			} else {
  				items[ items.length - 1 ] = item;
  			}
  		}
  	}
  }

  var contiguousWhitespace = /[ \t\f\r\n]+/g;
  var preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;
  var leadingWhitespace$1 = /^[ \t\f\r\n]+/;
  var trailingWhitespace = /[ \t\f\r\n]+$/;
  var leadingNewLine = /^(?:\r\n|\r|\n)/;
  var trailingNewLine = /(?:\r\n|\r|\n)$/;

  function cleanup ( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace ) {
  	if ( typeof items === 'string' ) return;

  	var i,
  		item,
  		previousItem,
  		nextItem,
  		preserveWhitespaceInsideFragment,
  		removeLeadingWhitespaceInsideFragment,
  		removeTrailingWhitespaceInsideFragment,
  		key;

  	// First pass - remove standalones and comments etc
  	stripStandalones( items );

  	i = items.length;
  	while ( i-- ) {
  		item = items[i];

  		// Remove delimiter changes, unsafe elements etc
  		if ( item.exclude ) {
  			items.splice( i, 1 );
  		}

  		// Remove comments, unless we want to keep them
  		else if ( stripComments && item.t === COMMENT ) {
  			items.splice( i, 1 );
  		}
  	}

  	// If necessary, remove leading and trailing whitespace
  	trimWhitespace( items, removeLeadingWhitespace ? leadingWhitespace$1 : null, removeTrailingWhitespace ? trailingWhitespace : null );

  	i = items.length;
  	while ( i-- ) {
  		item = items[i];

  		// Recurse
  		if ( item.f ) {
  			var isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test( item.e );
  			preserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;

  			if ( !preserveWhitespace && isPreserveWhitespaceElement ) {
  				trimWhitespace( item.f, leadingNewLine, trailingNewLine );
  			}

  			if ( !preserveWhitespaceInsideFragment ) {
  				previousItem = items[ i - 1 ];
  				nextItem = items[ i + 1 ];

  				// if the previous item was a text item with trailing whitespace,
  				// remove leading whitespace inside the fragment
  				if ( !previousItem || ( typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) ) {
  					removeLeadingWhitespaceInsideFragment = true;
  				}

  				// and vice versa
  				if ( !nextItem || ( typeof nextItem === 'string' && leadingWhitespace$1.test( nextItem ) ) ) {
  					removeTrailingWhitespaceInsideFragment = true;
  				}
  			}

  			cleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );

  			// clean up name templates (events, decorators, etc)
  			if ( isArray( item.f.n ) ) {
  				cleanup( item.f.n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespace );
  			}

  			// clean up arg templates (events, decorators, etc)
  			if ( isArray( item.f.d ) ) {
  				cleanup( item.f.d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespace );
  			}
  		}

  		// Split if-else blocks into two (an if, and an unless)
  		if ( item.l ) {
  			cleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );

  			item.l.forEach( function ( s ) { return s.l = 1; } );
  			item.l.unshift( i + 1, 0 );
  			items.splice.apply( items, item.l );
  			delete item.l; // TODO would be nice if there was a way around this
  		}

  		// Clean up element attributes
  		if ( item.a ) {
  			for ( key in item.a ) {
  				if ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {
  					cleanup( item.a[ key ], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );
  				}
  			}
  		}
  		// Clean up conditional attributes
  		if ( item.m ) {
  			cleanup( item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );
  			if ( item.m.length < 1 ) delete item.m;
  		}
  	}

  	// final pass - fuse text nodes together
  	i = items.length;
  	while ( i-- ) {
  		if ( typeof items[i] === 'string' ) {
  			if ( typeof items[i+1] === 'string' ) {
  				items[i] = items[i] + items[i+1];
  				items.splice( i + 1, 1 );
  			}

  			if ( !preserveWhitespace ) {
  				items[i] = items[i].replace( contiguousWhitespace, ' ' );
  			}

  			if ( items[i] === '' ) {
  				items.splice( i, 1 );
  			}
  		}
  	}
  }

  var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;

  function readClosingTag ( parser ) {
  	var start, tag;

  	start = parser.pos;

  	// are we looking at a closing tag?
  	if ( !parser.matchString( '</' ) ) {
  		return null;
  	}

  	if ( tag = parser.matchPattern( closingTagPattern ) ) {
  		if ( parser.inside && tag !== parser.inside ) {
  			parser.pos = start;
  			return null;
  		}

  		return {
  			t: CLOSING_TAG,
  			e: tag
  		};
  	}

  	// We have an illegal closing tag, report it
  	parser.pos -= 2;
  	parser.error( 'Illegal closing tag' );
  }

  var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
  var validTagNameFollower = /^[\s\n\/>]/;
  var exclude = { exclude: true };
  var disallowedContents;
  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
  disallowedContents = {
  	li: [ 'li' ],
  	dt: [ 'dt', 'dd' ],
  	dd: [ 'dt', 'dd' ],
  	p: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),
  	rt: [ 'rt', 'rp' ],
  	rp: [ 'rt', 'rp' ],
  	optgroup: [ 'optgroup' ],
  	option: [ 'option', 'optgroup' ],
  	thead: [ 'tbody', 'tfoot' ],
  	tbody: [ 'tbody', 'tfoot' ],
  	tfoot: [ 'tbody' ],
  	tr: [ 'tr', 'tbody' ],
  	td: [ 'td', 'th', 'tr' ],
  	th: [ 'td', 'th', 'tr' ]
  };

  function readElement ( parser ) {
  	var start,
  		element,
  		attribute,
  		selfClosing,
  		children,
  		partials,
  		hasPartials,
  		child,
  		closed,
  		pos,
  		remaining,
  		closingTag;

  	start = parser.pos;

  	if ( parser.inside || parser.inAttribute || parser.textOnlyMode ) {
  		return null;
  	}

  	if ( !parser.matchString( '<' ) ) {
  		return null;
  	}

  	// if this is a closing tag, abort straight away
  	if ( parser.nextChar() === '/' ) {
  		return null;
  	}

  	element = {};
  	if ( parser.includeLinePositions ) {
  		element.p = parser.getLinePos( start );
  	}

  	if ( parser.matchString( '!' ) ) {
  		element.t = DOCTYPE;
  		if ( !parser.matchPattern( /^doctype/i ) ) {
  			parser.error( 'Expected DOCTYPE declaration' );
  		}

  		element.a = parser.matchPattern( /^(.+?)>/ );
  		return element;
  	}

  	element.t = ELEMENT;

  	// element name
  	element.e = parser.matchPattern( tagNamePattern );
  	if ( !element.e ) {
  		return null;
  	}

  	// next character must be whitespace, closing solidus or '>'
  	if ( !validTagNameFollower.test( parser.nextChar() ) ) {
  		parser.error( 'Illegal tag name' );
  	}

  	parser.allowWhitespace();

  	parser.inTag = true;

  	// directives and attributes
  	while ( attribute = readMustache( parser ) ) {
  		if ( attribute !== false ) {
  			if ( !element.m ) element.m = [];
  			element.m.push( attribute );
  		}

  		parser.allowWhitespace();
  	}

  	parser.inTag = false;

  	// allow whitespace before closing solidus
  	parser.allowWhitespace();

  	// self-closing solidus?
  	if ( parser.matchString( '/' ) ) {
  		selfClosing = true;
  	}

  	// closing angle bracket
  	if ( !parser.matchString( '>' ) ) {
  		return null;
  	}

  	var lowerCaseName = element.e.toLowerCase();
  	var preserveWhitespace = parser.preserveWhitespace;

  	if ( !selfClosing && !voidElementNames.test( element.e ) ) {
  		parser.elementStack.push( lowerCaseName );

  		// Special case - if we open a script element, further tags should
  		// be ignored unless they're a closing script element
  		if ( lowerCaseName === 'script' || lowerCaseName === 'style' || lowerCaseName === 'textarea' ) {
  			parser.inside = lowerCaseName;
  		}

  		children = [];
  		partials = create( null );

  		do {
  			pos = parser.pos;
  			remaining = parser.remaining();

  			if ( !remaining ) {
  				parser.error( ("Missing end " + (parser.elementStack.length > 1 ? 'tags' : 'tag') + " (" + (parser.elementStack.reverse().map( function ( x ) { return ("</" + x + ">"); } ).join( '' )) + ")") );
  			}

  			// if for example we're in an <li> element, and we see another
  			// <li> tag, close the first so they become siblings
  			if ( !canContain( lowerCaseName, remaining ) ) {
  				closed = true;
  			}

  			// closing tag
  			else if ( closingTag = readClosingTag( parser ) ) {
  				closed = true;

  				var closingTagName = closingTag.e.toLowerCase();

  				// if this *isn't* the closing tag for the current element...
  				if ( closingTagName !== lowerCaseName ) {
  					// rewind parser
  					parser.pos = pos;

  					// if it doesn't close a parent tag, error
  					if ( !~parser.elementStack.indexOf( closingTagName ) ) {
  						var errorMessage = 'Unexpected closing tag';

  						// add additional help for void elements, since component names
  						// might clash with them
  						if ( voidElementNames.test( closingTagName ) ) {
  							errorMessage += " (<" + closingTagName + "> is a void element - it cannot contain children)";
  						}

  						parser.error( errorMessage );
  					}
  				}
  			}

  			// implicit close by closing section tag. TODO clean this up
  			else if ( child = readClosing( parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] } ) ) {
  				closed = true;
  				parser.pos = pos;
  			}

  			else {
  				if ( child = parser.read( PARTIAL_READERS ) ) {
  					if ( partials[ child.n ] ) {
  						parser.pos = pos;
  						parser.error( 'Duplicate partial definition' );
  					}

  					cleanup( child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );

  					partials[ child.n ] = child.f;
  					hasPartials = true;
  				}

  				else {
  					if ( child = parser.read( READERS ) ) {
  						children.push( child );
  					} else {
  						closed = true;
  					}
  				}
  			}
  		} while ( !closed );

  		if ( children.length ) {
  			element.f = children;
  		}

  		if ( hasPartials ) {
  			element.p = partials;
  		}

  		parser.elementStack.pop();
  	}

  	parser.inside = null;

  	if ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {
  		return exclude;
  	}

  	return element;
  }

  function canContain ( name, remaining ) {
  	var match, disallowed;

  	match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );
  	disallowed = disallowedContents[ name ];

  	if ( !match || !disallowed ) {
  		return true;
  	}

  	return !~disallowed.indexOf( match[1].toLowerCase() );
  }

  function readText ( parser ) {
  	var index, remaining, disallowed, barrier;

  	remaining = parser.remaining();

  	if ( parser.textOnlyMode ) {
  		disallowed = parser.tags.map( function ( t ) { return t.open; } );
  		disallowed = disallowed.concat( parser.tags.map( function ( t ) { return '\\' + t.open; } ) );

  		index = getLowestIndex( remaining, disallowed );
  	} else {
  		barrier = parser.inside ? '</' + parser.inside : '<';

  		if ( parser.inside && !parser.interpolate[ parser.inside ] ) {
  			index = remaining.indexOf( barrier );
  		} else {
  			disallowed = parser.tags.map( function ( t ) { return t.open; } );
  			disallowed = disallowed.concat( parser.tags.map( function ( t ) { return '\\' + t.open; } ) );

  			// http://developers.whatwg.org/syntax.html#syntax-attributes
  			if ( parser.inAttribute === true ) {
  				// we're inside an unquoted attribute value
  				disallowed.push( ("\""), ("'"), ("="), ("<"), (">"), '`' );
  			} else if ( parser.inAttribute ) {
  				// quoted attribute value
  				disallowed.push( parser.inAttribute );
  			} else {
  				disallowed.push( barrier );
  			}

  			index = getLowestIndex( remaining, disallowed );
  		}
  	}

  	if ( !index ) {
  		return null;
  	}

  	if ( index === -1 ) {
  		index = remaining.length;
  	}

  	parser.pos += index;

  	if ( ( parser.inside && parser.inside !== 'textarea' ) || parser.textOnlyMode ) {
  		return remaining.substr( 0, index );
  	} else {
  		return decodeCharacterReferences( remaining.substr( 0, index ) );
  	}
  }

  var startPattern = /^<!--\s*/;
  var namePattern$1 = /s*>\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\s*/;
  var finishPattern = /\s*-->/;

  function readPartialDefinitionComment ( parser ) {
  	var start = parser.pos;
  	var open = parser.standardDelimiters[0];
  	var close = parser.standardDelimiters[1];

  	if ( !parser.matchPattern( startPattern ) || !parser.matchString( open ) ) {
  		parser.pos = start;
  		return null;
  	}

  	var name = parser.matchPattern( namePattern$1 );

  	warnOnceIfDebug( ("Inline partial comments are deprecated.\nUse this...\n  {{#partial " + name + "}} ... {{/partial}}\n\n...instead of this:\n  <!-- {{>" + name + "}} --> ... <!-- {{/" + name + "}} -->'") );

  	// make sure the rest of the comment is in the correct place
  	if ( !parser.matchString( close ) || !parser.matchPattern( finishPattern ) ) {
  		parser.pos = start;
  		return null;
  	}

  	var content = [];
  	var closed;

  	var endPattern = new RegExp('^<!--\\s*' + escapeRegExp( open ) + '\\s*\\/\\s*' + name + '\\s*' + escapeRegExp( close ) + '\\s*-->');

  	do {
  		if ( parser.matchPattern( endPattern ) ) {
  			closed = true;
  		}

  		else {
  			var child = parser.read( READERS );
  			if ( !child ) {
  				parser.error( ("expected closing comment ('<!-- " + open + "/" + name + "" + close + " -->')") );
  			}

  			content.push( child );
  		}
  	} while ( !closed );

  	return {
  		t: INLINE_PARTIAL,
  		f: content,
  		n: name
  	};
  }

  var partialDefinitionSectionPattern = /^\s*#\s*partial\s+/;

  function readPartialDefinitionSection ( parser ) {
  	var start, name, content, child, closed;

  	start = parser.pos;

  	var delimiters = parser.standardDelimiters;

  	if ( !parser.matchString( delimiters[0] ) ) {
  		return null;
  	}

  	if ( !parser.matchPattern( partialDefinitionSectionPattern ) ) {
  		parser.pos = start;
  		return null;
  	}

  	name = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\-\/]*/ );

  	if ( !name ) {
  		parser.error( 'expected legal partial name' );
  	}

  	parser.allowWhitespace();
  	if ( !parser.matchString( delimiters[1] ) ) {
  		parser.error( ("Expected closing delimiter '" + (delimiters[1]) + "'") );
  	}

  	content = [];

  	do {
  		// TODO clean this up
  		if ( child = readClosing( parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] }) ) {
  			if ( !child.r === 'partial' ) {
  				parser.error( ("Expected " + (delimiters[0]) + "/partial" + (delimiters[1])) );
  			}

  			closed = true;
  		}

  		else {
  			child = parser.read( READERS );

  			if ( !child ) {
  				parser.error( ("Expected " + (delimiters[0]) + "/partial" + (delimiters[1])) );
  			}

  			content.push( child );
  		}
  	} while ( !closed );

  	return {
  		t: INLINE_PARTIAL,
  		n: name,
  		f: content
  	};
  }

  function readTemplate ( parser ) {
  	var fragment = [];
  	var partials = create( null );
  	var hasPartials = false;

  	var preserveWhitespace = parser.preserveWhitespace;

  	while ( parser.pos < parser.str.length ) {
  		var pos = parser.pos, item, partial;

  		if ( partial = parser.read( PARTIAL_READERS ) ) {
  			if ( partials[ partial.n ] ) {
  				parser.pos = pos;
  				parser.error( 'Duplicated partial definition' );
  			}

  			cleanup( partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );

  			partials[ partial.n ] = partial.f;
  			hasPartials = true;
  		} else if ( item = parser.read( READERS ) ) {
  			fragment.push( item );
  		} else  {
  			parser.error( 'Unexpected template content' );
  		}
  	}

  	var result = {
  		v: TEMPLATE_VERSION,
  		t: fragment
  	};

  	if ( hasPartials ) {
  		result.p = partials;
  	}

  	return result;
  }

  function insertExpressions ( obj, expr ) {

  	Object.keys( obj ).forEach( function ( key ) {
  		if  ( isExpression( key, obj ) ) return addTo( obj, expr );

  		var ref = obj[ key ];
  		if ( hasChildren( ref ) ) insertExpressions( ref, expr );
   	});
  }

  function isExpression( key, obj ) {
  	return key === 's' && isArray( obj.r );
  }

  function addTo( obj, expr ) {
  	var s = obj.s, r = obj.r;
  	if ( !expr[ s ] ) expr[ s ] = fromExpression( s, r.length );
  }

  function hasChildren( ref ) {
  	return isArray( ref ) || isObject( ref );
  }

  // See https://github.com/ractivejs/template-spec for information
  // about the Ractive template specification

  var STANDARD_READERS = [ readPartial, readUnescaped, readSection, readYielder, readInterpolator, readComment ];
  var TRIPLE_READERS = [ readTriple ];
  var STATIC_READERS = [ readUnescaped, readSection, readInterpolator ]; // TODO does it make sense to have a static section?

  var StandardParser;

  function parse ( template, options ) {
  	return new StandardParser( template, options || {} ).result;
  }

  parse.computedStrings = function( computed ) {
  	if ( !computed ) return [];

  	Object.keys( computed ).forEach( function ( key ) {
  		var value = computed[ key ];
  		if ( typeof value === 'string' ) {
  			computed[ key ] = fromComputationString( value );
  		}
  	});
  };


  var READERS = [ readMustache, readHtmlComment, readElement, readText ];
  var PARTIAL_READERS = [ readPartialDefinitionComment, readPartialDefinitionSection ];

  StandardParser = Parser$1.extend({
  	init: function ( str, options ) {
  		var tripleDelimiters = options.tripleDelimiters || [ '{{{', '}}}' ],
  			staticDelimiters = options.staticDelimiters || [ '[[', ']]' ],
  			staticTripleDelimiters = options.staticTripleDelimiters || [ '[[[', ']]]' ];

  		this.standardDelimiters = options.delimiters || [ '{{', '}}' ];

  		this.tags = [
  			{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS },
  			{ isStatic: false, isTriple: true,  open: tripleDelimiters[0],        close: tripleDelimiters[1],        readers: TRIPLE_READERS },
  			{ isStatic: true,  isTriple: false, open: staticDelimiters[0],        close: staticDelimiters[1],        readers: STATIC_READERS },
  			{ isStatic: true,  isTriple: true,  open: staticTripleDelimiters[0],  close: staticTripleDelimiters[1],  readers: TRIPLE_READERS }
  		];

  		this.contextLines = options.contextLines || 0;

  		this.sortMustacheTags();

  		this.sectionDepth = 0;
  		this.elementStack = [];

  		this.interpolate = {
  			script: !options.interpolate || options.interpolate.script !== false,
  			style: !options.interpolate || options.interpolate.style !== false,
  			textarea: true
  		};

  		if ( options.sanitize === true ) {
  			options.sanitize = {
  				// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json
  				elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),
  				eventAttributes: true
  			};
  		}

  		this.stripComments = options.stripComments !== false;
  		this.preserveWhitespace = options.preserveWhitespace;
  		this.sanitizeElements = options.sanitize && options.sanitize.elements;
  		this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;
  		this.includeLinePositions = options.includeLinePositions;
  		this.textOnlyMode = options.textOnlyMode;
  		this.csp = options.csp;
  	},

  	postProcess: function ( result ) {
  		// special case - empty string
  		if ( !result.length ) {
  			return { t: [], v: TEMPLATE_VERSION };
  		}

  		if ( this.sectionDepth > 0 ) {
  			this.error( 'A section was left open' );
  		}

  		cleanup( result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace );

  		if ( this.csp !== false ) {
  			var expr = {};
  			insertExpressions( result[0].t, expr );
  			if ( Object.keys( expr ).length ) result[0].e = expr;
  		}

  		return result[0];
  	},

  	converters: [
  		readTemplate
  	],

  	sortMustacheTags: function () {
  		// Sort in order of descending opening delimiter length (longer first),
  		// to protect against opening delimiters being substrings of each other
  		this.tags.sort( function ( a, b ) {
  			return b.open.length - a.open.length;
  		});
  	}
  });

  var parseOptions = [
  	'delimiters',
  	'tripleDelimiters',
  	'staticDelimiters',
  	'staticTripleDelimiters',
  	'csp',
  	'interpolate',
  	'preserveWhitespace',
  	'sanitize',
  	'stripComments',
  	'contextLines'
  ];

  var TEMPLATE_INSTRUCTIONS = "Either preparse or use a ractive runtime source that includes the parser. ";

  var COMPUTATION_INSTRUCTIONS = "Either use:\n\n\tRactive.parse.computedStrings( component.computed )\n\nat build time to pre-convert the strings to functions, or use functions instead of strings in computed properties.";


  function throwNoParse ( method, error, instructions ) {
  	if ( !method ) {
  		fatal( ("Missing Ractive.parse - cannot parse " + error + ". " + instructions) );
  	}
  }

  function createFunction ( body, length ) {
  	throwNoParse( fromExpression, 'new expression function', TEMPLATE_INSTRUCTIONS );
  	return fromExpression( body, length );
  }

  function createFunctionFromString ( str, bindTo ) {
  	throwNoParse( fromComputationString, 'compution string "${str}"', COMPUTATION_INSTRUCTIONS );
  	return fromComputationString( str, bindTo );
  }

  var parser = {

  	fromId: function ( id, options ) {
  		if ( !doc ) {
  			if ( options && options.noThrow ) { return; }
  			throw new Error( ("Cannot retrieve template #" + id + " as Ractive is not running in a browser.") );
  		}

  		if ( id ) id = id.replace( /^#/, '' );

  		var template;

  		if ( !( template = doc.getElementById( id ) )) {
  			if ( options && options.noThrow ) { return; }
  			throw new Error( ("Could not find template element with id #" + id) );
  		}

  		if ( template.tagName.toUpperCase() !== 'SCRIPT' ) {
  			if ( options && options.noThrow ) { return; }
  			throw new Error( ("Template element with id #" + id + ", must be a <script> element") );
  		}

  		return ( 'textContent' in template ? template.textContent : template.innerHTML );

  	},

  	isParsed: function ( template) {
  		return !( typeof template === 'string' );
  	},

  	getParseOptions: function ( ractive ) {
  		// Could be Ractive or a Component
  		if ( ractive.defaults ) { ractive = ractive.defaults; }

  		return parseOptions.reduce( function ( val, key ) {
  			val[ key ] = ractive[ key ];
  			return val;
  		}, {});
  	},

  	parse: function ( template, options ) {
  		throwNoParse( parse, 'template', TEMPLATE_INSTRUCTIONS );
  		var parsed = parse( template, options );
  		addFunctions( parsed );
  		return parsed;
  	},

  	parseFor: function( template, ractive ) {
  		return this.parse( template, this.getParseOptions( ractive ) );
  	}
  };

  var templateConfigurator = {
  	name: 'template',

  	extend: function ( Parent, proto, options ) {
  		// only assign if exists
  		if ( 'template' in options ) {
  			var template = options.template;

  			if ( typeof template === 'function' ) {
  				proto.template = template;
  			} else {
  				proto.template = parseTemplate( template, proto );
  			}
  		}
  	},

  	init: function ( Parent, ractive, options ) {
  		// TODO because of prototypal inheritance, we might just be able to use
  		// ractive.template, and not bother passing through the Parent object.
  		// At present that breaks the test mocks' expectations
  		var template = 'template' in options ? options.template : Parent.prototype.template;
  		template = template || { v: TEMPLATE_VERSION, t: [] };

  		if ( typeof template === 'function' ) {
  			var fn = template;
  			template = getDynamicTemplate( ractive, fn );

  			ractive._config.template = {
  				fn: fn,
  				result: template
  			};
  		}

  		template = parseTemplate( template, ractive );

  		// TODO the naming of this is confusing - ractive.template refers to [...],
  		// but Component.prototype.template refers to {v:1,t:[],p:[]}...
  		// it's unnecessary, because the developer never needs to access
  		// ractive.template
  		ractive.template = template.t;

  		if ( template.p ) {
  			extendPartials( ractive.partials, template.p );
  		}
  	},

  	reset: function ( ractive ) {
  		var result = resetValue( ractive );

  		if ( result ) {
  			var parsed = parseTemplate( result, ractive );

  			ractive.template = parsed.t;
  			extendPartials( ractive.partials, parsed.p, true );

  			return true;
  		}
  	}
  };

  function resetValue ( ractive ) {
  	var initial = ractive._config.template;

  	// If this isn't a dynamic template, there's nothing to do
  	if ( !initial || !initial.fn ) {
  		return;
  	}

  	var result = getDynamicTemplate( ractive, initial.fn );

  	// TODO deep equality check to prevent unnecessary re-rendering
  	// in the case of already-parsed templates
  	if ( result !== initial.result ) {
  		initial.result = result;
  		return result;
  	}
  }

  function getDynamicTemplate ( ractive, fn ) {
  	return fn.call( ractive, {
  		fromId: parser.fromId,
  		isParsed: parser.isParsed,
  		parse: function ( template, options ) {
  			if ( options === void 0 ) options = parser.getParseOptions( ractive );

  			return parser.parse( template, options );
  		}
  	});
  }

  function parseTemplate ( template, ractive ) {
  	if ( typeof template === 'string' ) {
  		// parse will validate and add expression functions
  		template = parseAsString( template, ractive );
  	}
  	else {
  		// need to validate and add exp for already parsed template
  		validate$1( template );
  		addFunctions( template );
  	}

  	return template;
  }

  function parseAsString ( template, ractive ) {
  	// ID of an element containing the template?
  	if ( template[0] === '#' ) {
  		template = parser.fromId( template );
  	}

  	return parser.parseFor( template, ractive );
  }

  function validate$1( template ) {

  	// Check that the template even exists
  	if ( template == undefined ) {
  		throw new Error( ("The template cannot be " + template + ".") );
  	}

  	// Check the parsed template has a version at all
  	else if ( typeof template.v !== 'number' ) {
  		throw new Error( 'The template parser was passed a non-string template, but the template doesn\'t have a version.  Make sure you\'re passing in the template you think you are.' );
  	}

  	// Check we're using the correct version
  	else if ( template.v !== TEMPLATE_VERSION ) {
  		throw new Error( ("Mismatched template version (expected " + TEMPLATE_VERSION + ", got " + (template.v) + ") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app") );
  	}
  }

  function extendPartials ( existingPartials, newPartials, overwrite ) {
  	if ( !newPartials ) return;

  	// TODO there's an ambiguity here - we need to overwrite in the `reset()`
  	// case, but not initially...

  	for ( var key in newPartials ) {
  		if ( overwrite || !existingPartials.hasOwnProperty( key ) ) {
  			existingPartials[ key ] = newPartials[ key ];
  		}
  	}
  }

  var registryNames = [
  	'adaptors',
  	'components',
  	'computed',
  	'decorators',
  	'easing',
  	'events',
  	'interpolators',
  	'partials',
  	'transitions'
  ];

  var Registry = function Registry ( name, useDefaults ) {
  	this.name = name;
  	this.useDefaults = useDefaults;
  };

  Registry.prototype.extend = function extend ( Parent, proto, options ) {
  	this.configure(
  		this.useDefaults ? Parent.defaults : Parent,
  		this.useDefaults ? proto : proto.constructor,
  		options );
  };

  Registry.prototype.init = function init () {
  	// noop
  };

  Registry.prototype.configure = function configure ( Parent, target, options ) {
  	var name = this.name;
  	var option = options[ name ];

  	var registry = create( Parent[name] );

  	for ( var key in option ) {
  		registry[ key ] = option[ key ];
  	}

  	target[ name ] = registry;
  };

  Registry.prototype.reset = function reset ( ractive ) {
  	var registry = ractive[ this.name ];
  	var changed = false;

  	Object.keys( registry ).forEach( function ( key ) {
  		var item = registry[ key ];
  			
  		if ( item._fn ) {
  			if ( item._fn.isOwner ) {
  				registry[key] = item._fn;
  			} else {
  				delete registry[key];
  			}
  			changed = true;
  		}
  	});

  	return changed;
  };

  var registries = registryNames.map( function ( name ) { return new Registry( name, name === 'computed' ); } );

  function wrap ( parent, name, method ) {
  	if ( !/_super/.test( method ) ) return method;

  	function wrapper () {
  		var superMethod = getSuperMethod( wrapper._parent, name );
  		var hasSuper = '_super' in this;
  		var oldSuper = this._super;

  		this._super = superMethod;

  		var result = method.apply( this, arguments );

  		if ( hasSuper ) {
  			this._super = oldSuper;
  		} else {
  			delete this._super;
  		}

  		return result;
  	}

  	wrapper._parent = parent;
  	wrapper._method = method;

  	return wrapper;
  }

  function getSuperMethod ( parent, name ) {
  	if ( name in parent ) {
  		var value = parent[ name ];

  		return typeof value === 'function' ?
  			value :
  			function () { return value; };
  	}

  	return noop;
  }

  function getMessage( deprecated, correct, isError ) {
  	return "options." + deprecated + " has been deprecated in favour of options." + correct + "."
  		+ ( isError ? (" You cannot specify both options, please use options." + correct + ".") : '' );
  }

  function deprecateOption ( options, deprecatedOption, correct ) {
  	if ( deprecatedOption in options ) {
  		if( !( correct in options ) ) {
  			warnIfDebug( getMessage( deprecatedOption, correct ) );
  			options[ correct ] = options[ deprecatedOption ];
  		} else {
  			throw new Error( getMessage( deprecatedOption, correct, true ) );
  		}
  	}
  }

  function deprecate ( options ) {
  	deprecateOption( options, 'beforeInit', 'onconstruct' );
  	deprecateOption( options, 'init', 'onrender' );
  	deprecateOption( options, 'complete', 'oncomplete' );
  	deprecateOption( options, 'eventDefinitions', 'events' );

  	// Using extend with Component instead of options,
  	// like Human.extend( Spider ) means adaptors as a registry
  	// gets copied to options. So we have to check if actually an array
  	if ( isArray( options.adaptors ) ) {
  		deprecateOption( options, 'adaptors', 'adapt' );
  	}
  }

  var custom = {
  	adapt: adaptConfigurator,
  	css: cssConfigurator,
  	data: dataConfigurator,
  	template: templateConfigurator
  };

  var defaultKeys = Object.keys( defaults );

  var isStandardKey = makeObj( defaultKeys.filter( function ( key ) { return !custom[ key ]; } ) );

  // blacklisted keys that we don't double extend
  var isBlacklisted = makeObj( defaultKeys.concat( registries.map( function ( r ) { return r.name; } ) ) );

  var order = [].concat(
  	defaultKeys.filter( function ( key ) { return !registries[ key ] && !custom[ key ]; } ),
  	registries,
  	//custom.data,
  	custom.template,
  	custom.css
  );

  var config = {
  	extend: function ( Parent, proto, options ) { return configure( 'extend', Parent, proto, options ); },

  	init: function ( Parent, ractive, options ) { return configure( 'init', Parent, ractive, options ); },

  	reset: function ( ractive ) {
  		return order.filter( function ( c ) {
  			return c.reset && c.reset( ractive );
  		}).map( function ( c ) { return c.name; } );
  	},

  	// this defines the order. TODO this isn't used anywhere in the codebase,
  	// only in the test suite - should get rid of it
  	order: order
  };

  function configure ( method, Parent, target, options ) {
  	deprecate( options );

  	for ( var key in options ) {
  		if ( isStandardKey.hasOwnProperty( key ) ) {
  			var value = options[ key ];

  			// warn the developer if they passed a function and ignore its value

  			// NOTE: we allow some functions on "el" because we duck type element lists
  			// and some libraries or ef'ed-up virtual browsers (phantomJS) return a
  			// function object as the result of querySelector methods
  			if ( key !== 'el' && typeof value === 'function' ) {
  				warnIfDebug( ("" + key + " is a Ractive option that does not expect a function and will be ignored"),
  					method === 'init' ? target : null );
  			}
  			else {
  				target[ key ] = value;
  			}
  		}
  	}

  	// disallow combination of `append` and `enhance`
  	if ( options.append && options.enhance ) {
  		throw new Error( 'Cannot use append and enhance at the same time' );
  	}

  	registries.forEach( function ( registry ) {
  		registry[ method ]( Parent, target, options );
  	});

  	adaptConfigurator[ method ]( Parent, target, options );
  	templateConfigurator[ method ]( Parent, target, options );
  	cssConfigurator[ method ]( Parent, target, options );

  	extendOtherMethods( Parent.prototype, target, options );
  }

  function extendOtherMethods ( parent, target, options ) {
  	for ( var key in options ) {
  		if ( !isBlacklisted[ key ] && options.hasOwnProperty( key ) ) {
  			var member = options[ key ];

  			// if this is a method that overwrites a method, wrap it:
  			if ( typeof member === 'function' ) {
  				member = wrap( parent, key, member );
  			}

  			target[ key ] = member;
  		}
  	}
  }

  function makeObj ( array ) {
  	var obj = {};
  	array.forEach( function ( x ) { return obj[x] = true; } );
  	return obj;
  }

  var shouldRerender = [ 'template', 'partials', 'components', 'decorators', 'events' ];

  var completeHook$1 = new Hook( 'complete' );
  var resetHook = new Hook( 'reset' );
  var renderHook$1 = new Hook( 'render' );
  var unrenderHook = new Hook( 'unrender' );

  function Ractive$reset ( data ) {
  	data = data || {};

  	if ( typeof data !== 'object' ) {
  		throw new Error( 'The reset method takes either no arguments, or an object containing new data' );
  	}

  	// TEMP need to tidy this up
  	data = dataConfigurator.init( this.constructor, this, { data: data });

  	var promise = runloop.start( this, true );

  	// If the root object is wrapped, try and use the wrapper's reset value
  	var wrapper = this.viewmodel.wrapper;
  	if ( wrapper && wrapper.reset ) {
  		if ( wrapper.reset( data ) === false ) {
  			// reset was rejected, we need to replace the object
  			this.viewmodel.set( data );
  		}
  	} else {
  		this.viewmodel.set( data );
  	}

  	// reset config items and track if need to rerender
  	var changes = config.reset( this );
  	var rerender;

  	var i = changes.length;
  	while ( i-- ) {
  		if ( shouldRerender.indexOf( changes[i] ) > -1 ) {
  			rerender = true;
  			break;
  		}
  	}

  	if ( rerender ) {
  		unrenderHook.fire( this );
  		this.fragment.resetTemplate( this.template );
  		renderHook$1.fire( this );
  		completeHook$1.fire( this );
  	}

  	runloop.end();

  	resetHook.fire( this, data );

  	return promise;
  }

  function collect( source, name, attr, dest ) {
  	source.forEach( function ( item ) {
  		// queue to rerender if the item is a partial and the current name matches
  		if ( item.type === PARTIAL && ( item.refName ===  name || item.name === name ) ) {
  			item.inAttribute = attr;
  			dest.push( item );
  			return; // go no further
  		}

  		// if it has a fragment, process its items
  		if ( item.fragment ) {
  			collect( item.fragment.iterations || item.fragment.items, name, attr, dest );
  		}

  		// or if it is itself a fragment, process its items
  		else if ( isArray( item.items ) ) {
  			collect( item.items, name, attr, dest );
  		}

  		// or if it is a component, step in and process its items
  		else if ( item.type === COMPONENT && item.instance ) {
  			// ...unless the partial is shadowed
  			if ( item.instance.partials[ name ] ) return;
  			collect( item.instance.fragment.items, name, attr, dest );
  		}

  		// if the item is an element, process its attributes too
  		if ( item.type === ELEMENT ) {
  			if ( isArray( item.attributes ) ) {
  				collect( item.attributes, name, true, dest );
  			}
  		}
  	});
  }

  function forceResetTemplate ( partial ) {
  	partial.forceResetTemplate();
  }

  function resetPartial ( name, partial ) {
  	var collection = [];
  	collect( this.fragment.items, name, false, collection );

  	var promise = runloop.start( this, true );

  	this.partials[ name ] = partial;
  	collection.forEach( forceResetTemplate );

  	runloop.end();

  	return promise;
  }

  var Item = function Item ( options ) {
  	this.parentFragment = options.parentFragment;
  	this.ractive = options.parentFragment.ractive;

  	this.template = options.template;
  	this.index = options.index;
  	this.type = options.template.t;

  	this.dirty = false;
  };

  Item.prototype.bubble = function bubble () {
  	if ( !this.dirty ) {
  		this.dirty = true;
  		this.parentFragment.bubble();
  	}
  };

  Item.prototype.destroyed = function destroyed () {
  	if ( this.fragment ) this.fragment.destroyed();
  };

  Item.prototype.find = function find () {
  	return null;
  };

  Item.prototype.findAll = function findAll () {
  	// noop
  };

  Item.prototype.findComponent = function findComponent () {
  	return null;
  };

  Item.prototype.findAllComponents = function findAllComponents () {
  	// noop;
  };

  Item.prototype.findNextNode = function findNextNode () {
  	return this.parentFragment.findNextNode( this );
  };

  Item.prototype.shuffled = function shuffled () {
  	if ( this.fragment ) this.fragment.shuffled();
  };

  Item.prototype.valueOf = function valueOf () {
  	return this.toString();
  };

  var ComputationChild = (function (Model) {
  	function ComputationChild () {
  		Model.apply(this, arguments);
  	}

  	ComputationChild.prototype = Object.create( Model && Model.prototype );
  	ComputationChild.prototype.constructor = ComputationChild;

  	ComputationChild.prototype.get = function get ( shouldCapture ) {
  		if ( shouldCapture ) capture( this );

  		var parentValue = this.parent.get();
  		return parentValue ? parentValue[ this.key ] : undefined;
  	};

  	ComputationChild.prototype.handleChange = function handleChange$1 () {
  		this.dirty = true;

  		this.links.forEach( marked );
  		this.deps.forEach( handleChange );
  		this.children.forEach( handleChange );
  		this.clearUnresolveds(); // TODO is this necessary?
  	};

  	ComputationChild.prototype.joinKey = function joinKey ( key ) {
  		if ( key === undefined || key === '' ) return this;

  		if ( !this.childByKey.hasOwnProperty( key ) ) {
  			var child = new ComputationChild( this, key );
  			this.children.push( child );
  			this.childByKey[ key ] = child;
  		}

  		return this.childByKey[ key ];
  	};

  	return ComputationChild;
  }(Model));

  function createResolver ( proxy, ref, index ) {
  	var resolver = proxy.fragment.resolve( ref, function ( model ) {
  		removeFromArray( proxy.resolvers, resolver );
  		proxy.models[ index ] = model;
  		proxy.bubble();
  	});

  	proxy.resolvers.push( resolver );
  }

  var ExpressionProxy = (function (Model) {
  	function ExpressionProxy ( fragment, template ) {
  		var this$1 = this;

  		Model.call( this, fragment.ractive.viewmodel, null );

  		this.fragment = fragment;
  		this.template = template;

  		this.isReadonly = true;
  		this.dirty = true;

  		this.fn = getFunction( template.s, template.r.length );

  		this.resolvers = [];
  		this.models = this.template.r.map( function ( ref, index ) {
  			var model = resolveReference( this$1.fragment, ref );

  			if ( !model ) {
  				createResolver( this$1, ref, index );
  			}

  			return model;
  		});
  		this.dependencies = [];

  		this.shuffle = undefined;

  		this.bubble();
  	}

  	ExpressionProxy.prototype = Object.create( Model && Model.prototype );
  	ExpressionProxy.prototype.constructor = ExpressionProxy;

  	ExpressionProxy.prototype.bubble = function bubble ( actuallyChanged ) {
  		// refresh the keypath
  		if ( actuallyChanged === void 0 ) actuallyChanged = true;

  		if ( this.registered ) delete this.root.expressions[ this.keypath ];
  		this.keypath = undefined;

  		if ( actuallyChanged ) {
  			this.dirty = true;
  			this.handleChange();
  		}
  	};

  	ExpressionProxy.prototype.get = function get ( shouldCapture ) {
  		if ( shouldCapture ) capture( this );

  		if ( this.dirty ) {
  			this.dirty = false;
  			this.value = this.getValue();
  			if ( this.wrapper ) this.newWrapperValue = this.value;
  			this.adapt();
  		}

  		return shouldCapture && this.wrapper ? this.wrapperValue : this.value;
  	};

  	ExpressionProxy.prototype.getKeypath = function getKeypath () {
  		var this$1 = this;

  		if ( !this.template ) return '@undefined';
  		if ( !this.keypath ) {
  			this.keypath = '@' + this.template.s.replace( /_(\d+)/g, function ( match, i ) {
  				if ( i >= this$1.models.length ) return match;

  				var model = this$1.models[i];
  				return model ? model.getKeypath() : '@undefined';
  			});

  			this.root.expressions[ this.keypath ] = this;
  			this.registered = true;
  		}

  		return this.keypath;
  	};

  	ExpressionProxy.prototype.getValue = function getValue () {
  		var this$1 = this;

  		startCapturing();
  		var result;

  		try {
  			var params = this.models.map( function ( m ) { return m ? m.get( true ) : undefined; } );
  			result = this.fn.apply( this.fragment.ractive, params );
  		} catch ( err ) {
  			warnIfDebug( ("Failed to compute " + (this.getKeypath()) + ": " + (err.message || err)) );
  		}

  		var dependencies = stopCapturing();
  		// remove missing deps
  		this.dependencies.filter( function ( d ) { return !~dependencies.indexOf( d ); } ).forEach( function ( d ) {
  			d.unregister( this$1 );
  			removeFromArray( this$1.dependencies, d );
  		});
  		// register new deps
  		dependencies.filter( function ( d ) { return !~this$1.dependencies.indexOf( d ); } ).forEach( function ( d ) {
  			d.register( this$1 );
  			this$1.dependencies.push( d );
  		});

  		return result;
  	};

  	ExpressionProxy.prototype.handleChange = function handleChange$1 () {
  		this.dirty = true;

  		this.links.forEach( marked );
  		this.deps.forEach( handleChange );
  		this.children.forEach( handleChange );

  		this.clearUnresolveds();
  	};

  	ExpressionProxy.prototype.joinKey = function joinKey ( key ) {
  		if ( key === undefined || key === '' ) return this;

  		if ( !this.childByKey.hasOwnProperty( key ) ) {
  			var child = new ComputationChild( this, key );
  			this.children.push( child );
  			this.childByKey[ key ] = child;
  		}

  		return this.childByKey[ key ];
  	};

  	ExpressionProxy.prototype.mark = function mark () {
  		this.handleChange();
  	};

  	ExpressionProxy.prototype.rebinding = function rebinding ( next, previous, safe ) {
  		var idx = this.models.indexOf( previous );

  		if ( ~idx ) {
  			next = rebindMatch( this.template.r[idx], next, previous );
  			if ( next !== previous ) {
  				previous.unregister( this );
  				this.models.splice( idx, 1, next );
  				// TODO: set up a resolver if there is no next?
  				if ( next ) next.addShuffleRegister( this, 'mark' );
  			}
  		}
  		this.bubble( !safe );
  	};

  	ExpressionProxy.prototype.retrieve = function retrieve () {
  		return this.get();
  	};

  	ExpressionProxy.prototype.teardown = function teardown () {
  		var this$1 = this;

  		this.unbind();
  		this.fragment = undefined;
  		if ( this.dependencies ) this.dependencies.forEach( function ( d ) { return d.unregister( this$1 ); } );
  		Model.prototype.teardown.call(this);
  	};

  	ExpressionProxy.prototype.unregister = function unregister( dep ) {
  		Model.prototype.unregister.call( this, dep );
  		if ( !this.deps.length ) this.teardown();
  	};

  	ExpressionProxy.prototype.unbind = function unbind$1 () {
  		this.resolvers.forEach( unbind );
  	};

  	return ExpressionProxy;
  }(Model));

  var ReferenceExpressionChild = (function (Model) {
  	function ReferenceExpressionChild ( parent, key ) {
  		Model.call ( this, parent, key );
  	}

  	ReferenceExpressionChild.prototype = Object.create( Model && Model.prototype );
  	ReferenceExpressionChild.prototype.constructor = ReferenceExpressionChild;

  	ReferenceExpressionChild.prototype.applyValue = function applyValue ( value ) {
  		if ( isEqual( value, this.value ) ) return;

  		var parent = this.parent, keys = [ this.key ];
  		while ( parent ) {
  			if ( parent.base ) {
  				var target = parent.model.joinAll( keys );
  				target.applyValue( value );
  				break;
  			}

  			keys.unshift( parent.key );

  			parent = parent.parent;
  		}
  	};

  	ReferenceExpressionChild.prototype.joinKey = function joinKey ( key ) {
  		if ( key === undefined || key === '' ) return this;

  		if ( !this.childByKey.hasOwnProperty( key ) ) {
  			var child = new ReferenceExpressionChild( this, key );
  			this.children.push( child );
  			this.childByKey[ key ] = child;
  		}

  		return this.childByKey[ key ];
  	};

  	ReferenceExpressionChild.prototype.retrieve = function retrieve () {
  		var parent = this.parent.get();
  		return parent && this.key in parent ? parent[ this.key ] : undefined;
  	};

  	return ReferenceExpressionChild;
  }(Model));

  var ReferenceExpressionProxy = (function (Model) {
  	function ReferenceExpressionProxy ( fragment, template ) {
  		var this$1 = this;

  		Model.call( this, null, null );
  		this.dirty = true;
  		this.root = fragment.ractive.viewmodel;
  		this.template = template;

  		this.resolvers = [];

  		this.base = resolve$2( fragment, template );
  		var baseResolver;

  		if ( !this.base ) {
  			baseResolver = fragment.resolve( template.r, function ( model ) {
  				this$1.base = model;
  				this$1.bubble();

  				removeFromArray( this$1.resolvers, baseResolver );
  			});

  			this.resolvers.push( baseResolver );
  		}

  		var intermediary = this.intermediary = {
  			handleChange: function () { return this$1.handleChange(); },
  			rebinding: function ( next, previous ) {
  				if ( previous === this$1.base ) {
  					next = rebindMatch( template, next, previous );
  					if ( next !== this$1.base ) {
  						this$1.base.unregister( intermediary );
  						this$1.base = next;
  						// TODO: if there is no next, set up a resolver?
  					}
  				} else {
  					var idx = this$1.members.indexOf( previous );
  					if ( ~idx ) {
  						// only direct references will rebind... expressions handle themselves
  						next = rebindMatch( template.m[idx].n, next, previous );
  						if ( next !== this$1.members[idx] ) {
  							this$1.members.splice( idx, 1, next );
  							// TODO: if there is no next, set up a resolver?
  						}
  					}
  				}

  				if ( next !== previous ) previous.unregister( intermediary );
  				if ( next ) next.addShuffleTask( function () { return next.register( intermediary ); } );

  				this$1.bubble();
  			}
  		};

  		this.members = template.m.map( function ( template, i ) {
  			if ( typeof template === 'string' ) {
  				return { get: function () { return template; } };
  			}

  			var model;
  			var resolver;

  			if ( template.t === REFERENCE ) {
  				model = resolveReference( fragment, template.n );

  				if ( model ) {
  					model.register( intermediary );
  				} else {
  					resolver = fragment.resolve( template.n, function ( model ) {
  						this$1.members[i] = model;

  						model.register( intermediary );
  						this$1.handleChange();

  						removeFromArray( this$1.resolvers, resolver );
  					});

  					this$1.resolvers.push( resolver );
  				}

  				return model;
  			}

  			model = new ExpressionProxy( fragment, template );
  			model.register( intermediary );
  			return model;
  		});

  		this.isUnresolved = true;
  		this.bubble();
  	}

  	ReferenceExpressionProxy.prototype = Object.create( Model && Model.prototype );
  	ReferenceExpressionProxy.prototype.constructor = ReferenceExpressionProxy;

  	ReferenceExpressionProxy.prototype.bubble = function bubble () {
  		if ( !this.base ) return;
  		if ( !this.dirty ) this.handleChange();
  	};

  	ReferenceExpressionProxy.prototype.forceResolution = function forceResolution () {
  		this.resolvers.forEach( function ( resolver ) { return resolver.forceResolution(); } );
  		this.dirty = true;
  		this.bubble();
  	};

  	ReferenceExpressionProxy.prototype.get = function get ( shouldCapture ) {
  		var this$1 = this;

  		if ( this.dirty ) {
  			this.bubble();

  			var i = this.members.length, resolved = true;
  			while ( resolved && i-- ) {
  				if ( !this$1.members[i] ) resolved = false;
  			}

  			if ( this.base && resolved ) {
  				var keys = this.members.map( function ( m ) { return escapeKey( String( m.get() ) ); } );
  				var model = this.base.joinAll( keys );

  				if ( model !== this.model ) {
  					if ( this.model ) {
  						this.model.unregister( this );
  						this.model.unregisterTwowayBinding( this );
  					}

  					this.model = model;
  					this.parent = model.parent;
  					this.model.register( this );
  					this.model.registerTwowayBinding( this );

  					if ( this.keypathModel ) this.keypathModel.handleChange();
  				}
  			}

  			this.value = this.model ? this.model.get( shouldCapture ) : undefined;
  			this.dirty = false;
  			this.mark();
  			return this.value;
  		} else {
  			return this.model ? this.model.get( shouldCapture ) : undefined;
  		}
  	};

  	// indirect two-way bindings
  	ReferenceExpressionProxy.prototype.getValue = function getValue () {
  		var this$1 = this;

  		this.value = this.model ? this.model.get() : undefined;

  		var i = this.bindings.length;
  		while ( i-- ) {
  			var value = this$1.bindings[i].getValue();
  			if ( value !== this$1.value ) return value;
  		}

  		// check one-way bindings
  		var oneway = findBoundValue( this.deps );
  		if ( oneway ) return oneway.value;

  		return this.value;
  	};

  	ReferenceExpressionProxy.prototype.getKeypath = function getKeypath () {
  		return this.model ? this.model.getKeypath() : '@undefined';
  	};

  	ReferenceExpressionProxy.prototype.handleChange = function handleChange$1 () {
  		this.dirty = true;
  		this.mark();
  	};

  	ReferenceExpressionProxy.prototype.joinKey = function joinKey ( key ) {
  		if ( key === undefined || key === '' ) return this;

  		if ( !this.childByKey.hasOwnProperty( key ) ) {
  			var child = new ReferenceExpressionChild( this, key );
  			this.children.push( child );
  			this.childByKey[ key ] = child;
  		}

  		return this.childByKey[ key ];
  	};

  	ReferenceExpressionProxy.prototype.mark = function mark$1 () {
  		if ( this.dirty ) {
  			this.deps.forEach( handleChange );
  		}

  		this.links.forEach( marked );
  		this.children.forEach( mark );
  		this.clearUnresolveds();
  	};

  	ReferenceExpressionProxy.prototype.retrieve = function retrieve () {
  		return this.value;
  	};

  	ReferenceExpressionProxy.prototype.rebinding = function rebinding () { }; // NOOP

  	ReferenceExpressionProxy.prototype.set = function set ( value ) {
  		if ( !this.model ) throw new Error( 'Unresolved reference expression. This should not happen!' );
  		this.model.set( value );
  	};

  	ReferenceExpressionProxy.prototype.unbind = function unbind$1 () {
  		this.resolvers.forEach( unbind );
  		if ( this.model ) {
  			this.model.unregister( this );
  			this.model.unregisterTwowayBinding( this );
  		}
  	};

  	return ReferenceExpressionProxy;
  }(Model));

  function resolve$2 ( fragment, template ) {
  	if ( template.r ) {
  		return resolveReference( fragment, template.r );
  	}

  	else if ( template.x ) {
  		return new ExpressionProxy( fragment, template.x );
  	}

  	else if ( template.rx ) {
  		return new ReferenceExpressionProxy( fragment, template.rx );
  	}
  }

  function resolveAliases( section ) {
  	if ( section.template.z ) {
  		section.aliases = {};

  		var refs = section.template.z;
  		for ( var i = 0; i < refs.length; i++ ) {
  			section.aliases[ refs[i].n ] = resolve$2( section.parentFragment, refs[i].x );
  		}
  	}
  }

  var Alias = (function (Item) {
  	function Alias ( options ) {
  		Item.call( this, options );

  		this.fragment = null;
  	}

  	Alias.prototype = Object.create( Item && Item.prototype );
  	Alias.prototype.constructor = Alias;

  	Alias.prototype.bind = function bind () {
  		resolveAliases( this );

  		this.fragment = new Fragment({
  			owner: this,
  			template: this.template.f
  		}).bind();
  	};

  	Alias.prototype.detach = function detach () {
  		return this.fragment ? this.fragment.detach() : createDocumentFragment();
  	};

  	Alias.prototype.find = function find ( selector ) {
  		if ( this.fragment ) {
  			return this.fragment.find( selector );
  		}
  	};

  	Alias.prototype.findAll = function findAll ( selector, query ) {
  		if ( this.fragment ) {
  			this.fragment.findAll( selector, query );
  		}
  	};

  	Alias.prototype.findComponent = function findComponent ( name ) {
  		if ( this.fragment ) {
  			return this.fragment.findComponent( name );
  		}
  	};

  	Alias.prototype.findAllComponents = function findAllComponents ( name, query ) {
  		if ( this.fragment ) {
  			this.fragment.findAllComponents( name, query );
  		}
  	};

  	Alias.prototype.firstNode = function firstNode ( skipParent ) {
  		return this.fragment && this.fragment.firstNode( skipParent );
  	};

  	Alias.prototype.rebinding = function rebinding () {
  		var this$1 = this;

  		if ( this.locked ) return;
  		this.locked = true;
  		runloop.scheduleTask( function () {
  			this$1.locked = false;
  			resolveAliases( this$1 );
  		});
  	};

  	Alias.prototype.render = function render ( target ) {
  		this.rendered = true;
  		if ( this.fragment ) this.fragment.render( target );
  	};

  	Alias.prototype.toString = function toString ( escape ) {
  		return this.fragment ? this.fragment.toString( escape ) : '';
  	};

  	Alias.prototype.unbind = function unbind () {
  		this.aliases = {};
  		if ( this.fragment ) this.fragment.unbind();
  	};

  	Alias.prototype.unrender = function unrender ( shouldDestroy ) {
  		if ( this.rendered && this.fragment ) this.fragment.unrender( shouldDestroy );
  		this.rendered = false;
  	};

  	Alias.prototype.update = function update () {
  		if ( this.dirty ) {
  			this.dirty = false;
  			this.fragment.update();
  		}
  	};

  	return Alias;
  }(Item));

  function findElement( start, orComponent, name ) {
  	if ( orComponent === void 0 ) orComponent = true;

  	while ( start && ( start.type !== ELEMENT || ( name && start.name !== name ) ) && ( !orComponent || start.type !== COMPONENT ) ) {
  		// start is a fragment - look at the owner
  		if ( start.owner ) start = start.owner;
  		// start is a component or yielder - look at the container
  		else if ( start.component ) start = start.containerFragment || start.component.parentFragment;
  		// start is an item - look at the parent
  		else if ( start.parent ) start = start.parent;
  		// start is an item without a parent - look at the parent fragment
  		else if ( start.parentFragment ) start = start.parentFragment;

  		else start = undefined;
  	}

  	return start;
  }

  function camelCase ( hyphenatedStr ) {
  	return hyphenatedStr.replace( /-([a-zA-Z])/g, function ( match, $1 ) {
  		return $1.toUpperCase();
  	});
  }

  var space = /\s+/;
  var specials$2 = { 'float': 'cssFloat' };
  var remove = /\/\*(?:[\s\S]*?)\*\//g;
  var escape = /url\(\s*(['"])(?:\\[\s\S]|(?!\1).)*\1\s*\)|url\((?:\\[\s\S]|[^)])*\)|(['"])(?:\\[\s\S]|(?!\1).)*\2/gi;
  var value = /\0(\d+)/g;

  function readStyle ( css ) {
      var values = [];

      if ( typeof css !== 'string' ) return {};

      return css.replace( escape, function ( match ) { return ("\u0000" + (values.push( match ) - 1)); })
          .replace( remove, '' )
          .split( ';' )
          .filter( function ( rule ) { return !!rule.trim(); } )
          .map( function ( rule ) { return rule.replace( value, function ( match, n ) { return values[ n ]; } ); } )
          .reduce(function ( rules, rule ) {
              var i = rule.indexOf(':');
              var name = camelCase( rule.substr( 0, i ).trim() );
              rules[ specials$2[ name ] || name ] = rule.substr( i + 1 ).trim();
              return rules;
          }, {});
  }

  function readClass ( str ) {
    var list = str.split( space );

    // remove any empty entries
    var i = list.length;
    while ( i-- ) {
      if ( !list[i] ) list.splice( i, 1 );
    }

    return list;
  }

  var textTypes = [ undefined, 'text', 'search', 'url', 'email', 'hidden', 'password', 'search', 'reset', 'submit' ];

  function getUpdateDelegate ( attribute ) {
  	var element = attribute.element, name = attribute.name;

  	if ( name === 'id' ) return updateId;

  	if ( name === 'value' ) {
  		if ( attribute.interpolator ) attribute.interpolator.bound = true;

  		// special case - selects
  		if ( element.name === 'select' && name === 'value' ) {
  			return element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;
  		}

  		if ( element.name === 'textarea' ) return updateStringValue;

  		// special case - contenteditable
  		if ( element.getAttribute( 'contenteditable' ) != null ) return updateContentEditableValue;

  		// special case - <input>
  		if ( element.name === 'input' ) {
  			var type = element.getAttribute( 'type' );

  			// type='file' value='{{fileList}}'>
  			if ( type === 'file' ) return noop; // read-only

  			// type='radio' name='{{twoway}}'
  			if ( type === 'radio' && element.binding && element.binding.attribute.name === 'name' ) return updateRadioValue;

  			if ( ~textTypes.indexOf( type ) ) return updateStringValue;
  		}

  		return updateValue;
  	}

  	var node = element.node;

  	// special case - <input type='radio' name='{{twoway}}' value='foo'>
  	if ( attribute.isTwoway && name === 'name' ) {
  		if ( node.type === 'radio' ) return updateRadioName;
  		if ( node.type === 'checkbox' ) return updateCheckboxName;
  	}

  	if ( name === 'style' ) return updateStyleAttribute;

  	if ( name.indexOf( 'style-' ) === 0 ) return updateInlineStyle;

  	// special case - class names. IE fucks things up, again
  	if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === html ) ) return updateClassName;

  	if ( name.indexOf( 'class-' ) === 0 ) return updateInlineClass;

  	if ( attribute.isBoolean ) {
  		var type$1 = element.getAttribute( 'type' );
  		if ( attribute.interpolator && name === 'checked' && ( type$1 === 'checkbox' || type$1 === 'radio' ) ) attribute.interpolator.bound = true;
  		return updateBoolean;
  	}

  	if ( attribute.namespace && attribute.namespace !== attribute.node.namespaceURI ) return updateNamespacedAttribute;

  	return updateAttribute;
  }

  function updateId ( reset ) {
  	var ref = this, node = ref.node;
  	var value = this.getValue();

  	// remove the mapping to this node if it hasn't already been replaced
  	if ( this.ractive.nodes[ node.id ] === node ) delete this.ractive.nodes[ node.id ];
  	if ( reset ) return node.removeAttribute( 'id' );

  	this.ractive.nodes[ value ] = node;

  	node.id = value;
  }

  function updateMultipleSelectValue ( reset ) {
  	var value = this.getValue();

  	if ( !isArray( value ) ) value = [ value ];

  	var options = this.node.options;
  	var i = options.length;

  	if ( reset ) {
  		while ( i-- ) options[i].selected = false;
  	} else {
  		while ( i-- ) {
  			var option = options[i];
  			var optionValue = option._ractive ?
  				option._ractive.value :
  				option.value; // options inserted via a triple don't have _ractive

  			option.selected = arrayContains( value, optionValue );
  		}
  	}
  }

  function updateSelectValue ( reset ) {
  	var value = this.getValue();

  	if ( !this.locked ) { // TODO is locked still a thing?
  		this.node._ractive.value = value;

  		var options = this.node.options;
  		var i = options.length;
  		var wasSelected = false;

  		if ( reset ) {
  			while ( i-- ) options[i].selected = false;
  		} else {
  			while ( i-- ) {
  				var option = options[i];
  				var optionValue = option._ractive ?
  					option._ractive.value :
  					option.value; // options inserted via a triple don't have _ractive
  				if ( option.disabled && option.selected ) wasSelected = true;

  				if ( optionValue == value ) { // double equals as we may be comparing numbers with strings
  					option.selected = true;
  					return;
  				}
  			}
  		}

  		if ( !wasSelected ) this.node.selectedIndex = -1;
  	}
  }


  function updateContentEditableValue ( reset ) {
  	var value = this.getValue();

  	if ( !this.locked ) {
  		if ( reset ) this.node.innerHTML = '';
  		else this.node.innerHTML = value === undefined ? '' : value;
  	}
  }

  function updateRadioValue ( reset ) {
  	var node = this.node;
  	var wasChecked = node.checked;

  	var value = this.getValue();

  	if ( reset ) return node.checked = false;

  	//node.value = this.element.getAttribute( 'value' );
  	node.value = this.node._ractive.value = value;
  	node.checked = value === this.element.getAttribute( 'name' );

  	// This is a special case - if the input was checked, and the value
  	// changed so that it's no longer checked, the twoway binding is
  	// most likely out of date. To fix it we have to jump through some
  	// hoops... this is a little kludgy but it works
  	if ( wasChecked && !node.checked && this.element.binding && this.element.binding.rendered ) {
  		this.element.binding.group.model.set( this.element.binding.group.getValue() );
  	}
  }

  function updateValue ( reset ) {
  	if ( !this.locked ) {
  		if ( reset ) {
  			this.node.removeAttribute( 'value' );
  			this.node.value = this.node._ractive.value = null;
  			return;
  		}

  		var value = this.getValue();

  		this.node.value = this.node._ractive.value = value;
  		this.node.setAttribute( 'value', value );
  	}
  }

  function updateStringValue ( reset ) {
  	if ( !this.locked ) {
  		if ( reset ) {
  			this.node._ractive.value = '';
  			this.node.removeAttribute( 'value' );
  			return;
  		}

  		var value = this.getValue();

  		this.node._ractive.value = value;

  		this.node.value = safeToStringValue( value );
  		this.node.setAttribute( 'value', safeToStringValue( value ) );
  	}
  }

  function updateRadioName ( reset ) {
  	if ( reset ) this.node.checked = false;
  	else this.node.checked = ( this.getValue() == this.node._ractive.value );
  }

  function updateCheckboxName ( reset ) {
  	var ref = this, element = ref.element, node = ref.node;
  	var binding = element.binding;

  	var value = this.getValue();
  	var valueAttribute = element.getAttribute( 'value' );

  	if ( reset ) {
  		// TODO: WAT?
  	}

  	if ( !isArray( value ) ) {
  		binding.isChecked = node.checked = ( value == valueAttribute );
  	} else {
  		var i = value.length;
  		while ( i-- ) {
  			if ( valueAttribute == value[i] ) {
  				binding.isChecked = node.checked = true;
  				return;
  			}
  		}
  		binding.isChecked = node.checked = false;
  	}
  }

  function updateStyleAttribute ( reset ) {
  	var props = reset ? {} : readStyle( this.getValue() || '' );
  	var style = this.node.style;
  	var keys = Object.keys( props );
  	var prev = this.previous || [];

  	var i = 0;
  	while ( i < keys.length ) {
  		if ( keys[i] in style ) style[ keys[i] ] = props[ keys[i] ];
  		i++;
  	}

  	// remove now-missing attrs
  	i = prev.length;
  	while ( i-- ) {
  		if ( !~keys.indexOf( prev[i] ) && prev[i] in style ) style[ prev[i] ] = '';
  	}

  	this.previous = keys;
  }

  function updateInlineStyle ( reset ) {
  	if ( !this.styleName ) {
  		this.styleName = camelize( this.name.substr( 6 ) );
  	}

  	this.node.style[ this.styleName ] = reset ? '' : this.getValue();
  }

  function updateClassName ( reset ) {
  	var value = reset ? [] : readClass( safeToStringValue( this.getValue() ) );
  	var attr = readClass( this.node.className );
  	var prev = this.previous || attr.slice( 0 );

  	var i = 0;
  	while ( i < value.length ) {
  		if ( !~attr.indexOf( value[i] ) ) attr.push( value[i] );
  		i++;
  	}

  	// remove now-missing classes
  	i = prev.length;
  	while ( i-- ) {
  		if ( !~value.indexOf( prev[i] ) ) {
  			var idx = attr.indexOf( prev[i] );
  			if ( ~idx ) attr.splice( idx, 1 );
  		}
  	}

  	var className = attr.join( ' ' );

  	if ( className !== this.node.className ) {
  		this.node.className = className;
  	}

  	this.previous = value;
  }

  function updateInlineClass ( reset ) {
  	var name = this.name.substr( 6 );
  	var attr = readClass( this.node.className );
  	var value = reset ? false : this.getValue();

  	if ( !this.inlineClass ) this.inlineClass = name;

  	if ( value && !~attr.indexOf( name ) ) attr.push( name );
  	else if ( !value && ~attr.indexOf( name ) ) attr.splice( attr.indexOf( name ), 1 );

  	this.node.className = attr.join( ' ' );
  }

  function updateBoolean ( reset ) {
  	// with two-way binding, only update if the change wasn't initiated by the user
  	// otherwise the cursor will often be sent to the wrong place
  	if ( !this.locked ) {
  		if ( reset ) {
  			if ( this.useProperty ) this.node[ this.propertyName ] = false;
  			this.node.removeAttribute( this.propertyName );
  			return;
  		}

  		if ( this.useProperty ) {
  			this.node[ this.propertyName ] = this.getValue();
  		} else {
  			if ( this.getValue() ) {
  				this.node.setAttribute( this.propertyName, '' );
  			} else {
  				this.node.removeAttribute( this.propertyName );
  			}
  		}
  	}
  }

  function updateAttribute ( reset ) {
  	if ( reset ) this.node.removeAttribute( this.name );
  	else this.node.setAttribute( this.name, safeToStringValue( this.getString() ) );
  }

  function updateNamespacedAttribute ( reset ) {
  	if ( reset ) this.node.removeAttributeNS( this.namespace, this.name.slice( this.name.indexOf( ':' ) + 1 ) );
  	else this.node.setAttributeNS( this.namespace, this.name.slice( this.name.indexOf( ':' ) + 1 ), safeToStringValue( this.getString() ) );
  }

  var propertyNames = {
  	'accept-charset': 'acceptCharset',
  	accesskey: 'accessKey',
  	bgcolor: 'bgColor',
  	'class': 'className',
  	codebase: 'codeBase',
  	colspan: 'colSpan',
  	contenteditable: 'contentEditable',
  	datetime: 'dateTime',
  	dirname: 'dirName',
  	'for': 'htmlFor',
  	'http-equiv': 'httpEquiv',
  	ismap: 'isMap',
  	maxlength: 'maxLength',
  	novalidate: 'noValidate',
  	pubdate: 'pubDate',
  	readonly: 'readOnly',
  	rowspan: 'rowSpan',
  	tabindex: 'tabIndex',
  	usemap: 'useMap'
  };

  function lookupNamespace ( node, prefix ) {
  	var qualified = "xmlns:" + prefix;

  	while ( node ) {
  		if ( node.hasAttribute && node.hasAttribute( qualified ) ) return node.getAttribute( qualified );
  		node = node.parentNode;
  	}

  	return namespaces[ prefix ];
  }

  var Attribute = (function (Item) {
  	function Attribute ( options ) {
  		Item.call( this, options );

  		this.name = options.template.n;
  		this.namespace = null;

  		this.owner = options.owner || options.parentFragment.owner || options.element || findElement( options.parentFragment );
  		this.element = options.element || (this.owner.attributeByName ? this.owner : findElement( options.parentFragment ) );
  		this.parentFragment = options.parentFragment; // shared
  		this.ractive = this.parentFragment.ractive;

  		this.rendered = false;
  		this.updateDelegate = null;
  		this.fragment = null;

  		this.element.attributeByName[ this.name ] = this;

  		if ( !isArray( options.template.f ) ) {
  			this.value = options.template.f;
  			if ( this.value === 0 ) {
  				this.value = '';
  			}
  		} else {
  			this.fragment = new Fragment({
  				owner: this,
  				template: options.template.f
  			});
  		}

  		this.interpolator = this.fragment &&
  			this.fragment.items.length === 1 &&
  			this.fragment.items[0].type === INTERPOLATOR &&
  			this.fragment.items[0];

  		if ( this.interpolator ) this.interpolator.owner = this;
  	}

  	Attribute.prototype = Object.create( Item && Item.prototype );
  	Attribute.prototype.constructor = Attribute;

  	Attribute.prototype.bind = function bind () {
  		if ( this.fragment ) {
  			this.fragment.bind();
  		}
  	};

  	Attribute.prototype.bubble = function bubble () {
  		if ( !this.dirty ) {
  			this.parentFragment.bubble();
  			this.element.bubble();
  			this.dirty = true;
  		}
  	};

  	Attribute.prototype.destroyed = function destroyed () {
  		this.updateDelegate( true );
  	};

  	Attribute.prototype.getString = function getString () {
  		return this.fragment ?
  			this.fragment.toString() :
  			this.value != null ? '' + this.value : '';
  	};

  	// TODO could getValue ever be called for a static attribute,
  	// or can we assume that this.fragment exists?
  	Attribute.prototype.getValue = function getValue () {
  		return this.fragment ? this.fragment.valueOf() : booleanAttributes.test( this.name ) ? true : this.value;
  	};

  	Attribute.prototype.render = function render () {
  		var node = this.element.node;
  		this.node = node;

  		// should we use direct property access, or setAttribute?
  		if ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {
  			this.propertyName = propertyNames[ this.name ] || this.name;

  			if ( node[ this.propertyName ] !== undefined ) {
  				this.useProperty = true;
  			}

  			// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
  			// node.selected = true rather than node.setAttribute( 'selected', '' )
  			if ( booleanAttributes.test( this.name ) || this.isTwoway ) {
  				this.isBoolean = true;
  			}

  			if ( this.propertyName === 'value' ) {
  				node._ractive.value = this.value;
  			}
  		}

  		if ( node.namespaceURI ) {
  			var index = this.name.indexOf( ':' );
  			if ( index !== -1 ) {
  				this.namespace = lookupNamespace( node, this.name.slice( 0, index ) );
  			} else {
  				this.namespace = node.namespaceURI;
  			}
  		}

  		this.rendered = true;
  		this.updateDelegate = getUpdateDelegate( this );
  		this.updateDelegate();
  	};

  	Attribute.prototype.toString = function toString () {
  		var value = this.getValue();

  		// Special case - select and textarea values (should not be stringified)
  		if ( this.name === 'value' && ( this.element.getAttribute( 'contenteditable' ) !== undefined || ( this.element.name === 'select' || this.element.name === 'textarea' ) ) ) {
  			return;
  		}

  		// Special case – bound radio `name` attributes
  		if ( this.name === 'name' && this.element.name === 'input' && this.interpolator && this.element.getAttribute( 'type' ) === 'radio' ) {
  			return ("name=\"{{" + (this.interpolator.model.getKeypath()) + "}}\"");
  		}

  		// Special case - style and class attributes and directives
  		if ( this.owner === this.element && ( this.name === 'style' || this.name === 'class' || this.styleName || this.inlineClass ) ) {
  			return;
  		}

  		if ( !this.rendered && this.owner === this.element && ( !this.name.indexOf( 'style-' ) || !this.name.indexOf( 'class-' ) ) ) {
  			if ( !this.name.indexOf( 'style-' ) ) {
  				this.styleName = camelize( this.name.substr( 6 ) );
  			} else {
  				this.inlineClass = this.name.substr( 6 );
  			}

  			return;
  		}

  		if ( booleanAttributes.test( this.name ) ) return value ? this.name : '';
  		if ( value == null ) return '';

  		var str = safeAttributeString( this.getString() );
  		return str ?
  			("" + (this.name) + "=\"" + str + "\"") :
  			this.name;
  	};

  	Attribute.prototype.unbind = function unbind () {
  		if ( this.fragment ) this.fragment.unbind();
  	};

  	Attribute.prototype.unrender = function unrender () {
  		this.updateDelegate( true );

  		this.rendered = false;
  	};

  	Attribute.prototype.update = function update () {
  		if ( this.dirty ) {
  			this.dirty = false;
  			if ( this.fragment ) this.fragment.update();
  			if ( this.rendered ) this.updateDelegate();
  			if ( this.isTwoway && !this.locked ) {
  				this.interpolator.twowayBinding.lastVal( true, this.interpolator.model.get() );
  			}
  		}
  	};

  	return Attribute;
  }(Item));

  var BindingFlag = (function (Item) {
  	function BindingFlag ( options ) {
  		Item.call( this, options );

  		this.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );
  		this.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );
  		this.flag = options.template.v === 'l' ? 'lazy' : 'twoway';

  		if ( this.element.type === ELEMENT ) {
  			if ( isArray( options.template.f ) ) {
  				this.fragment = new Fragment({
  					owner: this,
  					template: options.template.f
  				});
  			}

  			this.interpolator = this.fragment &&
  								this.fragment.items.length === 1 &&
  								this.fragment.items[0].type === INTERPOLATOR &&
  								this.fragment.items[0];
  		}
  	}

  	BindingFlag.prototype = Object.create( Item && Item.prototype );
  	BindingFlag.prototype.constructor = BindingFlag;

  	BindingFlag.prototype.bind = function bind () {
  		if ( this.fragment ) this.fragment.bind();
  		set$2( this, this.getValue(), true );
  	};

  	BindingFlag.prototype.bubble = function bubble () {
  		if ( !this.dirty ) {
  			this.element.bubble();
  			this.dirty = true;
  		}
  	};

  	BindingFlag.prototype.getValue = function getValue () {
  		if ( this.fragment ) return this.fragment.valueOf();
  		else if ( 'value' in this ) return this.value;
  		else if ( 'f' in this.template ) return this.template.f;
  		else return true;
  	};

  	BindingFlag.prototype.render = function render () {
  		set$2( this, this.getValue(), true );
  	};

  	BindingFlag.prototype.toString = function toString () { return ''; };

  	BindingFlag.prototype.unbind = function unbind () {
  		if ( this.fragment ) this.fragment.unbind();

  		delete this.element[ this.flag ];
  	};

  	BindingFlag.prototype.unrender = function unrender () {
  		if ( this.element.rendered ) this.element.recreateTwowayBinding();
  	};

  	BindingFlag.prototype.update = function update () {
  		if ( this.dirty ) {
  			if ( this.fragment ) this.fragment.update();
  			set$2( this, this.getValue(), true );
  		}
  	};

  	return BindingFlag;
  }(Item));

  function set$2 ( flag, value, update ) {
  	if ( value === 0 ) {
  		flag.value = true;
  	} else if ( value === 'true' ) {
  		flag.value = true;
  	} else if ( value === 'false' || value === '0' ) {
  		flag.value = false;
  	} else {
  		flag.value = value;
  	}

  	var current = flag.element[ flag.flag ];
  	flag.element[ flag.flag ] = flag.value;
  	if ( update && !flag.element.attributes.binding && current !== flag.value ) {
  		flag.element.recreateTwowayBinding();
  	}

  	return flag.value;
  }

  var div$1 = doc ? createElement( 'div' ) : null;

  var attributes = false;
  function inAttributes() { return attributes; }
  function doInAttributes( fn ) {
  	attributes = true;
  	fn();
  	attributes = false;
  }

  var ConditionalAttribute = (function (Item) {
  	function ConditionalAttribute ( options ) {
  		Item.call( this, options );

  		this.attributes = [];

  		this.owner = options.owner;

  		this.fragment = new Fragment({
  			ractive: this.ractive,
  			owner: this,
  			template: this.template
  		});
  		// this fragment can't participate in node-y things
  		this.fragment.findNextNode = noop;

  		this.dirty = false;
  	}

  	ConditionalAttribute.prototype = Object.create( Item && Item.prototype );
  	ConditionalAttribute.prototype.constructor = ConditionalAttribute;

  	ConditionalAttribute.prototype.bind = function bind () {
  		this.fragment.bind();
  	};

  	ConditionalAttribute.prototype.bubble = function bubble () {
  		if ( !this.dirty ) {
  			this.dirty = true;
  			this.owner.bubble();
  		}
  	};

  	ConditionalAttribute.prototype.render = function render () {
  		this.node = this.owner.node;
  		if ( this.node ) {
  			this.isSvg = this.node.namespaceURI === svg$1;
  		}

  		attributes = true;
  		if ( !this.rendered ) this.fragment.render();
  		attributes = false;

  		this.rendered = true;
  		this.dirty = true; // TODO this seems hacky, but necessary for tests to pass in browser AND node.js
  		this.update();
  	};

  	ConditionalAttribute.prototype.toString = function toString () {
  		return this.fragment.toString();
  	};

  	ConditionalAttribute.prototype.unbind = function unbind () {
  		this.fragment.unbind();
  	};

  	ConditionalAttribute.prototype.unrender = function unrender () {
  		this.rendered = false;
  		this.fragment.unrender();
  	};

  	ConditionalAttribute.prototype.update = function update () {
  		var this$1 = this;

  		var str;
  		var attrs;

  		if ( this.dirty ) {
  			this.dirty = false;

  			attributes = true;
  			this.fragment.update();
  			attributes = false;

  			if ( this.rendered && this.node ) {
  				str = this.fragment.toString();
  				attrs = parseAttributes( str, this.isSvg );

  				// any attributes that previously existed but no longer do
  				// must be removed
  				this.attributes.filter( function ( a ) { return notIn( attrs, a ); } ).forEach( function ( a ) {
  					this$1.node.removeAttribute( a.name );
  				});

  				attrs.forEach( function ( a ) {
  					this$1.node.setAttribute( a.name, a.value );
  				});

  				this.attributes = attrs;
  			}
  		}
  	};

  	return ConditionalAttribute;
  }(Item));

  function parseAttributes ( str, isSvg ) {
  	var tagName = isSvg ? 'svg' : 'div';
  	return str
  		? (div$1.innerHTML = "<" + tagName + " " + str + "></" + tagName + ">") &&
  			toArray(div$1.childNodes[0].attributes)
  		: [];
  }

  function notIn ( haystack, needle ) {
  	var i = haystack.length;

  	while ( i-- ) {
  		if ( haystack[i].name === needle.name ) {
  			return false;
  		}
  	}

  	return true;
  }

  function processWrapper ( wrapper, array, methodName, newIndices ) {
  	var __model = wrapper.__model;

  	if ( newIndices ) {
  		__model.shuffle( newIndices );
  	} else {
  		// If this is a sort or reverse, we just do root.set()...
  		// TODO use merge logic?
  		//root.viewmodel.mark( keypath );
  	}
  }

  var mutatorMethods = [ 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift' ];
  var patchedArrayProto = [];

  mutatorMethods.forEach( function ( methodName ) {
  	var method = function () {
  		var this$1 = this;
  		var args = [], len = arguments.length;
  		while ( len-- ) args[ len ] = arguments[ len ];

  		var newIndices = getNewIndices( this.length, methodName, args );

  		// lock any magic array wrappers, so that things don't get fudged
  		this._ractive.wrappers.forEach( function ( r ) { if ( r.magic ) r.magic.locked = true; } );

  		// apply the underlying method
  		var result = Array.prototype[ methodName ].apply( this, arguments );

  		// trigger changes
  		runloop.start();

  		this._ractive.setting = true;
  		var i = this._ractive.wrappers.length;
  		while ( i-- ) {
  			processWrapper( this$1._ractive.wrappers[i], this$1, methodName, newIndices );
  		}

  		runloop.end();

  		this._ractive.setting = false;

  		// unlock the magic arrays... magic... bah
  		this._ractive.wrappers.forEach( function ( r ) { if ( r.magic ) r.magic.locked = false; } );

  		return result;
  	};

  	defineProperty( patchedArrayProto, methodName, {
  		value: method,
  		configurable: true
  	});
  });

  var patchArrayMethods;
  var unpatchArrayMethods;

  // can we use prototype chain injection?
  // http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection
  if ( ({}).__proto__ ) {
  	// yes, we can
  	patchArrayMethods = function ( array ) { return array.__proto__ = patchedArrayProto; };
  	unpatchArrayMethods = function ( array ) { return array.__proto__ = Array.prototype; };
  }

  else {
  	// no, we can't
  	patchArrayMethods = function ( array ) {
  		var i = mutatorMethods.length;
  		while ( i-- ) {
  			var methodName = mutatorMethods[i];
  			defineProperty( array, methodName, {
  				value: patchedArrayProto[ methodName ],
  				configurable: true
  			});
  		}
  	};

  	unpatchArrayMethods = function ( array ) {
  		var i = mutatorMethods.length;
  		while ( i-- ) {
  			delete array[ mutatorMethods[i] ];
  		}
  	};
  }

  patchArrayMethods.unpatch = unpatchArrayMethods; // TODO export separately?
  var patch = patchArrayMethods;

  var errorMessage$1 = 'Something went wrong in a rather interesting way';

  var arrayAdaptor = {
  	filter: function ( object ) {
  		// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,
  		// or the array didn't trigger the get() itself
  		return isArray( object ) && ( !object._ractive || !object._ractive.setting );
  	},
  	wrap: function ( ractive, array, keypath ) {
  		return new ArrayWrapper( ractive, array, keypath );
  	}
  };

  var ArrayWrapper = function ArrayWrapper ( ractive, array ) {
  	this.root = ractive;
  	this.value = array;
  	this.__model = null; // filled in later

  	// if this array hasn't already been ractified, ractify it
  	if ( !array._ractive ) {
  		// define a non-enumerable _ractive property to store the wrappers
  		defineProperty( array, '_ractive', {
  			value: {
  				wrappers: [],
  				instances: [],
  				setting: false
  			},
  			configurable: true
  		});

  		patch( array );
  	}

  	// store the ractive instance, so we can handle transitions later
  	if ( !array._ractive.instances[ ractive._guid ] ) {
  		array._ractive.instances[ ractive._guid ] = 0;
  		array._ractive.instances.push( ractive );
  	}

  	array._ractive.instances[ ractive._guid ] += 1;
  	array._ractive.wrappers.push( this );
  };

  ArrayWrapper.prototype.get = function get () {
  	return this.value;
  };

  ArrayWrapper.prototype.reset = function reset ( value ) {
  	return this.value === value;
  };

  ArrayWrapper.prototype.teardown = function teardown () {
  	var array, storage, wrappers, instances, index;

  	array = this.value;
  	storage = array._ractive;
  	wrappers = storage.wrappers;
  	instances = storage.instances;

  	// if teardown() was invoked because we're clearing the cache as a result of
  	// a change that the array itself triggered, we can save ourselves the teardown
  	// and immediate setup
  	if ( storage.setting ) {
  		return false; // so that we don't remove it from cached wrappers
  	}

  	index = wrappers.indexOf( this );
  	if ( index === -1 ) {
  		throw new Error( errorMessage$1 );
  	}

  	wrappers.splice( index, 1 );

  	// if nothing else depends on this array, we can revert it to its
  	// natural state
  	if ( !wrappers.length ) {
  		delete array._ractive;
  		patch.unpatch( this.value );
  	}

  	else {
  		// remove ractive instance if possible
  		instances[ this.root._guid ] -= 1;
  		if ( !instances[ this.root._guid ] ) {
  			index = instances.indexOf( this.root );

  			if ( index === -1 ) {
  				throw new Error( errorMessage$1 );
  			}

  			instances.splice( index, 1 );
  		}
  	}
  };

  var magicAdaptor;

  try {
  	Object.defineProperty({}, 'test', { get: function() {}, set: function() {} });

  	magicAdaptor = {
  		filter: function ( value ) {
  			return value && typeof value === 'object';
  		},
  		wrap: function ( ractive, value, keypath ) {
  			return new MagicWrapper( ractive, value, keypath );
  		}
  	};
  } catch ( err ) {
  	magicAdaptor = false;
  }

  var magicAdaptor$1 = magicAdaptor;

  function createOrWrapDescriptor ( originalDescriptor, ractive, keypath, wrapper ) {
  	if ( originalDescriptor.set && originalDescriptor.set.__magic ) {
  		originalDescriptor.set.__magic.dependants.push({ ractive: ractive, keypath: keypath });
  		return originalDescriptor;
  	}

  	var setting;

  	var dependants = [{ ractive: ractive, keypath: keypath }];

  	var descriptor = {
  		get: function () {
  			return 'value' in originalDescriptor ? originalDescriptor.value : originalDescriptor.get.call( this );
  		},
  		set: function (value) {
  			if ( setting ) return;

  			if ( 'value' in originalDescriptor ) {
  				originalDescriptor.value = value;
  			} else {
  				originalDescriptor.set.call( this, value );
  			}

  			if ( wrapper.locked ) return;
  			setting = true;
  			dependants.forEach( function (ref) {
  				var ractive = ref.ractive;
  				var keypath = ref.keypath;

  				ractive.set( keypath, value );
  			});
  			setting = false;
  		},
  		enumerable: true
  	};

  	descriptor.set.__magic = { dependants: dependants, originalDescriptor: originalDescriptor };

  	return descriptor;
  }

  function revert ( descriptor, ractive, keypath ) {
  	if ( !descriptor.set || !descriptor.set.__magic ) return true;

  	var dependants = descriptor.set.__magic;
  	var i = dependants.length;
  	while ( i-- ) {
  		var dependant = dependants[i];
  		if ( dependant.ractive === ractive && dependant.keypath === keypath ) {
  			dependants.splice( i, 1 );
  			return false;
  		}
  	}
  }

  var MagicWrapper = function MagicWrapper ( ractive, value, keypath ) {
  	var this$1 = this;

  		this.ractive = ractive;
  	this.value = value;
  	this.keypath = keypath;

  	this.originalDescriptors = {};

  	// wrap all properties with getters
  	Object.keys( value ).forEach( function ( key ) {
  		var originalDescriptor = Object.getOwnPropertyDescriptor( this$1.value, key );
  		this$1.originalDescriptors[ key ] = originalDescriptor;

  		var childKeypath = keypath ? ("" + keypath + "." + (escapeKey( key ))) : escapeKey( key );

  		var descriptor = createOrWrapDescriptor( originalDescriptor, ractive, childKeypath, this$1 );



  		Object.defineProperty( this$1.value, key, descriptor );
  	});
  };

  MagicWrapper.prototype.get = function get () {
  	return this.value;
  };

  MagicWrapper.prototype.reset = function reset ( value ) {
  	return this.value === value;
  };

  MagicWrapper.prototype.set = function set ( key, value ) {
  	this.value[ key ] = value;
  };

  MagicWrapper.prototype.teardown = function teardown () {
  	var this$1 = this;

  		Object.keys( this.value ).forEach( function ( key ) {
  		var descriptor = Object.getOwnPropertyDescriptor( this$1.value, key );
  		if ( !descriptor.set || !descriptor.set.__magic ) return;

  		revert( descriptor );

  		if ( descriptor.set.__magic.dependants.length === 1 ) {
  			Object.defineProperty( this$1.value, key, descriptor.set.__magic.originalDescriptor );
  		}
  	});
  };

  var MagicArrayWrapper = function MagicArrayWrapper ( ractive, array, keypath ) {
  	this.value = array;

  	this.magic = true;

  	this.magicWrapper = magicAdaptor$1.wrap( ractive, array, keypath );
  	this.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );
  	this.arrayWrapper.magic = this.magicWrapper;

  	// ugh, this really is a terrible hack
  	Object.defineProperty( this, '__model', {
  		get: function () {
  			return this.arrayWrapper.__model;
  		},
  		set: function ( model ) {
  			this.arrayWrapper.__model = model;
  		}
  	});
  };

  MagicArrayWrapper.prototype.get = function get () {
  	return this.value;
  };

  MagicArrayWrapper.prototype.teardown = function teardown () {
  	this.arrayWrapper.teardown();
  	this.magicWrapper.teardown();
  };

  MagicArrayWrapper.prototype.reset = function reset ( value ) {
  	return this.arrayWrapper.reset( value ) && this.magicWrapper.reset( value );
  };

  var magicArrayAdaptor = {
  	filter: function ( object, keypath, ractive ) {
  		return magicAdaptor$1.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );
  	},

  	wrap: function ( ractive, array, keypath ) {
  		return new MagicArrayWrapper( ractive, array, keypath );
  	}
  };

  // TODO this is probably a bit anal, maybe we should leave it out
  function prettify ( fnBody ) {
  	var lines = fnBody
  		.replace( /^\t+/gm, function ( tabs ) { return tabs.split( '\t' ).join( '  ' ); } )
  		.split( '\n' );

  	var minIndent = lines.length < 2 ? 0 :
  		lines.slice( 1 ).reduce( function ( prev, line ) {
  			return Math.min( prev, /^\s*/.exec( line )[0].length );
  		}, Infinity );

  	return lines.map( function ( line, i ) {
  		return '    ' + ( i ? line.substring( minIndent ) : line );
  	}).join( '\n' );
  }

  // Ditto. This function truncates the stack to only include app code
  function truncateStack ( stack ) {
  	if ( !stack ) return '';

  	var lines = stack.split( '\n' );
  	var name = Computation.name + '.getValue';

  	var truncated = [];

  	var len = lines.length;
  	for ( var i = 1; i < len; i += 1 ) {
  		var line = lines[i];

  		if ( ~line.indexOf( name ) ) {
  			return truncated.join( '\n' );
  		} else {
  			truncated.push( line );
  		}
  	}
  }

  var Computation = (function (Model) {
  	function Computation ( viewmodel, signature, key ) {
  		Model.call( this, null, null );

  		this.root = this.parent = viewmodel;
  		this.signature = signature;

  		this.key = key; // not actually used, but helps with debugging
  		this.isExpression = key && key[0] === '@';

  		this.isReadonly = !this.signature.setter;

  		this.context = viewmodel.computationContext;

  		this.dependencies = [];

  		this.children = [];
  		this.childByKey = {};

  		this.deps = [];

  		this.dirty = true;

  		// TODO: is there a less hackish way to do this?
  		this.shuffle = undefined;
  	}

  	Computation.prototype = Object.create( Model && Model.prototype );
  	Computation.prototype.constructor = Computation;

  	Computation.prototype.get = function get ( shouldCapture ) {
  		if ( shouldCapture ) capture( this );

  		if ( this.dirty ) {
  			this.dirty = false;
  			this.value = this.getValue();
  			if ( this.wrapper ) this.newWrapperValue = this.value;
  			this.adapt();
  		}

  		// if capturing, this value needs to be unwrapped because it's for external use
  		return shouldCapture && this.wrapper ? this.wrapperValue : this.value;
  	};

  	Computation.prototype.getValue = function getValue () {
  		startCapturing();
  		var result;

  		try {
  			result = this.signature.getter.call( this.context );
  		} catch ( err ) {
  			warnIfDebug( ("Failed to compute " + (this.getKeypath()) + ": " + (err.message || err)) );

  			// TODO this is all well and good in Chrome, but...
  			// ...also, should encapsulate this stuff better, and only
  			// show it if Ractive.DEBUG
  			if ( hasConsole ) {
  				if ( console.groupCollapsed ) console.groupCollapsed( '%cshow details', 'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;' );
  				var functionBody = prettify( this.signature.getterString );
  				var stack = this.signature.getterUseStack ? '\n\n' + truncateStack( err.stack ) : '';
  				console.error( ("" + (err.name) + ": " + (err.message) + "\n\n" + functionBody + "" + stack) );
  				if ( console.groupCollapsed ) console.groupEnd();
  			}
  		}

  		var dependencies = stopCapturing();
  		this.setDependencies( dependencies );

  		// if not the first computation and the value is not the same,
  		// register the change for change events
  		if ( 'value' in this && result !== this.value ) {
  			this.registerChange( this.getKeypath(), result );
  		}

  		return result;
  	};

  	Computation.prototype.handleChange = function handleChange$1 () {
  		this.dirty = true;

  		this.links.forEach( marked );
  		this.deps.forEach( handleChange );
  		this.children.forEach( handleChange );
  		this.clearUnresolveds(); // TODO same question as on Model - necessary for primitives?
  	};

  	Computation.prototype.joinKey = function joinKey ( key ) {
  		if ( key === undefined || key === '' ) return this;

  		if ( !this.childByKey.hasOwnProperty( key ) ) {
  			var child = new ComputationChild( this, key );
  			this.children.push( child );
  			this.childByKey[ key ] = child;
  		}

  		return this.childByKey[ key ];
  	};

  	Computation.prototype.mark = function mark () {
  		this.handleChange();
  	};

  	Computation.prototype.rebinding = function rebinding ( next, previous ) {
  		// computations will grab all of their deps again automagically
  		if ( next !== previous ) this.handleChange();
  	};

  	Computation.prototype.set = function set ( value ) {
  		if ( !this.signature.setter ) {
  			throw new Error( ("Cannot set read-only computed value '" + (this.key) + "'") );
  		}

  		this.signature.setter( value );
  		this.mark();
  	};

  	Computation.prototype.setDependencies = function setDependencies ( dependencies ) {
  		// unregister any soft dependencies we no longer have
  		var this$1 = this;

  		var i = this.dependencies.length;
  		while ( i-- ) {
  			var model = this$1.dependencies[i];
  			if ( !~dependencies.indexOf( model ) ) model.unregister( this$1 );
  		}

  		// and add any new ones
  		i = dependencies.length;
  		while ( i-- ) {
  			var model$1 = dependencies[i];
  			if ( !~this$1.dependencies.indexOf( model$1 ) ) model$1.register( this$1 );
  		}

  		this.dependencies = dependencies;
  	};

  	Computation.prototype.teardown = function teardown () {
  		var this$1 = this;

  		var i = this.dependencies.length;
  		while ( i-- ) {
  			if ( this$1.dependencies[i] ) this$1.dependencies[i].unregister( this$1 );
  		}
  		if ( this.root.computations[this.key] === this ) delete this.root.computations[this.key];
  		Model.prototype.teardown.call(this);
  	};

  	Computation.prototype.unregister = function unregister ( dependent ) {
  		Model.prototype.unregister.call( this, dependent );
  		// tear down expressions with no deps, because they will be replaced when needed
  		if ( this.isExpression && this.deps.length === 0 ) this.teardown();
  	};

  	return Computation;
  }(Model));

  var RactiveModel = (function (Model) {
  	function RactiveModel ( ractive ) {
  		Model.call( this, null, '' );
  		this.value = ractive;
  		this.isRoot = true;
  		this.root = this;
  		this.adaptors = [];
  		this.ractive = ractive;
  		this.changes = {};
  	}

  	RactiveModel.prototype = Object.create( Model && Model.prototype );
  	RactiveModel.prototype.constructor = RactiveModel;

  	RactiveModel.prototype.getKeypath = function getKeypath() {
  		return '@this';
  	};

  	return RactiveModel;
  }(Model));

  var hasProp$1 = Object.prototype.hasOwnProperty;

  var RootModel = (function (Model) {
  	function RootModel ( options ) {
  		Model.call( this, null, null );

  		// TODO deprecate this
  		this.changes = {};

  		this.isRoot = true;
  		this.root = this;
  		this.ractive = options.ractive; // TODO sever this link

  		this.value = options.data;
  		this.adaptors = options.adapt;
  		this.adapt();

  		this.computationContext = options.ractive;
  		this.computations = {};

  		// TODO this is only for deprecation of using expression keypaths
  		this.expressions = {};
  	}

  	RootModel.prototype = Object.create( Model && Model.prototype );
  	RootModel.prototype.constructor = RootModel;

  	RootModel.prototype.applyChanges = function applyChanges () {
  		this._changeHash = {};
  		this.flush();

  		return this._changeHash;
  	};

  	RootModel.prototype.compute = function compute ( key, signature ) {
  		var computation = new Computation( this, signature, key );
  		this.computations[ key ] = computation;

  		return computation;
  	};

  	RootModel.prototype.createLink = function createLink ( keypath, target, targetPath ) {
  		var this$1 = this;

  		var keys = splitKeypathI( keypath );

  		var model = this;
  		while ( keys.length ) {
  			var key = keys.shift();
  			model = this$1.childByKey[ key ] || this$1.joinKey( key );
  		}

  		return model.link( target, targetPath );
  	};

  	RootModel.prototype.get = function get ( shouldCapture, options ) {
  		var this$1 = this;

  		if ( shouldCapture ) capture( this );

  		if ( !options || options.virtual !== false ) {
  			var result = this.getVirtual();
  			var keys = Object.keys( this.computations );
  			var i = keys.length;
  			while ( i-- ) {
  				var computation = this$1.computations[ keys[i] ];
  				// exclude template expressions
  				if ( !computation.isExpression ) {
  					result[ keys[i] ] = computation.get();
  				}
  			}

  			return result;
  		} else {
  			return this.value;
  		}
  	};

  	RootModel.prototype.getKeypath = function getKeypath () {
  		return '';
  	};

  	RootModel.prototype.getRactiveModel = function getRactiveModel() {
  		return this.ractiveModel || ( this.ractiveModel = new RactiveModel( this.ractive ) );
  	};

  	RootModel.prototype.getValueChildren = function getValueChildren () {
  		var children = Model.prototype.getValueChildren.call( this, this.value );

  		this.children.forEach( function ( child ) {
  			if ( child._link ) {
  				var idx = children.indexOf( child );
  				if ( ~idx ) children.splice( idx, 1, child._link );
  				else children.push( child._link );
  			}
  		});

  		for ( var k in this.computations ) {
  			children.push( this.computations[k] );
  		}

  		return children;
  	};

  	RootModel.prototype.handleChange = function handleChange$1 () {
  		this.deps.forEach( handleChange );
  	};

  	RootModel.prototype.has = function has ( key ) {
  		var value = this.value;

  		key = unescapeKey( key );
  		if ( hasProp$1.call( value, key ) ) return true;

  		// mappings/links and computations
  		if ( key in this.computations || this.childByKey[key] && this.childByKey[key]._link ) return true;
  		// TODO remove this after deprecation is done
  		if ( key in this.expressions ) return true;

  		// We climb up the constructor chain to find if one of them contains the key
  		var constructor = value.constructor;
  		while ( constructor !== Function && constructor !== Array && constructor !== Object ) {
  			if ( hasProp$1.call( constructor.prototype, key ) ) return true;
  			constructor = constructor.constructor;
  		}

  		return false;
  	};

  	RootModel.prototype.joinKey = function joinKey ( key, opts ) {
  		if ( key === '@global' ) return GlobalModel$1;
  		if ( key === '@this' ) return this.getRactiveModel();

  		if ( this.expressions.hasOwnProperty( key ) ) {
  			warnIfDebug( ("Accessing expression keypaths (" + (key.substr(1)) + ") from the instance is deprecated. You can used a getNodeInfo or event object to access keypaths with expression context.") );
  			return this.expressions[ key ];
  		}

  		return this.computations.hasOwnProperty( key ) ? this.computations[ key ] :
  		       Model.prototype.joinKey.call( this, key, opts );
  	};

  	RootModel.prototype.map = function map ( localKey, origin ) {
  		var local = this.joinKey( localKey );
  		local.link( origin );
  	};

  	RootModel.prototype.rebinding = function rebinding () {
  	};

  	RootModel.prototype.set = function set ( value ) {
  		// TODO wrapping root node is a baaaad idea. We should prevent this
  		var wrapper = this.wrapper;
  		if ( wrapper ) {
  			var shouldTeardown = !wrapper.reset || wrapper.reset( value ) === false;

  			if ( shouldTeardown ) {
  				wrapper.teardown();
  				this.wrapper = null;
  				this.value = value;
  				this.adapt();
  			}
  		} else {
  			this.value = value;
  			this.adapt();
  		}

  		this.deps.forEach( handleChange );
  		this.children.forEach( mark );
  		this.clearUnresolveds(); // TODO do we need to do this with primitive values? if not, what about e.g. unresolved `length` property of null -> string?
  	};

  	RootModel.prototype.retrieve = function retrieve () {
  		return this.wrapper ? this.wrapper.get() : this.value;
  	};

  	RootModel.prototype.update = function update () {
  		// noop
  	};

  	return RootModel;
  }(Model));

  function getComputationSignature ( ractive, key, signature ) {
  	var getter;
  	var setter;

  	// useful for debugging
  	var getterString;
  	var getterUseStack;
  	var setterString;

  	if ( typeof signature === 'function' ) {
  		getter = bind( signature, ractive );
  		getterString = signature.toString();
  		getterUseStack = true;
  	}

  	if ( typeof signature === 'string' ) {
  		getter = createFunctionFromString( signature, ractive );
  		getterString = signature;
  	}

  	if ( typeof signature === 'object' ) {
  		if ( typeof signature.get === 'string' ) {
  			getter = createFunctionFromString( signature.get, ractive );
  			getterString = signature.get;
  		} else if ( typeof signature.get === 'function' ) {
  			getter = bind( signature.get, ractive );
  			getterString = signature.get.toString();
  			getterUseStack = true;
  		} else {
  			fatal( '`%s` computation must have a `get()` method', key );
  		}

  		if ( typeof signature.set === 'function' ) {
  			setter = bind( signature.set, ractive );
  			setterString = signature.set.toString();
  		}
  	}

  	return {
  		getter: getter,
  		setter: setter,
  		getterString: getterString,
  		setterString: setterString,
  		getterUseStack: getterUseStack
  	};
  }

  var constructHook = new Hook( 'construct' );

  var registryNames$1 = [
  	'adaptors',
  	'components',
  	'decorators',
  	'easing',
  	'events',
  	'interpolators',
  	'partials',
  	'transitions'
  ];

  var uid = 0;

  function construct ( ractive, options ) {
  	if ( Ractive.DEBUG ) welcome();

  	initialiseProperties( ractive );

  	// TODO remove this, eventually
  	defineProperty( ractive, 'data', { get: deprecateRactiveData });

  	// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it
  	constructHook.fire( ractive, options );

  	// Add registries
  	registryNames$1.forEach( function ( name ) {
  		ractive[ name ] = extendObj( create( ractive.constructor[ name ] || null ), options[ name ] );
  	});

  	// Create a viewmodel
  	var viewmodel = new RootModel({
  		adapt: getAdaptors( ractive, ractive.adapt, options ),
  		data: dataConfigurator.init( ractive.constructor, ractive, options ),
  		ractive: ractive
  	});

  	ractive.viewmodel = viewmodel;

  	// Add computed properties
  	var computed = extendObj( create( ractive.constructor.prototype.computed ), options.computed );

  	for ( var key in computed ) {
  		var signature = getComputationSignature( ractive, key, computed[ key ] );
  		viewmodel.compute( key, signature );
  	}
  }

  function combine$2 ( arrays ) {
  	var res = [];
  	var args = res.concat.apply( res, arrays );

  	var i = args.length;
  	while ( i-- ) {
  		if ( !~res.indexOf( args[i] ) ) {
  			res.unshift( args[i] );
  		}
  	}

  	return res;
  }

  function getAdaptors ( ractive, protoAdapt, options ) {
  	protoAdapt = protoAdapt.map( lookup );
  	var adapt = ensureArray( options.adapt ).map( lookup );

  	var builtins = [];
  	var srcs = [ protoAdapt, adapt ];
  	if ( ractive.parent && !ractive.isolated ) {
  		srcs.push( ractive.parent.viewmodel.adaptors );
  	}
  	srcs.push( builtins );

  	var magic = 'magic' in options ? options.magic : ractive.magic;
  	var modifyArrays = 'modifyArrays' in options ? options.modifyArrays : ractive.modifyArrays;

  	if ( magic ) {
  		if ( !magicSupported ) {
  			throw new Error( 'Getters and setters (magic mode) are not supported in this browser' );
  		}

  		if ( modifyArrays ) {
  			builtins.push( magicArrayAdaptor );
  		}

  		builtins.push( magicAdaptor$1 );
  	}

  	if ( modifyArrays ) {
  		builtins.push( arrayAdaptor );
  	}

  	return combine$2( srcs );


  	function lookup ( adaptor ) {
  		if ( typeof adaptor === 'string' ) {
  			adaptor = findInViewHierarchy( 'adaptors', ractive, adaptor );

  			if ( !adaptor ) {
  				fatal( missingPlugin( adaptor, 'adaptor' ) );
  			}
  		}

  		return adaptor;
  	}
  }

  function initialiseProperties ( ractive ) {
  	// Generate a unique identifier, for places where you'd use a weak map if it
  	// existed
  	ractive._guid = 'r-' + uid++;

  	// events
  	ractive._subs = create( null );

  	// storage for item configuration from instantiation to reset,
  	// like dynamic functions or original values
  	ractive._config = {};

  	// nodes registry
  	ractive.nodes = {};

  	// events
  	ractive.event = null;
  	ractive._eventQueue = [];

  	// live queries
  	ractive._liveQueries = [];
  	ractive._liveComponentQueries = [];

  	// observers
  	ractive._observers = [];

  	if(!ractive.component){
  		ractive.root = ractive;
  		ractive.parent = ractive.container = null; // TODO container still applicable?
  	}

  }

  function deprecateRactiveData () {
  	throw new Error( 'Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead' );
  }

  function getChildQueue ( queue, ractive ) {
  	return queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );
  }

  function fire ( hookQueue, ractive ) {
  	var childQueue = getChildQueue( hookQueue.queue, ractive );

  	hookQueue.hook.fire( ractive );

  	// queue is "live" because components can end up being
  	// added while hooks fire on parents that modify data values.
  	while ( childQueue.length ) {
  		fire( hookQueue, childQueue.shift() );
  	}

  	delete hookQueue.queue[ ractive._guid ];
  }

  var HookQueue = function HookQueue ( event ) {
  	this.hook = new Hook( event );
  	this.inProcess = {};
  	this.queue = {};
  };

  HookQueue.prototype.begin = function begin ( ractive ) {
  	this.inProcess[ ractive._guid ] = true;
  };

  HookQueue.prototype.end = function end ( ractive ) {
  	var parent = ractive.parent;

  	// If this is *isn't* a child of a component that's in process,
  	// it should call methods or fire at this point
  	if ( !parent || !this.inProcess[ parent._guid ] ) {
  		fire( this, ractive );
  	}
  	// elsewise, handoff to parent to fire when ready
  	else {
  		getChildQueue( this.queue, parent ).push( ractive );
  	}

  	delete this.inProcess[ ractive._guid ];
  };

  var configHook = new Hook( 'config' );
  var initHook = new HookQueue( 'init' );

  function initialise ( ractive, userOptions, options ) {
  	Object.keys( ractive.viewmodel.computations ).forEach( function ( key ) {
  		var computation = ractive.viewmodel.computations[ key ];

  		if ( ractive.viewmodel.value.hasOwnProperty( key ) ) {
  			computation.set( ractive.viewmodel.value[ key ] );
  		}
  	});

  	// init config from Parent and options
  	config.init( ractive.constructor, ractive, userOptions );

  	configHook.fire( ractive );
  	initHook.begin( ractive );

  	var fragment;

  	// Render virtual DOM
  	if ( ractive.template ) {
  		var cssIds;

  		if ( options.cssIds || ractive.cssId ) {
  			cssIds = options.cssIds ? options.cssIds.slice() : [];

  			if ( ractive.cssId ) {
  				cssIds.push( ractive.cssId );
  			}
  		}

  		ractive.fragment = fragment = new Fragment({
  			owner: ractive,
  			template: ractive.template,
  			cssIds: cssIds
  		}).bind( ractive.viewmodel );
  	}

  	initHook.end( ractive );

  	if ( fragment ) {
  		// render automatically ( if `el` is specified )
  		var el = getElement( ractive.el );
  		if ( el ) {
  			var promise = ractive.render( el, ractive.append );

  			if ( Ractive.DEBUG_PROMISES ) {
  				promise['catch']( function ( err ) {
  					warnOnceIfDebug( 'Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\n  Ractive.DEBUG_PROMISES = false;' );
  					warnIfDebug( 'An error happened during rendering', { ractive: ractive });
  					logIfDebug( err );

  					throw err;
  				});
  			}
  		}
  	}
  }

  var DOMEvent = function DOMEvent ( name, owner ) {
  	if ( name.indexOf( '*' ) !== -1 ) {
  		fatal( ("Only component proxy-events may contain \"*\" wildcards, <" + (owner.name) + " on-" + name + "=\"...\"/> is not valid") );
  	}

  	this.name = name;
  	this.owner = owner;
  	this.node = null;
  	this.handler = null;
  };

  DOMEvent.prototype.listen = function listen ( directive ) {
  	var node = this.node = this.owner.node;
  	var name = this.name;

  	if ( !( ("on" + name) in node ) ) {
  		warnOnce( missingPlugin( name, 'events' ) );
  		}

  		node.addEventListener( name, this.handler = function( event ) {
  		directive.fire({
  				node: node,
  			original: event
  			});
  		}, false );
  };

  DOMEvent.prototype.unlisten = function unlisten () {
  	this.node.removeEventListener( this.name, this.handler, false );
  };

  var CustomEvent = function CustomEvent ( eventPlugin, owner ) {
  	this.eventPlugin = eventPlugin;
  	this.owner = owner;
  	this.handler = null;
  };

  CustomEvent.prototype.listen = function listen ( directive ) {
  	var node = this.owner.node;

  	this.handler = this.eventPlugin( node, function ( event ) {
  		if ( event === void 0 ) event = {};

  			event.node = event.node || node;
  		directive.fire( event );
  	});
  };

  CustomEvent.prototype.unlisten = function unlisten () {
  	this.handler.teardown();
  };

  var RactiveEvent = function RactiveEvent ( ractive, name ) {
  	this.ractive = ractive;
  	this.name = name;
  	this.handler = null;
  };

  RactiveEvent.prototype.listen = function listen ( directive ) {
  	var ractive = this.ractive;

  	this.handler = ractive.on( this.name, function () {
  		var event;

  		// semi-weak test, but what else? tag the event obj ._isEvent ?
  		if ( arguments.length && arguments[0] && arguments[0].node ) {
  			event = Array.prototype.shift.call( arguments );
  			event.component = ractive;
  		}

  		var args = Array.prototype.slice.call( arguments );
  		directive.fire( event, args );

  		// cancel bubbling
  		return false;
  	});
  };

  RactiveEvent.prototype.unlisten = function unlisten () {
  	this.handler.cancel();
  };

  var specialPattern = /^(event|arguments)(\..+)?$/;
  var dollarArgsPattern = /^\$(\d+)(\..+)?$/;

  var EventDirective = function EventDirective ( options ) {
  	var this$1 = this;

  		this.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );
  	this.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );
  	this.template = options.template;
  	this.parentFragment = options.parentFragment;
  	this.ractive = options.parentFragment.ractive;

  	this.events = [];

  	if ( this.element.type === COMPONENT ) {
  		this.template.n.split( '-' ).forEach( function ( n ) {
  			this$1.events.push( new RactiveEvent( this$1.element.instance, n ) );
  		});
  	} else {
  		this.template.n.split( '-' ).forEach( function ( n ) {
  			var fn = findInViewHierarchy( 'events', this$1.ractive, n );
  			// we need to pass in "this" in order to get
  			// access to node when it is created.
  			this$1.events.push(fn ? new CustomEvent( fn, this$1.element ) : new DOMEvent( n, this$1.element ));
  		});
  	}

  	this.context = null;

  	// method calls
  	this.resolvers = null;
  	this.models = null;

  	// handler directive
  	this.action = null;
  	this.args = null;
  };

  EventDirective.prototype.bind = function bind () {
  	var this$1 = this;

  		this.context = this.parentFragment.findContext();

  	var template = this.template.f;

  	if ( template.x ) {
  		this.fn = getFunction( template.x.s, template.x.r.length );
  		this.resolvers = [];
  		this.models = template.x.r.map( function ( ref, i ) {
  			var specialMatch = specialPattern.exec( ref );
  			if ( specialMatch ) {
  				// on-click="foo(event.node)"
  				return {
  					special: specialMatch[1],
  					keys: specialMatch[2] ? splitKeypathI( specialMatch[2].substr(1) ) : []
  				};
  			}

  			var dollarMatch = dollarArgsPattern.exec( ref );
  			if ( dollarMatch ) {
  				// on-click="foo($1)"
  				return {
  					special: 'arguments',
  					keys: [ dollarMatch[1] - 1 ].concat( dollarMatch[2] ? splitKeypathI( dollarMatch[2].substr( 1 ) ) : [] )
  				};
  			}

  			var resolver;

  			var model = resolveReference( this$1.parentFragment, ref );
  			if ( !model ) {
  				resolver = this$1.parentFragment.resolve( ref, function ( model ) {
  					this$1.models[i] = model;
  					removeFromArray( this$1.resolvers, resolver );
  					model.register( this$1 );
  				});

  				this$1.resolvers.push( resolver );
  			} else model.register( this$1 );

  			return model;
  		});
  	}

  	else {
  		// TODO deprecate this style of directive
  		this.action = typeof template === 'string' ? // on-click='foo'
  			template :
  			typeof template.n === 'string' ? // on-click='{{dynamic}}'
  				template.n :
  				new Fragment({
  					owner: this,
  					template: template.n
  				});

  		this.args = template.a ? // static arguments
  			( typeof template.a === 'string' ? [ template.a ] : template.a ) :
  			template.d ? // dynamic arguments
  				new Fragment({
  					owner: this,
  					template: template.d
  				}) :
  				[]; // no arguments
  	}

  	if ( this.action && typeof this.action !== 'string' ) this.action.bind();
  	if ( this.args && template.d ) this.args.bind();
  };

  EventDirective.prototype.bubble = function bubble () {
  	if ( !this.dirty ) {
  		this.dirty = true;
  		this.owner.bubble();
  	}
  };

  EventDirective.prototype.destroyed = function destroyed () {
  	this.events.forEach( function ( e ) { return e.unlisten(); } );
  };

  EventDirective.prototype.fire = function fire ( event, passedArgs ) {

  	// augment event object
  	if ( passedArgs === void 0 ) passedArgs = [];

  		if ( event && !event.hasOwnProperty( '_element' ) ) {
  		   addHelpers( event, this.owner );
  	}

  	if ( this.fn ) {
  		var values = [];

  		if ( event ) passedArgs.unshift( event );

  		if ( this.models ) {
  			this.models.forEach( function ( model ) {
  				if ( !model ) return values.push( undefined );

  				if ( model.special ) {
  					var obj = model.special === 'event' ? event : passedArgs;
  					var keys = model.keys.slice();

  					while ( keys.length ) obj = obj[ keys.shift() ];
  					return values.push( obj );
  				}

  				if ( model.wrapper ) {
  					return values.push( model.wrapperValue );
  				}

  				values.push( model.get() );
  			});
  		}

  		// make event available as `this.event`
  		var ractive = this.ractive;
  		var oldEvent = ractive.event;

  		ractive.event = event;
  		var result = this.fn.apply( ractive, values ).pop();

  		// Auto prevent and stop if return is explicitly false
  		if ( result === false ) {
  			var original = event ? event.original : undefined;
  			if ( original ) {
  				original.preventDefault && original.preventDefault();
  				original.stopPropagation && original.stopPropagation();
  			} else {
  				warnOnceIfDebug( ("handler '" + (this.template.n) + "' returned false, but there is no event available to cancel") );
  			}
  		}

  		ractive.event = oldEvent;
  	}

  	else {
  		var action = this.action.toString();
  		var args = this.template.f.d ? this.args.getArgsList() : this.args;

  		if ( passedArgs.length ) args = args.concat( passedArgs );

  		if ( event ) event.name = action;

  		fireEvent( this.ractive, action, {
  			event: event,
  			args: args
  		});
  	}
  };

  EventDirective.prototype.handleChange = function handleChange () {};

  EventDirective.prototype.rebinding = function rebinding ( next, previous ) {
  	var this$1 = this;

  		if ( !this.models ) return;
  	var idx = this.models.indexOf( previous );

  	if ( ~idx ) {
  		this.models.splice( idx, 1, next );
  		previous.unregister( this );
  		if ( next ) next.addShuffleTask( function () { return next.register( this$1 ); } );
  	}
  };

  EventDirective.prototype.render = function render () {
  	// render events after everything else, so they fire after bindings
  	var this$1 = this;

  		runloop.scheduleTask( function () { return this$1.events.forEach( function ( e ) { return e.listen( this$1 ); }, true ); } );
  };

  EventDirective.prototype.toString = function toString() { return ''; };

  EventDirective.prototype.unbind = function unbind$1 () {
  	var this$1 = this;

  		var template = this.template.f;

  	if ( template.m ) {
  		if ( this.resolvers ) this.resolvers.forEach( unbind );
  		this.resolvers = [];

  		if ( this.models ) this.models.forEach( function ( m ) {
  			if ( m.unregister ) m.unregister( this$1 );
  		});
  		this.models = null;
  	}

  	else {
  		// TODO this is brittle and non-explicit, fix it
  		if ( this.action && this.action.unbind ) this.action.unbind();
  		if ( this.args && this.args.unbind ) this.args.unbind();
  	}
  };

  EventDirective.prototype.unrender = function unrender () {
  	this.events.forEach( function ( e ) { return e.unlisten(); } );
  };

  EventDirective.prototype.update = function update () {
  	if ( this.method || !this.dirty ) return; // nothing to do

  	this.dirty = false;

  	// ugh legacy
  	if ( this.action && this.action.update ) this.action.update();
  	if ( this.args && this.args.update ) this.args.update();
  };

  // TODO it's unfortunate that this has to run every time a
  // component is rendered... is there a better way?
  function updateLiveQueries ( component ) {
  	// Does this need to be added to any live queries?
  	var instance = component.ractive;

  	do {
  		var liveQueries = instance._liveComponentQueries;

  		var i = liveQueries.length;
  		while ( i-- ) {
  			var name = liveQueries[i];
  			var query = liveQueries[ ("_" + name) ];

  			if ( query.test( component ) ) {
  				query.add( component.instance );
  				// keep register of applicable selectors, for when we teardown
  				component.liveQueries.push( query );
  			}
  		}
  	} while ( instance = instance.parent );
  }

  function removeFromLiveComponentQueries ( component ) {
  	var instance = component.ractive;

  	while ( instance ) {
  		var query = instance._liveComponentQueries[ ("_" + (component.name)) ];
  		if ( query ) query.remove( component );

  		instance = instance.parent;
  	}
  }

  function makeDirty ( query ) {
  	query.makeDirty();
  }

  var teardownHook = new Hook( 'teardown' );

  var Component = (function (Item) {
  	function Component ( options, ComponentConstructor ) {
  		var this$1 = this;

  		Item.call( this, options );
  		this.type = COMPONENT; // override ELEMENT from super

  		var instance = create( ComponentConstructor.prototype );

  		this.instance = instance;
  		this.name = options.template.e;
  		this.parentFragment = options.parentFragment;

  		this.liveQueries = [];

  		if ( instance.el ) {
  			warnIfDebug( ("The <" + (this.name) + "> component has a default 'el' property; it has been disregarded") );
  		}

  		var partials = options.template.p || {};
  		if ( !( 'content' in partials ) ) partials.content = options.template.f || [];
  		this._partials = partials; // TEMP

  		this.yielders = {};

  		// find container
  		var fragment = options.parentFragment;
  		var container;
  		while ( fragment ) {
  			if ( fragment.owner.type === YIELDER ) {
  				container = fragment.owner.container;
  				break;
  			}

  			fragment = fragment.parent;
  		}

  		// add component-instance-specific properties
  		instance.parent = this.parentFragment.ractive;
  		instance.container = container || null;
  		instance.root = instance.parent.root;
  		instance.component = this;

  		construct( this.instance, { partials: partials });

  		// for hackability, this could be an open option
  		// for any ractive instance, but for now, just
  		// for components and just for ractive...
  		instance._inlinePartials = partials;

  		this.attributeByName = {};

  		this.attributes = [];
  		var leftovers = [];
  		( this.template.m || [] ).forEach( function ( template ) {
  			switch ( template.t ) {
  				case ATTRIBUTE:
  				case EVENT:
  				case TRANSITION:
  					this$1.attributes.push( createItem({
  						owner: this$1,
  						parentFragment: this$1.parentFragment,
  						template: template
  					}) );
  					break;

  				case BINDING_FLAG:
  				case DECORATOR:
  					break;

  				default:
  					leftovers.push( template );
  					break;
  			}
  		});

  		this.attributes.push( new ConditionalAttribute({
  			owner: this,
  			parentFragment: this.parentFragment,
  			template: leftovers
  		}) );

  		this.eventHandlers = [];
  		if ( this.template.v ) this.setupEvents();
  	}

  	Component.prototype = Object.create( Item && Item.prototype );
  	Component.prototype.constructor = Component;

  	Component.prototype.bind = function bind$1$$ () {
  		this.attributes.forEach( bind$1 );

  		initialise( this.instance, {
  			partials: this._partials
  		}, {
  			cssIds: this.parentFragment.cssIds
  		});

  		this.eventHandlers.forEach( bind$1 );

  		this.bound = true;
  	};

  	Component.prototype.bubble = function bubble () {
  		if ( !this.dirty ) {
  			this.dirty = true;
  			this.parentFragment.bubble();
  		}
  	};

  	Component.prototype.checkYielders = function checkYielders () {
  		var this$1 = this;

  		Object.keys( this.yielders ).forEach( function ( name ) {
  			if ( this$1.yielders[ name ].length > 1 ) {
  				runloop.end();
  				throw new Error( ("A component template can only have one {{yield" + (name ? ' ' + name : '') + "}} declaration at a time") );
  			}
  		});
  	};

  	Component.prototype.destroyed = function destroyed () {
  		if ( this.instance.fragment ) this.instance.fragment.destroyed();
  	};

  	Component.prototype.detach = function detach () {
  		return this.instance.fragment.detach();
  	};

  	Component.prototype.find = function find ( selector ) {
  		return this.instance.fragment.find( selector );
  	};

  	Component.prototype.findAll = function findAll ( selector, query ) {
  		this.instance.fragment.findAll( selector, query );
  	};

  	Component.prototype.findComponent = function findComponent ( name ) {
  		if ( !name || this.name === name ) return this.instance;

  		if ( this.instance.fragment ) {
  			return this.instance.fragment.findComponent( name );
  		}
  	};

  	Component.prototype.findAllComponents = function findAllComponents ( name, query ) {
  		if ( query.test( this ) ) {
  			query.add( this.instance );

  			if ( query.live ) {
  				this.liveQueries.push( query );
  			}
  		}

  		this.instance.fragment.findAllComponents( name, query );
  	};

  	Component.prototype.firstNode = function firstNode ( skipParent ) {
  		return this.instance.fragment.firstNode( skipParent );
  	};

  	Component.prototype.render = function render$1$$ ( target, occupants ) {
  		render$1( this.instance, target, null, occupants );

  		this.checkYielders();
  		this.attributes.forEach( render );
  		this.eventHandlers.forEach( render );
  		updateLiveQueries( this );

  		this.rendered = true;
  	};

  	Component.prototype.setupEvents = function setupEvents () {
  		var this$1 = this;

  		var handlers = this.eventHandlers;

  		Object.keys( this.template.v ).forEach( function ( key ) {
  			var eventNames = key.split( '-' );
  			var template = this$1.template.v[ key ];

  			eventNames.forEach( function ( eventName ) {
  				var event = new RactiveEvent( this$1.instance, eventName );
  				handlers.push( new EventDirective( this$1, event, template ) );
  			});
  		});
  	};

  	Component.prototype.shuffled = function shuffled () {
  		this.liveQueries.forEach( makeDirty );
  		Item.prototype.shuffled.call(this);
  	};

  	Component.prototype.toString = function toString () {
  		return this.instance.toHTML();
  	};

  	Component.prototype.unbind = function unbind$1 () {
  		this.bound = false;

  		this.attributes.forEach( unbind );

  		var instance = this.instance;
  		instance.viewmodel.teardown();
  		instance.fragment.unbind();
  		instance._observers.forEach( cancel );

  		removeFromLiveComponentQueries( this );

  		if ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {
  			removeFromArray( instance.el.__ractive_instances__, instance );
  		}

  		teardownHook.fire( instance );
  	};

  	Component.prototype.unrender = function unrender$1 ( shouldDestroy ) {
  		var this$1 = this;

  		this.rendered = false;

  		this.shouldDestroy = shouldDestroy;
  		this.instance.unrender();
  		this.attributes.forEach( unrender );
  		this.eventHandlers.forEach( unrender );
  		this.liveQueries.forEach( function ( query ) { return query.remove( this$1.instance ); } );
  	};

  	Component.prototype.update = function update$1 () {
  		this.dirty = false;
  		this.instance.fragment.update();
  		this.checkYielders();
  		this.attributes.forEach( update );
  		this.eventHandlers.forEach( update );
  	};

  	return Component;
  }(Item));

  var missingDecorator = {
  	update: noop,
  	teardown: noop
  };

  var Decorator = function Decorator ( options ) {
  	this.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );
  	this.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );
  	this.parentFragment = this.owner.parentFragment;
  	this.ractive = this.owner.ractive;
  	var template = this.template = options.template;

  	this.dynamicName = typeof template.f.n === 'object';
  	this.dynamicArgs = !!template.f.d;

  	if ( this.dynamicName ) {
  		this.nameFragment = new Fragment({
  			owner: this,
  			template: template.f.n
  		});
  	} else {
  		this.name = template.f.n || template.f;
  	}

  	if ( this.dynamicArgs ) {
  		this.argsFragment = new Fragment({
  			owner: this,
  			template: template.f.d
  		});
  	} else {
  		if ( template.f.a && template.f.a.s ) {
  			this.args = [];
  		} else {
  			this.args = template.f.a || [];
  		}
  	}

  	this.node = null;
  	this.intermediary = null;

  	this.element.decorators.push( this );
  };

  Decorator.prototype.bind = function bind () {
  	var this$1 = this;

  		if ( this.dynamicName ) {
  		this.nameFragment.bind();
  		this.name = this.nameFragment.toString();
  	}

  	if ( this.dynamicArgs ) this.argsFragment.bind();

  	// TODO: dry this up once deprecation is done
  	if ( this.template.f.a && this.template.f.a.s ) {
  		this.resolvers = [];
  		this.models = this.template.f.a.r.map( function ( ref, i ) {
  			var resolver;
  			var model = resolveReference( this$1.parentFragment, ref );
  			if ( !model ) {
  				resolver = this$1.parentFragment.resolve( ref, function ( model ) {
  					this$1.models[i] = model;
  					removeFromArray( this$1.resolvers, resolver );
  					model.register( this$1 );
  				});

  				this$1.resolvers.push( resolver );
  			} else model.register( this$1 );

  			return model;
  		});
  		this.argsFn = getFunction( this.template.f.a.s, this.template.f.a.r.length );
  	}
  };

  Decorator.prototype.bubble = function bubble () {
  	if ( !this.dirty ) {
  		this.dirty = true;
  		this.owner.bubble();
  	}
  };

  Decorator.prototype.destroyed = function destroyed () {
  	if ( this.intermediary ) this.intermediary.teardown();
  };

  Decorator.prototype.handleChange = function handleChange () { this.bubble(); };

  Decorator.prototype.rebinding = function rebinding ( next, previous, safe ) {
  	var idx = this.models.indexOf( previous );
  	if ( !~idx ) return;

  	next = rebindMatch( this.template.f.a.r[ idx ], next, previous );
  	if ( next === previous ) return;

  	previous.unregister( this );
  	this.models.splice( idx, 1, next );
  	if ( next ) next.addShuffleRegister( this, 'mark' );

  	if ( !safe ) this.bubble();
  };

  Decorator.prototype.render = function render () {
  	var this$1 = this;

  		runloop.scheduleTask( function () {
  		var fn = findInViewHierarchy( 'decorators', this$1.ractive, this$1.name );

  		if ( !fn ) {
  			warnOnce( missingPlugin( this$1.name, 'decorator' ) );
  			this$1.intermediary = missingDecorator;
  			return;
  		}

  		this$1.node = this$1.element.node;

  		var args;
  		if ( this$1.argsFn ) {
  			args = this$1.models.map( function ( model ) {
  				if ( !model ) return undefined;

  				return model.get();
  			});
  			args = this$1.argsFn.apply( this$1.ractive, args );
  		} else {
  			args = this$1.dynamicArgs ? this$1.argsFragment.getArgsList() : this$1.args;
  		}

  		this$1.intermediary = fn.apply( this$1.ractive, [ this$1.node ].concat( args ) );

  		if ( !this$1.intermediary || !this$1.intermediary.teardown ) {
  			throw new Error( ("The '" + (this$1.name) + "' decorator must return an object with a teardown method") );
  		}
  	}, true );
  	this.rendered = true;
  };

  Decorator.prototype.toString = function toString () { return ''; };

  Decorator.prototype.unbind = function unbind$1 () {
  	var this$1 = this;

  		if ( this.dynamicName ) this.nameFragment.unbind();
  	if ( this.dynamicArgs ) this.argsFragment.unbind();
  	if ( this.resolvers ) this.resolvers.forEach( unbind );
  	if ( this.models ) this.models.forEach( function ( m ) {
  		if ( m ) m.unregister( this$1 );
  	});
  };

  Decorator.prototype.unrender = function unrender ( shouldDestroy ) {
  	if ( ( !shouldDestroy || this.element.rendered ) && this.intermediary ) this.intermediary.teardown();
  	this.rendered = false;
  };

  Decorator.prototype.update = function update () {
  	if ( !this.dirty ) return;

  	this.dirty = false;

  	var nameChanged = false;

  	if ( this.dynamicName && this.nameFragment.dirty ) {
  		var name = this.nameFragment.toString();
  		nameChanged = name !== this.name;
  		this.name = name;
  	}

  	if ( this.intermediary ) {
  		if ( nameChanged || !this.intermediary.update ) {
  			this.unrender();
  			this.render();
  		}
  		else {
  			if ( this.dynamicArgs ) {
  				if ( this.argsFragment.dirty ) {
  					var args = this.argsFragment.getArgsList();
  					this.intermediary.update.apply( this.ractive, args );
  				}
  			}
  			else if ( this.argsFn ) {
  				var args$1 = this.models.map( function ( model ) {
  					if ( !model ) return undefined;

  					return model.get();
  				});
  				this.intermediary.update.apply( this.ractive, this.argsFn.apply( this.ractive, args$1 ) );
  			}
  			else {
  				this.intermediary.update.apply( this.ractive, this.args );
  			}
  		}
  	}

  	// need to run these for unrender/render cases
  	// so can't just be in conditional if above

  	if ( this.dynamicName && this.nameFragment.dirty ) {
  		this.nameFragment.update();
  	}

  	if ( this.dynamicArgs && this.argsFragment.dirty ) {
  		this.argsFragment.update();
  	}
  };

  var Doctype = (function (Item) {
  	function Doctype () {
  		Item.apply(this, arguments);
  	}

  	Doctype.prototype = Object.create( Item && Item.prototype );
  	Doctype.prototype.constructor = Doctype;

  	Doctype.prototype.bind = function bind () {
  		// noop
  	};

  	Doctype.prototype.render = function render () {
  		// noop
  	};

  	Doctype.prototype.teardown = function teardown () {
  		// noop
  	};

  	Doctype.prototype.toString = function toString () {
  		return '<!DOCTYPE' + this.template.a + '>';
  	};

  	Doctype.prototype.unbind = function unbind () {
  		// noop
  	};

  	Doctype.prototype.unrender = function unrender () {
  		// noop
  	};

  	Doctype.prototype.update = function update () {
  		// noop
  	};

  	return Doctype;
  }(Item));

  function updateLiveQueries$1 ( element ) {
  	// Does this need to be added to any live queries?
  	var node = element.node;
  	var instance = element.ractive;

  	do {
  		var liveQueries = instance._liveQueries;

  		var i = liveQueries.length;
  		while ( i-- ) {
  			var selector = liveQueries[i];
  			var query = liveQueries[ ("_" + selector) ];

  			if ( query.test( node ) ) {
  				query.add( node );
  				// keep register of applicable selectors, for when we teardown
  				element.liveQueries.push( query );
  			}
  		}
  	} while ( instance = instance.parent );
  }

  function warnAboutAmbiguity ( description, ractive ) {
  	warnOnceIfDebug( ("The " + description + " being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity"), { ractive: ractive });
  }

  var Binding = function Binding ( element, name ) {
  	if ( name === void 0 ) name = 'value';

  		this.element = element;
  	this.ractive = element.ractive;
  	this.attribute = element.attributeByName[ name ];

  	var interpolator = this.attribute.interpolator;
  	interpolator.twowayBinding = this;

  	var model = interpolator.model;

  	// not bound?
  	if ( !model ) {
  		// try to force resolution
  		interpolator.resolver.forceResolution();
  		model = interpolator.model;

  		warnAboutAmbiguity( ("'" + (interpolator.template.r) + "' reference"), this.ractive );
  		}

  		else if ( model.isUnresolved ) {
  			// reference expressions (e.g. foo[bar])
  			model.forceResolution();
  			warnAboutAmbiguity( 'expression', this.ractive );
  	}

  	// TODO include index/key/keypath refs as read-only
  	else if ( model.isReadonly ) {
  		var keypath = model.getKeypath().replace( /^@/, '' );
  		warnOnceIfDebug( ("Cannot use two-way binding on <" + (element.name) + "> element: " + keypath + " is read-only. To suppress this warning use <" + (element.name) + " twoway='false'...>"), { ractive: this.ractive });
  		return false;
  	}

  	this.attribute.isTwoway = true;
  	this.model = model;

  	// initialise value, if it's undefined
  	var value = model.get();
  	this.wasUndefined = value === undefined;

  	if ( value === undefined && this.getInitialValue ) {
  		value = this.getInitialValue();
  		model.set( value );
  	}
  	this.lastVal( true, value );

  	var parentForm = findElement( this.element, false, 'form' );
  	if ( parentForm ) {
  		this.resetValue = value;
  		parentForm.formBindings.push( this );
  	}
  };

  Binding.prototype.bind = function bind () {
  	this.model.registerTwowayBinding( this );
  };

  Binding.prototype.handleChange = function handleChange () {
  	var this$1 = this;

  		var value = this.getValue();
  	if ( this.lastVal() === value ) return;

  	runloop.start( this.root );
  	this.attribute.locked = true;
  	this.model.set( value );
  	this.lastVal( true, value );

  	// if the value changes before observers fire, unlock to be updatable cause something weird and potentially freezy is up
  	if ( this.model.get() !== value ) this.attribute.locked = false;
  	else runloop.scheduleTask( function () { return this$1.attribute.locked = false; } );

  	runloop.end();
  };

  Binding.prototype.lastVal = function lastVal ( setting, value ) {
  	if ( setting ) this.lastValue = value;
  	else return this.lastValue;
  };

  Binding.prototype.rebinding = function rebinding ( next, previous ) {
  	var this$1 = this;

  		if ( this.model && this.model === previous ) previous.unregisterTwowayBinding( this );
  	if ( next ) {
  		this.model = next;
  		runloop.scheduleTask( function () { return next.registerTwowayBinding( this$1 ); } );
  	}
  };

  Binding.prototype.render = function render () {
  	this.node = this.element.node;
  	this.node._ractive.binding = this;
  	this.rendered = true; // TODO is this used anywhere?
  };

  	Binding.prototype.setFromNode = function setFromNode ( node ) {
  		this.model.set( node.value );
  };

  Binding.prototype.unbind = function unbind () {
  	this.model.unregisterTwowayBinding( this );
  };

  Binding.prototype.unrender = function unrender () {
  		// noop?
  	};

  // This is the handler for DOM events that would lead to a change in the model
  // (i.e. change, sometimes, input, and occasionally click and keyup)
  function handleDomEvent () {
  	this._ractive.binding.handleChange();
  }

  var CheckboxBinding = (function (Binding) {
  	function CheckboxBinding ( element ) {
  		Binding.call( this, element, 'checked' );
  	}

  	CheckboxBinding.prototype = Object.create( Binding && Binding.prototype );
  	CheckboxBinding.prototype.constructor = CheckboxBinding;

  	CheckboxBinding.prototype.render = function render () {
  		Binding.prototype.render.call(this);

  		this.node.addEventListener( 'change', handleDomEvent, false );

  		if ( this.node.attachEvent ) {
  			this.node.addEventListener( 'click', handleDomEvent, false );
  		}
  	};

  	CheckboxBinding.prototype.unrender = function unrender () {
  		this.node.removeEventListener( 'change', handleDomEvent, false );
  		this.node.removeEventListener( 'click', handleDomEvent, false );
  	};

  	CheckboxBinding.prototype.getInitialValue = function getInitialValue () {
  		return !!this.element.getAttribute( 'checked' );
  	};

  	CheckboxBinding.prototype.getValue = function getValue () {
  		return this.node.checked;
  	};

  	CheckboxBinding.prototype.setFromNode = function setFromNode ( node ) {
  		this.model.set( node.checked );
  	};

  	return CheckboxBinding;
  }(Binding));

  function getBindingGroup ( group, model, getValue ) {
  	var hash = "" + group + "-bindingGroup";
  	return model[hash] || ( model[ hash ] = new BindingGroup( hash, model, getValue ) );
  }

  var BindingGroup = function BindingGroup ( hash, model, getValue ) {
  	var this$1 = this;

  		this.model = model;
  	this.hash = hash;
  	this.getValue = function () {
  		this$1.value = getValue.call(this$1);
  		return this$1.value;
  	};

  	this.bindings = [];
  };

  BindingGroup.prototype.add = function add ( binding ) {
  	this.bindings.push( binding );
  };

  BindingGroup.prototype.bind = function bind () {
  	this.value = this.model.get();
  	this.model.registerTwowayBinding( this );
  	this.bound = true;
  };

  BindingGroup.prototype.remove = function remove ( binding ) {
  	removeFromArray( this.bindings, binding );
  	if ( !this.bindings.length ) {
  		this.unbind();
  	}
  };

  BindingGroup.prototype.unbind = function unbind () {
  	this.model.unregisterTwowayBinding( this );
  	this.bound = false;
  	delete this.model[this.hash];
  };

  var push$2 = [].push;

  function getValue() {
  	var all = this.bindings.filter(function ( b ) { return b.node && b.node.checked; }).map(function ( b ) { return b.element.getAttribute( 'value' ); });
  	var res = [];
  	all.forEach(function ( v ) { if ( !arrayContains( res, v ) ) res.push( v ); });
  	return res;
  }

  var CheckboxNameBinding = (function (Binding) {
  	function CheckboxNameBinding ( element ) {
  		Binding.call( this, element, 'name' );

  		this.checkboxName = true; // so that ractive.updateModel() knows what to do with this

  		// Each input has a reference to an array containing it and its
  		// group, as two-way binding depends on being able to ascertain
  		// the status of all inputs within the group
  		this.group = getBindingGroup( 'checkboxes', this.model, getValue );
  		this.group.add( this );

  		if ( this.noInitialValue ) {
  			this.group.noInitialValue = true;
  		}

  		// If no initial value was set, and this input is checked, we
  		// update the model
  		if ( this.group.noInitialValue && this.element.getAttribute( 'checked' ) ) {
  			var existingValue = this.model.get();
  			var bindingValue = this.element.getAttribute( 'value' );

  			if ( !arrayContains( existingValue, bindingValue ) ) {
  				push$2.call( existingValue, bindingValue ); // to avoid triggering runloop with array adaptor
  			}
  		}
  	}

  	CheckboxNameBinding.prototype = Object.create( Binding && Binding.prototype );
  	CheckboxNameBinding.prototype.constructor = CheckboxNameBinding;

  	CheckboxNameBinding.prototype.bind = function bind () {
  		if ( !this.group.bound ) {
  			this.group.bind();
  		}
  	};

  	CheckboxNameBinding.prototype.changed = function changed () {
  		var wasChecked = !!this.isChecked;
  		this.isChecked = this.node.checked;
  		return this.isChecked === wasChecked;
  	};

  	CheckboxNameBinding.prototype.getInitialValue = function getInitialValue () {
  		// This only gets called once per group (of inputs that
  		// share a name), because it only gets called if there
  		// isn't an initial value. By the same token, we can make
  		// a note of that fact that there was no initial value,
  		// and populate it using any `checked` attributes that
  		// exist (which users should avoid, but which we should
  		// support anyway to avoid breaking expectations)
  		this.noInitialValue = true; // TODO are noInitialValue and wasUndefined the same thing?
  		return [];
  	};

  	CheckboxNameBinding.prototype.getValue = function getValue$1 () {
  		return this.group.value;
  	};

  	CheckboxNameBinding.prototype.handleChange = function handleChange () {
  		this.isChecked = this.element.node.checked;
  		this.group.value = this.model.get();
  		var value = this.element.getAttribute( 'value' );
  		if ( this.isChecked && !arrayContains( this.group.value, value ) ) {
  			this.group.value.push( value );
  		} else if ( !this.isChecked && arrayContains( this.group.value, value ) ) {
  			removeFromArray( this.group.value, value );
  		}
  		// make sure super knows there's a change
  		this.lastValue = null;
  		Binding.prototype.handleChange.call(this);
  	};

  	CheckboxNameBinding.prototype.render = function render () {
  		Binding.prototype.render.call(this);

  		var node = this.node;

  		var existingValue = this.model.get();
  		var bindingValue = this.element.getAttribute( 'value' );

  		if ( isArray( existingValue ) ) {
  			this.isChecked = arrayContains( existingValue, bindingValue );
  		} else {
  			this.isChecked = existingValue == bindingValue;
  		}

  		node.name = '{{' + this.model.getKeypath() + '}}';
  		node.checked = this.isChecked;

  		node.addEventListener( 'change', handleDomEvent, false );

  		// in case of IE emergency, bind to click event as well
  		if ( node.attachEvent ) {
  			node.addEventListener( 'click', handleDomEvent, false );
  		}
  	};

  	CheckboxNameBinding.prototype.setFromNode = function setFromNode ( node ) {
  		this.group.bindings.forEach( function ( binding ) { return binding.wasUndefined = true; } );

  		if ( node.checked ) {
  			var valueSoFar = this.group.getValue();
  			valueSoFar.push( this.element.getAttribute( 'value' ) );

  			this.group.model.set( valueSoFar );
  		}
  	};

  	CheckboxNameBinding.prototype.unbind = function unbind () {
  		this.group.remove( this );
  	};

  	CheckboxNameBinding.prototype.unrender = function unrender () {
  		var node = this.element.node;

  		node.removeEventListener( 'change', handleDomEvent, false );
  		node.removeEventListener( 'click', handleDomEvent, false );
  	};

  	return CheckboxNameBinding;
  }(Binding));

  var ContentEditableBinding = (function (Binding) {
  	function ContentEditableBinding () {
  		Binding.apply(this, arguments);
  	}

  	ContentEditableBinding.prototype = Object.create( Binding && Binding.prototype );
  	ContentEditableBinding.prototype.constructor = ContentEditableBinding;

  	ContentEditableBinding.prototype.getInitialValue = function getInitialValue () {
  		return this.element.fragment ? this.element.fragment.toString() : '';
  	};

  	ContentEditableBinding.prototype.getValue = function getValue () {
  		return this.element.node.innerHTML;
  	};

  	ContentEditableBinding.prototype.render = function render () {
  		Binding.prototype.render.call(this);

  		var node = this.node;

  		node.addEventListener( 'change', handleDomEvent, false );
  		node.addEventListener( 'blur', handleDomEvent, false );

  		if ( !this.ractive.lazy ) {
  			node.addEventListener( 'input', handleDomEvent, false );

  			if ( node.attachEvent ) {
  				node.addEventListener( 'keyup', handleDomEvent, false );
  			}
  		}
  	};

  	ContentEditableBinding.prototype.setFromNode = function setFromNode ( node ) {
  		this.model.set( node.innerHTML );
  	};

  	ContentEditableBinding.prototype.unrender = function unrender () {
  		var node = this.node;

  		node.removeEventListener( 'blur', handleDomEvent, false );
  		node.removeEventListener( 'change', handleDomEvent, false );
  		node.removeEventListener( 'input', handleDomEvent, false );
  		node.removeEventListener( 'keyup', handleDomEvent, false );
  	};

  	return ContentEditableBinding;
  }(Binding));

  function handleBlur () {
  	handleDomEvent.call( this );

  	var value = this._ractive.binding.model.get();
  	this.value = value == undefined ? '' : value;
  }

  function handleDelay ( delay ) {
  	var timeout;

  	return function () {
  		var this$1 = this;

  		if ( timeout ) clearTimeout( timeout );

  		timeout = setTimeout( function () {
  			var binding = this$1._ractive.binding;
  			if ( binding.rendered ) handleDomEvent.call( this$1 );
  			timeout = null;
  		}, delay );
  	};
  }

  var GenericBinding = (function (Binding) {
  	function GenericBinding () {
  		Binding.apply(this, arguments);
  	}

  	GenericBinding.prototype = Object.create( Binding && Binding.prototype );
  	GenericBinding.prototype.constructor = GenericBinding;

  	GenericBinding.prototype.getInitialValue = function getInitialValue () {
  		return '';
  	};

  	GenericBinding.prototype.getValue = function getValue () {
  		return this.node.value;
  	};

  	GenericBinding.prototype.render = function render () {
  		Binding.prototype.render.call(this);

  		// any lazy setting for this element overrides the root
  		// if the value is a number, it's a timeout
  		var lazy = this.ractive.lazy;
  		var timeout = false;

  		if ( 'lazy' in this.element ) {
  			lazy = this.element.lazy;
  		}

  		if ( isNumeric( lazy ) ) {
  			timeout = +lazy;
  			lazy = false;
  		}

  		this.handler = timeout ? handleDelay( timeout ) : handleDomEvent;

  		var node = this.node;

  		node.addEventListener( 'change', handleDomEvent, false );

  		if ( !lazy ) {
  			node.addEventListener( 'input', this.handler, false );

  			if ( node.attachEvent ) {
  				node.addEventListener( 'keyup', this.handler, false );
  			}
  		}

  		node.addEventListener( 'blur', handleBlur, false );
  	};

  	GenericBinding.prototype.unrender = function unrender () {
  		var node = this.element.node;
  		this.rendered = false;

  		node.removeEventListener( 'change', handleDomEvent, false );
  		node.removeEventListener( 'input', this.handler, false );
  		node.removeEventListener( 'keyup', this.handler, false );
  		node.removeEventListener( 'blur', handleBlur, false );
  	};

  	return GenericBinding;
  }(Binding));

  var FileBinding = (function (GenericBinding) {
  	function FileBinding () {
  		GenericBinding.apply(this, arguments);
  	}

  	FileBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );
  	FileBinding.prototype.constructor = FileBinding;

  	FileBinding.prototype.getInitialValue = function getInitialValue () {
  		return undefined;
  	};

  	FileBinding.prototype.getValue = function getValue () {
  		return this.node.files;
  	};

  	FileBinding.prototype.render = function render () {
  		this.element.lazy = false;
  		GenericBinding.prototype.render.call(this);
  	};

  	FileBinding.prototype.setFromNode = function setFromNode( node ) {
  		this.model.set( node.files );
  	};

  	return FileBinding;
  }(GenericBinding));

  function getSelectedOptions ( select ) {
      return select.selectedOptions
  		? toArray( select.selectedOptions )
  		: select.options
  			? toArray( select.options ).filter( function ( option ) { return option.selected; } )
  			: [];
  }

  var MultipleSelectBinding = (function (Binding) {
  	function MultipleSelectBinding () {
  		Binding.apply(this, arguments);
  	}

  	MultipleSelectBinding.prototype = Object.create( Binding && Binding.prototype );
  	MultipleSelectBinding.prototype.constructor = MultipleSelectBinding;

  	MultipleSelectBinding.prototype.forceUpdate = function forceUpdate () {
  		var this$1 = this;

  		var value = this.getValue();

  		if ( value !== undefined ) {
  			this.attribute.locked = true;
  			runloop.scheduleTask( function () { return this$1.attribute.locked = false; } );
  			this.model.set( value );
  		}
  	};

  	MultipleSelectBinding.prototype.getInitialValue = function getInitialValue () {
  		return this.element.options
  			.filter( function ( option ) { return option.getAttribute( 'selected' ); } )
  			.map( function ( option ) { return option.getAttribute( 'value' ); } );
  	};

  	MultipleSelectBinding.prototype.getValue = function getValue () {
  		var options = this.element.node.options;
  		var len = options.length;

  		var selectedValues = [];

  		for ( var i = 0; i < len; i += 1 ) {
  			var option = options[i];

  			if ( option.selected ) {
  				var optionValue = option._ractive ? option._ractive.value : option.value;
  				selectedValues.push( optionValue );
  			}
  		}

  		return selectedValues;
  	};

  	MultipleSelectBinding.prototype.handleChange = function handleChange () {
  		var attribute = this.attribute;
  		var previousValue = attribute.getValue();

  		var value = this.getValue();

  		if ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {
  			Binding.prototype.handleChange.call(this);
  		}

  		return this;
  	};

  	MultipleSelectBinding.prototype.render = function render () {
  		Binding.prototype.render.call(this);

  		this.node.addEventListener( 'change', handleDomEvent, false );

  		if ( this.model.get() === undefined ) {
  			// get value from DOM, if possible
  			this.handleChange();
  		}
  	};

  	MultipleSelectBinding.prototype.setFromNode = function setFromNode ( node ) {
  		var selectedOptions = getSelectedOptions( node );
  		var i = selectedOptions.length;
  		var result = new Array( i );

  		while ( i-- ) {
  			var option = selectedOptions[i];
  			result[i] = option._ractive ? option._ractive.value : option.value;
  		}

  		this.model.set( result );
  	};

  	MultipleSelectBinding.prototype.setValue = function setValue () {
  		throw new Error( 'TODO not implemented yet' );
  	};

  	MultipleSelectBinding.prototype.unrender = function unrender () {
  		this.node.removeEventListener( 'change', handleDomEvent, false );
  	};

  	MultipleSelectBinding.prototype.updateModel = function updateModel () {
  		if ( this.attribute.value === undefined || !this.attribute.value.length ) {
  			this.keypath.set( this.initialValue );
  		}
  	};

  	return MultipleSelectBinding;
  }(Binding));

  var NumericBinding = (function (GenericBinding) {
  	function NumericBinding () {
  		GenericBinding.apply(this, arguments);
  	}

  	NumericBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );
  	NumericBinding.prototype.constructor = NumericBinding;

  	NumericBinding.prototype.getInitialValue = function getInitialValue () {
  		return undefined;
  	};

  	NumericBinding.prototype.getValue = function getValue () {
  		var value = parseFloat( this.node.value );
  		return isNaN( value ) ? undefined : value;
  	};

  	NumericBinding.prototype.setFromNode = function setFromNode( node ) {
  		var value = parseFloat( node.value );
  		if ( !isNaN( value ) ) this.model.set( value );
  	};

  	return NumericBinding;
  }(GenericBinding));

  var siblings = {};

  function getSiblings ( hash ) {
  	return siblings[ hash ] || ( siblings[ hash ] = [] );
  }

  var RadioBinding = (function (Binding) {
  	function RadioBinding ( element ) {
  		Binding.call( this, element, 'checked' );

  		this.siblings = getSiblings( this.ractive._guid + this.element.getAttribute( 'name' ) );
  		this.siblings.push( this );
  	}

  	RadioBinding.prototype = Object.create( Binding && Binding.prototype );
  	RadioBinding.prototype.constructor = RadioBinding;

  	RadioBinding.prototype.getValue = function getValue () {
  		return this.node.checked;
  	};

  	RadioBinding.prototype.handleChange = function handleChange () {
  		runloop.start( this.root );

  		this.siblings.forEach( function ( binding ) {
  			binding.model.set( binding.getValue() );
  		});

  		runloop.end();
  	};

  	RadioBinding.prototype.render = function render () {
  		Binding.prototype.render.call(this);

  		this.node.addEventListener( 'change', handleDomEvent, false );

  		if ( this.node.attachEvent ) {
  			this.node.addEventListener( 'click', handleDomEvent, false );
  		}
  	};

  	RadioBinding.prototype.setFromNode = function setFromNode ( node ) {
  		this.model.set( node.checked );
  	};

  	RadioBinding.prototype.unbind = function unbind () {
  		removeFromArray( this.siblings, this );
  	};

  	RadioBinding.prototype.unrender = function unrender () {
  		this.node.removeEventListener( 'change', handleDomEvent, false );
  		this.node.removeEventListener( 'click', handleDomEvent, false );
  	};

  	return RadioBinding;
  }(Binding));

  function getValue$1() {
  	var checked = this.bindings.filter( function ( b ) { return b.node.checked; } );
  	if ( checked.length > 0 ) {
  		return checked[0].element.getAttribute( 'value' );
  	}
  }

  var RadioNameBinding = (function (Binding) {
  	function RadioNameBinding ( element ) {
  		Binding.call( this, element, 'name' );

  		this.group = getBindingGroup( 'radioname', this.model, getValue$1 );
  		this.group.add( this );

  		if ( element.checked ) {
  			this.group.value = this.getValue();
  		}
  	}

  	RadioNameBinding.prototype = Object.create( Binding && Binding.prototype );
  	RadioNameBinding.prototype.constructor = RadioNameBinding;

  	RadioNameBinding.prototype.bind = function bind () {
  		var this$1 = this;

  		if ( !this.group.bound ) {
  			this.group.bind();
  		}

  		// update name keypath when necessary
  		this.nameAttributeBinding = {
  			handleChange: function () { return this$1.node.name = "{{" + (this$1.model.getKeypath()) + "}}"; }
  		};

  		this.model.getKeypathModel().register( this.nameAttributeBinding );
  	};

  	RadioNameBinding.prototype.getInitialValue = function getInitialValue () {
  		if ( this.element.getAttribute( 'checked' ) ) {
  			return this.element.getAttribute( 'value' );
  		}
  	};

  	RadioNameBinding.prototype.getValue = function getValue$1 () {
  		return this.element.getAttribute( 'value' );
  	};

  	RadioNameBinding.prototype.handleChange = function handleChange () {
  		// If this <input> is the one that's checked, then the value of its
  		// `name` model gets set to its value
  		if ( this.node.checked ) {
  			this.group.value = this.getValue();
  			Binding.prototype.handleChange.call(this);
  		}
  	};

  	RadioNameBinding.prototype.lastVal = function lastVal ( setting, value ) {
  		if ( !this.group ) return;
  		if ( setting ) this.group.lastValue = value;
  		else return this.group.lastValue;
  	};

  	RadioNameBinding.prototype.render = function render () {
  		Binding.prototype.render.call(this);

  		var node = this.node;

  		node.name = "{{" + (this.model.getKeypath()) + "}}";
  		node.checked = this.model.get() == this.element.getAttribute( 'value' );

  		node.addEventListener( 'change', handleDomEvent, false );

  		if ( node.attachEvent ) {
  			node.addEventListener( 'click', handleDomEvent, false );
  		}
  	};

  	RadioNameBinding.prototype.setFromNode = function setFromNode ( node ) {
  		if ( node.checked ) {
  			this.group.model.set( this.element.getAttribute( 'value' ) );
  		}
  	};

  	RadioNameBinding.prototype.unbind = function unbind () {
  		this.group.remove( this );

  		this.model.getKeypathModel().unregister( this.nameAttributeBinding );
  	};

  	RadioNameBinding.prototype.unrender = function unrender () {
  		var node = this.node;

  		node.removeEventListener( 'change', handleDomEvent, false );
  		node.removeEventListener( 'click', handleDomEvent, false );
  	};

  	return RadioNameBinding;
  }(Binding));

  var SingleSelectBinding = (function (Binding) {
  	function SingleSelectBinding () {
  		Binding.apply(this, arguments);
  	}

  	SingleSelectBinding.prototype = Object.create( Binding && Binding.prototype );
  	SingleSelectBinding.prototype.constructor = SingleSelectBinding;

  	SingleSelectBinding.prototype.forceUpdate = function forceUpdate () {
  		var this$1 = this;

  		var value = this.getValue();

  		if ( value !== undefined ) {
  			this.attribute.locked = true;
  			runloop.scheduleTask( function () { return this$1.attribute.locked = false; } );
  			this.model.set( value );
  		}
  	};

  	SingleSelectBinding.prototype.getInitialValue = function getInitialValue () {
  		if ( this.element.getAttribute( 'value' ) !== undefined ) {
  			return;
  		}

  		var options = this.element.options;
  		var len = options.length;

  		if ( !len ) return;

  		var value;
  		var optionWasSelected;
  		var i = len;

  		// take the final selected option...
  		while ( i-- ) {
  			var option = options[i];

  			if ( option.getAttribute( 'selected' ) ) {
  				if ( !option.getAttribute( 'disabled' ) ) {
  					value = option.getAttribute( 'value' );
  				}

  				optionWasSelected = true;
  				break;
  			}
  		}

  		// or the first non-disabled option, if none are selected
  		if ( !optionWasSelected ) {
  			while ( ++i < len ) {
  				if ( !options[i].getAttribute( 'disabled' ) ) {
  					value = options[i].getAttribute( 'value' );
  					break;
  				}
  			}
  		}

  		// This is an optimisation (aka hack) that allows us to forgo some
  		// other more expensive work
  		// TODO does it still work? seems at odds with new architecture
  		if ( value !== undefined ) {
  			this.element.attributeByName.value.value = value;
  		}

  		return value;
  	};

  	SingleSelectBinding.prototype.getValue = function getValue () {
  		var options = this.node.options;
  		var len = options.length;

  		var i;
  		for ( i = 0; i < len; i += 1 ) {
  			var option = options[i];

  			if ( options[i].selected && !options[i].disabled ) {
  				return option._ractive ? option._ractive.value : option.value;
  			}
  		}
  	};

  	SingleSelectBinding.prototype.render = function render () {
  		Binding.prototype.render.call(this);
  		this.node.addEventListener( 'change', handleDomEvent, false );
  	};

  	SingleSelectBinding.prototype.setFromNode = function setFromNode ( node ) {
  		var option = getSelectedOptions( node )[0];
  		this.model.set( option._ractive ? option._ractive.value : option.value );
  	};

  	// TODO this method is an anomaly... is it necessary?
  	SingleSelectBinding.prototype.setValue = function setValue ( value ) {
  		this.model.set( value );
  	};

  	SingleSelectBinding.prototype.unrender = function unrender () {
  		this.node.removeEventListener( 'change', handleDomEvent, false );
  	};

  	return SingleSelectBinding;
  }(Binding));

  function isBindable ( attribute ) {
  	return attribute &&
  		   attribute.template.f &&
  	       attribute.template.f.length === 1 &&
  	       attribute.template.f[0].t === INTERPOLATOR &&
  	       !attribute.template.f[0].s;
  }

  function selectBinding ( element ) {
  	var attributes = element.attributeByName;

  	// contenteditable - bind if the contenteditable attribute is true
  	// or is bindable and may thus become true...
  	if ( element.getAttribute( 'contenteditable' ) || isBindable( attributes.contenteditable ) ) {
  		// ...and this element also has a value attribute to bind
  		return isBindable( attributes.value ) ? ContentEditableBinding : null;
  	}

  	// <input>
  	if ( element.name === 'input' ) {
  		var type = element.getAttribute( 'type' );

  		if ( type === 'radio' || type === 'checkbox' ) {
  			var bindName = isBindable( attributes.name );
  			var bindChecked = isBindable( attributes.checked );

  			// for radios we can either bind the name attribute, or the checked attribute - not both
  			if ( bindName && bindChecked ) {
  				if ( type === 'radio' ) {
  					warnIfDebug( 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both', { ractive: element.root });
  				} else {
  					// A checkbox with bindings for both name and checked - see https://github.com/ractivejs/ractive/issues/1749
  					return CheckboxBinding;
  				}
  			}

  			if ( bindName ) {
  				return type === 'radio' ? RadioNameBinding : CheckboxNameBinding;
  			}

  			if ( bindChecked ) {
  				return type === 'radio' ? RadioBinding : CheckboxBinding;
  			}
  		}

  		if ( type === 'file' && isBindable( attributes.value ) ) {
  			return FileBinding;
  		}

  		if ( isBindable( attributes.value ) ) {
  			return ( type === 'number' || type === 'range' ) ? NumericBinding : GenericBinding;
  		}

  		return null;
  	}

  	// <select>
  	if ( element.name === 'select' && isBindable( attributes.value ) ) {
  		return element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SingleSelectBinding;
  	}

  	// <textarea>
  	if ( element.name === 'textarea' && isBindable( attributes.value ) ) {
  		return GenericBinding;
  	}
  }

  function makeDirty$1 ( query ) {
  	query.makeDirty();
  }

  var endsWithSemi = /;\s*$/;

  var Element = (function (Item) {
  	function Element ( options ) {
  		var this$1 = this;

  		Item.call( this, options );

  		this.liveQueries = []; // TODO rare case. can we handle differently?

  		this.name = options.template.e.toLowerCase();
  		this.isVoid = voidElementNames.test( this.name );

  		// find parent element
  		this.parent = findElement( this.parentFragment, false );

  		if ( this.parent && this.parent.name === 'option' ) {
  			throw new Error( ("An <option> element cannot contain other elements (encountered <" + (this.name) + ">)") );
  		}

  		this.decorators = [];

  		// create attributes
  		this.attributeByName = {};

  		this.attributes = [];
  		var leftovers = [];
  		( this.template.m || [] ).forEach( function ( template ) {
  			switch ( template.t ) {
  				case ATTRIBUTE:
  				case BINDING_FLAG:
  				case DECORATOR:
  				case EVENT:
  				case TRANSITION:
  					this$1.attributes.push( createItem({
  						owner: this$1,
  						parentFragment: this$1.parentFragment,
  						template: template
  					}) );
  					break;

  				default:
  					leftovers.push( template );
  					break;
  			}
  		});

  		if ( leftovers.length ) {
  			this.attributes.push( new ConditionalAttribute({
  				owner: this,
  				parentFragment: this.parentFragment,
  				template: leftovers
  			}) );
  		}

  		var i = this.attributes.length;
  		while ( i-- ) {
  			var attr = this$1.attributes[ i ];
  			if ( attr.name === 'type' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );
  			else if ( attr.name === 'max' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );
  			else if ( attr.name === 'min' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );
  			else if ( attr.name === 'class' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );
  			else if ( attr.name === 'value' ) {
  				this$1.attributes.push( this$1.attributes.splice( i, 1 )[ 0 ] );
  			}
  		}

  		// create children
  		if ( options.template.f && !options.deferContent ) {
  			this.fragment = new Fragment({
  				template: options.template.f,
  				owner: this,
  				cssIds: null
  			});
  		}

  		this.binding = null; // filled in later
  	}

  	Element.prototype = Object.create( Item && Item.prototype );
  	Element.prototype.constructor = Element;

  	Element.prototype.bind = function bind$1$$ () {
  		this.attributes.binding = true;
  		this.attributes.forEach( bind$1 );
  		this.attributes.binding = false;

  		if ( this.fragment ) this.fragment.bind();

  		// create two-way binding if necessary
  		if ( !this.binding ) this.recreateTwowayBinding();
  	};

  	Element.prototype.createTwowayBinding = function createTwowayBinding () {
  		var shouldBind = 'twoway' in this ? this.twoway : this.ractive.twoway;

  		if ( !shouldBind ) return null;

  		var Binding = selectBinding( this );

  		if ( !Binding ) return null;

  		var binding = new Binding( this );

  		return binding && binding.model ?
  			binding :
  			null;
  	};

  	Element.prototype.destroyed = function destroyed () {
  		this.attributes.forEach( function ( a ) { return a.destroyed(); } );
  		if ( this.fragment ) this.fragment.destroyed();
  	};

  	Element.prototype.detach = function detach () {
  		// if this element is no longer rendered, the transitions are complete and the attributes can be torn down
  		if ( !this.rendered ) this.destroyed();

  		return detachNode( this.node );
  	};

  	Element.prototype.find = function find ( selector ) {
  		if ( matches( this.node, selector ) ) return this.node;
  		if ( this.fragment ) {
  			return this.fragment.find( selector );
  		}
  	};

  	Element.prototype.findAll = function findAll ( selector, query ) {
  		// Add this node to the query, if applicable, and register the
  		// query on this element
  		var matches = query.test( this.node );
  		if ( matches ) {
  			query.add( this.node );
  			if ( query.live ) this.liveQueries.push( query );
  		}

  		if ( this.fragment ) {
  			this.fragment.findAll( selector, query );
  		}
  	};

  	Element.prototype.findComponent = function findComponent ( name ) {
  		if ( this.fragment ) {
  			return this.fragment.findComponent( name );
  		}
  	};

  	Element.prototype.findAllComponents = function findAllComponents ( name, query ) {
  		if ( this.fragment ) {
  			this.fragment.findAllComponents( name, query );
  		}
  	};

  	Element.prototype.findNextNode = function findNextNode () {
  		return null;
  	};

  	Element.prototype.firstNode = function firstNode () {
  		return this.node;
  	};

  	Element.prototype.getAttribute = function getAttribute ( name ) {
  		var attribute = this.attributeByName[ name ];
  		return attribute ? attribute.getValue() : undefined;
  	};

  	Element.prototype.recreateTwowayBinding = function recreateTwowayBinding () {
  		if ( this.binding ) {
  			this.binding.unbind();
  			this.binding.unrender();
  		}

  		if ( this.binding = this.createTwowayBinding() ) {
  			this.binding.bind();
  			if ( this.rendered ) this.binding.render();
  		}
  	};

  	Element.prototype.render = function render$1 ( target, occupants ) {
  		// TODO determine correct namespace
  		var this$1 = this;

  		this.namespace = getNamespace( this );

  		var node;
  		var existing = false;

  		if ( occupants ) {
  			var n;
  			while ( ( n = occupants.shift() ) ) {
  				if ( n.nodeName.toUpperCase() === this$1.template.e.toUpperCase() && n.namespaceURI === this$1.namespace ) {
  					this$1.node = node = n;
  					existing = true;
  					break;
  				} else {
  					detachNode( n );
  				}
  			}
  		}

  		if ( !node ) {
  			node = createElement( this.template.e, this.namespace, this.getAttribute( 'is' ) );
  			this.node = node;
  		}

  		defineProperty( node, '_ractive', {
  			value: {
  				proxy: this
  			}
  		});

  		// Is this a top-level node of a component? If so, we may need to add
  		// a data-ractive-css attribute, for CSS encapsulation
  		if ( this.parentFragment.cssIds ) {
  			node.setAttribute( 'data-ractive-css', this.parentFragment.cssIds.map( function ( x ) { return ("{" + x + "}"); } ).join( ' ' ) );
  		}

  		if ( existing && this.foundNode ) this.foundNode( node );

  		if ( this.fragment ) {
  			var children = existing ? toArray( node.childNodes ) : undefined;

  			this.fragment.render( node, children );

  			// clean up leftover children
  			if ( children ) {
  				children.forEach( detachNode );
  			}
  		}

  		if ( existing ) {
  			// store initial values for two-way binding
  			if ( this.binding && this.binding.wasUndefined ) this.binding.setFromNode( node );
  			// remove unused attributes
  			var i = node.attributes.length;
  			while ( i-- ) {
  				var name = node.attributes[i].name;
  				if ( !( name in this$1.attributeByName ) ) node.removeAttribute( name );
  			}
  		}

  		this.attributes.forEach( render );

  		if ( this.binding ) this.binding.render();

  		updateLiveQueries$1( this );

  		if ( this._introTransition && this.ractive.transitionsEnabled ) {
  			this._introTransition.isIntro = true;
  			runloop.registerTransition( this._introTransition );
  		}

  		if ( !existing ) {
  			target.appendChild( node );
  		}

  		this.rendered = true;
  	};

  	Element.prototype.shuffled = function shuffled () {
  		this.liveQueries.forEach( makeDirty$1 );
  		Item.prototype.shuffled.call(this);
  	};

  	Element.prototype.toString = function toString () {
  		var tagName = this.template.e;

  		var attrs = this.attributes.map( stringifyAttribute ).join( '' );

  		// Special case - selected options
  		if ( this.name === 'option' && this.isSelected() ) {
  			attrs += ' selected';
  		}

  		// Special case - two-way radio name bindings
  		if ( this.name === 'input' && inputIsCheckedRadio( this ) ) {
  			attrs += ' checked';
  		}

  		// Special case style and class attributes and directives
  		var style, cls;
  		this.attributes.forEach( function ( attr ) {
  			if ( attr.name === 'class' ) {
  				cls = ( cls || '' ) + ( cls ? ' ' : '' ) + safeAttributeString( attr.getString() );
  			} else if ( attr.name === 'style' ) {
  				style = ( style || '' ) + ( style ? ' ' : '' ) + safeAttributeString( attr.getString() );
  				if ( style && !endsWithSemi.test( style ) ) style += ';';
  			} else if ( attr.styleName ) {
  				style = ( style || '' ) + ( style ? ' ' : '' ) +  "" + (decamelize( attr.styleName )) + ": " + (safeAttributeString( attr.getString() )) + ";";
  			} else if ( attr.inlineClass && attr.getValue() ) {
  				cls = ( cls || '' ) + ( cls ? ' ' : '' ) + attr.inlineClass;
  			}
  		});
  		// put classes first, then inline style
  		if ( style !== undefined ) attrs = ' style' + ( style ? ("=\"" + style + "\"") : '' ) + attrs;
  		if ( cls !== undefined ) attrs = ' class' + (cls ? ("=\"" + cls + "\"") : '') + attrs;

  		var str = "<" + tagName + "" + attrs + ">";

  		if ( this.isVoid ) return str;

  		// Special case - textarea
  		if ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {
  			str += escapeHtml( this.getAttribute( 'value' ) );
  		}

  		// Special case - contenteditable
  		else if ( this.getAttribute( 'contenteditable' ) !== undefined ) {
  			str += ( this.getAttribute( 'value' ) || '' );
  		}

  		if ( this.fragment ) {
  			str += this.fragment.toString( !/^(?:script|style)$/i.test( this.template.e ) ); // escape text unless script/style
  		}

  		str += "</" + tagName + ">";
  		return str;
  	};

  	Element.prototype.unbind = function unbind$1 () {
  		this.attributes.forEach( unbind );

  		if ( this.binding ) this.binding.unbind();
  		if ( this.fragment ) this.fragment.unbind();
  	};

  	Element.prototype.unrender = function unrender ( shouldDestroy ) {
  		if ( !this.rendered ) return;
  		this.rendered = false;

  		// unrendering before intro completed? complete it now
  		// TODO should be an API for aborting transitions
  		var transition = this._introTransition;
  		if ( transition && transition.complete ) transition.complete();

  		// Detach as soon as we can
  		if ( this.name === 'option' ) {
  			// <option> elements detach immediately, so that
  			// their parent <select> element syncs correctly, and
  			// since option elements can't have transitions anyway
  			this.detach();
  		} else if ( shouldDestroy ) {
  			runloop.detachWhenReady( this );
  		}

  		if ( this.fragment ) this.fragment.unrender();

  		if ( this.binding ) this.binding.unrender();

  		// outro transition
  		if ( this._outroTransition && this.ractive.transitionsEnabled ) {
  			this._outroTransition.isIntro = false;
  			runloop.registerTransition( this._outroTransition );
  		}

  		removeFromLiveQueries( this );
  		// TODO forms are a special case
  	};

  	Element.prototype.update = function update$1 () {
  		if ( this.dirty ) {
  			this.dirty = false;

  			this.attributes.forEach( update );

  			if ( this.fragment ) this.fragment.update();
  		}
  	};

  	return Element;
  }(Item));

  function inputIsCheckedRadio ( element ) {
  	var attributes = element.attributeByName;

  	var typeAttribute  = attributes.type;
  	var valueAttribute = attributes.value;
  	var nameAttribute  = attributes.name;

  	if ( !typeAttribute || ( typeAttribute.value !== 'radio' ) || !valueAttribute || !nameAttribute.interpolator ) {
  		return;
  	}

  	if ( valueAttribute.getValue() === nameAttribute.interpolator.model.get() ) {
  		return true;
  	}
  }

  function stringifyAttribute ( attribute ) {
  	var str = attribute.toString();
  	return str ? ' ' + str : '';
  }

  function removeFromLiveQueries ( element ) {
  	var i = element.liveQueries.length;
  	while ( i-- ) {
  		var query = element.liveQueries[i];
  		query.remove( element.node );
  	}
  }

  function getNamespace ( element ) {
  	// Use specified namespace...
  	var xmlns = element.getAttribute( 'xmlns' );
  	if ( xmlns ) return xmlns;

  	// ...or SVG namespace, if this is an <svg> element
  	if ( element.name === 'svg' ) return svg$1;

  	var parent = element.parent;

  	if ( parent ) {
  		// ...or HTML, if the parent is a <foreignObject>
  		if ( parent.name === 'foreignobject' ) return html;

  		// ...or inherit from the parent node
  		return parent.node.namespaceURI;
  	}

  	return element.ractive.el.namespaceURI;
  }

  var Form = (function (Element) {
  	function Form ( options ) {
  		Element.call( this, options );
  		this.formBindings = [];
  	}

  	Form.prototype = Object.create( Element && Element.prototype );
  	Form.prototype.constructor = Form;

  	Form.prototype.render = function render ( target, occupants ) {
  		Element.prototype.render.call( this, target, occupants );
  		this.node.addEventListener( 'reset', handleReset, false );
  	};

  	Form.prototype.unrender = function unrender ( shouldDestroy ) {
  		this.node.removeEventListener( 'reset', handleReset, false );
  		Element.prototype.unrender.call( this, shouldDestroy );
  	};

  	return Form;
  }(Element));

  function handleReset () {
  	var element = this._ractive.proxy;

  	runloop.start();
  	element.formBindings.forEach( updateModel$1 );
  	runloop.end();
  }

  function updateModel$1 ( binding ) {
  	binding.model.set( binding.resetValue );
  }

  var Mustache = (function (Item) {
  	function Mustache ( options ) {
  		Item.call( this, options );

  		this.parentFragment = options.parentFragment;
  		this.template = options.template;
  		this.index = options.index;
  		if ( options.owner ) this.parent = options.owner;

  		this.isStatic = !!options.template.s;

  		this.model = null;
  		this.dirty = false;
  	}

  	Mustache.prototype = Object.create( Item && Item.prototype );
  	Mustache.prototype.constructor = Mustache;

  	Mustache.prototype.bind = function bind () {
  		// try to find a model for this view
  		var this$1 = this;

  		var model = resolve$2( this.parentFragment, this.template );
  		var value = model ? model.get() : undefined;

  		if ( this.isStatic ) {
  			this.model = { get: function () { return value; } };
  			return;
  		}

  		if ( model ) {
  			model.register( this );
  			this.model = model;
  		} else {
  			this.resolver = this.parentFragment.resolve( this.template.r, function ( model ) {
  				this$1.model = model;
  				model.register( this$1 );

  				this$1.handleChange();
  				this$1.resolver = null;
  			});
  		}
  	};

  	Mustache.prototype.handleChange = function handleChange () {
  		this.bubble();
  	};

  	Mustache.prototype.rebinding = function rebinding ( next, previous, safe ) {
  		next = rebindMatch( this.template, next, previous );
  		if ( this['static'] ) return false;
  		if ( next === this.model ) return false;

  		if ( this.model ) {
  			this.model.unregister( this );
  		}
  		if ( next ) next.addShuffleRegister( this, 'mark' );
  		this.model = next;
  		if ( !safe ) this.handleChange();
  		return true;
  	};

  	Mustache.prototype.unbind = function unbind () {
  		if ( !this.isStatic ) {
  			this.model && this.model.unregister( this );
  			this.model = undefined;
  			this.resolver && this.resolver.unbind();
  		}
  	};

  	return Mustache;
  }(Item));

  var Interpolator = (function (Mustache) {
  	function Interpolator () {
  		Mustache.apply(this, arguments);
  	}

  	Interpolator.prototype = Object.create( Mustache && Mustache.prototype );
  	Interpolator.prototype.constructor = Interpolator;

  	Interpolator.prototype.bubble = function bubble () {
  		if ( this.owner ) this.owner.bubble();
  		Mustache.prototype.bubble.call(this);
  	};

  	Interpolator.prototype.detach = function detach () {
  		return detachNode( this.node );
  	};

  	Interpolator.prototype.firstNode = function firstNode () {
  		return this.node;
  	};

  	Interpolator.prototype.getString = function getString () {
  		return this.model ? safeToStringValue( this.model.get() ) : '';
  	};

  	Interpolator.prototype.render = function render ( target, occupants ) {
  		if ( inAttributes() ) return;
  		var value = this.getString();

  		this.rendered = true;

  		if ( occupants ) {
  			var n = occupants[0];
  			if ( n && n.nodeType === 3 ) {
  				occupants.shift();
  				if ( n.nodeValue !== value ) {
  					n.nodeValue = value;
  				}
  			} else {
  				n = this.node = doc.createTextNode( value );
  				if ( occupants[0] ) {
  					target.insertBefore( n, occupants[0] );
  				} else {
  					target.appendChild( n );
  				}
  			}

  			this.node = n;
  		} else {
  			this.node = doc.createTextNode( value );
  			target.appendChild( this.node );
  		}
  	};

  	Interpolator.prototype.toString = function toString ( escape ) {
  		var string = this.getString();
  		return escape ? escapeHtml( string ) : string;
  	};

  	Interpolator.prototype.unrender = function unrender ( shouldDestroy ) {
  		if ( shouldDestroy ) this.detach();
  		this.rendered = false;
  	};

  	Interpolator.prototype.update = function update () {
  		if ( this.dirty ) {
  			this.dirty = false;
  			if ( this.rendered ) {
  				this.node.data = this.getString();
  			}
  		}
  	};

  	Interpolator.prototype.valueOf = function valueOf () {
  		return this.model ? this.model.get() : undefined;
  	};

  	return Interpolator;
  }(Mustache));

  var Input = (function (Element) {
  	function Input () {
  		Element.apply(this, arguments);
  	}

  	Input.prototype = Object.create( Element && Element.prototype );
  	Input.prototype.constructor = Input;

  	Input.prototype.render = function render ( target, occupants ) {
  		Element.prototype.render.call( this, target, occupants );
  		this.node.defaultValue = this.node.value;
  	};

  	return Input;
  }(Element));

  var Mapping = (function (Item) {
  	function Mapping ( options ) {
  		Item.call( this, options );

  		this.name = options.template.n;

  		this.owner = options.owner || options.parentFragment.owner || options.element || findElement( options.parentFragment );
  		this.element = options.element || (this.owner.attributeByName ? this.owner : findElement( options.parentFragment ) );
  		this.parentFragment = this.element.parentFragment; // shared
  		this.ractive = this.parentFragment.ractive;

  		this.fragment = null;

  		this.element.attributeByName[ this.name ] = this;

  		this.value = options.template.f;
  	}

  	Mapping.prototype = Object.create( Item && Item.prototype );
  	Mapping.prototype.constructor = Mapping;

  	Mapping.prototype.bind = function bind () {
  		if ( this.fragment ) {
  			this.fragment.bind();
  		}

  		var template = this.template.f;
  		var viewmodel = this.element.instance.viewmodel;

  		if ( template === 0 ) {
  			// empty attributes are `true`
  			viewmodel.joinKey( this.name ).set( true );
  		}

  		else if ( typeof template === 'string' ) {
  			var parsed = parseJSON( template );
  			viewmodel.joinKey( this.name ).set( parsed ? parsed.value : template );
  		}

  		else if ( isArray( template ) ) {
  			createMapping( this, true );
  		}
  	};

  	Mapping.prototype.render = function render () {};

  	Mapping.prototype.unbind = function unbind () {
  		if ( this.fragment ) this.fragment.unbind();
  		if ( this.boundFragment ) this.boundFragment.unbind();

  		if ( this.element.bound ) {
  			if ( this.link.target === this.model ) this.link.owner.unlink();
  		}
  	};

  	Mapping.prototype.unrender = function unrender () {};

  	Mapping.prototype.update = function update () {
  		if ( this.dirty ) {
  			this.dirty = false;
  			if ( this.fragment ) this.fragment.update();
  			if ( this.boundFragment ) this.boundFragment.update();
  			if ( this.rendered ) this.updateDelegate();
  		}
  	};

  	return Mapping;
  }(Item));

  function createMapping ( item ) {
  	var template = item.template.f;
  	var viewmodel = item.element.instance.viewmodel;
  	var childData = viewmodel.value;

  	if ( template.length === 1 && template[0].t === INTERPOLATOR ) {
  		item.model = resolve$2( item.parentFragment, template[0] );

  		if ( !item.model ) {
  			warnOnceIfDebug( ("The " + (item.name) + "='{{" + (template[0].r) + "}}' mapping is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity"), { ractive: item.element.instance }); // TODO add docs page explaining item
  			item.parentFragment.ractive.get( item.name ); // side-effect: create mappings as necessary
  			item.model = item.parentFragment.findContext().joinKey( item.name );
  		}

  		item.link = viewmodel.createLink( item.name, item.model, template[0].r );

  		if ( item.model.get() === undefined && item.name in childData ) {
  			item.model.set( childData[ item.name ] );
  		}
  	}

  	else {
  		item.boundFragment = new Fragment({
  			owner: item,
  			template: template
  		}).bind();

  		item.model = viewmodel.joinKey( item.name );
  		item.model.set( item.boundFragment.valueOf() );

  		// item is a *bit* of a hack
  		item.boundFragment.bubble = function () {
  			Fragment.prototype.bubble.call( item.boundFragment );
  			// defer this to avoid mucking around model deps if there happens to be an expression involved
  			runloop.scheduleTask(function () {
  				item.boundFragment.update();
  				item.model.set( item.boundFragment.valueOf() );
  			});
  		};
  	}
  }

  var Option = (function (Element) {
  	function Option ( options ) {
  		var template = options.template;
  		if ( !template.a ) template.a = {};

  		// If the value attribute is missing, use the element's content,
  		// as long as it isn't disabled
  		if ( template.a.value === undefined && !( 'disabled' in template.a ) ) {
  			template.a.value = template.f || '';
  		}

  		Element.call( this, options );

  		this.select = findElement( this.parent || this.parentFragment, false, 'select' );
  	}

  	Option.prototype = Object.create( Element && Element.prototype );
  	Option.prototype.constructor = Option;

  	Option.prototype.bind = function bind () {
  		if ( !this.select ) {
  			Element.prototype.bind.call(this);
  			return;
  		}

  		// If the select has a value, it overrides the `selected` attribute on
  		// this option - so we delete the attribute
  		var selectedAttribute = this.attributeByName.selected;
  		if ( selectedAttribute && this.select.getAttribute( 'value' ) !== undefined ) {
  			var index = this.attributes.indexOf( selectedAttribute );
  			this.attributes.splice( index, 1 );
  			delete this.attributeByName.selected;
  		}

  		Element.prototype.bind.call(this);
  		this.select.options.push( this );
  	};

  	Option.prototype.bubble = function bubble () {
  		// if we're using content as value, may need to update here
  		var value = this.getAttribute( 'value' );
  		if ( this.node && this.node.value !== value ) {
  			this.node._ractive.value = value;
  		}
  		Element.prototype.bubble.call(this);
  	};

  	Option.prototype.getAttribute = function getAttribute ( name ) {
  		var attribute = this.attributeByName[ name ];
  		return attribute ? attribute.getValue() : name === 'value' && this.fragment ? this.fragment.valueOf() : undefined;
  	};

  	Option.prototype.isSelected = function isSelected () {
  		var optionValue = this.getAttribute( 'value' );

  		if ( optionValue === undefined || !this.select ) {
  			return false;
  		}

  		var selectValue = this.select.getAttribute( 'value' );

  		if ( selectValue == optionValue ) {
  			return true;
  		}

  		if ( this.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {
  			var i = selectValue.length;
  			while ( i-- ) {
  				if ( selectValue[i] == optionValue ) {
  					return true;
  				}
  			}
  		}
  	};

  	Option.prototype.render = function render ( target, occupants ) {
  		Element.prototype.render.call( this, target, occupants );

  		if ( !this.attributeByName.value ) {
  			this.node._ractive.value = this.getAttribute( 'value' );
  		}
  	};

  	Option.prototype.unbind = function unbind () {
  		Element.prototype.unbind.call(this);

  		if ( this.select ) {
  			removeFromArray( this.select.options, this );
  		}
  	};

  	return Option;
  }(Element));

  function getPartialTemplate ( ractive, name, parentFragment ) {
  	// If the partial in instance or view heirarchy instances, great
  	var partial = getPartialFromRegistry( ractive, name, parentFragment || {} );
  	if ( partial ) return partial;

  	// Does it exist on the page as a script tag?
  	partial = parser.fromId( name, { noThrow: true } );
  	if ( partial ) {
  		// parse and register to this ractive instance
  		var parsed = parser.parseFor( partial, ractive );

  		// register extra partials on the ractive instance if they don't already exist
  		if ( parsed.p ) fillGaps( ractive.partials, parsed.p );

  		// register (and return main partial if there are others in the template)
  		return ractive.partials[ name ] = parsed.t;
  	}
  }

  function getPartialFromRegistry ( ractive, name, parentFragment ) {
  	// if there was an instance up-hierarchy, cool
  	var partial = findParentPartial( name, parentFragment.owner );
  	if ( partial ) return partial;

  	// find first instance in the ractive or view hierarchy that has this partial
  	var instance = findInstance( 'partials', ractive, name );

  	if ( !instance ) { return; }

  	partial = instance.partials[ name ];

  	// partial is a function?
  	var fn;
  	if ( typeof partial === 'function' ) {
  		fn = partial.bind( instance );
  		fn.isOwner = instance.partials.hasOwnProperty(name);
  		partial = fn.call( ractive, parser );
  	}

  	if ( !partial && partial !== '' ) {
  		warnIfDebug( noRegistryFunctionReturn, name, 'partial', 'partial', { ractive: ractive });
  		return;
  	}

  	// If this was added manually to the registry,
  	// but hasn't been parsed, parse it now
  	if ( !parser.isParsed( partial ) ) {
  		// use the parseOptions of the ractive instance on which it was found
  		var parsed = parser.parseFor( partial, instance );

  		// Partials cannot contain nested partials!
  		// TODO add a test for this
  		if ( parsed.p ) {
  			warnIfDebug( 'Partials ({{>%s}}) cannot contain nested inline partials', name, { ractive: ractive });
  		}

  		// if fn, use instance to store result, otherwise needs to go
  		// in the correct point in prototype chain on instance or constructor
  		var target = fn ? instance : findOwner( instance, name );

  		// may be a template with partials, which need to be registered and main template extracted
  		target.partials[ name ] = partial = parsed.t;
  	}

  	// store for reset
  	if ( fn ) partial._fn = fn;

  	return partial.v ? partial.t : partial;
  }

  function findOwner ( ractive, key ) {
  	return ractive.partials.hasOwnProperty( key )
  		? ractive
  		: findConstructor( ractive.constructor, key);
  }

  function findConstructor ( constructor, key ) {
  	if ( !constructor ) { return; }
  	return constructor.partials.hasOwnProperty( key )
  		? constructor
  		: findConstructor( constructor._Parent, key );
  }

  function findParentPartial( name, parent ) {
  	if ( parent ) {
  		if ( parent.template && parent.template.p && parent.template.p[name] ) {
  			return parent.template.p[name];
  		} else if ( parent.parentFragment && parent.parentFragment.owner ) {
  			return findParentPartial( name, parent.parentFragment.owner );
  		}
  	}
  }

  var Partial = (function (Mustache) {
  	function Partial () {
  		Mustache.apply(this, arguments);
  	}

  	Partial.prototype = Object.create( Mustache && Mustache.prototype );
  	Partial.prototype.constructor = Partial;

  	Partial.prototype.bind = function bind () {
  		// keep track of the reference name for future resets
  		this.refName = this.template.r;

  		// name matches take priority over expressions
  		var template = this.refName ? getPartialTemplate( this.ractive, this.refName, this.parentFragment ) || null : null;
  		var templateObj;

  		if ( template ) {
  			this.named = true;
  			this.setTemplate( this.template.r, template );
  		}

  		if ( !template ) {
  			Mustache.prototype.bind.call(this);
  			if ( this.model && ( templateObj = this.model.get() ) && typeof templateObj === 'object' && ( typeof templateObj.template === 'string' || isArray( templateObj.t ) ) ) {
  				if ( templateObj.template ) {
  					this.source = templateObj.template;
  					templateObj = parsePartial( this.template.r, templateObj.template, this.ractive );
  				} else {
  					this.source = templateObj.t;
  				}
  				this.setTemplate( this.template.r, templateObj.t );
  			} else if ( ( !this.model || typeof this.model.get() !== 'string' ) && this.refName ) {
  				this.setTemplate( this.refName, template );
  			} else {
  				this.setTemplate( this.model.get() );
  			}
  		}

  		this.fragment = new Fragment({
  			owner: this,
  			template: this.partialTemplate
  		}).bind();
  	};

  	Partial.prototype.detach = function detach () {
  		return this.fragment.detach();
  	};

  	Partial.prototype.find = function find ( selector ) {
  		return this.fragment.find( selector );
  	};

  	Partial.prototype.findAll = function findAll ( selector, query ) {
  		this.fragment.findAll( selector, query );
  	};

  	Partial.prototype.findComponent = function findComponent ( name ) {
  		return this.fragment.findComponent( name );
  	};

  	Partial.prototype.findAllComponents = function findAllComponents ( name, query ) {
  		this.fragment.findAllComponents( name, query );
  	};

  	Partial.prototype.firstNode = function firstNode ( skipParent ) {
  		return this.fragment.firstNode( skipParent );
  	};

  	Partial.prototype.forceResetTemplate = function forceResetTemplate () {
  		var this$1 = this;

  		this.partialTemplate = undefined;

  		// on reset, check for the reference name first
  		if ( this.refName ) {
  			this.partialTemplate = getPartialTemplate( this.ractive, this.refName, this.parentFragment );
  		}

  		// then look for the resolved name
  		if ( !this.partialTemplate ) {
  			this.partialTemplate = getPartialTemplate( this.ractive, this.name, this.parentFragment );
  		}

  		if ( !this.partialTemplate ) {
  			warnOnceIfDebug( ("Could not find template for partial '" + (this.name) + "'") );
  			this.partialTemplate = [];
  		}

  		if ( this.inAttribute ) {
  			doInAttributes( function () { return this$1.fragment.resetTemplate( this$1.partialTemplate ); } );
  		} else {
  			this.fragment.resetTemplate( this.partialTemplate );
  		}

  		this.bubble();
  	};

  	Partial.prototype.render = function render ( target, occupants ) {
  		this.fragment.render( target, occupants );
  	};

  	Partial.prototype.setTemplate = function setTemplate ( name, template ) {
  		this.name = name;

  		if ( !template && template !== null ) template = getPartialTemplate( this.ractive, name, this.parentFragment );

  		if ( !template ) {
  			warnOnceIfDebug( ("Could not find template for partial '" + name + "'") );
  		}

  		this.partialTemplate = template || [];
  	};

  	Partial.prototype.toString = function toString ( escape ) {
  		return this.fragment.toString( escape );
  	};

  	Partial.prototype.unbind = function unbind () {
  		Mustache.prototype.unbind.call(this);
  		this.fragment.unbind();
  	};

  	Partial.prototype.unrender = function unrender ( shouldDestroy ) {
  		this.fragment.unrender( shouldDestroy );
  	};

  	Partial.prototype.update = function update () {
  		var template;

  		if ( this.dirty ) {
  			this.dirty = false;

  			if ( !this.named ) {
  				if ( this.model ) {
  					template = this.model.get();
  				}

  				if ( template && typeof template === 'string' && template !== this.name ) {
  					this.setTemplate( template );
  					this.fragment.resetTemplate( this.partialTemplate );
  				} else if ( template && typeof template === 'object' && ( typeof template.template === 'string' || isArray( template.t ) ) ) {
  					if ( template.t !== this.source && template.template !== this.source ) {
  						if ( template.template ) {
  							this.source = template.template;
  							template = parsePartial( this.name, template.template, this.ractive );
  						} else {
  							this.source = template.t;
  						}
  						this.setTemplate( this.name, template.t );
  						this.fragment.resetTemplate( this.partialTemplate );
  					}
  				}
  			}

  			this.fragment.update();
  		}
  	};

  	return Partial;
  }(Mustache));

  function parsePartial( name, partial, ractive ) {
  	var parsed;

  	try {
  		parsed = parser.parse( partial, parser.getParseOptions( ractive ) );
  	} catch (e) {
  		warnIfDebug( ("Could not parse partial from expression '" + name + "'\n" + (e.message)) );
  	}

  	return parsed || { t: [] };
  }

  var RepeatedFragment = function RepeatedFragment ( options ) {
  	this.parent = options.owner.parentFragment;

  	// bit of a hack, so reference resolution works without another
  	// layer of indirection
  	this.parentFragment = this;
  	this.owner = options.owner;
  	this.ractive = this.parent.ractive;

  	// encapsulated styles should be inherited until they get applied by an element
  	this.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );

  	this.context = null;
  	this.rendered = false;
  	this.iterations = [];

  	this.template = options.template;

  	this.indexRef = options.indexRef;
  	this.keyRef = options.keyRef;

  	this.pendingNewIndices = null;
  	this.previousIterations = null;

  	// track array versus object so updates of type rest
  	this.isArray = false;
  };

  RepeatedFragment.prototype.bind = function bind ( context ) {
  	var this$1 = this;

  		this.context = context;
  	var value = context.get();

  	// {{#each array}}...
  	if ( this.isArray = isArray( value ) ) {
  		// we can't use map, because of sparse arrays
  		this.iterations = [];
  		var max = value.length;
  		for ( var i = 0; i < max; i += 1 ) {
  			this$1.iterations[i] = this$1.createIteration( i, i );
  		}
  	}

  	// {{#each object}}...
  	else if ( isObject( value ) ) {
  		this.isArray = false;

  		// TODO this is a dreadful hack. There must be a neater way
  		if ( this.indexRef ) {
  			var refs = this.indexRef.split( ',' );
  			this.keyRef = refs[0];
  			this.indexRef = refs[1];
  		}

  		this.iterations = Object.keys( value ).map( function ( key, index ) {
  			return this$1.createIteration( key, index );
  		});
  	}

  	return this;
  };

  RepeatedFragment.prototype.bubble = function bubble () {
  	this.owner.bubble();
  };

  RepeatedFragment.prototype.createIteration = function createIteration ( key, index ) {
  	var fragment = new Fragment({
  		owner: this,
  		template: this.template
  	});

  	// TODO this is a bit hacky
  	fragment.key = key;
  	fragment.index = index;
  	fragment.isIteration = true;

  	var model = this.context.joinKey( key );

  	// set up an iteration alias if there is one
  	if ( this.owner.template.z ) {
  		fragment.aliases = {};
  		fragment.aliases[ this.owner.template.z[0].n ] = model;
  	}

  	return fragment.bind( model );
  };

  RepeatedFragment.prototype.destroyed = function destroyed () {
  	this.iterations.forEach( function ( i ) { return i.destroyed(); } );
  };

  RepeatedFragment.prototype.detach = function detach () {
  	var docFrag = createDocumentFragment();
  	this.iterations.forEach( function ( fragment ) { return docFrag.appendChild( fragment.detach() ); } );
  	return docFrag;
  };

  RepeatedFragment.prototype.find = function find ( selector ) {
  	var this$1 = this;

  		var len = this.iterations.length;
  	var i;

  	for ( i = 0; i < len; i += 1 ) {
  		var found = this$1.iterations[i].find( selector );
  		if ( found ) return found;
  	}
  };

  RepeatedFragment.prototype.findAll = function findAll ( selector, query ) {
  	var this$1 = this;

  		var len = this.iterations.length;
  	var i;

  	for ( i = 0; i < len; i += 1 ) {
  		this$1.iterations[i].findAll( selector, query );
  	}
  };

  RepeatedFragment.prototype.findComponent = function findComponent ( name ) {
  	var this$1 = this;

  		var len = this.iterations.length;
  	var i;

  	for ( i = 0; i < len; i += 1 ) {
  		var found = this$1.iterations[i].findComponent( name );
  		if ( found ) return found;
  	}
  };

  RepeatedFragment.prototype.findAllComponents = function findAllComponents ( name, query ) {
  	var this$1 = this;

  		var len = this.iterations.length;
  	var i;

  	for ( i = 0; i < len; i += 1 ) {
  		this$1.iterations[i].findAllComponents( name, query );
  	}
  };

  RepeatedFragment.prototype.findNextNode = function findNextNode ( iteration ) {
  	var this$1 = this;

  		if ( iteration.index < this.iterations.length - 1 ) {
  		for ( var i = iteration.index + 1; i < this$1.iterations.length; i++ ) {
  			var node = this$1.iterations[ i ].firstNode( true );
  			if ( node ) return node;
  		}
  	}

  	return this.owner.findNextNode();
  };

  RepeatedFragment.prototype.firstNode = function firstNode ( skipParent ) {
  	return this.iterations[0] ? this.iterations[0].firstNode( skipParent ) : null;
  };

  RepeatedFragment.prototype.rebinding = function rebinding ( next ) {
  	var this$1 = this;

  		this.context = next;
  	this.iterations.forEach( function ( fragment ) {
  		var model = next ? next.joinKey( fragment.key || fragment.index ) : undefined;
  		fragment.context = model;
  		if ( this$1.owner.template.z ) {
  			fragment.aliases = {};
  			fragment.aliases[ this$1.owner.template.z[0].n ] = model;
  		}
  	});
  };

  RepeatedFragment.prototype.render = function render ( target, occupants ) {
  	// TODO use docFrag.cloneNode...

  	if ( this.iterations ) {
  		this.iterations.forEach( function ( fragment ) { return fragment.render( target, occupants ); } );
  	}

  	this.rendered = true;
  };

  RepeatedFragment.prototype.shuffle = function shuffle ( newIndices ) {
  	var this$1 = this;

  		if ( !this.pendingNewIndices ) this.previousIterations = this.iterations.slice();

  	if ( !this.pendingNewIndices ) this.pendingNewIndices = [];

  	this.pendingNewIndices.push( newIndices );

  	var iterations = [];

  	newIndices.forEach( function ( newIndex, oldIndex ) {
  		if ( newIndex === -1 ) return;

  		var fragment = this$1.iterations[ oldIndex ];
  		iterations[ newIndex ] = fragment;

  		if ( newIndex !== oldIndex && fragment ) fragment.dirty = true;
  	});

  	this.iterations = iterations;

  	this.bubble();
  };

  RepeatedFragment.prototype.shuffled = function shuffled () {
  	this.iterations.forEach( function ( i ) { return i.shuffled(); } );
  };

  RepeatedFragment.prototype.toString = function toString$1$$ ( escape ) {
  	return this.iterations ?
  		this.iterations.map( escape ? toEscapedString : toString$1 ).join( '' ) :
  		'';
  };

  RepeatedFragment.prototype.unbind = function unbind$1 () {
  	this.iterations.forEach( unbind );
  	return this;
  };

  RepeatedFragment.prototype.unrender = function unrender$1 ( shouldDestroy ) {
  	this.iterations.forEach( shouldDestroy ? unrenderAndDestroy : unrender );
  	if ( this.pendingNewIndices && this.previousIterations ) {
  		this.previousIterations.forEach( function ( fragment ) {
  			if ( fragment.rendered ) shouldDestroy ? unrenderAndDestroy( fragment ) : unrender( fragment );
  		});
  	}
  	this.rendered = false;
  };

  // TODO smart update
  RepeatedFragment.prototype.update = function update$1 () {
  	// skip dirty check, since this is basically just a facade

  	var this$1 = this;

  		if ( this.pendingNewIndices ) {
  		this.updatePostShuffle();
  		return;
  	}

  	if ( this.updating ) return;
  	this.updating = true;

  	var value = this.context.get(),
  			  wasArray = this.isArray;

  	var toRemove;
  	var oldKeys;
  	var reset = true;
  	var i;

  	if ( this.isArray = isArray( value ) ) {
  		if ( wasArray ) {
  			reset = false;
  			if ( this.iterations.length > value.length ) {
  				toRemove = this.iterations.splice( value.length );
  			}
  		}
  	} else if ( isObject( value ) && !wasArray ) {
  		reset = false;
  		toRemove = [];
  		oldKeys = {};
  		i = this.iterations.length;

  		while ( i-- ) {
  			var fragment$1 = this$1.iterations[i];
  			if ( fragment$1.key in value ) {
  				oldKeys[ fragment$1.key ] = true;
  			} else {
  				this$1.iterations.splice( i, 1 );
  				toRemove.push( fragment$1 );
  			}
  		}
  	}

  	if ( reset ) {
  		toRemove = this.iterations;
  		this.iterations = [];
  	}

  	if ( toRemove ) {
  		toRemove.forEach( function ( fragment ) {
  			fragment.unbind();
  			fragment.unrender( true );
  		});
  	}

  	// update the remaining ones
  	this.iterations.forEach( update );

  	// add new iterations
  	var newLength = isArray( value ) ?
  		value.length :
  		isObject( value ) ?
  			Object.keys( value ).length :
  			0;

  	var docFrag;
  	var fragment;

  	if ( newLength > this.iterations.length ) {
  		docFrag = this.rendered ? createDocumentFragment() : null;
  		i = this.iterations.length;

  		if ( isArray( value ) ) {
  			while ( i < value.length ) {
  				fragment = this$1.createIteration( i, i );

  				this$1.iterations.push( fragment );
  				if ( this$1.rendered ) fragment.render( docFrag );

  				i += 1;
  			}
  		}

  		else if ( isObject( value ) ) {
  			// TODO this is a dreadful hack. There must be a neater way
  			if ( this.indexRef && !this.keyRef ) {
  				var refs = this.indexRef.split( ',' );
  				this.keyRef = refs[0];
  				this.indexRef = refs[1];
  			}

  			Object.keys( value ).forEach( function ( key ) {
  				if ( !oldKeys || !( key in oldKeys ) ) {
  					fragment = this$1.createIteration( key, i );

  					this$1.iterations.push( fragment );
  					if ( this$1.rendered ) fragment.render( docFrag );

  					i += 1;
  				}
  			});
  		}

  		if ( this.rendered ) {
  			var parentNode = this.parent.findParentNode();
  			var anchor = this.parent.findNextNode( this.owner );

  			parentNode.insertBefore( docFrag, anchor );
  		}
  	}

  	this.updating = false;
  };

  RepeatedFragment.prototype.updatePostShuffle = function updatePostShuffle () {
  	var this$1 = this;

  		var newIndices = this.pendingNewIndices[ 0 ];

  	// map first shuffle through
  	this.pendingNewIndices.slice( 1 ).forEach( function ( indices ) {
  		newIndices.forEach( function ( newIndex, oldIndex ) {
  			newIndices[ oldIndex ] = indices[ newIndex ];
  		});
  	});

  	// This algorithm (for detaching incorrectly-ordered fragments from the DOM and
  	// storing them in a document fragment for later reinsertion) seems a bit hokey,
  	// but it seems to work for now
  	var len = this.context.get().length, oldLen = this.previousIterations.length;
  	var i;
  	var removed = {};

  	newIndices.forEach( function ( newIndex, oldIndex ) {
  		var fragment = this$1.previousIterations[ oldIndex ];
  		this$1.previousIterations[ oldIndex ] = null;

  		if ( newIndex === -1 ) {
  			removed[ oldIndex ] = fragment;
  		} else if ( fragment.index !== newIndex ) {
  			var model = this$1.context.joinKey( newIndex );
  			fragment.index = newIndex;
  			fragment.context = model;
  			if ( this$1.owner.template.z ) {
  				fragment.aliases = {};
  				fragment.aliases[ this$1.owner.template.z[0].n ] = model;
  			}
  		}
  	});

  	// if the array was spliced outside of ractive, sometimes there are leftover fragments not in the newIndices
  	this.previousIterations.forEach( function ( frag, i ) {
  		if ( frag ) removed[ i ] = frag;
  	});

  	// create new/move existing iterations
  	var docFrag = this.rendered ? createDocumentFragment() : null;
  	var parentNode = this.rendered ? this.parent.findParentNode() : null;

  	var contiguous = 'startIndex' in newIndices;
  	i = contiguous ? newIndices.startIndex : 0;

  	for ( i; i < len; i++ ) {
  		var frag = this$1.iterations[i];

  		if ( frag && contiguous ) {
  			// attach any built-up iterations
  			if ( this$1.rendered ) {
  				if ( removed[i] ) docFrag.appendChild( removed[i].detach() );
  				if ( docFrag.childNodes.length  ) parentNode.insertBefore( docFrag, frag.firstNode() );
  			}
  			continue;
  		}

  		if ( !frag ) this$1.iterations[i] = this$1.createIteration( i, i );

  		if ( this$1.rendered ) {
  			if ( removed[i] ) docFrag.appendChild( removed[i].detach() );

  			if ( frag ) docFrag.appendChild( frag.detach() );
  			else {
  				this$1.iterations[i].render( docFrag );
  			}
  		}
  	}

  	// append any leftovers
  	if ( this.rendered ) {
  		for ( i = len; i < oldLen; i++ ) {
  			if ( removed[i] ) docFrag.appendChild( removed[i].detach() );
  		}

  		if ( docFrag.childNodes.length ) {
  			parentNode.insertBefore( docFrag, this.owner.findNextNode() );
  		}
  	}

  	// trigger removal on old nodes
  	Object.keys( removed ).forEach( function ( k ) { return removed[k].unbind().unrender( true ); } );

  	this.iterations.forEach( update );

  	this.pendingNewIndices = null;

  	this.shuffled();
  };

  function isEmpty ( value ) {
  	return !value ||
  	       ( isArray( value ) && value.length === 0 ) ||
  		   ( isObject( value ) && Object.keys( value ).length === 0 );
  }

  function getType ( value, hasIndexRef ) {
  	if ( hasIndexRef || isArray( value ) ) return SECTION_EACH;
  	if ( isObject( value ) || typeof value === 'function' ) return SECTION_IF_WITH;
  	if ( value === undefined ) return null;
  	return SECTION_IF;
  }

  var Section = (function (Mustache) {
  	function Section ( options ) {
  		Mustache.call( this, options );

  		this.sectionType = options.template.n || null;
  		this.templateSectionType = this.sectionType;
  		this.subordinate = options.template.l === 1;
  		this.fragment = null;
  	}

  	Section.prototype = Object.create( Mustache && Mustache.prototype );
  	Section.prototype.constructor = Section;

  	Section.prototype.bind = function bind () {
  		Mustache.prototype.bind.call(this);

  		if ( this.subordinate ) {
  			this.sibling = this.parentFragment.items[ this.parentFragment.items.indexOf( this ) - 1 ];
  			this.sibling.nextSibling = this;
  		}

  		// if we managed to bind, we need to create children
  		if ( this.model ) {
  			this.dirty = true;
  			this.update();
  		} else if ( this.sectionType && this.sectionType === SECTION_UNLESS && ( !this.sibling || !this.sibling.isTruthy() ) ) {
  			this.fragment = new Fragment({
  				owner: this,
  				template: this.template.f
  			}).bind();
  		}
  	};

  	Section.prototype.detach = function detach () {
  		return this.fragment ? this.fragment.detach() : createDocumentFragment();
  	};

  	Section.prototype.find = function find ( selector ) {
  		if ( this.fragment ) {
  			return this.fragment.find( selector );
  		}
  	};

  	Section.prototype.findAll = function findAll ( selector, query ) {
  		if ( this.fragment ) {
  			this.fragment.findAll( selector, query );
  		}
  	};

  	Section.prototype.findComponent = function findComponent ( name ) {
  		if ( this.fragment ) {
  			return this.fragment.findComponent( name );
  		}
  	};

  	Section.prototype.findAllComponents = function findAllComponents ( name, query ) {
  		if ( this.fragment ) {
  			this.fragment.findAllComponents( name, query );
  		}
  	};

  	Section.prototype.firstNode = function firstNode ( skipParent ) {
  		return this.fragment && this.fragment.firstNode( skipParent );
  	};

  	Section.prototype.isTruthy = function isTruthy () {
  		if ( this.subordinate && this.sibling.isTruthy() ) return true;
  		var value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();
  		return !!value && ( this.templateSectionType === SECTION_IF_WITH || !isEmpty( value ) );
  	};

  	Section.prototype.rebinding = function rebinding ( next, previous, safe ) {
  		if ( Mustache.prototype.rebinding.call( this, next, previous, safe ) ) {
  			if ( this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ) {
  				this.fragment.rebinding( next, previous );
  			}
  		}
  	};

  	Section.prototype.render = function render ( target, occupants ) {
  		this.rendered = true;
  		if ( this.fragment ) this.fragment.render( target, occupants );
  	};

  	Section.prototype.shuffle = function shuffle ( newIndices ) {
  		if ( this.fragment && this.sectionType === SECTION_EACH ) {
  			this.fragment.shuffle( newIndices );
  		}
  	};

  	Section.prototype.toString = function toString ( escape ) {
  		return this.fragment ? this.fragment.toString( escape ) : '';
  	};

  	Section.prototype.unbind = function unbind () {
  		Mustache.prototype.unbind.call(this);
  		if ( this.fragment ) this.fragment.unbind();
  	};

  	Section.prototype.unrender = function unrender ( shouldDestroy ) {
  		if ( this.rendered && this.fragment ) this.fragment.unrender( shouldDestroy );
  		this.rendered = false;
  	};

  	Section.prototype.update = function update () {
  		if ( !this.dirty ) return;

  		if ( this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ) {
  			this.fragment.context = this.model;
  		}

  		if ( !this.model && this.sectionType !== SECTION_UNLESS ) return;

  		this.dirty = false;

  		var value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();
  		var siblingFalsey = !this.subordinate || !this.sibling.isTruthy();
  		var lastType = this.sectionType;

  		// watch for switching section types
  		if ( this.sectionType === null || this.templateSectionType === null ) this.sectionType = getType( value, this.template.i );
  		if ( lastType && lastType !== this.sectionType && this.fragment ) {
  			if ( this.rendered ) {
  				this.fragment.unbind().unrender( true );
  			}

  			this.fragment = null;
  		}

  		var newFragment;

  		var fragmentShouldExist = this.sectionType === SECTION_EACH || // each always gets a fragment, which may have no iterations
  		                            this.sectionType === SECTION_WITH || // with (partial context) always gets a fragment
  		                            ( siblingFalsey && ( this.sectionType === SECTION_UNLESS ? !this.isTruthy() : this.isTruthy() ) ); // if, unless, and if-with depend on siblings and the condition

  		if ( fragmentShouldExist ) {
  			if ( this.fragment ) {
  				this.fragment.update();
  			} else {
  				if ( this.sectionType === SECTION_EACH ) {
  					newFragment = new RepeatedFragment({
  						owner: this,
  						template: this.template.f,
  						indexRef: this.template.i
  					}).bind( this.model );
  				} else {
  	 				// only with and if-with provide context - if and unless do not
  					var context = this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ? this.model : null;
  					newFragment = new Fragment({
  						owner: this,
  						template: this.template.f
  					}).bind( context );
  				}
  			}
  		} else {
  			if ( this.fragment && this.rendered ) {
  				this.fragment.unbind().unrender( true );
  			}

  			this.fragment = null;
  		}

  		if ( newFragment ) {
  			if ( this.rendered ) {
  				var parentNode = this.parentFragment.findParentNode();
  				var anchor = this.parentFragment.findNextNode( this );

  				if ( anchor ) {
  					var docFrag = createDocumentFragment();
  					newFragment.render( docFrag );

  					// we use anchor.parentNode, not parentNode, because the sibling
  					// may be temporarily detached as a result of a shuffle
  					anchor.parentNode.insertBefore( docFrag, anchor );
  				} else {
  					newFragment.render( parentNode );
  				}
  			}

  			this.fragment = newFragment;
  		}

  		if ( this.nextSibling ) {
  			this.nextSibling.dirty = true;
  			this.nextSibling.update();
  		}
  	};

  	return Section;
  }(Mustache));

  function valueContains ( selectValue, optionValue ) {
  	var i = selectValue.length;
  	while ( i-- ) {
  		if ( selectValue[i] == optionValue ) return true;
  	}
  }

  var Select = (function (Element) {
  	function Select ( options ) {
  		Element.call( this, options );
  		this.options = [];
  	}

  	Select.prototype = Object.create( Element && Element.prototype );
  	Select.prototype.constructor = Select;

  	Select.prototype.foundNode = function foundNode ( node ) {
  		if ( this.binding ) {
  			var selectedOptions = getSelectedOptions( node );

  			if ( selectedOptions.length > 0 ) {
  				this.selectedOptions = selectedOptions;
  			}
  		}
  	};

  	Select.prototype.render = function render ( target, occupants ) {
  		Element.prototype.render.call( this, target, occupants );
  		this.sync();

  		var node = this.node;

  		var i = node.options.length;
  		while ( i-- ) {
  			node.options[i].defaultSelected = node.options[i].selected;
  		}

  		this.rendered = true;
  	};

  	Select.prototype.sync = function sync () {
  		var this$1 = this;

  		var selectNode = this.node;

  		if ( !selectNode ) return;

  		var options = toArray( selectNode.options );

  		if ( this.selectedOptions ) {
  			options.forEach( function ( o ) {
  				if ( this$1.selectedOptions.indexOf( o ) >= 0 ) o.selected = true;
  				else o.selected = false;
  			});
  			this.binding.setFromNode( selectNode );
  			delete this.selectedOptions;
  			return;
  		}

  		var selectValue = this.getAttribute( 'value' );
  		var isMultiple = this.getAttribute( 'multiple' );

  		// If the <select> has a specified value, that should override
  		// these options
  		if ( selectValue !== undefined ) {
  			var optionWasSelected;

  			options.forEach( function ( o ) {
  				var optionValue = o._ractive ? o._ractive.value : o.value;
  				var shouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;

  				if ( shouldSelect ) {
  					optionWasSelected = true;
  				}

  				o.selected = shouldSelect;
  			});

  			if ( !optionWasSelected && !isMultiple ) {
  				if ( this.binding ) {
  					this.binding.forceUpdate();
  				}
  			}
  		}

  		// Otherwise the value should be initialised according to which
  		// <option> element is selected, if twoway binding is in effect
  		else if ( this.binding ) {
  			this.binding.forceUpdate();
  		}
  	};

  	Select.prototype.update = function update () {
  		Element.prototype.update.call(this);
  		this.sync();
  	};

  	return Select;
  }(Element));

  var Textarea = (function (Input) {
  	function Textarea( options ) {
  		var template = options.template;

  		options.deferContent = true;

  		Input.call( this, options );

  		// check for single interpolator binding
  		if ( !this.attributeByName.value ) {
  			if ( template.f && isBindable( { template: template } ) ) {
  				this.attributes.push( createItem( {
  					owner: this,
  					template: { t: ATTRIBUTE, f: template.f, n: 'value' },
  					parentFragment: this.parentFragment
  				} ) );
  			} else {
  				this.fragment = new Fragment({ owner: this, cssIds: null, template: template.f });
  			}
  		}
  	}

  	Textarea.prototype = Object.create( Input && Input.prototype );
  	Textarea.prototype.constructor = Textarea;

  	Textarea.prototype.bubble = function bubble () {
  		var this$1 = this;

  		if ( !this.dirty ) {
  			this.dirty = true;

  			if ( this.rendered && !this.binding && this.fragment ) {
  				runloop.scheduleTask( function () {
  					this$1.dirty = false;
  					this$1.node.value = this$1.fragment.toString();
  				});
  			}

  			this.parentFragment.bubble(); // default behaviour
  		}
  	};

  	return Textarea;
  }(Input));

  var Text = (function (Item) {
  	function Text ( options ) {
  		Item.call( this, options );
  		this.type = TEXT;
  	}

  	Text.prototype = Object.create( Item && Item.prototype );
  	Text.prototype.constructor = Text;

  	Text.prototype.bind = function bind () {
  		// noop
  	};

  	Text.prototype.detach = function detach () {
  		return detachNode( this.node );
  	};

  	Text.prototype.firstNode = function firstNode () {
  		return this.node;
  	};

  	Text.prototype.render = function render ( target, occupants ) {
  		if ( inAttributes() ) return;
  		this.rendered = true;

  		if ( occupants ) {
  			var n = occupants[0];
  			if ( n && n.nodeType === 3 ) {
  				occupants.shift();
  				if ( n.nodeValue !== this.template ) {
  					n.nodeValue = this.template;
  				}
  			} else {
  				n = this.node = doc.createTextNode( this.template );
  				if ( occupants[0] ) {
  					target.insertBefore( n, occupants[0] );
  				} else {
  					target.appendChild( n );
  				}
  			}

  			this.node = n;
  		} else {
  			this.node = doc.createTextNode( this.template );
  			target.appendChild( this.node );
  		}
  	};

  	Text.prototype.toString = function toString ( escape ) {
  		return escape ? escapeHtml( this.template ) : this.template;
  	};

  	Text.prototype.unbind = function unbind () {
  		// noop
  	};

  	Text.prototype.unrender = function unrender ( shouldDestroy ) {
  		if ( this.rendered && shouldDestroy ) this.detach();
  		this.rendered = false;
  	};

  	Text.prototype.update = function update () {
  		// noop
  	};

  	Text.prototype.valueOf = function valueOf () {
  		return this.template;
  	};

  	return Text;
  }(Item));

  var prefix;

  if ( !isClient ) {
  	prefix = null;
  } else {
  	var prefixCache = {};
  	var testStyle = createElement( 'div' ).style;

  	prefix = function ( prop ) {
  		prop = camelCase( prop );

  		if ( !prefixCache[ prop ] ) {
  			if ( testStyle[ prop ] !== undefined ) {
  				prefixCache[ prop ] = prop;
  			}

  			else {
  				// test vendors...
  				var capped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );

  				var i = vendors.length;
  				while ( i-- ) {
  					var vendor = vendors[i];
  					if ( testStyle[ vendor + capped ] !== undefined ) {
  						prefixCache[ prop ] = vendor + capped;
  						break;
  					}
  				}
  			}
  		}

  		return prefixCache[ prop ];
  	};
  }

  var prefix$1 = prefix;

  var visible;
  var hidden = 'hidden';

  if ( doc ) {
  	var prefix$2;

  	if ( hidden in doc ) {
  		prefix$2 = '';
  	} else {
  		var i$1 = vendors.length;
  		while ( i$1-- ) {
  			var vendor = vendors[i$1];
  			hidden = vendor + 'Hidden';

  			if ( hidden in doc ) {
  				prefix$2 = vendor;
  				break;
  			}
  		}
  	}

  	if ( prefix$2 !== undefined ) {
  		doc.addEventListener( prefix$2 + 'visibilitychange', onChange );
  		onChange();
  	} else {
  		// gah, we're in an old browser
  		if ( 'onfocusout' in doc ) {
  			doc.addEventListener( 'focusout', onHide );
  			doc.addEventListener( 'focusin', onShow );
  		}

  		else {
  			win.addEventListener( 'pagehide', onHide );
  			win.addEventListener( 'blur', onHide );

  			win.addEventListener( 'pageshow', onShow );
  			win.addEventListener( 'focus', onShow );
  		}

  		visible = true; // until proven otherwise. Not ideal but hey
  	}
  }

  function onChange () {
  	visible = !doc[ hidden ];
  }

  function onHide () {
  	visible = false;
  }

  function onShow () {
  	visible = true;
  }

  var unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );

  function unprefix ( prop ) {
  	return prop.replace( unprefixPattern, '' );
  }

  var vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );

  function hyphenate ( str ) {
  	if ( !str ) return ''; // edge case

  	if ( vendorPattern.test( str ) ) str = '-' + str;

  	return str.replace( /[A-Z]/g, function ( match ) { return '-' + match.toLowerCase(); } );
  }

  var createTransitions;

  if ( !isClient ) {
  	createTransitions = null;
  } else {
  	var testStyle$1 = createElement( 'div' ).style;
  	var linear$1 = function ( x ) { return x; };

  	var canUseCssTransitions = {};
  	var cannotUseCssTransitions = {};

  	// determine some facts about our environment
  	var TRANSITION$1;
  	var TRANSITIONEND;
  	var CSS_TRANSITIONS_ENABLED;
  	var TRANSITION_DURATION;
  	var TRANSITION_PROPERTY;
  	var TRANSITION_TIMING_FUNCTION;

  	if ( testStyle$1.transition !== undefined ) {
  		TRANSITION$1 = 'transition';
  		TRANSITIONEND = 'transitionend';
  		CSS_TRANSITIONS_ENABLED = true;
  	} else if ( testStyle$1.webkitTransition !== undefined ) {
  		TRANSITION$1 = 'webkitTransition';
  		TRANSITIONEND = 'webkitTransitionEnd';
  		CSS_TRANSITIONS_ENABLED = true;
  	} else {
  		CSS_TRANSITIONS_ENABLED = false;
  	}

  	if ( TRANSITION$1 ) {
  		TRANSITION_DURATION = TRANSITION$1 + 'Duration';
  		TRANSITION_PROPERTY = TRANSITION$1 + 'Property';
  		TRANSITION_TIMING_FUNCTION = TRANSITION$1 + 'TimingFunction';
  	}

  	createTransitions = function ( t, to, options, changedProperties, resolve ) {

  		// Wait a beat (otherwise the target styles will be applied immediately)
  		// TODO use a fastdom-style mechanism?
  		setTimeout( function () {
  			var jsTransitionsComplete;
  			var cssTransitionsComplete;
  			var cssTimeout;

  			function transitionDone () { clearTimeout( cssTimeout ); }

  			function checkComplete () {
  				if ( jsTransitionsComplete && cssTransitionsComplete ) {
  					t.unregisterCompleteHandler( transitionDone );
  					// will changes to events and fire have an unexpected consequence here?
  					t.ractive.fire( t.name + ':end', t.node, t.isIntro );
  					resolve();
  				}
  			}

  			// this is used to keep track of which elements can use CSS to animate
  			// which properties
  			var hashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;

  			// need to reset transition properties
  			var style = t.node.style;
  			var previous = {
  				property: style[ TRANSITION_PROPERTY ],
  				timing: style[ TRANSITION_TIMING_FUNCTION ],
  				duration: style[ TRANSITION_DURATION ]
  			};

  			style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix$1 ).map( hyphenate ).join( ',' );
  			style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );
  			style[ TRANSITION_DURATION ] = ( options.duration / 1000 ) + 's';

  			function transitionEndHandler ( event ) {
  				var index = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );

  				if ( index !== -1 ) {
  					changedProperties.splice( index, 1 );
  				}

  				if ( changedProperties.length ) {
  					// still transitioning...
  					return;
  				}

  				clearTimeout( cssTimeout );
  				cssTransitionsDone();
  			}

  			function cssTransitionsDone () {
  				style[ TRANSITION_PROPERTY ] = previous.property;
  				style[ TRANSITION_TIMING_FUNCTION ] = previous.duration;
  				style[ TRANSITION_DURATION ] = previous.timing;

  				t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );

  				cssTransitionsComplete = true;
  				checkComplete();
  			}

  			t.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );

  			// safety net in case transitionend never fires
  			cssTimeout = setTimeout( function () {
  				changedProperties = [];
  				cssTransitionsDone();
  			}, options.duration + ( options.delay || 0 ) + 50 );
  			t.registerCompleteHandler( transitionDone );

  			setTimeout( function () {
  				var i = changedProperties.length;
  				var hash;
  				var originalValue;
  				var index;
  				var propertiesToTransitionInJs = [];
  				var prop;
  				var suffix;
  				var interpolator;

  				while ( i-- ) {
  					prop = changedProperties[i];
  					hash = hashPrefix + prop;

  					if ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {
  						style[ prefix$1( prop ) ] = to[ prop ];

  						// If we're not sure if CSS transitions are supported for
  						// this tag/property combo, find out now
  						if ( !canUseCssTransitions[ hash ] ) {
  							originalValue = t.getStyle( prop );

  							// if this property is transitionable in this browser,
  							// the current style will be different from the target style
  							canUseCssTransitions[ hash ] = ( t.getStyle( prop ) != to[ prop ] );
  							cannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];

  							// Reset, if we're going to use timers after all
  							if ( cannotUseCssTransitions[ hash ] ) {
  								style[ prefix$1( prop ) ] = originalValue;
  							}
  						}
  					}

  					if ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {
  						// we need to fall back to timer-based stuff
  						if ( originalValue === undefined ) {
  							originalValue = t.getStyle( prop );
  						}

  						// need to remove this from changedProperties, otherwise transitionEndHandler
  						// will get confused
  						index = changedProperties.indexOf( prop );
  						if ( index === -1 ) {
  							warnIfDebug( 'Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!', { node: t.node });
  						} else {
  							changedProperties.splice( index, 1 );
  						}

  						// TODO Determine whether this property is animatable at all

  						suffix = /[^\d]*$/.exec( to[ prop ] )[0];
  						interpolator = interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ) || ( function () { return to[ prop ]; } );

  						// ...then kick off a timer-based transition
  						propertiesToTransitionInJs.push({
  							name: prefix$1( prop ),
  							interpolator: interpolator,
  							suffix: suffix
  						});
  					}
  				}

  				// javascript transitions
  				if ( propertiesToTransitionInJs.length ) {
  					var easing;

  					if ( typeof options.easing === 'string' ) {
  						easing = t.ractive.easing[ options.easing ];

  						if ( !easing ) {
  							warnOnceIfDebug( missingPlugin( options.easing, 'easing' ) );
  							easing = linear$1;
  						}
  					} else if ( typeof options.easing === 'function' ) {
  						easing = options.easing;
  					} else {
  						easing = linear$1;
  					}

  					new Ticker({
  						duration: options.duration,
  						easing: easing,
  						step: function ( pos ) {
  							var i = propertiesToTransitionInJs.length;
  							while ( i-- ) {
  								var prop = propertiesToTransitionInJs[i];
  								t.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;
  							}
  						},
  						complete: function () {
  							jsTransitionsComplete = true;
  							checkComplete();
  						}
  					});
  				} else {
  					jsTransitionsComplete = true;
  				}

  				if ( !changedProperties.length ) {
  					// We need to cancel the transitionEndHandler, and deal with
  					// the fact that it will never fire
  					t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
  					cssTransitionsComplete = true;
  					checkComplete();
  				}
  			}, 0 );
  		}, options.delay || 0 );
  	};
  }

  var createTransitions$1 = createTransitions;

  function resetStyle ( node, style ) {
  	if ( style ) {
  		node.setAttribute( 'style', style );
  	} else {
  		// Next line is necessary, to remove empty style attribute!
  		// See http://stackoverflow.com/a/7167553
  		node.getAttribute( 'style' );
  		node.removeAttribute( 'style' );
  	}
  }

  var getComputedStyle = win && ( win.getComputedStyle || legacy.getComputedStyle );
  var resolved = Promise$1.resolve();

  var names = {
  	t0: 'intro-outro',
  	t1: 'intro',
  	t2: 'outro'
  };

  var Transition = function Transition ( options ) {
  	this.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );
  	this.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );
  	this.ractive = this.owner.ractive;
  	this.template = options.template;
  	this.parentFragment = options.parentFragment;
  	this.options = options;
  	this.onComplete = [];
  };

  Transition.prototype.animateStyle = function animateStyle ( style, value, options ) {
  	var this$1 = this;

  		if ( arguments.length === 4 ) {
  		throw new Error( 't.animateStyle() returns a promise - use .then() instead of passing a callback' );
  	}

  	// Special case - page isn't visible. Don't animate anything, because
  	// that way you'll never get CSS transitionend events
  	if ( !visible ) {
  		this.setStyle( style, value );
  		return resolved;
  	}

  	var to;

  	if ( typeof style === 'string' ) {
  		to = {};
  		to[ style ] = value;
  	} else {
  		to = style;

  		// shuffle arguments
  		options = value;
  	}

  	// As of 0.3.9, transition authors should supply an `option` object with
  	// `duration` and `easing` properties (and optional `delay`), plus a
  	// callback function that gets called after the animation completes

  	// TODO remove this check in a future version
  	if ( !options ) {
  		warnOnceIfDebug( 'The "%s" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340', this.name );
  		options = this;
  	}

  	return new Promise$1( function ( fulfil ) {
  		// Edge case - if duration is zero, set style synchronously and complete
  		if ( !options.duration ) {
  			this$1.setStyle( to );
  			fulfil();
  			return;
  		}

  		// Get a list of the properties we're animating
  		var propertyNames = Object.keys( to );
  		var changedProperties = [];

  		// Store the current styles
  		var computedStyle = getComputedStyle( this$1.owner.node );

  		var i = propertyNames.length;
  		while ( i-- ) {
  			var prop = propertyNames[i];
  			var current = computedStyle[ prefix$1( prop ) ];

  			if ( current === '0px' ) current = 0;

  			// we need to know if we're actually changing anything
  			if ( current != to[ prop ] ) { // use != instead of !==, so we can compare strings with numbers
  				changedProperties.push( prop );

  				// make the computed style explicit, so we can animate where
  				// e.g. height='auto'
  				this$1.owner.node.style[ prefix$1( prop ) ] = current;
  			}
  		}

  		// If we're not actually changing anything, the transitionend event
  		// will never fire! So we complete early
  		if ( !changedProperties.length ) {
  			fulfil();
  			return;
  		}

  		createTransitions$1( this$1, to, options, changedProperties, fulfil );
  	});
  };

  Transition.prototype.bind = function bind () {
  	var this$1 = this;

  		var options = this.options;
  	if ( options.template ) {
  		if ( options.template.v === 't0' || options.template.v == 't1' ) this.element._introTransition = this;
  		if ( options.template.v === 't0' || options.template.v == 't2' ) this.element._outroTransition = this;
  		this.eventName = names[ options.template.v ];
  	}

  	var ractive = this.owner.ractive;

  	if ( options.name ) {
  		this.name = options.name;
  	} else {
  		var name = options.template.f;
  		if ( typeof name.n === 'string' ) name = name.n;

  		if ( typeof name !== 'string' ) {
  			var fragment = new Fragment({
  				owner: this.owner,
  				template: name.n
  			}).bind(); // TODO need a way to capture values without bind()

  			name = fragment.toString();
  			fragment.unbind();

  			if ( name === '' ) {
  				// empty string okay, just no transition
  				return;
  			}
  		}

  		this.name = name;
  	}

  	if ( options.params ) {
  		this.params = options.params;
  	} else {
  		if ( options.template.f.a && !options.template.f.a.s ) {
  			this.params = options.template.f.a;
  		}

  		else if ( options.template.f.d ) {
  			// TODO is there a way to interpret dynamic arguments without all the
  			// 'dependency thrashing'?
  			var fragment$1 = new Fragment({
  				owner: this.owner,
  				template: options.template.f.d
  			}).bind();

  			this.params = fragment$1.getArgsList();
  			fragment$1.unbind();
  		}
  	}

  	if ( typeof this.name === 'function' ) {
  		this._fn = this.name;
  		this.name = this._fn.name;
  	} else {
  		this._fn = findInViewHierarchy( 'transitions', ractive, this.name );
  	}

  	if ( !this._fn ) {
  		warnOnceIfDebug( missingPlugin( this.name, 'transition' ), { ractive: ractive });
  	}

  	// TODO: dry up after deprecation is done
  	if ( options.template && this.template.f.a && this.template.f.a.s ) {
  		this.resolvers = [];
  		this.models = this.template.f.a.r.map( function ( ref, i ) {
  			var resolver;
  			var model = resolveReference( this$1.parentFragment, ref );
  			if ( !model ) {
  				resolver = this$1.parentFragment.resolve( ref, function ( model ) {
  					this$1.models[i] = model;
  					removeFromArray( this$1.resolvers, resolver );
  					model.register( this$1 );
  				});

  				this$1.resolvers.push( resolver );
  			} else model.register( this$1 );

  			return model;
  		});
  		this.argsFn = getFunction( this.template.f.a.s, this.template.f.a.r.length );
  	}
  };

  Transition.prototype.destroyed = function destroyed () {};

  Transition.prototype.getStyle = function getStyle ( props ) {
  	var computedStyle = getComputedStyle( this.owner.node );

  	if ( typeof props === 'string' ) {
  		var value = computedStyle[ prefix$1( props ) ];
  		return value === '0px' ? 0 : value;
  	}

  	if ( !isArray( props ) ) {
  		throw new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );
  	}

  	var styles = {};

  	var i = props.length;
  	while ( i-- ) {
  		var prop = props[i];
  		var value$1 = computedStyle[ prefix$1( prop ) ];

  		if ( value$1 === '0px' ) value$1 = 0;
  		styles[ prop ] = value$1;
  	}

  	return styles;
  };

  Transition.prototype.processParams = function processParams ( params, defaults ) {
  	if ( typeof params === 'number' ) {
  		params = { duration: params };
  	}

  	else if ( typeof params === 'string' ) {
  		if ( params === 'slow' ) {
  			params = { duration: 600 };
  		} else if ( params === 'fast' ) {
  			params = { duration: 200 };
  		} else {
  			params = { duration: 400 };
  		}
  	} else if ( !params ) {
  		params = {};
  	}

  	return extendObj( {}, defaults, params );
  };

  Transition.prototype.rebinding = function rebinding ( next, previous ) {
  	var idx = this.models.indexOf( previous );
  	if ( !~idx ) return;

  	next = rebindMatch( this.template.f.a.r[ idx ], next, previous );
  	if ( next === previous ) return;

  	previous.unregister( this );
  	this.models.splice( idx, 1, next );
  	if ( next ) next.addShuffleRegister( this, 'mark' );
  };

  Transition.prototype.registerCompleteHandler = function registerCompleteHandler ( fn ) {
  	addToArray( this.onComplete, fn );
  };

  Transition.prototype.render = function render () {};

  Transition.prototype.setStyle = function setStyle ( style, value ) {
  	if ( typeof style === 'string' ) {
  		this.owner.node.style[ prefix$1( style ) ] = value;
  	}

  	else {
  		var prop;
  		for ( prop in style ) {
  			if ( style.hasOwnProperty( prop ) ) {
  				this.owner.node.style[ prefix$1( prop ) ] = style[ prop ];
  			}
  		}
  	}

  	return this;
  };

  Transition.prototype.start = function start () {
  	var this$1 = this;

  		var node = this.node = this.element.node;
  	var originalStyle = node.getAttribute( 'style' );

  	var completed;
  	var args = this.params;

  	// create t.complete() - we don't want this on the prototype,
  	// because we don't want `this` silliness when passing it as
  	// an argument
  	this.complete = function ( noReset ) {
  		if ( completed ) {
  			return;
  		}

  		this$1.onComplete.forEach( function ( fn ) { return fn(); } );
  		if ( !noReset && this$1.isIntro ) {
  			resetStyle( node, originalStyle);
  		}

  		this$1._manager.remove( this$1 );

  		completed = true;
  	};

  	// If the transition function doesn't exist, abort
  	if ( !this._fn ) {
  		this.complete();
  		return;
  	}

  	// get expression args if supplied
  	if ( this.argsFn ) {
  		var values = this.models.map( function ( model ) {
  			if ( !model ) return undefined;

  			return model.get();
  		});
  		args = this.argsFn.apply( this.ractive, values );
  	}

  	var promise = this._fn.apply( this.ractive, [ this ].concat( args ) );
  	if ( promise ) promise.then( this.complete );
  };

  Transition.prototype.toString = function toString () { return ''; };

  Transition.prototype.unbind = function unbind$1 () {
  	if ( this.resolvers ) this.resolvers.forEach( unbind );
  };

  Transition.prototype.unregisterCompleteHandler = function unregisterCompleteHandler ( fn ) {
  	removeFromArray( this.onComplete, fn );
  };

  Transition.prototype.unrender = function unrender () {};

  Transition.prototype.update = function update () {};

  var elementCache = {};

  var ieBug;
  var ieBlacklist;

  try {
  	createElement( 'table' ).innerHTML = 'foo';
  } catch ( err ) {
  	ieBug = true;

  	ieBlacklist = {
  		TABLE:  [ '<table class="x">', '</table>' ],
  		THEAD:  [ '<table><thead class="x">', '</thead></table>' ],
  		TBODY:  [ '<table><tbody class="x">', '</tbody></table>' ],
  		TR:     [ '<table><tr class="x">', '</tr></table>' ],
  		SELECT: [ '<select class="x">', '</select>' ]
  	};
  }

  function insertHtml ( html, node, docFrag ) {
  	var nodes = [];

  	// render 0 and false
  	if ( html == null || html === '' ) return nodes;

  	var container;
  	var wrapper;
  	var selectedOption;

  	if ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {
  		container = element( 'DIV' );
  		container.innerHTML = wrapper[0] + html + wrapper[1];
  		container = container.querySelector( '.x' );

  		if ( container.tagName === 'SELECT' ) {
  			selectedOption = container.options[ container.selectedIndex ];
  		}
  	}

  	else if ( node.namespaceURI === svg$1 ) {
  		container = element( 'DIV' );
  		container.innerHTML = '<svg class="x">' + html + '</svg>';
  		container = container.querySelector( '.x' );
  	}

  	else if ( node.tagName === 'TEXTAREA' ) {
  		container = createElement( 'div' );

  		if ( typeof container.textContent !== 'undefined' ) {
  			container.textContent = html;
  		} else {
  			container.innerHTML = html;
  		}
  	}

  	else {
  		container = element( node.tagName );
  		container.innerHTML = html;

  		if ( container.tagName === 'SELECT' ) {
  			selectedOption = container.options[ container.selectedIndex ];
  		}
  	}

  	var child;
  	while ( child = container.firstChild ) {
  		nodes.push( child );
  		docFrag.appendChild( child );
  	}

  	// This is really annoying. Extracting <option> nodes from the
  	// temporary container <select> causes the remaining ones to
  	// become selected. So now we have to deselect them. IE8, you
  	// amaze me. You really do
  	// ...and now Chrome too
  	var i;
  	if ( node.tagName === 'SELECT' ) {
  		i = nodes.length;
  		while ( i-- ) {
  			if ( nodes[i] !== selectedOption ) {
  				nodes[i].selected = false;
  			}
  		}
  	}

  	return nodes;
  }

  function element ( tagName ) {
  	return elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );
  }

  var Triple = (function (Mustache) {
  	function Triple ( options ) {
  		Mustache.call( this, options );
  	}

  	Triple.prototype = Object.create( Mustache && Mustache.prototype );
  	Triple.prototype.constructor = Triple;

  	Triple.prototype.detach = function detach () {
  		var docFrag = createDocumentFragment();
  		this.nodes.forEach( function ( node ) { return docFrag.appendChild( node ); } );
  		return docFrag;
  	};

  	Triple.prototype.find = function find ( selector ) {
  		var this$1 = this;

  		var len = this.nodes.length;
  		var i;

  		for ( i = 0; i < len; i += 1 ) {
  			var node = this$1.nodes[i];

  			if ( node.nodeType !== 1 ) continue;

  			if ( matches( node, selector ) ) return node;

  			var queryResult = node.querySelector( selector );
  			if ( queryResult ) return queryResult;
  		}

  		return null;
  	};

  	Triple.prototype.findAll = function findAll ( selector, query ) {
  		var this$1 = this;

  		var len = this.nodes.length;
  		var i;

  		for ( i = 0; i < len; i += 1 ) {
  			var node = this$1.nodes[i];

  			if ( node.nodeType !== 1 ) continue;

  			if ( query.test( node ) ) query.add( node );

  			var queryAllResult = node.querySelectorAll( selector );
  			if ( queryAllResult ) {
  				var numNodes = queryAllResult.length;
  				var j;

  				for ( j = 0; j < numNodes; j += 1 ) {
  					query.add( queryAllResult[j] );
  				}
  			}
  		}
  	};

  	Triple.prototype.findComponent = function findComponent () {
  		return null;
  	};

  	Triple.prototype.firstNode = function firstNode () {
  		return this.nodes[0];
  	};

  	Triple.prototype.render = function render ( target ) {
  		var html = this.model ? this.model.get() : '';
  		this.nodes = insertHtml( html, this.parentFragment.findParentNode(), target );
  		this.rendered = true;
  	};

  	Triple.prototype.toString = function toString () {
  		return this.model && this.model.get() != null ? decodeCharacterReferences( '' + this.model.get() ) : '';
  	};

  	Triple.prototype.unrender = function unrender () {
  		if ( this.nodes ) this.nodes.forEach( function ( node ) { return detachNode( node ); } );
  		this.rendered = false;
  	};

  	Triple.prototype.update = function update () {
  		if ( this.rendered && this.dirty ) {
  			this.dirty = false;

  			this.unrender();
  			var docFrag = createDocumentFragment();
  			this.render( docFrag );

  			var parentNode = this.parentFragment.findParentNode();
  			var anchor = this.parentFragment.findNextNode( this );

  			parentNode.insertBefore( docFrag, anchor );
  		} else {
  			// make sure to reset the dirty flag even if not rendered
  			this.dirty = false;
  		}
  	};

  	return Triple;
  }(Mustache));

  var Yielder = (function (Item) {
  	function Yielder ( options ) {
  		Item.call( this, options );

  		this.container = options.parentFragment.ractive;
  		this.component = this.container.component;

  		this.containerFragment = options.parentFragment;
  		this.parentFragment = this.component.parentFragment;

  		// {{yield}} is equivalent to {{yield content}}
  		this.name = options.template.n || '';
  	}

  	Yielder.prototype = Object.create( Item && Item.prototype );
  	Yielder.prototype.constructor = Yielder;

  	Yielder.prototype.bind = function bind () {
  		var name = this.name;

  		( this.component.yielders[ name ] || ( this.component.yielders[ name ] = [] ) ).push( this );

  		// TODO don't parse here
  		var template = this.container._inlinePartials[ name || 'content' ];

  		if ( typeof template === 'string' ) {
  			template = parse( template ).t;
  		}

  		if ( !template ) {
  			warnIfDebug( ("Could not find template for partial \"" + name + "\""), { ractive: this.ractive });
  			template = [];
  		}

  		this.fragment = new Fragment({
  			owner: this,
  			ractive: this.container.parent,
  			template: template
  		}).bind();
  	};

  	Yielder.prototype.bubble = function bubble () {
  		if ( !this.dirty ) {
  			this.containerFragment.bubble();
  			this.dirty = true;
  		}
  	};

  	Yielder.prototype.detach = function detach () {
  		return this.fragment.detach();
  	};

  	Yielder.prototype.find = function find ( selector ) {
  		return this.fragment.find( selector );
  	};

  	Yielder.prototype.findAll = function findAll ( selector, queryResult ) {
  		this.fragment.findAll( selector, queryResult );
  	};

  	Yielder.prototype.findComponent = function findComponent ( name ) {
  		return this.fragment.findComponent( name );
  	};

  	Yielder.prototype.findAllComponents = function findAllComponents ( name, queryResult ) {
  		this.fragment.findAllComponents( name, queryResult );
  	};

  	Yielder.prototype.findNextNode = function findNextNode() {
  		return this.containerFragment.findNextNode( this );
  	};

  	Yielder.prototype.firstNode = function firstNode ( skipParent ) {
  		return this.fragment.firstNode( skipParent );
  	};

  	Yielder.prototype.render = function render ( target, occupants ) {
  		return this.fragment.render( target, occupants );
  	};

  	Yielder.prototype.setTemplate = function setTemplate ( name ) {
  		var template = this.parentFragment.ractive.partials[ name ];

  		if ( typeof template === 'string' ) {
  			template = parse( template ).t;
  		}

  		this.partialTemplate = template || []; // TODO warn on missing partial
  	};

  	Yielder.prototype.toString = function toString ( escape ) {
  		return this.fragment.toString( escape );
  	};

  	Yielder.prototype.unbind = function unbind () {
  		this.fragment.unbind();
  		removeFromArray( this.component.yielders[ this.name ], this );
  	};

  	Yielder.prototype.unrender = function unrender ( shouldDestroy ) {
  		this.fragment.unrender( shouldDestroy );
  	};

  	Yielder.prototype.update = function update () {
  		this.dirty = false;
  		this.fragment.update();
  	};

  	return Yielder;
  }(Item));

  // finds the component constructor in the registry or view hierarchy registries
  function getComponentConstructor ( ractive, name ) {
  	var instance = findInstance( 'components', ractive, name );
  	var Component;

  	if ( instance ) {
  		Component = instance.components[ name ];

  		// best test we have for not Ractive.extend
  		if ( !Component._Parent ) {
  			// function option, execute and store for reset
  			var fn = Component.bind( instance );
  			fn.isOwner = instance.components.hasOwnProperty( name );
  			Component = fn();

  			if ( !Component ) {
  				warnIfDebug( noRegistryFunctionReturn, name, 'component', 'component', { ractive: ractive });
  				return;
  			}

  			if ( typeof Component === 'string' ) {
  				// allow string lookup
  				Component = getComponentConstructor( ractive, Component );
  			}

  			Component._fn = fn;
  			instance.components[ name ] = Component;
  		}
  	}

  	return Component;
  }

  var constructors = {};
  constructors[ ALIAS ] = Alias;
  constructors[ DOCTYPE ] = Doctype;
  constructors[ INTERPOLATOR ] = Interpolator;
  constructors[ PARTIAL ] = Partial;
  constructors[ SECTION ] = Section;
  constructors[ TRIPLE ] = Triple;
  constructors[ YIELDER ] = Yielder;

  constructors[ ATTRIBUTE ] = Attribute;
  constructors[ BINDING_FLAG ] = BindingFlag;
  constructors[ DECORATOR ] = Decorator;
  constructors[ EVENT ] = EventDirective;
  constructors[ TRANSITION ] = Transition;

  var specialElements = {
  	doctype: Doctype,
  	form: Form,
  	input: Input,
  	option: Option,
  	select: Select,
  	textarea: Textarea
  };

  function createItem ( options ) {
  	if ( typeof options.template === 'string' ) {
  		return new Text( options );
  	}

  	if ( options.template.t === ELEMENT ) {
  		// could be component or element
  		var ComponentConstructor = getComponentConstructor( options.parentFragment.ractive, options.template.e );
  		if ( ComponentConstructor ) {
  			return new Component( options, ComponentConstructor );
  		}

  		var tagName = options.template.e.toLowerCase();

  		var ElementConstructor = specialElements[ tagName ] || Element;
  		return new ElementConstructor( options );
  	}

  	var Item;

  	// component mappings are a special case of attribute
  	if ( options.template.t === ATTRIBUTE ) {
  		var el = options.owner;
  		if ( !el || ( el.type !== COMPONENT && el.type !== ELEMENT ) ) {
  			el = findElement( options.parentFragment );
  		}
  		options.element = el;

  		Item = el.type === COMPONENT ? Mapping : Attribute;
  	} else {
  		Item = constructors[ options.template.t ];
  	}

  	if ( !Item ) throw new Error( ("Unrecognised item type " + (options.template.t)) );

  	return new Item( options );
  }

  // TODO all this code needs to die
  function processItems ( items, values, guid, counter ) {
  	if ( counter === void 0 ) counter = 0;

  	return items.map( function ( item ) {
  		if ( item.type === TEXT ) {
  			return item.template;
  		}

  		if ( item.fragment ) {
  			if ( item.fragment.iterations ) {
  				return item.fragment.iterations.map( function ( fragment ) {
  					return processItems( fragment.items, values, guid, counter );
  				}).join( '' );
  			} else {
  				return processItems( item.fragment.items, values, guid, counter );
  			}
  		}

  		var placeholderId = "" + guid + "-" + (counter++);
  		var model = item.model || item.newModel;

  		values[ placeholderId ] = model ?
  			model.wrapper ?
  				model.wrapperValue :
  				model.get() :
  			undefined;

  		return '${' + placeholderId + '}';
  	}).join( '' );
  }

  function unrenderAndDestroy$1 ( item ) {
  	item.unrender( true );
  }

  var Fragment = function Fragment ( options ) {
  	this.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute

  	this.isRoot = !options.owner.parentFragment;
  	this.parent = this.isRoot ? null : this.owner.parentFragment;
  	this.ractive = options.ractive || ( this.isRoot ? options.owner : this.parent.ractive );

  	this.componentParent = ( this.isRoot && this.ractive.component ) ? this.ractive.component.parentFragment : null;

  	this.context = null;
  	this.rendered = false;

  	// encapsulated styles should be inherited until they get applied by an element
  	this.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );

  	this.resolvers = [];

  	this.dirty = false;
  	this.dirtyArgs = this.dirtyValue = true; // TODO getArgsList is nonsense - should deprecate legacy directives style

  	this.template = options.template || [];
  	this.createItems();
  };

  Fragment.prototype.bind = function bind$1$$ ( context ) {
  	this.context = context;
  	this.items.forEach( bind$1 );
  	this.bound = true;

  	// in rare cases, a forced resolution (or similar) will cause the
  	// fragment to be dirty before it's even finished binding. In those
  	// cases we update immediately
  	if ( this.dirty ) this.update();

  	return this;
  };

  Fragment.prototype.bubble = function bubble () {
  	this.dirtyArgs = this.dirtyValue = true;

  	if ( !this.dirty ) {
  		this.dirty = true;

  		if ( this.isRoot ) { // TODO encapsulate 'is component root, but not overall root' check?
  			if ( this.ractive.component ) {
  				this.ractive.component.bubble();
  			} else if ( this.bound ) {
  				runloop.addFragment( this );
  			}
  		} else {
  			this.owner.bubble();
  		}
  	}
  };

  Fragment.prototype.createItems = function createItems () {
  	// this is a hot code path
  	var this$1 = this;

  		var max = this.template.length;
  	this.items = [];
  	for ( var i = 0; i < max; i++ ) {
  		this$1.items[i] = createItem({ parentFragment: this$1, template: this$1.template[i], index: i });
  	}
  };

  Fragment.prototype.destroyed = function destroyed () {
  	this.items.forEach( function ( i ) { return i.destroyed(); } );
  };

  Fragment.prototype.detach = function detach () {
  	var docFrag = createDocumentFragment();
  	this.items.forEach( function ( item ) { return docFrag.appendChild( item.detach() ); } );
  	return docFrag;
  };

  Fragment.prototype.find = function find ( selector ) {
  	var this$1 = this;

  		var len = this.items.length;
  	var i;

  	for ( i = 0; i < len; i += 1 ) {
  		var found = this$1.items[i].find( selector );
  		if ( found ) return found;
  	}
  };

  Fragment.prototype.findAll = function findAll ( selector, query ) {
  	var this$1 = this;

  		if ( this.items ) {
  		var len = this.items.length;
  		var i;

  		for ( i = 0; i < len; i += 1 ) {
  			var item = this$1.items[i];

  			if ( item.findAll ) {
  				item.findAll( selector, query );
  			}
  		}
  	}

  	return query;
  };

  Fragment.prototype.findComponent = function findComponent ( name ) {
  	var this$1 = this;

  		var len = this.items.length;
  	var i;

  	for ( i = 0; i < len; i += 1 ) {
  		var found = this$1.items[i].findComponent( name );
  		if ( found ) return found;
  	}
  };

  Fragment.prototype.findAllComponents = function findAllComponents ( name, query ) {
  	var this$1 = this;

  		if ( this.items ) {
  		var len = this.items.length;
  		var i;

  		for ( i = 0; i < len; i += 1 ) {
  			var item = this$1.items[i];

  			if ( item.findAllComponents ) {
  				item.findAllComponents( name, query );
  			}
  		}
  	}

  	return query;
  };

  Fragment.prototype.findContext = function findContext () {
  	var fragment = this;
  	while ( fragment && !fragment.context ) fragment = fragment.parent;
  	if ( !fragment ) return this.ractive.viewmodel;
  	else return fragment.context;
  };

  Fragment.prototype.findNextNode = function findNextNode ( item ) {
  	// search for the next node going forward
  	var this$1 = this;

  		if ( item ) {
  		for ( var i = item.index + 1; i < this$1.items.length; i++ ) {
  			if ( !this$1.items[ i ] ) continue;

  			var node = this$1.items[ i ].firstNode( true );
  			if ( node ) return node;
  		}
  	}

  	// if this is the root fragment, and there are no more items,
  	// it means we're at the end...
  	if ( this.isRoot ) {
  		if ( this.ractive.component ) {
  			return this.ractive.component.parentFragment.findNextNode( this.ractive.component );
  		}

  		// TODO possible edge case with other content
  		// appended to this.ractive.el?
  		return null;
  	}

  	if ( this.parent ) return this.owner.findNextNode( this ); // the argument is in case the parent is a RepeatedFragment
  };

  Fragment.prototype.findParentNode = function findParentNode () {
  	var fragment = this;

  	do {
  		if ( fragment.owner.type === ELEMENT ) {
  			return fragment.owner.node;
  		}

  		if ( fragment.isRoot && !fragment.ractive.component ) { // TODO encapsulate check
  			return fragment.ractive.el;
  		}

  		if ( fragment.owner.type === YIELDER ) {
  			fragment = fragment.owner.containerFragment;
  		} else {
  			fragment = fragment.componentParent || fragment.parent; // TODO ugh
  		}
  	} while ( fragment );

  	throw new Error( 'Could not find parent node' ); // TODO link to issue tracker
  };

  Fragment.prototype.findRepeatingFragment = function findRepeatingFragment () {
  	var fragment = this;
  	// TODO better check than fragment.parent.iterations
  	while ( ( fragment.parent || fragment.componentParent ) && !fragment.isIteration ) {
  		fragment = fragment.parent || fragment.componentParent;
  	}

  	return fragment;
  };

  Fragment.prototype.firstNode = function firstNode ( skipParent ) {
  	var this$1 = this;

  		var node;
  	for ( var i = 0; i < this$1.items.length; i++ ) {
  		node = this$1.items[i].firstNode( true );

  		if ( node ) {
  			return node;
  		}
  	}

  	if ( skipParent ) return null;

  	return this.parent.findNextNode( this.owner );
  };

  // TODO ideally, this would be deprecated in favour of an
  // expression-like approach
  Fragment.prototype.getArgsList = function getArgsList () {
  	if ( this.dirtyArgs ) {
  		var values = {};
  		var source = processItems( this.items, values, this.ractive._guid );
  		var parsed = parseJSON( '[' + source + ']', values );

  		this.argsList = parsed ?
  			parsed.value :
  			[ this.toString() ];

  		this.dirtyArgs = false;
  	}

  	return this.argsList;
  };

  Fragment.prototype.rebinding = function rebinding ( next ) {
  	this.context = next;
  };

  Fragment.prototype.render = function render ( target, occupants ) {
  	if ( this.rendered ) throw new Error( 'Fragment is already rendered!' );
  	this.rendered = true;

  	this.items.forEach( function ( item ) { return item.render( target, occupants ); } );
  };

  Fragment.prototype.resetTemplate = function resetTemplate ( template ) {
  	var wasBound = this.bound;
  	var wasRendered = this.rendered;

  	// TODO ensure transitions are disabled globally during reset

  	if ( wasBound ) {
  		if ( wasRendered ) this.unrender( true );
  		this.unbind();
  	}

  	this.template = template;
  	this.createItems();

  	if ( wasBound ) {
  		this.bind( this.context );

  		if ( wasRendered ) {
  			var parentNode = this.findParentNode();
  			var anchor = this.findNextNode();

  			if ( anchor ) {
  				var docFrag = createDocumentFragment();
  				this.render( docFrag );
  				parentNode.insertBefore( docFrag, anchor );
  			} else {
  				this.render( parentNode );
  			}
  		}
  	}
  };

  Fragment.prototype.resolve = function resolve ( template, callback ) {
  	if ( !this.context && this.parent.resolve ) {
  		return this.parent.resolve( template, callback );
  	}

  	var resolver = new ReferenceResolver( this, template, callback );
  	this.resolvers.push( resolver );

  	return resolver; // so we can e.g. force resolution
  };

  Fragment.prototype.shuffled = function shuffled () {
  	this.items.forEach( function ( i ) { return i.shuffled(); } );
  };

  Fragment.prototype.toHtml = function toHtml () {
  	return this.toString();
  };

  Fragment.prototype.toString = function toString$1$$ ( escape ) {
  	return this.items.map( escape ? toEscapedString : toString$1 ).join( '' );
  };

  Fragment.prototype.unbind = function unbind$1 () {
  	this.items.forEach( unbind );
  	this.bound = false;

  	return this;
  };

  Fragment.prototype.unrender = function unrender$1 ( shouldDestroy ) {
  	this.items.forEach( shouldDestroy ? unrenderAndDestroy$1 : unrender );
  	this.rendered = false;
  };

  Fragment.prototype.update = function update$1 () {
  	if ( this.dirty ) {
  		if ( !this.updating ) {
  			this.dirty = false;
  			this.updating = true;
  			this.items.forEach( update );
  			this.updating = false;
  		} else if ( this.isRoot ) {
  			runloop.addFragmentToRoot( this );
  		}
  	}
  };

  Fragment.prototype.valueOf = function valueOf () {
  	if ( this.items.length === 1 ) {
  		return this.items[0].valueOf();
  	}

  	if ( this.dirtyValue ) {
  		var values = {};
  		var source = processItems( this.items, values, this.ractive._guid );
  		var parsed = parseJSON( source, values );

  		this.value = parsed ?
  			parsed.value :
  			this.toString();

  		this.dirtyValue = false;
  	}

  	return this.value;
  };

  // TODO should resetTemplate be asynchronous? i.e. should it be a case
  // of outro, update template, intro? I reckon probably not, since that
  // could be achieved with unrender-resetTemplate-render. Also, it should
  // conceptually be similar to resetPartial, which couldn't be async

  function Ractive$resetTemplate ( template ) {
  	templateConfigurator.init( null, this, { template: template });

  	var transitionsEnabled = this.transitionsEnabled;
  	this.transitionsEnabled = false;

  	// Is this is a component, we need to set the `shouldDestroy`
  	// flag, otherwise it will assume by default that a parent node
  	// will be detached, and therefore it doesn't need to bother
  	// detaching its own nodes
  	var component = this.component;
  	if ( component ) component.shouldDestroy = true;
  	this.unrender();
  	if ( component ) component.shouldDestroy = false;

  	// remove existing fragment and create new one
  	this.fragment.unbind().unrender( true );

  	this.fragment = new Fragment({
  		template: this.template,
  		root: this,
  		owner: this
  	});

  	var docFrag = createDocumentFragment();
  	this.fragment.bind( this.viewmodel ).render( docFrag );

  	// if this is a component, its el may not be valid, so find a
  	// target based on the component container
  	if ( component ) {
  		this.fragment.findParentNode().insertBefore( docFrag, component.findNextNode() );
  	} else {
  		this.el.insertBefore( docFrag, this.anchor );
  	}

  	this.transitionsEnabled = transitionsEnabled;
  }

  var reverse$1 = makeArrayMethod( 'reverse' ).path;

  function Ractive$set ( keypath, value ) {
  	var ractive = this;

  	return set( ractive, build( ractive, keypath, value ) );
  }

  var shift$1 = makeArrayMethod( 'shift' ).path;

  var sort$1 = makeArrayMethod( 'sort' ).path;

  var splice$1 = makeArrayMethod( 'splice' ).path;

  function Ractive$subtract ( keypath, d ) {
  	return add( this, keypath, ( d === undefined ? -1 : -d ) );
  }

  var teardownHook$1 = new Hook( 'teardown' );

  // Teardown. This goes through the root fragment and all its children, removing observers
  // and generally cleaning up after itself

  function Ractive$teardown () {
  	if ( this.torndown ) {
  		warnIfDebug( 'ractive.teardown() was called on a Ractive instance that was already torn down' );
  		return Promise$1.resolve();
  	}

  	this.torndown = true;
  	this.fragment.unbind();
  	this.viewmodel.teardown();

  	this._observers.forEach( cancel );

  	if ( this.fragment.rendered && this.el.__ractive_instances__ ) {
  		removeFromArray( this.el.__ractive_instances__, this );
  	}

  	this.shouldDestroy = true;
  	var promise = ( this.fragment.rendered ? this.unrender() : Promise$1.resolve() );

  	teardownHook$1.fire( this );

  	return promise;
  }

  function Ractive$toggle ( keypath ) {
  	if ( typeof keypath !== 'string' ) {
  		throw new TypeError( badArguments );
  	}

  	return set( this, gather( this, keypath ).map( function ( m ) { return [ m, !m.get() ]; } ) );
  }

  function Ractive$toCSS() {
  	var cssIds = [ this.cssId ].concat( this.findAllComponents().map( function ( c ) { return c.cssId; } ) );
  	var uniqueCssIds = Object.keys(cssIds.reduce( function ( ids, id ) { return (ids[id] = true, ids); }, {}));
  	return getCSS( uniqueCssIds );
  }

  function Ractive$toHTML () {
  	return this.fragment.toString( true );
  }

  function toText () {
  	return this.fragment.toString( false );
  }

  function Ractive$transition ( name, node, params ) {

  	if ( node instanceof HTMLElement ) {
  		// good to go
  	}
  	else if ( isObject( node ) ) {
  		// omitted, use event node
  		params = node;
  	}

  	// if we allow query selector, then it won't work
  	// simple params like "fast"

  	// else if ( typeof node === 'string' ) {
  	// 	// query selector
  	// 	node = this.find( node )
  	// }

  	node = node || this.event.node;

  	if ( !node || !node._ractive ) {
  		fatal( ("No node was supplied for transition " + name) );
  	}

  	params = params || {};
  	var owner = node._ractive.proxy;
  	var transition = new Transition({ owner: owner, parentFragment: owner.parentFragment, name: name, params: params });
  	transition.bind();

  	var promise = runloop.start( this, true );
  	runloop.registerTransition( transition );
  	runloop.end();

  	promise.then( function () { return transition.unbind(); } );
  	return promise;
  }

  function unlink$1( here ) {
  	var promise = runloop.start();
  	this.viewmodel.joinAll( splitKeypathI( here ), { lastLink: false } ).unlink();
  	runloop.end();
  	return promise;
  }

  var unrenderHook$1 = new Hook( 'unrender' );

  function Ractive$unrender () {
  	if ( !this.fragment.rendered ) {
  		warnIfDebug( 'ractive.unrender() was called on a Ractive instance that was not rendered' );
  		return Promise$1.resolve();
  	}

  	var promise = runloop.start( this, true );

  	// If this is a component, and the component isn't marked for destruction,
  	// don't detach nodes from the DOM unnecessarily
  	var shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;
  	this.fragment.unrender( shouldDestroy );

  	removeFromArray( this.el.__ractive_instances__, this );

  	unrenderHook$1.fire( this );

  	runloop.end();
  	return promise;
  }

  var unshift$1 = makeArrayMethod( 'unshift' ).path;

  function Ractive$updateModel ( keypath, cascade ) {
  	var promise = runloop.start( this, true );

  	if ( !keypath ) {
  		this.viewmodel.updateFromBindings( true );
  	} else {
  		this.viewmodel.joinAll( splitKeypathI( keypath ) ).updateFromBindings( cascade !== false );
  	}

  	runloop.end();

  	return promise;
  }

  var proto = {
  	add: Ractive$add,
  	animate: Ractive$animate,
  	detach: Ractive$detach,
  	find: Ractive$find,
  	findAll: Ractive$findAll,
  	findAllComponents: Ractive$findAllComponents,
  	findComponent: Ractive$findComponent,
  	findContainer: Ractive$findContainer,
  	findParent: Ractive$findParent,
  	fire: Ractive$fire,
  	get: Ractive$get,
  	getNodeInfo: getNodeInfo,
  	insert: Ractive$insert,
  	link: link$1,
  	merge: thisRactive$merge,
  	observe: observe,
  	observeList: observeList,
  	observeOnce: observeOnce,
  	// TODO reinstate these
  	// observeListOnce,
  	off: Ractive$off,
  	on: Ractive$on,
  	once: Ractive$once,
  	pop: pop$1,
  	push: push$1,
  	render: Ractive$render,
  	reset: Ractive$reset,
  	resetPartial: resetPartial,
  	resetTemplate: Ractive$resetTemplate,
  	reverse: reverse$1,
  	set: Ractive$set,
  	shift: shift$1,
  	sort: sort$1,
  	splice: splice$1,
  	subtract: Ractive$subtract,
  	teardown: Ractive$teardown,
  	toggle: Ractive$toggle,
  	toCSS: Ractive$toCSS,
  	toCss: Ractive$toCSS,
  	toHTML: Ractive$toHTML,
  	toHtml: Ractive$toHTML,
  	toText: toText,
  	transition: Ractive$transition,
  	unlink: unlink$1,
  	unrender: Ractive$unrender,
  	unshift: unshift$1,
  	update: Ractive$update,
  	updateModel: Ractive$updateModel
  };

  function wrap$1 ( method, superMethod, force ) {

  	if ( force || needsSuper( method, superMethod ) )  {

  		return function () {

  			var hasSuper = ( '_super' in this ), _super = this._super, result;

  			this._super = superMethod;

  			result = method.apply( this, arguments );

  			if ( hasSuper ) {
  				this._super = _super;
  			}

  			return result;
  		};
  	}

  	else {
  		return method;
  	}
  }

  function needsSuper ( method, superMethod ) {
  	return typeof superMethod === 'function' && /_super/.test( method );
  }

  function unwrap ( Child ) {
  	var options = {};

  	while ( Child ) {
  		addRegistries( Child, options );
  		addOtherOptions( Child, options );

  		if ( Child._Parent !== Ractive ) {
  			Child = Child._Parent;
  		} else {
  			Child = false;
  		}
  	}

  	return options;
  }

  function addRegistries ( Child, options ) {
  	registries.forEach( function ( r ) {
  		addRegistry(
  			r.useDefaults ? Child.prototype : Child,
  			options, r.name );
  	});
  }

  function addRegistry ( target, options, name ) {
  	var registry, keys = Object.keys( target[ name ] );

  	if ( !keys.length ) { return; }

  	if ( !( registry = options[ name ] ) ) {
  		registry = options[ name ] = {};
  	}

  	keys
  		.filter( function ( key ) { return !( key in registry ); } )
  		.forEach( function ( key ) { return registry[ key ] = target[ name ][ key ]; } );
  }

  function addOtherOptions ( Child, options ) {
  	Object.keys( Child.prototype ).forEach( function ( key ) {
  		if ( key === 'computed' ) { return; }

  		var value = Child.prototype[ key ];

  		if ( !( key in options ) ) {
  			options[ key ] = value._method ? value._method : value;
  		}

  		// is it a wrapped function?
  		else if ( typeof options[ key ] === 'function'
  				&& typeof value === 'function'
  				&& options[ key ]._method ) {

  			var result, needsSuper = value._method;

  			if ( needsSuper ) { value = value._method; }

  			// rewrap bound directly to parent fn
  			result = wrap$1( options[ key ]._method, value );

  			if ( needsSuper ) { result._method = result; }

  			options[ key ] = result;
  		}
  	});
  }

  function extend () {
  	var options = [], len = arguments.length;
  	while ( len-- ) options[ len ] = arguments[ len ];

  	if( !options.length ) {
  		return extendOne( this );
  	} else {
  		return options.reduce( extendOne, this );
  	}
  }

  function extendOne ( Parent, options ) {
  	if ( options === void 0 ) options = {};

  	var Child, proto;

  	// if we're extending with another Ractive instance...
  	//
  	//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);
  	//   var Spiderman = Human.extend( Spider );
  	//
  	// ...inherit prototype methods and default options as well
  	if ( options.prototype instanceof Ractive ) {
  		options = unwrap( options );
  	}

  	Child = function ( options ) {
  		if ( !( this instanceof Child ) ) return new Child( options );

  		construct( this, options || {} );
  		initialise( this, options || {}, {} );
  	};

  	proto = create( Parent.prototype );
  	proto.constructor = Child;

  	// Static properties
  	defineProperties( Child, {
  		// alias prototype as defaults
  		defaults: { value: proto },

  		// extendable
  		extend: { value: extend, writable: true, configurable: true },

  		// Parent - for IE8, can't use Object.getPrototypeOf
  		_Parent: { value: Parent }
  	});

  	// extend configuration
  	config.extend( Parent, proto, options );

  	dataConfigurator.extend( Parent, proto, options );

  	if ( options.computed ) {
  		proto.computed = extendObj( create( Parent.prototype.computed ), options.computed );
  	}

  	Child.prototype = proto;

  	return Child;
  }

  function joinKeys () {
  	var keys = [], len = arguments.length;
  	while ( len-- ) keys[ len ] = arguments[ len ];

  	return keys.map( escapeKey ).join( '.' );
  }

  function splitKeypath ( keypath ) {
  	return splitKeypathI( keypath ).map( unescapeKey );
  }

  // Ractive.js makes liberal use of things like Array.prototype.indexOf. In
  // older browsers, these are made available via a shim - here, we do a quick
  // pre-flight check to make sure that either a) we're not in a shit browser,
  // or b) we're using a Ractive-legacy.js build
  var FUNCTION = 'function';

  if (
  	typeof Date.now !== FUNCTION                 ||
  	typeof String.prototype.trim !== FUNCTION    ||
  	typeof Object.keys !== FUNCTION              ||
  	typeof Array.prototype.indexOf !== FUNCTION  ||
  	typeof Array.prototype.forEach !== FUNCTION  ||
  	typeof Array.prototype.map !== FUNCTION      ||
  	typeof Array.prototype.filter !== FUNCTION   ||
  	( win && typeof win.addEventListener !== FUNCTION )
  ) {
  	throw new Error( 'It looks like you\'re attempting to use Ractive.js in an older browser. You\'ll need to use one of the \'legacy builds\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );
  }

  function Ractive ( options ) {
  	if ( !( this instanceof Ractive ) ) return new Ractive( options );

  	construct( this, options || {} );
  	initialise( this, options || {}, {} );
  }

  extendObj( Ractive.prototype, proto, defaults );
  Ractive.prototype.constructor = Ractive;

  // alias prototype as `defaults`
  Ractive.defaults = Ractive.prototype;

  // static properties
  defineProperties( Ractive, {

  	// debug flag
  	DEBUG:          { writable: true, value: true },
  	DEBUG_PROMISES: { writable: true, value: true },

  	// static methods:
  	extend:         { value: extend },
  	escapeKey:      { value: escapeKey },
  	getNodeInfo:    { value: staticInfo },
  	joinKeys:       { value: joinKeys },
  	parse:          { value: parse },
  	splitKeypath:   { value: splitKeypath },
  	unescapeKey:    { value: unescapeKey },
  	getCSS:         { value: getCSS },

  	// namespaced constructors
  	Promise:        { value: Promise$1 },

  	// support
  	enhance:        { writable: true, value: false },
  	svg:            { value: svg },
  	magic:          { value: magicSupported },

  	// version
  	VERSION:        { value: '0.8.5' },

  	// plugins
  	adaptors:       { writable: true, value: {} },
  	components:     { writable: true, value: {} },
  	decorators:     { writable: true, value: {} },
  	easing:         { writable: true, value: easing },
  	events:         { writable: true, value: {} },
  	interpolators:  { writable: true, value: interpolators },
  	partials:       { writable: true, value: {} },
  	transitions:    { writable: true, value: {} }
  });

  return Ractive;

}));
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],305:[function(require,module,exports){
(function (process,global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" ||
              (method === "throw" && delegate.iterator[method] === undefined)) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = arg;

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":302}],306:[function(require,module,exports){
module.exports={"v":4,"t":[{"t":7,"e":"header","m":[{"n":"headerId","f":"header-homepage","t":13}]}," ",{"t":7,"e":"navbar"}," ",{"t":4,"f":[{"t":7,"e":"newsletterForm"}],"r":"newsletterForm.show"}]}
},{}],307:[function(require,module,exports){
module.exports={"v":4,"t":[{"t":7,"e":"div","m":[{"n":"class","f":"header","t":13}],"f":[{"t":7,"e":"h1","m":[{"n":"id","f":[{"t":2,"r":"headerId"}],"t":13}],"f":[{"t":2,"r":"i18n.header.text"}]}]}]}
},{}],308:[function(require,module,exports){
module.exports={"v":4,"t":[{"t":7,"e":"div","m":[{"n":"class","f":"navbar","t":13}],"f":[{"t":7,"e":"input","m":[{"n":"type","f":"button","t":13},{"n":"click","f":"showNewsletterForm","t":70},{"n":"value","f":[{"t":2,"r":"i18n.navbar.newsletterButton"}],"t":13}]}," ",{"t":7,"e":"select","m":[{"n":"change","f":"setLanguage","t":70}],"f":[{"t":7,"e":"option","m":[{"n":"id","f":"en","t":13}],"f":["English"]}," ",{"t":7,"e":"option","m":[{"n":"id","f":"de","t":13}],"f":["Deutsch"]}," ",{"t":7,"e":"option","m":[{"n":"id","f":"nl","t":13}],"f":["Nederlands"]}]}]}]}
},{}],309:[function(require,module,exports){
module.exports={"v":4,"t":[{"t":7,"e":"div","m":[{"n":"class","f":"newsletter-form","t":13}],"f":[{"t":7,"e":"div","m":[{"n":"class","f":"newsletter-form-text","t":13}],"f":[{"t":2,"r":"i18n.newsletterForm.body"}]}," ",{"t":7,"e":"form","m":[{"n":"class","f":"pure-form-stacked","t":13}],"f":[{"t":7,"e":"label","f":[{"t":2,"r":"i18n.newsletterForm.titleEmail"}," ",{"t":7,"e":"input","m":[{"n":"type","f":"email","t":13},{"n":"placeholder","f":"","t":13}]}]}," ",{"t":7,"e":"label","f":[{"t":2,"r":"i18n.newsletterForm.titleFirstName"}," ",{"t":7,"e":"input","m":[{"n":"type","f":"text","t":13},{"n":"placeholder","f":"","t":13}]}]}," ",{"t":7,"e":"label","f":[{"t":2,"r":"i18n.newsletterForm.titleLastName"}," ",{"t":7,"e":"input","m":[{"n":"type","f":"text","t":13},{"n":"placeholder","f":"","t":13}]}]}," ",{"t":7,"e":"label","f":[{"t":2,"r":"i18n.newsletterForm.titleLanguage"}]}," ",{"t":7,"e":"label","f":[{"t":2,"r":"i18n.newsletterForm.languages.de"}," ",{"t":7,"e":"input","m":[{"n":"type","f":"radio","t":13}]}]}," ",{"t":7,"e":"label","f":[{"t":2,"r":"i18n.newsletterForm.languages.en"}," ",{"t":7,"e":"input","m":[{"n":"type","f":"radio","t":13}]}]}," ",{"t":7,"e":"label","f":[{"t":2,"r":"i18n.newsletterForm.languages.nl"}," ",{"t":7,"e":"input","m":[{"n":"type","f":"radio","t":13}]}]}," ",{"t":7,"e":"label","f":[{"t":2,"r":"i18n.newsletterForm.languages.es"}," ",{"t":7,"e":"input","m":[{"n":"type","f":"radio","t":13}]}]}," ",{"t":7,"e":"label","f":[{"t":2,"r":"i18n.newsletterForm.languages.fr"}," ",{"t":7,"e":"input","m":[{"n":"type","f":"radio","t":13}]}]}," ",{"t":7,"e":"label","f":[{"t":2,"r":"i18n.newsletterForm.titleCountry"}," ",{"t":7,"e":"input","m":[{"n":"type","f":"input","t":13}]}]}," ",{"t":7,"e":"label","f":[{"t":2,"r":"i18n.newsletterForm.titleGender"}]}," ",{"t":7,"e":"label","f":[{"t":2,"r":"i18n.newsletterForm.gender.m"}," ",{"t":7,"e":"input","m":[{"n":"type","f":"radio","t":13}]}]}," ",{"t":7,"e":"label","f":[{"t":2,"r":"i18n.newsletterForm.gender.f"}," ",{"t":7,"e":"input","m":[{"n":"type","f":"radio","t":13}]}]}," ",{"t":7,"e":"input","m":[{"n":"type","f":"button","t":13},{"n":"click","f":"validateForm","t":70},{"n":"value","f":[{"t":2,"r":"i18n.newsletterForm.buttonSubmit"}],"t":13}]}]}]}]}
},{}]},{},[5])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9hcHAuanMiLCJqcy9jb21wb25lbnRzL2hlYWRlci5qcyIsImpzL2NvbXBvbmVudHMvbmF2YmFyLmpzIiwianMvY29tcG9uZW50cy9uZXdzbGV0dGVyLWZvcm0uanMiLCJqcy9tYWluLmpzIiwianMvcGhyYXNlcy5qc29uIiwibm9kZV9tb2R1bGVzL2JhYmVsLXBvbHlmaWxsL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL3JlZ2V4cC9lc2NhcGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1yZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi13ZWFrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kYXRlLXRvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19maXgtcmUtd2tzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fa2V5b2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1leHBtMS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtbG9nMXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLXNpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19taWNyb3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZm9yY2VkLXBhbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtdG8tYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vd24ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWZsb2F0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtaW50LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcGFydGlhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhdGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZXBsYWNlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NhbWUtdmFsdWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpY3QtbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctaHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1wYWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcmVwZWF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXRyaW0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctd3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190YXNrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdHlwZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191aWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNicnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5oeXBvdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaW11bC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaWFkZGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmltdWxoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pc3ViaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgudW11bGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnRpbWVycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JhY3RpdmUtdHJhbnNpdGlvbnMtZmFkZS9kaXN0L3JhY3RpdmUtdHJhbnNpdGlvbnMtZmFkZS51bWQuanMiLCJub2RlX21vZHVsZXMvcmFjdGl2ZS9yYWN0aXZlLmpzIiwibm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsInBhZ2VzL2hvbWUuaHRtbCIsInBhcnRpYWxzL2hlYWRlci9pbmRleC5odG1sIiwicGFydGlhbHMvbmF2YmFyL2luZGV4Lmh0bWwiLCJwYXJ0aWFscy9uZXdzbGV0dGVyLWZvcm0vaW5kZXguaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztBQ0FBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFHQTtBQUNBLGtCQUFRLFdBQVIsQ0FBb0IsSUFBcEI7O0FBRUEsSUFBTSxZQUFZLFNBQVosU0FBWSxTQUFVO0FBQUEsTUFHeEIsRUFId0IsR0FLdEIsTUFMc0IsQ0FHeEIsRUFId0I7QUFBQSx5QkFLdEIsTUFMc0IsQ0FJeEIsUUFKd0I7QUFBQSxNQUl4QixRQUp3QixvQ0FJYixJQUphOzs7QUFPMUIsTUFBTSxNQUFNLHNCQUFZO0FBQ3RCLFVBRHNCO0FBRXRCLDRCQUZzQjtBQUd0QixnQkFBWTtBQUNWLDhDQURVO0FBRVYsOEJBRlU7QUFHVjtBQUhVLEtBSFU7QUFRdEIsVUFBTTtBQUNKLHdCQURJO0FBRUosWUFBTSxJQUZGO0FBR0osc0JBQWdCO0FBQ2QsY0FBTSxLQURRO0FBRWQsbUJBQVcsSUFGRztBQUdkLGtCQUFVLElBSEk7QUFJZCxlQUFPLElBSk87QUFLZCxpQkFBUyxJQUxLO0FBTWQsa0JBQVUsSUFOSTtBQU9kLGdCQUFRO0FBUE07QUFIWixLQVJnQjtBQXFCdEIsVUFyQnNCLG9CQXFCYjtBQUNQLFdBQUssR0FBTCxDQUFTLE1BQVQsRUFBaUIsa0JBQVEsS0FBSyxHQUFMLENBQVMsVUFBVCxDQUFSLENBQWpCO0FBQ0EsY0FBUSxHQUFSLENBQVksS0FBSyxHQUFMLENBQVMsTUFBVCxDQUFaO0FBQ0Q7QUF4QnFCLEdBQVosQ0FBWjs7QUEyQkEsTUFBSSxFQUFKLENBQU87QUFDTCxpQ0FBNkIsa0NBQVMsQ0FBVCxFQUFXO0FBQ3RDLFdBQUssR0FBTCxDQUFTLHFCQUFULEVBQWdDLENBQUMsS0FBSyxHQUFMLENBQVMscUJBQVQsQ0FBakM7QUFDRCxLQUhJO0FBSUwsMEJBQXNCLDJCQUFTLENBQVQsRUFBVztBQUMvQixVQUFJLFNBQVMsRUFBRSxRQUFGLENBQVcsTUFBeEI7QUFDQSxVQUFJLE9BQU8sT0FBTyxPQUFQLENBQWUsT0FBTyxhQUF0QixFQUFxQyxFQUFoRDtBQUNBLFdBQUssR0FBTCxDQUFTLFVBQVQsRUFBcUIsSUFBckI7QUFDQSxXQUFLLEdBQUwsQ0FBUyxNQUFULEVBQWlCLGtCQUFRLElBQVIsQ0FBakI7QUFDRDtBQVRJLEdBQVA7O0FBWUEsU0FBTyxHQUFQO0FBQ0QsQ0EvQ0Q7O2tCQWtEZSxTOzs7Ozs7Ozs7QUM5RGY7Ozs7QUFDQTs7OztBQUVBOzs7Ozs7QUFHQSxJQUFNLFNBQVMsa0JBQVEsTUFBUixDQUFlO0FBQzVCO0FBRDRCLENBQWYsQ0FBZjtBQUpBO2tCQWVlLE07Ozs7Ozs7OztBQ2pCZjs7OztBQUNBOzs7O0FBRUE7Ozs7OztBQUdBLElBQU0sU0FBUyxrQkFBUSxNQUFSLENBQWU7QUFDNUI7QUFENEIsQ0FBZixDQUFmO0FBSkE7a0JBZWUsTTs7Ozs7Ozs7O0FDakJmOzs7O0FBQ0E7Ozs7QUFFQTs7Ozs7O0FBR0EsSUFBTSxPQUFPLGtCQUFRLE1BQVIsQ0FBZTtBQUMxQiwyQkFEMEI7QUFFMUIsVUFBUSxrQkFBVTtBQUNoQixTQUFLLEVBQUwsQ0FBUSxjQUFSLEVBQXdCLFlBQVc7QUFDakMsYUFBTyxLQUFQLENBQWEsK0JBQWI7QUFDRCxLQUZEO0FBR0Q7QUFOeUIsQ0FBZixDQUFiO0FBSkE7OztBQWFBLEtBQUssV0FBTCxDQUFpQixJQUFqQjs7a0JBRWUsSTs7Ozs7QUNqQmY7O0FBQ0E7Ozs7OztBQUdBLE9BQU8sTUFBUCxHQUFnQixZQUFVO0FBQ3hCLHFCQUFVO0FBQ1IsUUFBSSxNQURJO0FBRVIsY0FBVTtBQUZGLEdBQVY7QUFJRCxDQUxEOzs7QUNKQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7O0FDQUE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7O0FDRkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdG9oQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM3FCQTs7QUNBQTs7QUNBQTs7QUNBQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJpbXBvcnQgZmFkZSBmcm9tICdyYWN0aXZlLXRyYW5zaXRpb25zLWZhZGUnXG5pbXBvcnQgUmFjdGl2ZSBmcm9tICdyYWN0aXZlJ1xuaW1wb3J0IHRlbXBsYXRlIGZyb20gJy4uL3BhZ2VzL2hvbWUuaHRtbCdcbmltcG9ydCBoZWFkZXIgZnJvbSAnLi9jb21wb25lbnRzL2hlYWRlcidcbmltcG9ydCBuYXZiYXIgZnJvbSAnLi9jb21wb25lbnRzL25hdmJhcidcbmltcG9ydCBuZXdzbGV0dGVyRm9ybSBmcm9tICcuL2NvbXBvbmVudHMvbmV3c2xldHRlci1mb3JtJ1xuaW1wb3J0IHBocmFzZXMgZnJvbSAnLi9waHJhc2VzLmpzb24nXG5cblxuLy8gc2V0IGdsb2JhbCBmYWRlXG5SYWN0aXZlLnRyYW5zaXRpb25zLmZhZGUgPSBmYWRlXG5cbmNvbnN0IGNyZWF0ZUFwcCA9IGNvbmZpZyA9PiB7XG5cbiAgbGV0IHtcbiAgICBlbCxcbiAgICBsYW5ndWFnZSA9ICdubCcsXG4gIH0gPSBjb25maWdcblxuICBjb25zdCBhcHAgPSBuZXcgUmFjdGl2ZSh7XG4gICAgZWwsXG4gICAgdGVtcGxhdGUsXG4gICAgY29tcG9uZW50czoge1xuICAgICAgbmV3c2xldHRlckZvcm0sXG4gICAgICBoZWFkZXIsXG4gICAgICBuYXZiYXIsXG4gICAgfSxcbiAgICBkYXRhOiB7XG4gICAgICBsYW5ndWFnZSxcbiAgICAgIGkxOG46IG51bGwsXG4gICAgICBuZXdzbGV0dGVyRm9ybToge1xuICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgZmlyc3ROYW1lOiBudWxsLFxuICAgICAgICBsYXN0TmFtZTogbnVsbCxcbiAgICAgICAgZW1haWw6IG51bGwsXG4gICAgICAgIGNvdW50cnk6IG51bGwsXG4gICAgICAgIGxhbmd1YWdlOiBudWxsLFxuICAgICAgICBnZW5kZXI6IG51bGwsXG4gICAgICB9XG4gICAgfSxcbiAgICBvbmluaXQoKSB7XG4gICAgICB0aGlzLnNldCgnaTE4bicsIHBocmFzZXNbdGhpcy5nZXQoJ2xhbmd1YWdlJyldKVxuICAgICAgY29uc29sZS5sb2codGhpcy5nZXQoJ2kxOG4nKSlcbiAgICB9XG4gIH0pXG5cbiAgYXBwLm9uKHtcbiAgICAnbmF2YmFyLnNob3dOZXdzbGV0dGVyRm9ybSc6IGZ1bmN0aW9uKGUpe1xuICAgICAgdGhpcy5zZXQoJ25ld3NsZXR0ZXJGb3JtLnNob3cnLCAhdGhpcy5nZXQoJ25ld3NsZXR0ZXJGb3JtLnNob3cnKSlcbiAgICB9LFxuICAgICduYXZiYXIuc2V0TGFuZ3VhZ2UnOiBmdW5jdGlvbihlKXtcbiAgICAgIGxldCB0YXJnZXQgPSBlLm9yaWdpbmFsLnRhcmdldFxuICAgICAgbGV0IGxhbmcgPSB0YXJnZXQub3B0aW9uc1t0YXJnZXQuc2VsZWN0ZWRJbmRleF0uaWRcbiAgICAgIHRoaXMuc2V0KCdsYW5ndWFnZScsIGxhbmcpXG4gICAgICB0aGlzLnNldCgnaTE4bicsIHBocmFzZXNbbGFuZ10pXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBhcHBcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVBcHBcbiIsImltcG9ydCBmYWRlIGZyb20gJ3JhY3RpdmUtdHJhbnNpdGlvbnMtZmFkZSdcbmltcG9ydCBSYWN0aXZlIGZyb20gJ3JhY3RpdmUnXG4vL2ltcG9ydCBSIGZyb20gJ3JhbWRhJ1xuaW1wb3J0IHRlbXBsYXRlIGZyb20gJy4uLy4uL3BhcnRpYWxzL2hlYWRlci9pbmRleC5odG1sJ1xuXG5cbmNvbnN0IGhlYWRlciA9IFJhY3RpdmUuZXh0ZW5kKHtcbiAgdGVtcGxhdGUsXG4gIC8vIG9uaW5pdDogZnVuY3Rpb24oKXtcbiAgLy8gICB0aGlzLm9uKCdoZWFkZXJDbGljaycsIGZ1bmN0aW9uKCkge1xuICAvLyAgICAgbGV0IHRvZ2dsZSA9IHRoaXMucm9vdC5nZXQoJ3Nob3dOZXdzbGV0dGVyRm9ybScpXG4gIC8vICAgICB0aGlzLnJvb3Quc2V0KCdzaG93TmV3c2xldHRlckZvcm0nLCAhdG9nZ2xlKVxuICAvLyAgIH0pXG4gIC8vIH0sXG59KVxuXG5cbmV4cG9ydCBkZWZhdWx0IGhlYWRlclxuIiwiaW1wb3J0IGZhZGUgZnJvbSAncmFjdGl2ZS10cmFuc2l0aW9ucy1mYWRlJ1xuaW1wb3J0IFJhY3RpdmUgZnJvbSAncmFjdGl2ZSdcbi8vaW1wb3J0IFIgZnJvbSAncmFtZGEnXG5pbXBvcnQgdGVtcGxhdGUgZnJvbSAnLi4vLi4vcGFydGlhbHMvbmF2YmFyL2luZGV4Lmh0bWwnXG5cblxuY29uc3QgaGVhZGVyID0gUmFjdGl2ZS5leHRlbmQoe1xuICB0ZW1wbGF0ZSxcbiAgLy8gb25pbml0OiBmdW5jdGlvbigpe1xuICAvLyAgIHRoaXMub24oJ2hlYWRlckNsaWNrJywgZnVuY3Rpb24oKSB7XG4gIC8vICAgICBsZXQgdG9nZ2xlID0gdGhpcy5yb290LmdldCgnc2hvd05ld3NsZXR0ZXJGb3JtJylcbiAgLy8gICAgIHRoaXMucm9vdC5zZXQoJ3Nob3dOZXdzbGV0dGVyRm9ybScsICF0b2dnbGUpXG4gIC8vICAgfSlcbiAgLy8gfSxcbn0pXG5cblxuZXhwb3J0IGRlZmF1bHQgaGVhZGVyXG4iLCJpbXBvcnQgZmFkZSBmcm9tICdyYWN0aXZlLXRyYW5zaXRpb25zLWZhZGUnXG5pbXBvcnQgUmFjdGl2ZSBmcm9tICdyYWN0aXZlJ1xuLy9pbXBvcnQgUiBmcm9tICdyYW1kYSdcbmltcG9ydCB0ZW1wbGF0ZSBmcm9tICcuLi8uLi9wYXJ0aWFscy9uZXdzbGV0dGVyLWZvcm0vaW5kZXguaHRtbCdcblxuXG5jb25zdCBmb3JtID0gUmFjdGl2ZS5leHRlbmQoe1xuICB0ZW1wbGF0ZSxcbiAgb25pbml0OiBmdW5jdGlvbigpe1xuICAgIHRoaXMub24oJ3ZhbGlkYXRlRm9ybScsIGZ1bmN0aW9uKCkge1xuICAgICAgd2luZG93LmFsZXJ0KCd0byBwdXJlc2NyaXB0IChpbiBkdWUgY291cnNlKScpXG4gICAgfSlcbiAgfSxcbn0pXG5cbmZvcm0udHJhbnNpdGlvbnMuZmFkZSA9IGZhZGVcblxuZXhwb3J0IGRlZmF1bHQgZm9ybVxuXG4iLCJpbXBvcnQgJ2JhYmVsLXBvbHlmaWxsJ1xuaW1wb3J0IGNyZWF0ZUFwcCBmcm9tICcuL2FwcCdcblxuXG53aW5kb3cub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgY3JlYXRlQXBwKHtcbiAgICBlbDogJyNhcHAnLFxuICAgIGxhbmd1YWdlOiAnZW4nLFxuICB9KVxufVxuXG4iLCJtb2R1bGUuZXhwb3J0cz17XCJlblwiOntcIm5hdmJhclwiOntcIm5ld3NsZXR0ZXJCdXR0b25cIjpcIlN1YnNjcmliZSB0byBvdXIgbmV3c2xldHRlciFcIn0sXCJoZWFkZXJcIjp7XCJ0ZXh0XCI6XCJUaGlzIGlzIGEgaGVhZGVyIVwifSxcIm5ld3NsZXR0ZXJGb3JtXCI6e1wiaGVhZGVyXCI6XCJTdWJzY3JpYmUgdG8gb3VyIG5ld3NsZXR0ZXIhXCIsXCJib2R5XCI6XCJTdGF5IGluZm9ybWVkIGFib3V0IG91ciBjYW1wYWlucyBhbmQgZG9uJ3QgbWlzcyBvdXQgb24gYW55IHByb21vdGlvbiEgQWZ0ZXIgc3VibWl0dGluZyB0aGlzIGZvcm0geW91IHdpbGwgcmVjZWl2ZSBhIGNvbmZpcm1hdGlvbiBlbWFpbC5cIixcInRpdGxlRW1haWxcIjpcIkUtbWFpbCBBZGRyZXNzXCIsXCJ0aXRsZUZpcnN0TmFtZVwiOlwiRmlyc3QgbmFtZVwiLFwidGl0bGVMYXN0TmFtZVwiOlwiTGFzdCBuYW1lXCIsXCJ0aXRsZUxhbmd1YWdlXCI6XCJMYW5ndWFnZVwiLFwibGFuZ3VhZ2VzXCI6e1wiZW5cIjpcIkVuZ2xpc2ggKEVuZ2xpc2gpXCIsXCJkZVwiOlwiR2VybWFuIChEZXV0c2NoKVwiLFwibmxcIjpcIkR1dGNoIChOZWRlcmxhbmRzKVwiLFwiZXNcIjpcIlNwYW5pc2ggKEVzcGHDsW9sKVwiLFwiZnJcIjpcIkZyZW5jaCAoRnJhbsOnYWlzKVwifSxcInRpdGxlQ291bnRyeVwiOlwiQ291bnRyeVwiLFwidGl0bGVHZW5kZXJcIjpcIkdlbmRlclwiLFwiZ2VuZGVyXCI6e1wibVwiOlwiTWFsZVwiLFwiZlwiOlwiRmVtYWxlXCJ9LFwiYnV0dG9uU3VibWl0XCI6XCJTdWJtaXRcIn19LFwibmxcIjp7XCJuYXZiYXJcIjp7XCJuZXdzbGV0dGVyQnV0dG9uXCI6XCJBYm9ubmVlcnQgdSBhbGxlbiBvcCBvbnplIG5pZXV3c2JyaWVmIVwifSxcImhlYWRlclwiOntcInRleHRcIjpcIkRpdCBpcyBlZW4gaGVhZGVyIVwifSxcIm5ld3NsZXR0ZXJGb3JtXCI6e1wiaGVhZGVyXCI6XCJNZWxkdCB1IGFhbiB2b29yIG9uemUgbmlldXdzYnJpZWYhXCIsXCJib2R5XCI6XCJCbGlqZiBvcCBkZSBob29ndGUgdmFuIG9uemUgY2FtcGFnbmVzIGVuIG1pcyBub29pdCBtZWVyIGVlbiBha3RpZSEgTmEgZGUgYWFubWVsZGluZyBrcmlqZ3QgdSBlZW4gYmV2ZXN0aWdpbmdzIGVtYWlsLlwiLFwidGl0bGVFbWFpbFwiOlwiRS1tYWlsIGFkcmVzXCIsXCJ0aXRsZUZpcnN0TmFtZVwiOlwiVm9vcm5hYW1cIixcInRpdGxlTGFzdE5hbWVcIjpcIkFjaHRlcm5hYW1cIixcInRpdGxlTGFuZ3VhZ2VcIjpcIlRhYWxcIixcImxhbmd1YWdlc1wiOntcIm5sXCI6XCJOZWRlcmxhbmRzIChOZWRlcmxhbmRzKVwiLFwiZGVcIjpcIkR1aXRzIChEZXV0c2NoKVwiLFwiZW5cIjpcIkVuZ2VscyAoRW5nbGlzaClcIixcImVzXCI6XCJTcGFhbnMgKEVzcGHDsW9sKVwiLFwiZnJcIjpcIkZyYW5zIChGcmFuw6dhaXMpXCJ9LFwidGl0bGVDb3VudHJ5XCI6XCJMYW5kXCIsXCJ0aXRsZUdlbmRlclwiOlwiR2VzY2hsYWNodFwiLFwiZ2VuZGVyXCI6e1wibVwiOlwiTWFuXCIsXCJmXCI6XCJWcm91d1wifSxcImJ1dHRvblN1Ym1pdFwiOlwiVmVyc3R1dXJcIn19LFwiZGVcIjp7XCJuYXZiYXJcIjp7XCJuZXdzbGV0dGVyQnV0dG9uXCI6XCJBYm9ubmllcmVuIFNpZSBzaWNoIGF1ZiB1bnNlcmUgTmV3c2xldHRlciFcIn0sXCJoZWFkZXJcIjp7XCJ0ZXh0XCI6XCJEaWVzIGlzdCBlaW4gS8O2cGZlciFcIn0sXCJuZXdzbGV0dGVyRm9ybVwiOntcImhlYWRlclwiOlwiTWVsZGVuIFNpZSBzaWNoIGbDvHIgdW5zZXJlbiBOZXdzbGV0dGVyIGFuIVwiLFwiYm9keVwiOlwiQmxlaWJlbiBTaWUgYXVmIGRlbSBMYXVmZW5kZW4gbWl0IHVuc2VyZW4gS2FtcGFnbmVuIHVuZCB2ZXJwYXNzZW4gU2llIGtlaW5lIHVuc2VyZXIgQWt0aW9uZW4gbWVociEgTmFjaCBkZXIgQW5tZWxkdW5nIGVyaGFsdGVuIFNpZSBlaW5lIEJlc3TDpHRpZ3VuZyBwZXIgRS1NYWlsLlwiLFwidGl0bGVFbWFpbFwiOlwiRS1tYWlsIEFkcmVzc2VcIixcInRpdGxlRmlyc3ROYW1lXCI6XCJWb3JuYW1lXCIsXCJ0aXRsZUxhc3ROYW1lXCI6XCJOYWNobmFtZVwiLFwidGl0bGVMYW5ndWFnZVwiOlwiU3ByYWNoZVwiLFwibGFuZ3VhZ2VzXCI6e1wiZGVcIjpcIkRldXRzY2ggKERldXRzY2gpXCIsXCJlblwiOlwiRW5nbGlzY2ggKEVuZ2xpc2gpXCIsXCJubFwiOlwiSG9sbMOkbmRpc2NoIChOZWRlcmxhbmRzKVwiLFwiZXNcIjpcIlNwYW5pc2NoIChFc3Bhw7FvbClcIixcImZyXCI6XCJGcmFuesO2c2lzY2ggKEZyYW7Dp2FpcylcIn0sXCJ0aXRsZUNvdW50cnlcIjpcIkxhbmRcIixcInRpdGxlR2VuZGVyXCI6XCJHZXNjaGxlY2h0XCIsXCJnZW5kZXJcIjp7XCJtXCI6XCJNw6RubmxpY2hcIixcImZcIjpcIldlaWJsaWNoXCJ9LFwiYnV0dG9uU3VibWl0XCI6XCJBYnNlbmRlblwifX19IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL3NoaW1cIik7XG5cbnJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWVcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL2ZuL3JlZ2V4cC9lc2NhcGVcIik7XG5cbmlmIChnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwib25seSBvbmUgaW5zdGFuY2Ugb2YgYmFiZWwtcG9seWZpbGwgaXMgYWxsb3dlZFwiKTtcbn1cbmdsb2JhbC5fYmFiZWxQb2x5ZmlsbCA9IHRydWU7XG5cbnZhciBERUZJTkVfUFJPUEVSVFkgPSBcImRlZmluZVByb3BlcnR5XCI7XG5mdW5jdGlvbiBkZWZpbmUoTywga2V5LCB2YWx1ZSkge1xuICBPW2tleV0gfHwgT2JqZWN0W0RFRklORV9QUk9QRVJUWV0oTywga2V5LCB7XG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cblxuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkTGVmdFwiLCBcIlwiLnBhZFN0YXJ0KTtcbmRlZmluZShTdHJpbmcucHJvdG90eXBlLCBcInBhZFJpZ2h0XCIsIFwiXCIucGFkRW5kKTtcblxuXCJwb3AscmV2ZXJzZSxzaGlmdCxrZXlzLHZhbHVlcyxlbnRyaWVzLGluZGV4T2YsZXZlcnksc29tZSxmb3JFYWNoLG1hcCxmaWx0ZXIsZmluZCxmaW5kSW5kZXgsaW5jbHVkZXMsam9pbixzbGljZSxjb25jYXQscHVzaCxzcGxpY2UsdW5zaGlmdCxzb3J0LGxhc3RJbmRleE9mLHJlZHVjZSxyZWR1Y2VSaWdodCxjb3B5V2l0aGluLGZpbGxcIi5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFtdW2tleV0gJiYgZGVmaW5lKEFycmF5LCBrZXksIEZ1bmN0aW9uLmNhbGwuYmluZChbXVtrZXldKSk7XG59KTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuUmVnRXhwLmVzY2FwZTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBtc2cpe1xuICBpZih0eXBlb2YgaXQgIT0gJ251bWJlcicgJiYgY29mKGl0KSAhPSAnTnVtYmVyJyl0aHJvdyBUeXBlRXJyb3IobXNnKTtcbiAgcmV0dXJuICtpdDtcbn07IiwiLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3Vuc2NvcGFibGVzJylcbiAgLCBBcnJheVByb3RvICA9IEFycmF5LnByb3RvdHlwZTtcbmlmKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZClyZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCl7XG4gIGlmKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKXtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvSW5kZXggID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gW10uY29weVdpdGhpbiB8fCBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldC8qPSAwKi8sIHN0YXJ0Lyo9IDAsIGVuZCA9IEBsZW5ndGgqLyl7XG4gIHZhciBPICAgICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgLCBsZW4gICA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICwgdG8gICAgPSB0b0luZGV4KHRhcmdldCwgbGVuKVxuICAgICwgZnJvbSAgPSB0b0luZGV4KHN0YXJ0LCBsZW4pXG4gICAgLCBlbmQgICA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkXG4gICAgLCBjb3VudCA9IE1hdGgubWluKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvSW5kZXgoZW5kLCBsZW4pKSAtIGZyb20sIGxlbiAtIHRvKVxuICAgICwgaW5jICAgPSAxO1xuICBpZihmcm9tIDwgdG8gJiYgdG8gPCBmcm9tICsgY291bnQpe1xuICAgIGluYyAgPSAtMTtcbiAgICBmcm9tICs9IGNvdW50IC0gMTtcbiAgICB0byAgICs9IGNvdW50IC0gMTtcbiAgfVxuICB3aGlsZShjb3VudC0tID4gMCl7XG4gICAgaWYoZnJvbSBpbiBPKU9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byAgICs9IGluYztcbiAgICBmcm9tICs9IGluYztcbiAgfSByZXR1cm4gTztcbn07IiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvSW5kZXggID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyosIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLyl7XG4gIHZhciBPICAgICAgPSB0b09iamVjdCh0aGlzKVxuICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCBhTGVuICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSB0b0luZGV4KGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpXG4gICAgLCBlbmQgICAgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZFxuICAgICwgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0luZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUoZW5kUG9zID4gaW5kZXgpT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07IiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlciwgSVRFUkFUT1Ipe1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHRvSW5kZXggICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcbiAgICAgICwgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I3RvSW5kZXggaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59OyIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGFzYyAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVFlQRSwgJGNyZWF0ZSl7XG4gIHZhciBJU19NQVAgICAgICAgID0gVFlQRSA9PSAxXG4gICAgLCBJU19GSUxURVIgICAgID0gVFlQRSA9PSAyXG4gICAgLCBJU19TT01FICAgICAgID0gVFlQRSA9PSAzXG4gICAgLCBJU19FVkVSWSAgICAgID0gVFlQRSA9PSA0XG4gICAgLCBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2XG4gICAgLCBOT19IT0xFUyAgICAgID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVhcbiAgICAsIGNyZWF0ZSAgICAgICAgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KXtcbiAgICB2YXIgTyAgICAgID0gdG9PYmplY3QoJHRoaXMpXG4gICAgICAsIHNlbGYgICA9IElPYmplY3QoTylcbiAgICAgICwgZiAgICAgID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAwXG4gICAgICAsIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWRcbiAgICAgICwgdmFsLCByZXM7XG4gICAgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKXtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmKFRZUEUpe1xuICAgICAgICBpZihJU19NQVApcmVzdWx0W2luZGV4XSA9IHJlczsgICAgICAgICAgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZihyZXMpc3dpdGNoKFRZUEUpe1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYoSVNfRVZFUlkpcmV0dXJuIGZhbHNlOyAgICAgICAgICAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTsiLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgdG9PYmplY3QgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCBjYWxsYmFja2ZuLCBhTGVuLCBtZW1vLCBpc1JpZ2h0KXtcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICB2YXIgTyAgICAgID0gdG9PYmplY3QodGhhdClcbiAgICAsIHNlbGYgICA9IElPYmplY3QoTylcbiAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICwgaW5kZXggID0gaXNSaWdodCA/IGxlbmd0aCAtIDEgOiAwXG4gICAgLCBpICAgICAgPSBpc1JpZ2h0ID8gLTEgOiAxO1xuICBpZihhTGVuIDwgMilmb3IoOzspe1xuICAgIGlmKGluZGV4IGluIHNlbGYpe1xuICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCArPSBpO1xuICAgIGlmKGlzUmlnaHQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpe1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuICB9XG4gIGZvcig7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSlpZihpbmRleCBpbiBzZWxmKXtcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICB9XG4gIHJldHVybiBtZW1vO1xufTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGlzQXJyYXkgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIFNQRUNJRVMgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCl7XG4gIHZhciBDO1xuICBpZihpc0FycmF5KG9yaWdpbmFsKSl7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKUMgPSB1bmRlZmluZWQ7XG4gICAgaWYoaXNPYmplY3QoQykpe1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZihDID09PSBudWxsKUMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59OyIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWwsIGxlbmd0aCl7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBhRnVuY3Rpb24gID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgaXNPYmplY3QgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaW52b2tlICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgYXJyYXlTbGljZSA9IFtdLnNsaWNlXG4gICwgZmFjdG9yaWVzICA9IHt9O1xuXG52YXIgY29uc3RydWN0ID0gZnVuY3Rpb24oRiwgbGVuLCBhcmdzKXtcbiAgaWYoIShsZW4gaW4gZmFjdG9yaWVzKSl7XG4gICAgZm9yKHZhciBuID0gW10sIGkgPSAwOyBpIDwgbGVuOyBpKyspbltpXSA9ICdhWycgKyBpICsgJ10nO1xuICAgIGZhY3Rvcmllc1tsZW5dID0gRnVuY3Rpb24oJ0YsYScsICdyZXR1cm4gbmV3IEYoJyArIG4uam9pbignLCcpICsgJyknKTtcbiAgfSByZXR1cm4gZmFjdG9yaWVzW2xlbl0oRiwgYXJncyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmJpbmQgfHwgZnVuY3Rpb24gYmluZCh0aGF0IC8qLCBhcmdzLi4uICovKXtcbiAgdmFyIGZuICAgICAgID0gYUZ1bmN0aW9uKHRoaXMpXG4gICAgLCBwYXJ0QXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgYm91bmQgPSBmdW5jdGlvbigvKiBhcmdzLi4uICovKXtcbiAgICB2YXIgYXJncyA9IHBhcnRBcmdzLmNvbmNhdChhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZCA/IGNvbnN0cnVjdChmbiwgYXJncy5sZW5ndGgsIGFyZ3MpIDogaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbiAgaWYoaXNPYmplY3QoZm4ucHJvdG90eXBlKSlib3VuZC5wcm90b3R5cGUgPSBmbi5wcm90b3R5cGU7XG4gIHJldHVybiBib3VuZDtcbn07IiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXG4gIC8vIEVTMyB3cm9uZyBoZXJlXG4gICwgQVJHID0gY29mKGZ1bmN0aW9uKCl7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTsiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBjcmVhdGUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgYW5JbnN0YW5jZSAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgZGVmaW5lZCAgICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBmb3JPZiAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpXG4gICwgc3RlcCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIHNldFNwZWNpZXMgID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKVxuICAsIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIGZhc3RLZXkgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLmZhc3RLZXlcbiAgLCBTSVpFICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJztcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24odGhhdCwga2V5KXtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KSwgZW50cnk7XG4gIGlmKGluZGV4ICE9PSAnRicpcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgaWYoZW50cnkuayA9PSBrZXkpcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5faSA9IGNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAvLyBzaXplXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCl7XG4gICAgICAgIGZvcih2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKGVudHJ5LnApZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAgICwgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZihlbnRyeSl7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uXG4gICAgICAgICAgICAsIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKHByZXYpcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZihuZXh0KW5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYodGhhdC5fZiA9PSBlbnRyeSl0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZih0aGF0Ll9sID09IGVudHJ5KXRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGlzLCBDLCAnZm9yRWFjaCcpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMylcbiAgICAgICAgICAsIGVudHJ5O1xuICAgICAgICB3aGlsZShlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2Ype1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYoREVTQ1JJUFRPUlMpZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gZGVmaW5lZCh0aGlzW1NJWkVdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbih0aGF0LCBrZXksIHZhbHVlKXtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpXG4gICAgICAsIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmKGVudHJ5KXtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmKCF0aGF0Ll9mKXRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmKHByZXYpcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmKGluZGV4ICE9PSAnRicpdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24oQywgTkFNRSwgSVNfTUFQKXtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgJGl0ZXJEZWZpbmUoQywgTkFNRSwgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICAgICAgdGhpcy5fdCA9IGl0ZXJhdGVkOyAgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICwga2luZCAgPSB0aGF0Ll9rXG4gICAgICAgICwgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZighdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKXtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycgLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIGZyb20gICAgPSByZXF1aXJlKCcuL19hcnJheS1mcm9tLWl0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUpe1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCl7XG4gICAgaWYoY2xhc3NvZih0aGlzKSAhPSBOQU1FKXRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciByZWRlZmluZUFsbCAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgZ2V0V2VhayAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuZ2V0V2Vha1xuICAsIGFuT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBpc09iamVjdCAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgZm9yT2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpXG4gICwgJGhhcyAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIGFycmF5RmluZCAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNSlcbiAgLCBhcnJheUZpbmRJbmRleCAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpXG4gICwgaWQgICAgICAgICAgICAgICAgPSAwO1xuXG4vLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24odGhhdCl7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUpO1xufTtcbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hID0gW107XG59O1xudmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uKHN0b3JlLCBrZXkpe1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24oa2V5KXtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZihlbnRyeSlyZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZihlbnRyeSllbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgdmFyIGluZGV4ID0gYXJyYXlGaW5kSW5kZXgodGhpcy5hLCBmdW5jdGlvbihpdCl7XG4gICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICB9KTtcbiAgICBpZih+aW5kZXgpdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5faSA9IGlkKys7ICAgICAgLy8gY29sbGVjdGlvbiBpZFxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgaWYoIWlzT2JqZWN0KGtleSkpcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYoZGF0YSA9PT0gdHJ1ZSlyZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGlzKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgaWYoIWlzT2JqZWN0KGtleSkpcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYoZGF0YSA9PT0gdHJ1ZSlyZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGlzKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbih0aGF0LCBrZXksIHZhbHVlKXtcbiAgICB2YXIgZGF0YSA9IGdldFdlYWsoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG4gICAgaWYoZGF0YSA9PT0gdHJ1ZSl1bmNhdWdodEZyb3plblN0b3JlKHRoYXQpLnNldChrZXksIHZhbHVlKTtcbiAgICBlbHNlIGRhdGFbdGhhdC5faV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhhdDtcbiAgfSxcbiAgdWZzdG9yZTogdW5jYXVnaHRGcm96ZW5TdG9yZVxufTsiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsICRleHBvcnQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCByZWRlZmluZUFsbCAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgbWV0YSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJylcbiAgLCBmb3JPZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgaXNPYmplY3QgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGZhaWxzICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsICRpdGVyRGV0ZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKVxuICAsIHNldFRvU3RyaW5nVGFnICAgID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKXtcbiAgdmFyIEJhc2UgID0gZ2xvYmFsW05BTUVdXG4gICAgLCBDICAgICA9IEJhc2VcbiAgICAsIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJ1xuICAgICwgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlXG4gICAgLCBPICAgICA9IHt9O1xuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24oS0VZKXtcbiAgICB2YXIgZm4gPSBwcm90b1tLRVldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBLRVksXG4gICAgICBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbihhKXtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGEpe1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoYSl7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSl7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgOiBmdW5jdGlvbiBzZXQoYSwgYil7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhLCBiKTsgcmV0dXJuIHRoaXM7IH1cbiAgICApO1xuICB9O1xuICBpZih0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKXtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlICAgICAgICAgICAgID0gbmV3IENcbiAgICAgIC8vIGVhcmx5IGltcGxlbWVudGF0aW9ucyBub3Qgc3VwcG9ydHMgY2hhaW5pbmdcbiAgICAgICwgSEFTTlRfQ0hBSU5JTkcgICAgICAgPSBpbnN0YW5jZVtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpICE9IGluc3RhbmNlXG4gICAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICAgICwgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbigpeyBpbnN0YW5jZS5oYXMoMSk7IH0pXG4gICAgICAvLyBtb3N0IGVhcmx5IGltcGxlbWVudGF0aW9ucyBkb2Vzbid0IHN1cHBvcnRzIGl0ZXJhYmxlcywgbW9zdCBtb2Rlcm4gLSBub3QgY2xvc2UgaXQgY29ycmVjdGx5XG4gICAgICAsIEFDQ0VQVF9JVEVSQUJMRVMgICAgID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24oaXRlcil7IG5ldyBDKGl0ZXIpOyB9KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgLy8gZm9yIGVhcmx5IGltcGxlbWVudGF0aW9ucyAtMCBhbmQgKzAgbm90IHRoZSBzYW1lXG4gICAgICAsIEJVR0dZX1pFUk8gPSAhSVNfV0VBSyAmJiBmYWlscyhmdW5jdGlvbigpe1xuICAgICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcbiAgICAgICAgdmFyICRpbnN0YW5jZSA9IG5ldyBDKClcbiAgICAgICAgICAsIGluZGV4ICAgICA9IDU7XG4gICAgICAgIHdoaWxlKGluZGV4LS0pJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gISRpbnN0YW5jZS5oYXMoLTApO1xuICAgICAgfSk7XG4gICAgaWYoIUFDQ0VQVF9JVEVSQUJMRVMpeyBcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgaXRlcmFibGUpe1xuICAgICAgICBhbkluc3RhbmNlKHRhcmdldCwgQywgTkFNRSk7XG4gICAgICAgIHZhciB0aGF0ID0gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UsIHRhcmdldCwgQyk7XG4gICAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBpZihUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKXtcbiAgICAgIGZpeE1ldGhvZCgnZGVsZXRlJyk7XG4gICAgICBmaXhNZXRob2QoJ2hhcycpO1xuICAgICAgSVNfTUFQICYmIGZpeE1ldGhvZCgnZ2V0Jyk7XG4gICAgfVxuICAgIGlmKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpZml4TWV0aG9kKEFEREVSKTtcbiAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIHNob3VsZCBub3QgY29udGFpbnMgLmNsZWFyIG1ldGhvZFxuICAgIGlmKElTX1dFQUsgJiYgcHJvdG8uY2xlYXIpZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuXG4gIGlmKCFJU19XRUFLKWNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07IiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGluZGV4LCB2YWx1ZSl7XG4gIGlmKGluZGV4IGluIG9iamVjdCkkZGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGluZGV4LCBjcmVhdGVEZXNjKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xufTsiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIE5VTUJFUiAgICAgID0gJ251bWJlcic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGludCl7XG4gIGlmKGhpbnQgIT09ICdzdHJpbmcnICYmIGhpbnQgIT09IE5VTUJFUiAmJiBoaW50ICE9PSAnZGVmYXVsdCcpdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgaGludCcpO1xuICByZXR1cm4gdG9QcmltaXRpdmUoYW5PYmplY3QodGhpcyksIGhpbnQgIT0gTlVNQkVSKTtcbn07IiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTsiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTsiLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciByZXN1bHQgICAgID0gZ2V0S2V5cyhpdClcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmKGdldFN5bWJvbHMpe1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcbiAgICAgICwgaXNFbnVtICA9IHBJRS5mXG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZSAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSlcbiAgICAsIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZih0YXJnZXQpcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYoZXhwb3J0c1trZXldICE9IG91dCloaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZihJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dClleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDsiLCJ2YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIHJlID0gLy4vO1xuICB0cnkge1xuICAgICcvLi8nW0tFWV0ocmUpO1xuICB9IGNhdGNoKGUpe1xuICAgIHRyeSB7XG4gICAgICByZVtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAhJy8uLydbS0VZXShyZSk7XG4gICAgfSBjYXRjaChmKXsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiB0cnVlO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG52YXIgaGlkZSAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBmYWlscyAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBkZWZpbmVkICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIHdrcyAgICAgID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBsZW5ndGgsIGV4ZWMpe1xuICB2YXIgU1lNQk9MICAgPSB3a3MoS0VZKVxuICAgICwgZm5zICAgICAgPSBleGVjKGRlZmluZWQsIFNZTUJPTCwgJydbS0VZXSlcbiAgICAsIHN0cmZuICAgID0gZm5zWzBdXG4gICAgLCByeGZuICAgICA9IGZuc1sxXTtcbiAgaWYoZmFpbHMoZnVuY3Rpb24oKXtcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pKXtcbiAgICByZWRlZmluZShTdHJpbmcucHJvdG90eXBlLCBLRVksIHN0cmZuKTtcbiAgICBoaWRlKFJlZ0V4cC5wcm90b3R5cGUsIFNZTUJPTCwgbGVuZ3RoID09IDJcbiAgICAgIC8vIDIxLjIuNS44IFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXShzdHJpbmcsIHJlcGxhY2VWYWx1ZSlcbiAgICAgIC8vIDIxLjIuNS4xMSBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdKHN0cmluZywgbGltaXQpXG4gICAgICA/IGZ1bmN0aW9uKHN0cmluZywgYXJnKXsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbihzdHJpbmcpeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIHRoYXQgICA9IGFuT2JqZWN0KHRoaXMpXG4gICAgLCByZXN1bHQgPSAnJztcbiAgaWYodGhhdC5nbG9iYWwpICAgICByZXN1bHQgKz0gJ2cnO1xuICBpZih0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmKHRoYXQubXVsdGlsaW5lKSAgcmVzdWx0ICs9ICdtJztcbiAgaWYodGhhdC51bmljb2RlKSAgICByZXN1bHQgKz0gJ3UnO1xuICBpZih0aGF0LnN0aWNreSkgICAgIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59OyIsInZhciBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBnZXRJdGVyRm4gICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJylcbiAgLCBCUkVBSyAgICAgICA9IHt9XG4gICwgUkVUVVJOICAgICAgPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKXtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKVxuICAgICwgZiAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmKGlzQXJyYXlJdGVyKGl0ZXJGbikpZm9yKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7ICl7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyAgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTsiLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7IiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTsiLCJ2YXIgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCB0YXJnZXQsIEMpe1xuICB2YXIgUCwgUyA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgaWYoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZil7XG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XG4gIH0gcmV0dXJuIHRoYXQ7XG59OyIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTsiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTsiLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgSVRFUkFUT1IgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59OyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07IiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGZsb29yICAgID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KXtcbiAgcmV0dXJuICFpc09iamVjdChpdCkgJiYgaXNGaW5pdGUoaXQpICYmIGZsb29yKGl0KSA9PT0gaXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTsiLCIvLyA3LjIuOCBJc1JlZ0V4cChhcmd1bWVudClcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgY29mICAgICAgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIE1BVENIICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59OyIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGRlc2NyaXB0b3IgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJdGVyYXRvcnMgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgJGl0ZXJDcmVhdGUgICAgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBJVEVSQVRPUiAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICAsIEZGX0lURVJBVE9SICAgID0gJ0BAaXRlcmF0b3InXG4gICwgS0VZUyAgICAgICAgICAgPSAna2V5cydcbiAgLCBWQUxVRVMgICAgICAgICA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCl7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuICAgIGlmKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKXJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyAgICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFU1xuICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXG4gICAgLCBwcm90byAgICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsICRuYXRpdmUgICAgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cbiAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxuICAgICwgJGVudHJpZXMgICA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWRcbiAgICAsICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlXG4gICAgLCBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKCRhbnlOYXRpdmUpe1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKSk7XG4gICAgaWYoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpe1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKXtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiAgICBJU19TRVQgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTsiLCJ2YXIgSVRFUkFUT1IgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbigpeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbigpeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjLCBza2lwQ2xvc2luZyl7XG4gIGlmKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKXJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyICA9IFs3XVxuICAgICAgLCBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKCl7IHJldHVybiB7ZG9uZTogc2FmZSA9IHRydWV9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbigpeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7fTsiLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTsiLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBtMSA9IE1hdGguZXhwbTE7XG5tb2R1bGUuZXhwb3J0cyA9ICghJGV4cG0xXG4gIC8vIE9sZCBGRiBidWdcbiAgfHwgJGV4cG0xKDEwKSA+IDIyMDI1LjQ2NTc5NDgwNjcxOSB8fCAkZXhwbTEoMTApIDwgMjIwMjUuNDY1Nzk0ODA2NzE2NTE2OFxuICAvLyBUb3IgQnJvd3NlciBidWdcbiAgfHwgJGV4cG0xKC0yZS0xNykgIT0gLTJlLTE3XG4pID8gZnVuY3Rpb24gZXhwbTEoeCl7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBNYXRoLmV4cCh4KSAtIDE7XG59IDogJGV4cG0xOyIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubG9nMXAgfHwgZnVuY3Rpb24gbG9nMXAoeCl7XG4gIHJldHVybiAoeCA9ICt4KSA+IC0xZS04ICYmIHggPCAxZS04ID8geCAtIHggKiB4IC8gMiA6IE1hdGgubG9nKDEgKyB4KTtcbn07IiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KXtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTsiLCJ2YXIgTUVUQSAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGhhcyAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBzZXREZXNjICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBpZCAgICAgICA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG4gIHNldERlc2MoaXQsIE1FVEEsIHt2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH19KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24oaXQpe1xuICBpZihGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6ICAgICAgTUVUQSxcbiAgTkVFRDogICAgIGZhbHNlLFxuICBmYXN0S2V5OiAgZmFzdEtleSxcbiAgZ2V0V2VhazogIGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTsiLCJ2YXIgTWFwICAgICA9IHJlcXVpcmUoJy4vZXM2Lm1hcCcpXG4gICwgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2hhcmVkICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdtZXRhZGF0YScpXG4gICwgc3RvcmUgICA9IHNoYXJlZC5zdG9yZSB8fCAoc2hhcmVkLnN0b3JlID0gbmV3IChyZXF1aXJlKCcuL2VzNi53ZWFrLW1hcCcpKSk7XG5cbnZhciBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRLZXksIGNyZWF0ZSl7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICBpZighdGFyZ2V0TWV0YWRhdGEpe1xuICAgIGlmKCFjcmVhdGUpcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBzdG9yZS5zZXQodGFyZ2V0LCB0YXJnZXRNZXRhZGF0YSA9IG5ldyBNYXApO1xuICB9XG4gIHZhciBrZXlNZXRhZGF0YSA9IHRhcmdldE1ldGFkYXRhLmdldCh0YXJnZXRLZXkpO1xuICBpZigha2V5TWV0YWRhdGEpe1xuICAgIGlmKCFjcmVhdGUpcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB0YXJnZXRNZXRhZGF0YS5zZXQodGFyZ2V0S2V5LCBrZXlNZXRhZGF0YSA9IG5ldyBNYXApO1xuICB9IHJldHVybiBrZXlNZXRhZGF0YTtcbn07XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBtZXRhZGF0YU1hcC5oYXMoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtZXRhZGF0YU1hcC5nZXQoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApe1xuICBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIHRydWUpLnNldChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSk7XG59O1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRLZXkpe1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKHRhcmdldCwgdGFyZ2V0S2V5LCBmYWxzZSlcbiAgICAsIGtleXMgICAgICAgID0gW107XG4gIGlmKG1ldGFkYXRhTWFwKW1ldGFkYXRhTWFwLmZvckVhY2goZnVuY3Rpb24oXywga2V5KXsga2V5cy5wdXNoKGtleSk7IH0pO1xuICByZXR1cm4ga2V5cztcbn07XG52YXIgdG9NZXRhS2V5ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6IFN0cmluZyhpdCk7XG59O1xudmFyIGV4cCA9IGZ1bmN0aW9uKE8pe1xuICAkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCBPKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdG9yZTogc3RvcmUsXG4gIG1hcDogZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCxcbiAgaGFzOiBvcmRpbmFyeUhhc093bk1ldGFkYXRhLFxuICBnZXQ6IG9yZGluYXJ5R2V0T3duTWV0YWRhdGEsXG4gIHNldDogb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSxcbiAga2V5czogb3JkaW5hcnlPd25NZXRhZGF0YUtleXMsXG4gIGtleTogdG9NZXRhS2V5LFxuICBleHA6IGV4cFxufTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0XG4gICwgT2JzZXJ2ZXIgID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXJcbiAgLCBwcm9jZXNzICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIFByb21pc2UgICA9IGdsb2JhbC5Qcm9taXNlXG4gICwgaXNOb2RlICAgID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZihpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSlwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlKGhlYWQpe1xuICAgICAgZm4gICA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIGlmKGhlYWQpbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYocGFyZW50KXBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYoaXNOb2RlKXtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gIH0gZWxzZSBpZihPYnNlcnZlcil7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWVcbiAgICAgICwgbm9kZSAgID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZihQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSl7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oZm4pe1xuICAgIHZhciB0YXNrID0ge2ZuOiBmbiwgbmV4dDogdW5kZWZpbmVkfTtcbiAgICBpZihsYXN0KWxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYoIWhlYWQpe1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTsiLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCAkYXNzaWduICA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBBID0ge31cbiAgICAsIEIgPSB7fVxuICAgICwgUyA9IFN5bWJvbCgpXG4gICAgLCBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oayl7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgICAgID0gdG9PYmplY3QodGFyZ2V0KVxuICAgICwgYUxlbiAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpbmRleCA9IDFcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmZcbiAgICAsIGlzRW51bSAgICAgPSBwSUUuZjtcbiAgd2hpbGUoYUxlbiA+IGluZGV4KXtcbiAgICB2YXIgUyAgICAgID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pXG4gICAgICAsIGtleXMgICA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaiAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gailpZihpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKVRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduOyIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBkUHMgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpXG4gICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcbiAgICAsIGx0ICAgICA9ICc8J1xuICAgICwgZ3QgICAgID0gJz4nXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xuICB2YXIgcmVzdWx0O1xuICBpZihPICE9PSBudWxsKXtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07IiwidmFyIGRQICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGkgPSAwXG4gICAgLCBQO1xuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTsiLCIvLyBGb3JjZWQgcmVwbGFjZW1lbnQgcHJvdG90eXBlIGFjY2Vzc29ycyBtZXRob2RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKXx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBLID0gTWF0aC5yYW5kb20oKTtcbiAgLy8gSW4gRkYgdGhyb3dzIG9ubHkgZGVmaW5lIG1ldGhvZHNcbiAgX19kZWZpbmVTZXR0ZXJfXy5jYWxsKG51bGwsIEssIGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovfSk7XG4gIGRlbGV0ZSByZXF1aXJlKCcuL19nbG9iYWwnKVtLXTtcbn0pOyIsInZhciBwSUUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTsiLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgZ09QTiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXG4gICwgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKXtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTsiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzOyIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oTyl7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYoaGFzKE8sIElFX1BST1RPKSlyZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3Ipe1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07IiwidmFyIGhhcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCBJRV9QUk9UTyAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59OyIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59OyIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlOyIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvcmUgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcbiAgdmFyIGZuICA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuICAgICwgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07IiwidmFyIGdldEtleXMgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBpc0VudW0gICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNFbnRyaWVzKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKGl0KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KGl0KVxuICAgICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGkgICAgICA9IDBcbiAgICAgICwgcmVzdWx0ID0gW11cbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoTywga2V5ID0ga2V5c1tpKytdKSl7XG4gICAgICByZXN1bHQucHVzaChpc0VudHJpZXMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH07XG59OyIsIi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBnT1BOICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgUmVmbGVjdCAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0ICYmIFJlZmxlY3Qub3duS2V5cyB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KXtcbiAgdmFyIGtleXMgICAgICAgPSBnT1BOLmYoYW5PYmplY3QoaXQpKVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTsiLCJ2YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUZsb2F0XG4gICwgJHRyaW0gICAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG5cbm1vZHVsZS5leHBvcnRzID0gMSAvICRwYXJzZUZsb2F0KHJlcXVpcmUoJy4vX3N0cmluZy13cycpICsgJy0wJykgIT09IC1JbmZpbml0eSA/IGZ1bmN0aW9uIHBhcnNlRmxvYXQoc3RyKXtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKVxuICAgICwgcmVzdWx0ID0gJHBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiBzdHJpbmcuY2hhckF0KDApID09ICctJyA/IC0wIDogcmVzdWx0O1xufSA6ICRwYXJzZUZsb2F0OyIsInZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUludFxuICAsICR0cmltICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbVxuICAsIHdzICAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpXG4gICwgaGV4ICAgICAgID0gL15bXFwtK10/MFt4WF0vO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRwYXJzZUludCh3cyArICcwOCcpICE9PSA4IHx8ICRwYXJzZUludCh3cyArICcweDE2JykgIT09IDIyID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyLCByYWRpeCl7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHJldHVybiAkcGFyc2VJbnQoc3RyaW5nLCAocmFkaXggPj4+IDApIHx8IChoZXgudGVzdChzdHJpbmcpID8gMTYgOiAxMCkpO1xufSA6ICRwYXJzZUludDsiLCIndXNlIHN0cmljdCc7XG52YXIgcGF0aCAgICAgID0gcmVxdWlyZSgnLi9fcGF0aCcpXG4gICwgaW52b2tlICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKC8qIC4uLnBhcmdzICovKXtcbiAgdmFyIGZuICAgICA9IGFGdW5jdGlvbih0aGlzKVxuICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgcGFyZ3MgID0gQXJyYXkobGVuZ3RoKVxuICAgICwgaSAgICAgID0gMFxuICAgICwgXyAgICAgID0gcGF0aC5fXG4gICAgLCBob2xkZXIgPSBmYWxzZTtcbiAgd2hpbGUobGVuZ3RoID4gaSlpZigocGFyZ3NbaV0gPSBhcmd1bWVudHNbaSsrXSkgPT09IF8paG9sZGVyID0gdHJ1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBqID0gMCwgayA9IDAsIGFyZ3M7XG4gICAgaWYoIWhvbGRlciAmJiAhYUxlbilyZXR1cm4gaW52b2tlKGZuLCBwYXJncywgdGhhdCk7XG4gICAgYXJncyA9IHBhcmdzLnNsaWNlKCk7XG4gICAgaWYoaG9sZGVyKWZvcig7bGVuZ3RoID4gajsgaisrKWlmKGFyZ3Nbal0gPT09IF8pYXJnc1tqXSA9IGFyZ3VtZW50c1trKytdO1xuICAgIHdoaWxlKGFMZW4gPiBrKWFyZ3MucHVzaChhcmd1bWVudHNbaysrXSk7XG4gICAgcmV0dXJuIGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59OyIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjLCBzYWZlKXtcbiAgZm9yKHZhciBrZXkgaW4gc3JjKXJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgU1JDICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpXG4gICwgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJ1xuICAsICR0b1N0cmluZyA9IEZ1bmN0aW9uW1RPX1NUUklOR11cbiAgLCBUUEwgICAgICAgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywga2V5LCB2YWwsIHNhZmUpe1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmKE9ba2V5XSA9PT0gdmFsKXJldHVybjtcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYoTyA9PT0gZ2xvYmFsKXtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaWYoIXNhZmUpe1xuICAgICAgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihPW2tleV0pT1trZXldID0gdmFsO1xuICAgICAgZWxzZSBoaWRlKE8sIGtleSwgdmFsKTtcbiAgICB9XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocmVnRXhwLCByZXBsYWNlKXtcbiAgdmFyIHJlcGxhY2VyID0gcmVwbGFjZSA9PT0gT2JqZWN0KHJlcGxhY2UpID8gZnVuY3Rpb24ocGFydCl7XG4gICAgcmV0dXJuIHJlcGxhY2VbcGFydF07XG4gIH0gOiByZXBsYWNlO1xuICByZXR1cm4gZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBTdHJpbmcoaXQpLnJlcGxhY2UocmVnRXhwLCByZXBsYWNlcik7XG4gIH07XG59OyIsIi8vIDcuMi45IFNhbWVWYWx1ZSh4LCB5KVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSl7XG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTsiLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgU1BFQ0lFUyAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59OyIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaGFzID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTsiLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59OyIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgU1BFQ0lFUyAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywgRCl7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3IsIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07IiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRob2QsIGFyZyl7XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbigpe1xuICAgIGFyZyA/IG1ldGhvZC5jYWxsKG51bGwsIGZ1bmN0aW9uKCl7fSwgMSkgOiBtZXRob2QuY2FsbChudWxsKTtcbiAgfSk7XG59OyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59OyIsIi8vIGhlbHBlciBmb3IgU3RyaW5nI3tzdGFydHNXaXRoLCBlbmRzV2l0aCwgaW5jbHVkZXN9XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKVxuICAsIGRlZmluZWQgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSl7XG4gIGlmKGlzUmVnRXhwKHNlYXJjaFN0cmluZykpdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcIiBkb2Vzbid0IGFjY2VwdCByZWdleCFcIik7XG4gIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG59OyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBxdW90ICAgID0gL1wiL2c7XG4vLyBCLjIuMy4yLjEgQ3JlYXRlSFRNTChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSlcbnZhciBjcmVhdGVIVE1MID0gZnVuY3Rpb24oc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgdmFyIFMgID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSlcbiAgICAsIHAxID0gJzwnICsgdGFnO1xuICBpZihhdHRyaWJ1dGUgIT09ICcnKXAxICs9ICcgJyArIGF0dHJpYnV0ZSArICc9XCInICsgU3RyaW5nKHZhbHVlKS5yZXBsYWNlKHF1b3QsICcmcXVvdDsnKSArICdcIic7XG4gIHJldHVybiBwMSArICc+JyArIFMgKyAnPC8nICsgdGFnICsgJz4nO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSwgZXhlYyl7XG4gIHZhciBPID0ge307XG4gIE9bTkFNRV0gPSBleGVjKGNyZWF0ZUhUTUwpO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHRlc3QgPSAnJ1tOQU1FXSgnXCInKTtcbiAgICByZXR1cm4gdGVzdCAhPT0gdGVzdC50b0xvd2VyQ2FzZSgpIHx8IHRlc3Quc3BsaXQoJ1wiJykubGVuZ3RoID4gMztcbiAgfSksICdTdHJpbmcnLCBPKTtcbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgcmVwZWF0ICAgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0JylcbiAgLCBkZWZpbmVkICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCBtYXhMZW5ndGgsIGZpbGxTdHJpbmcsIGxlZnQpe1xuICB2YXIgUyAgICAgICAgICAgID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgLCBzdHJpbmdMZW5ndGggPSBTLmxlbmd0aFxuICAgICwgZmlsbFN0ciAgICAgID0gZmlsbFN0cmluZyA9PT0gdW5kZWZpbmVkID8gJyAnIDogU3RyaW5nKGZpbGxTdHJpbmcpXG4gICAgLCBpbnRNYXhMZW5ndGggPSB0b0xlbmd0aChtYXhMZW5ndGgpO1xuICBpZihpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoIHx8IGZpbGxTdHIgPT0gJycpcmV0dXJuIFM7XG4gIHZhciBmaWxsTGVuID0gaW50TWF4TGVuZ3RoIC0gc3RyaW5nTGVuZ3RoXG4gICAgLCBzdHJpbmdGaWxsZXIgPSByZXBlYXQuY2FsbChmaWxsU3RyLCBNYXRoLmNlaWwoZmlsbExlbiAvIGZpbGxTdHIubGVuZ3RoKSk7XG4gIGlmKHN0cmluZ0ZpbGxlci5sZW5ndGggPiBmaWxsTGVuKXN0cmluZ0ZpbGxlciA9IHN0cmluZ0ZpbGxlci5zbGljZSgwLCBmaWxsTGVuKTtcbiAgcmV0dXJuIGxlZnQgPyBzdHJpbmdGaWxsZXIgKyBTIDogUyArIHN0cmluZ0ZpbGxlcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChjb3VudCl7XG4gIHZhciBzdHIgPSBTdHJpbmcoZGVmaW5lZCh0aGlzKSlcbiAgICAsIHJlcyA9ICcnXG4gICAgLCBuICAgPSB0b0ludGVnZXIoY291bnQpO1xuICBpZihuIDwgMCB8fCBuID09IEluZmluaXR5KXRocm93IFJhbmdlRXJyb3IoXCJDb3VudCBjYW4ndCBiZSBuZWdhdGl2ZVwiKTtcbiAgZm9yKDtuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpaWYobiAmIDEpcmVzICs9IHN0cjtcbiAgcmV0dXJuIHJlcztcbn07IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNwYWNlcyAgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKVxuICAsIHNwYWNlICAgPSAnWycgKyBzcGFjZXMgKyAnXSdcbiAgLCBub24gICAgID0gJ1xcdTIwMGJcXHUwMDg1J1xuICAsIGx0cmltICAgPSBSZWdFeHAoJ14nICsgc3BhY2UgKyBzcGFjZSArICcqJylcbiAgLCBydHJpbSAgID0gUmVnRXhwKHNwYWNlICsgc3BhY2UgKyAnKiQnKTtcblxudmFyIGV4cG9ydGVyID0gZnVuY3Rpb24oS0VZLCBleGVjLCBBTElBUyl7XG4gIHZhciBleHAgICA9IHt9O1xuICB2YXIgRk9SQ0UgPSBmYWlscyhmdW5jdGlvbigpe1xuICAgIHJldHVybiAhIXNwYWNlc1tLRVldKCkgfHwgbm9uW0tFWV0oKSAhPSBub247XG4gIH0pO1xuICB2YXIgZm4gPSBleHBbS0VZXSA9IEZPUkNFID8gZXhlYyh0cmltKSA6IHNwYWNlc1tLRVldO1xuICBpZihBTElBUylleHBbQUxJQVNdID0gZm47XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0UsICdTdHJpbmcnLCBleHApO1xufTtcblxuLy8gMSAtPiBTdHJpbmcjdHJpbUxlZnRcbi8vIDIgLT4gU3RyaW5nI3RyaW1SaWdodFxuLy8gMyAtPiBTdHJpbmcjdHJpbVxudmFyIHRyaW0gPSBleHBvcnRlci50cmltID0gZnVuY3Rpb24oc3RyaW5nLCBUWVBFKXtcbiAgc3RyaW5nID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIGlmKFRZUEUgJiAxKXN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gIGlmKFRZUEUgJiAyKXN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVyOyIsIm1vZHVsZS5leHBvcnRzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArXG4gICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJzsiLCJ2YXIgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBpbnZva2UgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGh0bWwgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2h0bWwnKVxuICAsIGNlbCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBzZXRUYXNrICAgICAgICAgICAgPSBnbG9iYWwuc2V0SW1tZWRpYXRlXG4gICwgY2xlYXJUYXNrICAgICAgICAgID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlXG4gICwgTWVzc2FnZUNoYW5uZWwgICAgID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsXG4gICwgY291bnRlciAgICAgICAgICAgID0gMFxuICAsIHF1ZXVlICAgICAgICAgICAgICA9IHt9XG4gICwgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSdcbiAgLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgaWQgPSArdGhpcztcbiAgaWYocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKXtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpe1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighc2V0VGFzayB8fCAhY2xlYXJUYXNrKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbil7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCl7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYoTWVzc2FnZUNoYW5uZWwpe1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWw7XG4gICAgcG9ydCAgICA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZihnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiAgIHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07IiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTsiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07IiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTsiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07IiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSl7XG4gIHZhciBMSUJSQVJZICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICAgLCBnbG9iYWwgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgICAsIGZhaWxzICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICAgLCAkZXhwb3J0ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgICAsICR0eXBlZCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190eXBlZCcpXG4gICAgLCAkYnVmZmVyICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJylcbiAgICAsIGN0eCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAgICwgYW5JbnN0YW5jZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgICAsIHByb3BlcnR5RGVzYyAgICAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgICAsIGhpZGUgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgICAsIHJlZGVmaW5lQWxsICAgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAgICwgdG9JbnRlZ2VyICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAgICwgdG9MZW5ndGggICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICAgLCB0b0luZGV4ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAgICwgdG9QcmltaXRpdmUgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICAgLCBoYXMgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgICAsIHNhbWUgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19zYW1lLXZhbHVlJylcbiAgICAsIGNsYXNzb2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgICAsIGlzT2JqZWN0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAgICwgdG9PYmplY3QgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICAgLCBpc0FycmF5SXRlciAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICAgLCBjcmVhdGUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICAgLCBnZXRQcm90b3R5cGVPZiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICAgLCBnT1BOICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICAgLCBnZXRJdGVyRm4gICAgICAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKVxuICAgICwgdWlkICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICAgLCB3a3MgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgICAsIGNyZWF0ZUFycmF5TWV0aG9kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJylcbiAgICAsIGNyZWF0ZUFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpXG4gICAgLCBzcGVjaWVzQ29uc3RydWN0b3IgID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICAgLCBBcnJheUl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKVxuICAgICwgSXRlcmF0b3JzICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICAgLCAkaXRlckRldGVjdCAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKVxuICAgICwgc2V0U3BlY2llcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJylcbiAgICAsIGFycmF5RmlsbCAgICAgICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJylcbiAgICAsIGFycmF5Q29weVdpdGhpbiAgICAgPSByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpXG4gICAgLCAkRFAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgICAsICRHT1BEICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICAgLCBkUCAgICAgICAgICAgICAgICAgID0gJERQLmZcbiAgICAsIGdPUEQgICAgICAgICAgICAgICAgPSAkR09QRC5mXG4gICAgLCBSYW5nZUVycm9yICAgICAgICAgID0gZ2xvYmFsLlJhbmdlRXJyb3JcbiAgICAsIFR5cGVFcnJvciAgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICAgLCBVaW50OEFycmF5ICAgICAgICAgID0gZ2xvYmFsLlVpbnQ4QXJyYXlcbiAgICAsIEFSUkFZX0JVRkZFUiAgICAgICAgPSAnQXJyYXlCdWZmZXInXG4gICAgLCBTSEFSRURfQlVGRkVSICAgICAgID0gJ1NoYXJlZCcgKyBBUlJBWV9CVUZGRVJcbiAgICAsIEJZVEVTX1BFUl9FTEVNRU5UICAgPSAnQllURVNfUEVSX0VMRU1FTlQnXG4gICAgLCBQUk9UT1RZUEUgICAgICAgICAgID0gJ3Byb3RvdHlwZSdcbiAgICAsIEFycmF5UHJvdG8gICAgICAgICAgPSBBcnJheVtQUk9UT1RZUEVdXG4gICAgLCAkQXJyYXlCdWZmZXIgICAgICAgID0gJGJ1ZmZlci5BcnJheUJ1ZmZlclxuICAgICwgJERhdGFWaWV3ICAgICAgICAgICA9ICRidWZmZXIuRGF0YVZpZXdcbiAgICAsIGFycmF5Rm9yRWFjaCAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCgwKVxuICAgICwgYXJyYXlGaWx0ZXIgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDIpXG4gICAgLCBhcnJheVNvbWUgICAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoMylcbiAgICAsIGFycmF5RXZlcnkgICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg0KVxuICAgICwgYXJyYXlGaW5kICAgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpXG4gICAgLCBhcnJheUZpbmRJbmRleCAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNilcbiAgICAsIGFycmF5SW5jbHVkZXMgICAgICAgPSBjcmVhdGVBcnJheUluY2x1ZGVzKHRydWUpXG4gICAgLCBhcnJheUluZGV4T2YgICAgICAgID0gY3JlYXRlQXJyYXlJbmNsdWRlcyhmYWxzZSlcbiAgICAsIGFycmF5VmFsdWVzICAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy52YWx1ZXNcbiAgICAsIGFycmF5S2V5cyAgICAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy5rZXlzXG4gICAgLCBhcnJheUVudHJpZXMgICAgICAgID0gQXJyYXlJdGVyYXRvcnMuZW50cmllc1xuICAgICwgYXJyYXlMYXN0SW5kZXhPZiAgICA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2ZcbiAgICAsIGFycmF5UmVkdWNlICAgICAgICAgPSBBcnJheVByb3RvLnJlZHVjZVxuICAgICwgYXJyYXlSZWR1Y2VSaWdodCAgICA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHRcbiAgICAsIGFycmF5Sm9pbiAgICAgICAgICAgPSBBcnJheVByb3RvLmpvaW5cbiAgICAsIGFycmF5U29ydCAgICAgICAgICAgPSBBcnJheVByb3RvLnNvcnRcbiAgICAsIGFycmF5U2xpY2UgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlXG4gICAgLCBhcnJheVRvU3RyaW5nICAgICAgID0gQXJyYXlQcm90by50b1N0cmluZ1xuICAgICwgYXJyYXlUb0xvY2FsZVN0cmluZyA9IEFycmF5UHJvdG8udG9Mb2NhbGVTdHJpbmdcbiAgICAsIElURVJBVE9SICAgICAgICAgICAgPSB3a3MoJ2l0ZXJhdG9yJylcbiAgICAsIFRBRyAgICAgICAgICAgICAgICAgPSB3a3MoJ3RvU3RyaW5nVGFnJylcbiAgICAsIFRZUEVEX0NPTlNUUlVDVE9SICAgPSB1aWQoJ3R5cGVkX2NvbnN0cnVjdG9yJylcbiAgICAsIERFRl9DT05TVFJVQ1RPUiAgICAgPSB1aWQoJ2RlZl9jb25zdHJ1Y3RvcicpXG4gICAgLCBBTExfQ09OU1RSVUNUT1JTICAgID0gJHR5cGVkLkNPTlNUUlxuICAgICwgVFlQRURfQVJSQVkgICAgICAgICA9ICR0eXBlZC5UWVBFRFxuICAgICwgVklFVyAgICAgICAgICAgICAgICA9ICR0eXBlZC5WSUVXXG4gICAgLCBXUk9OR19MRU5HVEggICAgICAgID0gJ1dyb25nIGxlbmd0aCEnO1xuXG4gIHZhciAkbWFwID0gY3JlYXRlQXJyYXlNZXRob2QoMSwgZnVuY3Rpb24oTywgbGVuZ3RoKXtcbiAgICByZXR1cm4gYWxsb2NhdGUoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxlbmd0aCk7XG4gIH0pO1xuXG4gIHZhciBMSVRUTEVfRU5ESUFOID0gZmFpbHMoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KFsxXSkuYnVmZmVyKVswXSA9PT0gMTtcbiAgfSk7XG5cbiAgdmFyIEZPUkNFRF9TRVQgPSAhIVVpbnQ4QXJyYXkgJiYgISFVaW50OEFycmF5W1BST1RPVFlQRV0uc2V0ICYmIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3IFVpbnQ4QXJyYXkoMSkuc2V0KHt9KTtcbiAgfSk7XG5cbiAgdmFyIHN0cmljdFRvTGVuZ3RoID0gZnVuY3Rpb24oaXQsIFNBTUUpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgdmFyIG51bWJlciA9ICtpdFxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChpdCk7XG4gICAgaWYoU0FNRSAmJiAhc2FtZShudW1iZXIsIGxlbmd0aCkpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH07XG5cbiAgdmFyIHRvT2Zmc2V0ID0gZnVuY3Rpb24oaXQsIEJZVEVTKXtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGl0KTtcbiAgICBpZihvZmZzZXQgPCAwIHx8IG9mZnNldCAlIEJZVEVTKXRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uKGl0KXtcbiAgICBpZihpc09iamVjdChpdCkgJiYgVFlQRURfQVJSQVkgaW4gaXQpcmV0dXJuIGl0O1xuICAgIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgdHlwZWQgYXJyYXkhJyk7XG4gIH07XG5cbiAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24oQywgbGVuZ3RoKXtcbiAgICBpZighKGlzT2JqZWN0KEMpICYmIFRZUEVEX0NPTlNUUlVDVE9SIGluIEMpKXtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSXQgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IhJyk7XG4gICAgfSByZXR1cm4gbmV3IEMobGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgc3BlY2llc0Zyb21MaXN0ID0gZnVuY3Rpb24oTywgbGlzdCl7XG4gICAgcmV0dXJuIGZyb21MaXN0KHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsaXN0KTtcbiAgfTtcblxuICB2YXIgZnJvbUxpc3QgPSBmdW5jdGlvbihDLCBsaXN0KXtcbiAgICB2YXIgaW5kZXggID0gMFxuICAgICAgLCBsZW5ndGggPSBsaXN0Lmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSBhbGxvY2F0ZShDLCBsZW5ndGgpO1xuICAgIHdoaWxlKGxlbmd0aCA+IGluZGV4KXJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uKGl0LCBrZXksIGludGVybmFsKXtcbiAgICBkUChpdCwga2V5LCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fZFtpbnRlcm5hbF07IH19KTtcbiAgfTtcblxuICB2YXIgJGZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiwgbWFwZm4sIHRoaXNBcmcgKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3Qoc291cmNlKVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBpLCBsZW5ndGgsIHZhbHVlcywgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZihpdGVyRm4gIT0gdW5kZWZpbmVkICYmICFpc0FycmF5SXRlcihpdGVyRm4pKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCB2YWx1ZXMgPSBbXSwgaSA9IDA7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaSsrKXtcbiAgICAgICAgdmFsdWVzLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICB9IE8gPSB2YWx1ZXM7XG4gICAgfVxuICAgIGlmKG1hcHBpbmcgJiYgYUxlbiA+IDIpbWFwZm4gPSBjdHgobWFwZm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgZm9yKGkgPSAwLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCksIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7IGxlbmd0aCA+IGk7IGkrKyl7XG4gICAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciAkb2YgPSBmdW5jdGlvbiBvZigvKi4uLml0ZW1zKi8pe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTtcbiAgICB3aGlsZShsZW5ndGggPiBpbmRleClyZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gaU9TIFNhZmFyaSA2LnggZmFpbHMgaGVyZVxuICB2YXIgVE9fTE9DQUxFX0JVRyA9ICEhVWludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbigpeyBhcnJheVRvTG9jYWxlU3RyaW5nLmNhbGwobmV3IFVpbnQ4QXJyYXkoMSkpOyB9KTtcblxuICB2YXIgJHRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoKXtcbiAgICByZXR1cm4gYXJyYXlUb0xvY2FsZVN0cmluZy5hcHBseShUT19MT0NBTEVfQlVHID8gYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpKSA6IHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBwcm90byA9IHtcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQgLyosIGVuZCAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlDb3B5V2l0aGluLmNhbGwodmFsaWRhdGUodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUV2ZXJ5KHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qLCBzdGFydCwgZW5kICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5RmlsbC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheUZpbHRlcih2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbixcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKTtcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUZpbmQodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUZpbmRJbmRleCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgYXJyYXlGb3JFYWNoKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXtcbiAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcil7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUpvaW4uYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5TGFzdEluZGV4T2YuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gJG1hcCh2YWxpZGF0ZSh0aGlzKSwgbWFwZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyosIGluaXRpYWxWYWx1ZSAqLyl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZS5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qLCBpbml0aWFsVmFsdWUgKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2VSaWdodC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKXtcbiAgICAgIHZhciB0aGF0ICAgPSB0aGlzXG4gICAgICAgICwgbGVuZ3RoID0gdmFsaWRhdGUodGhhdCkubGVuZ3RoXG4gICAgICAgICwgbWlkZGxlID0gTWF0aC5mbG9vcihsZW5ndGggLyAyKVxuICAgICAgICAsIGluZGV4ICA9IDBcbiAgICAgICAgLCB2YWx1ZTtcbiAgICAgIHdoaWxlKGluZGV4IDwgbWlkZGxlKXtcbiAgICAgICAgdmFsdWUgICAgICAgICA9IHRoYXRbaW5kZXhdO1xuICAgICAgICB0aGF0W2luZGV4KytdID0gdGhhdFstLWxlbmd0aF07XG4gICAgICAgIHRoYXRbbGVuZ3RoXSAgPSB2YWx1ZTtcbiAgICAgIH0gcmV0dXJuIHRoYXQ7XG4gICAgfSxcbiAgICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5U29tZSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pe1xuICAgICAgcmV0dXJuIGFycmF5U29ydC5jYWxsKHZhbGlkYXRlKHRoaXMpLCBjb21wYXJlZm4pO1xuICAgIH0sXG4gICAgc3ViYXJyYXk6IGZ1bmN0aW9uIHN1YmFycmF5KGJlZ2luLCBlbmQpe1xuICAgICAgdmFyIE8gICAgICA9IHZhbGlkYXRlKHRoaXMpXG4gICAgICAgICwgbGVuZ3RoID0gTy5sZW5ndGhcbiAgICAgICAgLCAkYmVnaW4gPSB0b0luZGV4KGJlZ2luLCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSkpKFxuICAgICAgICBPLmJ1ZmZlcixcbiAgICAgICAgTy5ieXRlT2Zmc2V0ICsgJGJlZ2luICogTy5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgdG9MZW5ndGgoKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbmRleChlbmQsIGxlbmd0aCkpIC0gJGJlZ2luKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyICRzbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpe1xuICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpLCBzdGFydCwgZW5kKSk7XG4gIH07XG5cbiAgdmFyICRzZXQgPSBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlIC8qLCBvZmZzZXQgKi8pe1xuICAgIHZhbGlkYXRlKHRoaXMpO1xuICAgIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHNbMV0sIDEpXG4gICAgICAsIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgICAsIHNyYyAgICA9IHRvT2JqZWN0KGFycmF5TGlrZSlcbiAgICAgICwgbGVuICAgID0gdG9MZW5ndGgoc3JjLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMDtcbiAgICBpZihsZW4gKyBvZmZzZXQgPiBsZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHdoaWxlKGluZGV4IDwgbGVuKXRoaXNbb2Zmc2V0ICsgaW5kZXhdID0gc3JjW2luZGV4KytdO1xuICB9O1xuXG4gIHZhciAkaXRlcmF0b3JzID0ge1xuICAgIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKXtcbiAgICAgIHJldHVybiBhcnJheUVudHJpZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKCl7XG4gICAgICByZXR1cm4gYXJyYXlLZXlzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKXtcbiAgICAgIHJldHVybiBhcnJheVZhbHVlcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzVEFJbmRleCA9IGZ1bmN0aW9uKHRhcmdldCwga2V5KXtcbiAgICByZXR1cm4gaXNPYmplY3QodGFyZ2V0KVxuICAgICAgJiYgdGFyZ2V0W1RZUEVEX0FSUkFZXVxuICAgICAgJiYgdHlwZW9mIGtleSAhPSAnc3ltYm9sJ1xuICAgICAgJiYga2V5IGluIHRhcmdldFxuICAgICAgJiYgU3RyaW5nKCtrZXkpID09IFN0cmluZyhrZXkpO1xuICB9O1xuICB2YXIgJGdldERlc2MgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpe1xuICAgIHJldHVybiBpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgPyBwcm9wZXJ0eURlc2MoMiwgdGFyZ2V0W2tleV0pXG4gICAgICA6IGdPUEQodGFyZ2V0LCBrZXkpO1xuICB9O1xuICB2YXIgJHNldERlc2MgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzYyl7XG4gICAgaWYoaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgICYmIGlzT2JqZWN0KGRlc2MpXG4gICAgICAmJiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICAgICYmICFoYXMoZGVzYywgJ2dldCcpXG4gICAgICAmJiAhaGFzKGRlc2MsICdzZXQnKVxuICAgICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAgICYmICFkZXNjLmNvbmZpZ3VyYWJsZVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ3dyaXRhYmxlJykgfHwgZGVzYy53cml0YWJsZSlcbiAgICAgICYmICghaGFzKGRlc2MsICdlbnVtZXJhYmxlJykgfHwgZGVzYy5lbnVtZXJhYmxlKVxuICAgICl7XG4gICAgICB0YXJnZXRba2V5XSA9IGRlc2MudmFsdWU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gZWxzZSByZXR1cm4gZFAodGFyZ2V0LCBrZXksIGRlc2MpO1xuICB9O1xuXG4gIGlmKCFBTExfQ09OU1RSVUNUT1JTKXtcbiAgICAkR09QRC5mID0gJGdldERlc2M7XG4gICAgJERQLmYgICA9ICRzZXREZXNjO1xuICB9XG5cbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhQUxMX0NPTlNUUlVDVE9SUywgJ09iamVjdCcsIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXREZXNjLFxuICAgIGRlZmluZVByb3BlcnR5OiAgICAgICAgICAgJHNldERlc2NcbiAgfSk7XG5cbiAgaWYoZmFpbHMoZnVuY3Rpb24oKXsgYXJyYXlUb1N0cmluZy5jYWxsKHt9KTsgfSkpe1xuICAgIGFycmF5VG9TdHJpbmcgPSBhcnJheVRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgJFR5cGVkQXJyYXlQcm90b3R5cGUkID0gcmVkZWZpbmVBbGwoe30sIHByb3RvKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAkaXRlcmF0b3JzKTtcbiAgaGlkZSgkVHlwZWRBcnJheVByb3RvdHlwZSQsIElURVJBVE9SLCAkaXRlcmF0b3JzLnZhbHVlcyk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwge1xuICAgIHNsaWNlOiAgICAgICAgICAkc2xpY2UsXG4gICAgc2V0OiAgICAgICAgICAgICRzZXQsXG4gICAgY29uc3RydWN0b3I6ICAgIGZ1bmN0aW9uKCl7IC8qIG5vb3AgKi8gfSxcbiAgICB0b1N0cmluZzogICAgICAgYXJyYXlUb1N0cmluZyxcbiAgICB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nXG4gIH0pO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnVmZmVyJywgJ2InKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVPZmZzZXQnLCAnbycpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZUxlbmd0aCcsICdsJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdsZW5ndGgnLCAnZScpO1xuICBkUCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIFRBRywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXNbVFlQRURfQVJSQVldOyB9XG4gIH0pO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBCWVRFUywgd3JhcHBlciwgQ0xBTVBFRCl7XG4gICAgQ0xBTVBFRCA9ICEhQ0xBTVBFRDtcbiAgICB2YXIgTkFNRSAgICAgICA9IEtFWSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5J1xuICAgICAgLCBJU05UX1VJTlQ4ID0gTkFNRSAhPSAnVWludDhBcnJheSdcbiAgICAgICwgR0VUVEVSICAgICA9ICdnZXQnICsgS0VZXG4gICAgICAsIFNFVFRFUiAgICAgPSAnc2V0JyArIEtFWVxuICAgICAgLCBUeXBlZEFycmF5ID0gZ2xvYmFsW05BTUVdXG4gICAgICAsIEJhc2UgICAgICAgPSBUeXBlZEFycmF5IHx8IHt9XG4gICAgICAsIFRBQyAgICAgICAgPSBUeXBlZEFycmF5ICYmIGdldFByb3RvdHlwZU9mKFR5cGVkQXJyYXkpXG4gICAgICAsIEZPUkNFRCAgICAgPSAhVHlwZWRBcnJheSB8fCAhJHR5cGVkLkFCVlxuICAgICAgLCBPICAgICAgICAgID0ge31cbiAgICAgICwgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkgJiYgVHlwZWRBcnJheVtQUk9UT1RZUEVdO1xuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbih0aGF0LCBpbmRleCl7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICByZXR1cm4gZGF0YS52W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24odGhhdCwgaW5kZXgsIHZhbHVlKXtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIGlmKENMQU1QRUQpdmFsdWUgPSAodmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhmZiA/IDB4ZmYgOiB2YWx1ZSAmIDB4ZmY7XG4gICAgICBkYXRhLnZbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCB2YWx1ZSwgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uKHRoYXQsIGluZGV4KXtcbiAgICAgIGRQKHRoYXQsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgICByZXR1cm4gZ2V0dGVyKHRoaXMsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmKEZPUkNFRCl7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FLCAnX2QnKTtcbiAgICAgICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICAgICAsIG9mZnNldCA9IDBcbiAgICAgICAgICAsIGJ1ZmZlciwgYnl0ZUxlbmd0aCwgbGVuZ3RoLCBrbGFzcztcbiAgICAgICAgaWYoIWlzT2JqZWN0KGRhdGEpKXtcbiAgICAgICAgICBsZW5ndGggICAgID0gc3RyaWN0VG9MZW5ndGgoZGF0YSwgdHJ1ZSlcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyICAgICA9IG5ldyAkQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZihkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKXtcbiAgICAgICAgICBidWZmZXIgPSBkYXRhO1xuICAgICAgICAgIG9mZnNldCA9IHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKTtcbiAgICAgICAgICB2YXIgJGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBpZigkbGVuZ3RoID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgaWYoJGxlbiAlIEJZVEVTKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYoYnl0ZUxlbmd0aCA8IDApdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgIGlmKGJ5dGVMZW5ndGggKyBvZmZzZXQgPiAkbGVuKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYoVFlQRURfQVJSQVkgaW4gZGF0YSl7XG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGhpZGUodGhhdCwgJ19kJywge1xuICAgICAgICAgIGI6IGJ1ZmZlcixcbiAgICAgICAgICBvOiBvZmZzZXQsXG4gICAgICAgICAgbDogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBlOiBsZW5ndGgsXG4gICAgICAgICAgdjogbmV3ICREYXRhVmlldyhidWZmZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZShpbmRleCA8IGxlbmd0aClhZGRFbGVtZW50KHRoYXQsIGluZGV4KyspO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gY3JlYXRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCk7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIFR5cGVkQXJyYXkpO1xuICAgIH0gZWxzZSBpZighJGl0ZXJEZXRlY3QoZnVuY3Rpb24oaXRlcil7XG4gICAgICAvLyBWOCB3b3JrcyB3aXRoIGl0ZXJhdG9ycywgYnV0IGZhaWxzIGluIG1hbnkgb3RoZXIgY2FzZXNcbiAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00NTUyXG4gICAgICBuZXcgVHlwZWRBcnJheShudWxsKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KGl0ZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0sIHRydWUpKXtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpe1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUpO1xuICAgICAgICB2YXIga2xhc3M7XG4gICAgICAgIC8vIGB3c2AgbW9kdWxlIGJ1ZywgdGVtcG9yYXJpbHkgcmVtb3ZlIHZhbGlkYXRpb24gbGVuZ3RoIGZvciBVaW50OEFycmF5XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL3B1bGwvNjQ1XG4gICAgICAgIGlmKCFpc09iamVjdChkYXRhKSlyZXR1cm4gbmV3IEJhc2Uoc3RyaWN0VG9MZW5ndGgoZGF0YSwgSVNOVF9VSU5UOCkpO1xuICAgICAgICBpZihkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKXtcbiAgICAgICAgICByZXR1cm4gJGxlbmd0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSwgJGxlbmd0aClcbiAgICAgICAgICAgIDogJG9mZnNldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpKVxuICAgICAgICAgICAgICA6IG5ldyBCYXNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmKFRZUEVEX0FSUkFZIGluIGRhdGEpcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgYXJyYXlGb3JFYWNoKFRBQyAhPT0gRnVuY3Rpb24ucHJvdG90eXBlID8gZ09QTihCYXNlKS5jb25jYXQoZ09QTihUQUMpKSA6IGdPUE4oQmFzZSksIGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIGlmKCEoa2V5IGluIFR5cGVkQXJyYXkpKWhpZGUoVHlwZWRBcnJheSwga2V5LCBCYXNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBUeXBlZEFycmF5UHJvdG90eXBlO1xuICAgICAgaWYoIUxJQlJBUlkpVHlwZWRBcnJheVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR5cGVkQXJyYXk7XG4gICAgfVxuICAgIHZhciAkbmF0aXZlSXRlcmF0b3IgICA9IFR5cGVkQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdXG4gICAgICAsIENPUlJFQ1RfSVRFUl9OQU1FID0gISEkbmF0aXZlSXRlcmF0b3IgJiYgKCRuYXRpdmVJdGVyYXRvci5uYW1lID09ICd2YWx1ZXMnIHx8ICRuYXRpdmVJdGVyYXRvci5uYW1lID09IHVuZGVmaW5lZClcbiAgICAgICwgJGl0ZXJhdG9yICAgICAgICAgPSAkaXRlcmF0b3JzLnZhbHVlcztcbiAgICBoaWRlKFR5cGVkQXJyYXksIFRZUEVEX0NPTlNUUlVDVE9SLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRZUEVEX0FSUkFZLCBOQU1FKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgREVGX0NPTlNUUlVDVE9SLCBUeXBlZEFycmF5KTtcblxuICAgIGlmKENMQU1QRUQgPyBuZXcgVHlwZWRBcnJheSgxKVtUQUddICE9IE5BTUUgOiAhKFRBRyBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSl7XG4gICAgICBkUChUeXBlZEFycmF5UHJvdG90eXBlLCBUQUcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gTkFNRTsgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgT1tOQU1FXSA9IFR5cGVkQXJyYXk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChUeXBlZEFycmF5ICE9IEJhc2UpLCBPKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5TLCBOQU1FLCB7XG4gICAgICBCWVRFU19QRVJfRUxFTUVOVDogQllURVMsXG4gICAgICBmcm9tOiAkZnJvbSxcbiAgICAgIG9mOiAkb2ZcbiAgICB9KTtcblxuICAgIGlmKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAsIE5BTUUsIHByb3RvKTtcblxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFRF9TRVQsIE5BTUUsIHtzZXQ6ICRzZXR9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIUNPUlJFQ1RfSVRFUl9OQU1FLCBOQU1FLCAkaXRlcmF0b3JzKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZyksIE5BTUUsIHt0b1N0cmluZzogYXJyYXlUb1N0cmluZ30pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpe1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMSkuc2xpY2UoKTtcbiAgICB9KSwgTkFNRSwge3NsaWNlOiAkc2xpY2V9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IFR5cGVkQXJyYXkoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpXG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsIDJdKTtcbiAgICB9KSksIE5BTUUsIHt0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nfSk7XG5cbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBDT1JSRUNUX0lURVJfTkFNRSA/ICRuYXRpdmVJdGVyYXRvciA6ICRpdGVyYXRvcjtcbiAgICBpZighTElCUkFSWSAmJiAhQ09SUkVDVF9JVEVSX05BTUUpaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBJVEVSQVRPUiwgJGl0ZXJhdG9yKTtcbiAgfTtcbn0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICR0eXBlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmVBbGwgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGZhaWxzICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGFuSW5zdGFuY2UgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIHRvSW50ZWdlciAgICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgdG9MZW5ndGggICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGdPUE4gICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgZFAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgYXJyYXlGaWxsICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBBUlJBWV9CVUZGRVIgICA9ICdBcnJheUJ1ZmZlcidcbiAgLCBEQVRBX1ZJRVcgICAgICA9ICdEYXRhVmlldydcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgV1JPTkdfTEVOR1RIICAgPSAnV3JvbmcgbGVuZ3RoISdcbiAgLCBXUk9OR19JTkRFWCAgICA9ICdXcm9uZyBpbmRleCEnXG4gICwgJEFycmF5QnVmZmVyICAgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXVxuICAsICREYXRhVmlldyAgICAgID0gZ2xvYmFsW0RBVEFfVklFV11cbiAgLCBNYXRoICAgICAgICAgICA9IGdsb2JhbC5NYXRoXG4gICwgUmFuZ2VFcnJvciAgICAgPSBnbG9iYWwuUmFuZ2VFcnJvclxuICAsIEluZmluaXR5ICAgICAgID0gZ2xvYmFsLkluZmluaXR5XG4gICwgQmFzZUJ1ZmZlciAgICAgPSAkQXJyYXlCdWZmZXJcbiAgLCBhYnMgICAgICAgICAgICA9IE1hdGguYWJzXG4gICwgcG93ICAgICAgICAgICAgPSBNYXRoLnBvd1xuICAsIGZsb29yICAgICAgICAgID0gTWF0aC5mbG9vclxuICAsIGxvZyAgICAgICAgICAgID0gTWF0aC5sb2dcbiAgLCBMTjIgICAgICAgICAgICA9IE1hdGguTE4yXG4gICwgQlVGRkVSICAgICAgICAgPSAnYnVmZmVyJ1xuICAsIEJZVEVfTEVOR1RIICAgID0gJ2J5dGVMZW5ndGgnXG4gICwgQllURV9PRkZTRVQgICAgPSAnYnl0ZU9mZnNldCdcbiAgLCAkQlVGRkVSICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19iJyA6IEJVRkZFUlxuICAsICRMRU5HVEggICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX2wnIDogQllURV9MRU5HVEhcbiAgLCAkT0ZGU0VUICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19vJyA6IEJZVEVfT0ZGU0VUO1xuXG4vLyBJRUVFNzU0IGNvbnZlcnNpb25zIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxudmFyIHBhY2tJRUVFNzU0ID0gZnVuY3Rpb24odmFsdWUsIG1MZW4sIG5CeXRlcyl7XG4gIHZhciBidWZmZXIgPSBBcnJheShuQnl0ZXMpXG4gICAgLCBlTGVuICAgPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgICAsIGVNYXggICA9ICgxIDw8IGVMZW4pIC0gMVxuICAgICwgZUJpYXMgID0gZU1heCA+PiAxXG4gICAgLCBydCAgICAgPSBtTGVuID09PSAyMyA/IHBvdygyLCAtMjQpIC0gcG93KDIsIC03NykgOiAwXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBzICAgICAgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwXG4gICAgLCBlLCBtLCBjO1xuICB2YWx1ZSA9IGFicyh2YWx1ZSlcbiAgaWYodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IEluZmluaXR5KXtcbiAgICBtID0gdmFsdWUgIT0gdmFsdWUgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gZmxvb3IobG9nKHZhbHVlKSAvIExOMik7XG4gICAgaWYodmFsdWUgKiAoYyA9IHBvdygyLCAtZSkpIDwgMSl7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmKGUgKyBlQmlhcyA+PSAxKXtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBwb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYodmFsdWUgKiBjID49IDIpe1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cbiAgICBpZihlICsgZUJpYXMgPj0gZU1heCl7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZihlICsgZUJpYXMgPj0gMSl7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cbiAgZm9yKDsgbUxlbiA+PSA4OyBidWZmZXJbaSsrXSA9IG0gJiAyNTUsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuICBlID0gZSA8PCBtTGVuIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IoOyBlTGVuID4gMDsgYnVmZmVyW2krK10gPSBlICYgMjU1LCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcbiAgYnVmZmVyWy0taV0gfD0gcyAqIDEyODtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG52YXIgdW5wYWNrSUVFRTc1NCA9IGZ1bmN0aW9uKGJ1ZmZlciwgbUxlbiwgbkJ5dGVzKXtcbiAgdmFyIGVMZW4gID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gICAgLCBlTWF4ICA9ICgxIDw8IGVMZW4pIC0gMVxuICAgICwgZUJpYXMgPSBlTWF4ID4+IDFcbiAgICAsIG5CaXRzID0gZUxlbiAtIDdcbiAgICAsIGkgICAgID0gbkJ5dGVzIC0gMVxuICAgICwgcyAgICAgPSBidWZmZXJbaS0tXVxuICAgICwgZSAgICAgPSBzICYgMTI3XG4gICAgLCBtO1xuICBzID4+PSA3O1xuICBmb3IoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxO1xuICBlID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvcig7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIGlmKGUgPT09IDApe1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZihlID09PSBlTWF4KXtcbiAgICByZXR1cm4gbSA/IE5hTiA6IHMgPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIHBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9IHJldHVybiAocyA/IC0xIDogMSkgKiBtICogcG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbnZhciB1bnBhY2tJMzIgPSBmdW5jdGlvbihieXRlcyl7XG4gIHJldHVybiBieXRlc1szXSA8PCAyNCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xufTtcbnZhciBwYWNrSTggPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBbaXQgJiAweGZmXTtcbn07XG52YXIgcGFja0kxNiA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmXTtcbn07XG52YXIgcGFja0kzMiA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmLCBpdCA+PiAxNiAmIDB4ZmYsIGl0ID4+IDI0ICYgMHhmZl07XG59O1xudmFyIHBhY2tGNjQgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgNTIsIDgpO1xufTtcbnZhciBwYWNrRjMyID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDIzLCA0KTtcbn07XG5cbnZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbihDLCBrZXksIGludGVybmFsKXtcbiAgZFAoQ1tQUk9UT1RZUEVdLCBrZXksIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzW2ludGVybmFsXTsgfX0pO1xufTtcblxudmFyIGdldCA9IGZ1bmN0aW9uKHZpZXcsIGJ5dGVzLCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pe1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXhcbiAgICAsIGludEluZGV4ID0gdG9JbnRlZ2VyKG51bUluZGV4KTtcbiAgaWYobnVtSW5kZXggIT0gaW50SW5kZXggfHwgaW50SW5kZXggPCAwIHx8IGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iXG4gICAgLCBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXVxuICAgICwgcGFjayAgPSBzdG9yZS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcyk7XG4gIHJldHVybiBpc0xpdHRsZUVuZGlhbiA/IHBhY2sgOiBwYWNrLnJldmVyc2UoKTtcbn07XG52YXIgc2V0ID0gZnVuY3Rpb24odmlldywgYnl0ZXMsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pe1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXhcbiAgICAsIGludEluZGV4ID0gdG9JbnRlZ2VyKG51bUluZGV4KTtcbiAgaWYobnVtSW5kZXggIT0gaW50SW5kZXggfHwgaW50SW5kZXggPCAwIHx8IGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iXG4gICAgLCBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXVxuICAgICwgcGFjayAgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBieXRlczsgaSsrKXN0b3JlW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGJ5dGVzIC0gaSAtIDFdO1xufTtcblxudmFyIHZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHMgPSBmdW5jdGlvbih0aGF0LCBsZW5ndGgpe1xuICBhbkluc3RhbmNlKHRoYXQsICRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbiAgdmFyIG51bWJlckxlbmd0aCA9ICtsZW5ndGhcbiAgICAsIGJ5dGVMZW5ndGggICA9IHRvTGVuZ3RoKG51bWJlckxlbmd0aCk7XG4gIGlmKG51bWJlckxlbmd0aCAhPSBieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgcmV0dXJuIGJ5dGVMZW5ndGg7XG59O1xuXG5pZighJHR5cGVkLkFCVil7XG4gICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCl7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB2YWxpZGF0ZUFycmF5QnVmZmVyQXJndW1lbnRzKHRoaXMsIGxlbmd0aCk7XG4gICAgdGhpcy5fYiAgICAgICA9IGFycmF5RmlsbC5jYWxsKEFycmF5KGJ5dGVMZW5ndGgpLCAwKTtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICAkRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpe1xuICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlclskTEVOR1RIXVxuICAgICAgLCBvZmZzZXQgICAgICAgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgaWYob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmZXJMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiB0b0xlbmd0aChieXRlTGVuZ3RoKTtcbiAgICBpZihvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB0aGlzWyRCVUZGRVJdID0gYnVmZmVyO1xuICAgIHRoaXNbJE9GRlNFVF0gPSBvZmZzZXQ7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgaWYoREVTQ1JJUFRPUlMpe1xuICAgIGFkZEdldHRlcigkQXJyYXlCdWZmZXIsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCVUZGRVIsICdfYicpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX09GRlNFVCwgJ19vJyk7XG4gIH1cblxuICByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCl7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdIDw8IDI0ID4+IDI0O1xuICAgIH0sXG4gICAgZ2V0VWludDg6IGZ1bmN0aW9uIGdldFVpbnQ4KGJ5dGVPZmZzZXQpe1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gKGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXSkgPDwgMTYgPj4gMTY7XG4gICAgfSxcbiAgICBnZXRVaW50MTY6IGZ1bmN0aW9uIGdldFVpbnQxNihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyKGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKSA+Pj4gMDtcbiAgICB9LFxuICAgIGdldEZsb2F0MzI6IGZ1bmN0aW9uIGdldEZsb2F0MzIoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCAyMywgNCk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgNTIsIDgpO1xuICAgIH0sXG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0SW50MTY6IGZ1bmN0aW9uIHNldEludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDE2OiBmdW5jdGlvbiBzZXRVaW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MzI6IGZ1bmN0aW9uIHNldFVpbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0MzI6IGZ1bmN0aW9uIHNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0YzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIHBhY2tGNjQsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBpZighZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgJEFycmF5QnVmZmVyOyAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3ICRBcnJheUJ1ZmZlciguNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0pKXtcbiAgICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpe1xuICAgICAgcmV0dXJuIG5ldyBCYXNlQnVmZmVyKHZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHModGhpcywgbGVuZ3RoKSk7XG4gICAgfTtcbiAgICB2YXIgQXJyYXlCdWZmZXJQcm90byA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdID0gQmFzZUJ1ZmZlcltQUk9UT1RZUEVdO1xuICAgIGZvcih2YXIga2V5cyA9IGdPUE4oQmFzZUJ1ZmZlciksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgKXtcbiAgICAgIGlmKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSloaWRlKCRBcnJheUJ1ZmZlciwga2V5LCBCYXNlQnVmZmVyW2tleV0pO1xuICAgIH07XG4gICAgaWYoIUxJQlJBUlkpQXJyYXlCdWZmZXJQcm90by5jb25zdHJ1Y3RvciA9ICRBcnJheUJ1ZmZlcjtcbiAgfVxuICAvLyBpT1MgU2FmYXJpIDcueCBidWdcbiAgdmFyIHZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpXG4gICAgLCAkc2V0SW50OCA9ICREYXRhVmlld1tQUk9UT1RZUEVdLnNldEludDg7XG4gIHZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdmlldy5zZXRJbnQ4KDEsIDIxNDc0ODM2NDkpO1xuICBpZih2aWV3LmdldEludDgoMCkgfHwgIXZpZXcuZ2V0SW50OCgxKSlyZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cbnNldFRvU3RyaW5nVGFnKCRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbnNldFRvU3RyaW5nVGFnKCREYXRhVmlldywgREFUQV9WSUVXKTtcbmhpZGUoJERhdGFWaWV3W1BST1RPVFlQRV0sICR0eXBlZC5WSUVXLCB0cnVlKTtcbmV4cG9ydHNbQVJSQVlfQlVGRkVSXSA9ICRBcnJheUJ1ZmZlcjtcbmV4cG9ydHNbREFUQV9WSUVXXSA9ICREYXRhVmlldzsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFRZUEVEICA9IHVpZCgndHlwZWRfYXJyYXknKVxuICAsIFZJRVcgICA9IHVpZCgndmlldycpXG4gICwgQUJWICAgID0gISEoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGdsb2JhbC5EYXRhVmlldylcbiAgLCBDT05TVFIgPSBBQlZcbiAgLCBpID0gMCwgbCA9IDksIFR5cGVkO1xuXG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9IChcbiAgJ0ludDhBcnJheSxVaW50OEFycmF5LFVpbnQ4Q2xhbXBlZEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5J1xuKS5zcGxpdCgnLCcpO1xuXG53aGlsZShpIDwgbCl7XG4gIGlmKFR5cGVkID0gZ2xvYmFsW1R5cGVkQXJyYXlDb25zdHJ1Y3RvcnNbaSsrXV0pe1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBUWVBFRCwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICB9IGVsc2UgQ09OU1RSID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBQlY6ICAgIEFCVixcbiAgQ09OU1RSOiBDT05TVFIsXG4gIFRZUEVEOiAgVFlQRUQsXG4gIFZJRVc6ICAgVklFV1xufTsiLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTsiLCJ2YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwge3ZhbHVlOiB3a3NFeHQuZihuYW1lKX0pO1xufTsiLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTsiLCJ2YXIgc3RvcmUgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFN5bWJvbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2xcbiAgLCBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTsiLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtaW5nci9SZXhFeHAuZXNjYXBlXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHJlICAgICA9IHJlcXVpcmUoJy4vX3JlcGxhY2VyJykoL1tcXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVnRXhwJywge2VzY2FwZTogZnVuY3Rpb24gZXNjYXBlKGl0KXsgcmV0dXJuICRyZShpdCk7IH19KTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtjb3B5V2l0aGluOiByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdjb3B5V2l0aGluJyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRldmVyeSAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNCk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5ldmVyeSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjUgLyAxNS40LjQuMTYgQXJyYXkucHJvdG90eXBlLmV2ZXJ5KGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRldmVyeSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7ZmlsbDogcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmaWxsJyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMik7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5maWx0ZXIsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy43IC8gMTUuNC40LjIwIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy45IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaW5kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNilcbiAgLCBLRVkgICAgID0gJ2ZpbmRJbmRleCdcbiAgLCBmb3JjZWQgID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZihLRVkgaW4gW10pQXJyYXkoMSlbS0VZXShmdW5jdGlvbigpeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZpbmQgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg1KVxuICAsIEtFWSAgICAgPSAnZmluZCdcbiAgLCBmb3JjZWQgID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZihLRVkgaW4gW10pQXJyYXkoMSlbS0VZXShmdW5jdGlvbigpeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZvckVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMClcbiAgLCBTVFJJQ1QgICA9IHJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5mb3JFYWNoLCB0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhU1RSSUNULCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGNhbGwgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIHRvTGVuZ3RoICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpXG4gICwgZ2V0SXRlckZuICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlLyosIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBDICAgICAgID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYobWFwcGluZyltYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQzsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRpbmRleE9mICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsICRuYXRpdmUgICAgICAgPSBbXS5pbmRleE9mXG4gICwgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTEgLyAxNS40LjQuMTQgQXJyYXkucHJvdG90eXBlLmluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCA9IDAgKi8pe1xuICAgIHJldHVybiBORUdBVElWRV9aRVJPXG4gICAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgICA/ICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwXG4gICAgICA6ICRpbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIi8vIDIyLjEuMi4yIC8gMTUuNC4zLjIgQXJyYXkuaXNBcnJheShhcmcpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0FycmF5Jywge2lzQXJyYXk6IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyl9KTsiLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpXG4gICwgc3RlcCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUuam9pbihzZXBhcmF0b3IpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBhcnJheUpvaW4gPSBbXS5qb2luO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2Ugc3RyaW5nc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAocmVxdWlyZSgnLi9faW9iamVjdCcpICE9IE9iamVjdCB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKGFycmF5Sm9pbikpLCAnQXJyYXknLCB7XG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKXtcbiAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodG9JT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9JbnRlZ2VyICAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIHRvTGVuZ3RoICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsICRuYXRpdmUgICAgICAgPSBbXS5sYXN0SW5kZXhPZlxuICAsIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5sYXN0SW5kZXhPZigxLCAtMCkgPCAwO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNCAvIDE1LjQuNC4xNSBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ID0gQFsqLTFdICovKXtcbiAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgaWYoTkVHQVRJVkVfWkVSTylyZXR1cm4gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDA7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCh0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gbGVuZ3RoIC0gMTtcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSlpbmRleCA9IE1hdGgubWluKGluZGV4LCB0b0ludGVnZXIoYXJndW1lbnRzWzFdKSk7XG4gICAgaWYoaW5kZXggPCAwKWluZGV4ID0gbGVuZ3RoICsgaW5kZXg7XG4gICAgZm9yKDtpbmRleCA+PSAwOyBpbmRleC0tKWlmKGluZGV4IGluIE8paWYoT1tpbmRleF0gPT09IHNlYXJjaEVsZW1lbnQpcmV0dXJuIGluZGV4IHx8IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJG1hcCAgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgxKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLm1hcCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE1IC8gMTUuNC40LjE5IEFycmF5LnByb3RvdHlwZS5tYXAoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuLy8gV2ViS2l0IEFycmF5Lm9mIGlzbid0IGdlbmVyaWNcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICBmdW5jdGlvbiBGKCl7fVxuICByZXR1cm4gIShBcnJheS5vZi5jYWxsKEYpIGluc3RhbmNlb2YgRik7XG59KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMyBBcnJheS5vZiggLi4uaXRlbXMpXG4gIG9mOiBmdW5jdGlvbiBvZigvKiAuLi5hcmdzICovKXtcbiAgICB2YXIgaW5kZXggID0gMFxuICAgICAgLCBhTGVuICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIHJlc3VsdCA9IG5ldyAodHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheSkoYUxlbik7XG4gICAgd2hpbGUoYUxlbiA+IGluZGV4KWNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGFMZW47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZVJpZ2h0LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTkgLyAxNS40LjQuMjIgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pe1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgdHJ1ZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2UsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLyl7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCBmYWxzZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBodG1sICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY29mICAgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgdG9JbmRleCAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCB0b0xlbmd0aCAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBhcnJheVNsaWNlID0gW10uc2xpY2U7XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICBpZihodG1sKWFycmF5U2xpY2UuY2FsbChodG1sKTtcbn0pLCAnQXJyYXknLCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKXtcbiAgICB2YXIgbGVuICAgPSB0b0xlbmd0aCh0aGlzLmxlbmd0aClcbiAgICAgICwga2xhc3MgPSBjb2YodGhpcyk7XG4gICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQ7XG4gICAgaWYoa2xhc3MgPT0gJ0FycmF5JylyZXR1cm4gYXJyYXlTbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHZhciBzdGFydCAgPSB0b0luZGV4KGJlZ2luLCBsZW4pXG4gICAgICAsIHVwVG8gICA9IHRvSW5kZXgoZW5kLCBsZW4pXG4gICAgICAsIHNpemUgICA9IHRvTGVuZ3RoKHVwVG8gLSBzdGFydClcbiAgICAgICwgY2xvbmVkID0gQXJyYXkoc2l6ZSlcbiAgICAgICwgaSAgICAgID0gMDtcbiAgICBmb3IoOyBpIDwgc2l6ZTsgaSsrKWNsb25lZFtpXSA9IGtsYXNzID09ICdTdHJpbmcnXG4gICAgICA/IHRoaXMuY2hhckF0KHN0YXJ0ICsgaSlcbiAgICAgIDogdGhpc1tzdGFydCArIGldO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkc29tZSAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDMpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uc29tZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjIzIC8gMTUuNC40LjE3IEFycmF5LnByb3RvdHlwZS5zb21lKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkc29tZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCB0b09iamVjdCAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGZhaWxzICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCAkc29ydCAgICAgPSBbXS5zb3J0XG4gICwgdGVzdCAgICAgID0gWzEsIDIsIDNdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbigpe1xuICAvLyBJRTgtXG4gIHRlc3Quc29ydCh1bmRlZmluZWQpO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gIC8vIFY4IGJ1Z1xuICB0ZXN0LnNvcnQobnVsbCk7XG4gIC8vIE9sZCBXZWJLaXRcbn0pIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJHNvcnQpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjUgQXJyYXkucHJvdG90eXBlLnNvcnQoY29tcGFyZWZuKVxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbil7XG4gICAgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcykpXG4gICAgICA6ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcyksIGFGdW5jdGlvbihjb21wYXJlZm4pKTtcbiAgfVxufSk7IiwicmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnQXJyYXknKTsiLCIvLyAyMC4zLjMuMSAvIDE1LjkuNC40IERhdGUubm93KClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRGF0ZScsIHtub3c6IGZ1bmN0aW9uKCl7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfX0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIwLjMuNC4zNiAvIDE1LjkuNS40MyBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBnZXRUaW1lID0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZTtcblxudmFyIGx6ID0gZnVuY3Rpb24obnVtKXtcbiAgcmV0dXJuIG51bSA+IDkgPyBudW0gOiAnMCcgKyBudW07XG59O1xuXG4vLyBQaGFudG9tSlMgLyBvbGQgV2ViS2l0IGhhcyBhIGJyb2tlbiBpbXBsZW1lbnRhdGlvbnNcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBuZXcgRGF0ZSgtNWUxMyAtIDEpLnRvSVNPU3RyaW5nKCkgIT0gJzAzODUtMDctMjVUMDc6MDY6MzkuOTk5Wic7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgbmV3IERhdGUoTmFOKS50b0lTT1N0cmluZygpO1xufSkpLCAnRGF0ZScsIHtcbiAgdG9JU09TdHJpbmc6IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCl7XG4gICAgaWYoIWlzRmluaXRlKGdldFRpbWUuY2FsbCh0aGlzKSkpdGhyb3cgUmFuZ2VFcnJvcignSW52YWxpZCB0aW1lIHZhbHVlJyk7XG4gICAgdmFyIGQgPSB0aGlzXG4gICAgICAsIHkgPSBkLmdldFVUQ0Z1bGxZZWFyKClcbiAgICAgICwgbSA9IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKClcbiAgICAgICwgcyA9IHkgPCAwID8gJy0nIDogeSA+IDk5OTkgPyAnKycgOiAnJztcbiAgICByZXR1cm4gcyArICgnMDAwMDAnICsgTWF0aC5hYnMoeSkpLnNsaWNlKHMgPyAtNiA6IC00KSArXG4gICAgICAnLScgKyBseihkLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArIGx6KGQuZ2V0VVRDRGF0ZSgpKSArXG4gICAgICAnVCcgKyBseihkLmdldFVUQ0hvdXJzKCkpICsgJzonICsgbHooZC5nZXRVVENNaW51dGVzKCkpICtcbiAgICAgICc6JyArIGx6KGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChtID4gOTkgPyBtIDogJzAnICsgbHoobSkpICsgJ1onO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIG5ldyBEYXRlKE5hTikudG9KU09OKCkgIT09IG51bGwgfHwgRGF0ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoe3RvSVNPU3RyaW5nOiBmdW5jdGlvbigpeyByZXR1cm4gMTsgfX0pICE9PSAxO1xufSksICdEYXRlJywge1xuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTihrZXkpe1xuICAgIHZhciBPICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIHB2ID0gdG9QcmltaXRpdmUoTyk7XG4gICAgcmV0dXJuIHR5cGVvZiBwdiA9PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUocHYpID8gbnVsbCA6IE8udG9JU09TdHJpbmcoKTtcbiAgfVxufSk7IiwidmFyIFRPX1BSSU1JVElWRSA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1ByaW1pdGl2ZScpXG4gICwgcHJvdG8gICAgICAgID0gRGF0ZS5wcm90b3R5cGU7XG5cbmlmKCEoVE9fUFJJTUlUSVZFIGluIHByb3RvKSlyZXF1aXJlKCcuL19oaWRlJykocHJvdG8sIFRPX1BSSU1JVElWRSwgcmVxdWlyZSgnLi9fZGF0ZS10by1wcmltaXRpdmUnKSk7IiwidmFyIERhdGVQcm90byAgICA9IERhdGUucHJvdG90eXBlXG4gICwgSU5WQUxJRF9EQVRFID0gJ0ludmFsaWQgRGF0ZSdcbiAgLCBUT19TVFJJTkcgICAgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nICAgID0gRGF0ZVByb3RvW1RPX1NUUklOR11cbiAgLCBnZXRUaW1lICAgICAgPSBEYXRlUHJvdG8uZ2V0VGltZTtcbmlmKG5ldyBEYXRlKE5hTikgKyAnJyAhPSBJTlZBTElEX0RBVEUpe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKERhdGVQcm90bywgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHZhciB2YWx1ZSA9IGdldFRpbWUuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gJHRvU3RyaW5nLmNhbGwodGhpcykgOiBJTlZBTElEX0RBVEU7XG4gIH0pO1xufSIsIi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnRnVuY3Rpb24nLCB7YmluZDogcmVxdWlyZSgnLi9fYmluZCcpfSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIEhBU19JTlNUQU5DRSAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2hhc0luc3RhbmNlJylcbiAgLCBGdW5jdGlvblByb3RvICA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIDE5LjIuMy42IEZ1bmN0aW9uLnByb3RvdHlwZVtAQGhhc0luc3RhbmNlXShWKVxuaWYoIShIQVNfSU5TVEFOQ0UgaW4gRnVuY3Rpb25Qcm90bykpcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihGdW5jdGlvblByb3RvLCBIQVNfSU5TVEFOQ0UsIHt2YWx1ZTogZnVuY3Rpb24oTyl7XG4gIGlmKHR5cGVvZiB0aGlzICE9ICdmdW5jdGlvbicgfHwgIWlzT2JqZWN0KE8pKXJldHVybiBmYWxzZTtcbiAgaWYoIWlzT2JqZWN0KHRoaXMucHJvdG90eXBlKSlyZXR1cm4gTyBpbnN0YW5jZW9mIHRoaXM7XG4gIC8vIGZvciBlbnZpcm9ubWVudCB3L28gbmF0aXZlIGBAQGhhc0luc3RhbmNlYCBsb2dpYyBlbm91Z2ggYGluc3RhbmNlb2ZgLCBidXQgYWRkIHRoaXM6XG4gIHdoaWxlKE8gPSBnZXRQcm90b3R5cGVPZihPKSlpZih0aGlzLnByb3RvdHlwZSA9PT0gTylyZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufX0pOyIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBoYXMgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBGUHJvdG8gICAgID0gRnVuY3Rpb24ucHJvdG90eXBlXG4gICwgbmFtZVJFICAgICA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopL1xuICAsIE5BTUUgICAgICAgPSAnbmFtZSc7XG5cbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gMTkuMi40LjIgbmFtZVxuTkFNRSBpbiBGUHJvdG8gfHwgcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiBkUChGUHJvdG8sIE5BTUUsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgICAsIG5hbWUgPSAoJycgKyB0aGF0KS5tYXRjaChuYW1lUkUpWzFdO1xuICAgICAgaGFzKHRoYXQsIE5BTUUpIHx8ICFpc0V4dGVuc2libGUodGhhdCkgfHwgZFAodGhhdCwgTkFNRSwgY3JlYXRlRGVzYyg1LCBuYW1lKSk7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdNYXAnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTsiLCIvLyAyMC4yLjIuMyBNYXRoLmFjb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgbG9nMXAgICA9IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKVxuICAsIHNxcnQgICAgPSBNYXRoLnNxcnRcbiAgLCAkYWNvc2ggID0gTWF0aC5hY29zaDtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhY29zaFxuICAvLyBWOCBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNTA5XG4gICYmIE1hdGguZmxvb3IoJGFjb3NoKE51bWJlci5NQVhfVkFMVUUpKSA9PSA3MTBcbiAgLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFjb3NoKEluZmluaXR5KSAtPiBOYU4gXG4gICYmICRhY29zaChJbmZpbml0eSkgPT0gSW5maW5pdHlcbiksICdNYXRoJywge1xuICBhY29zaDogZnVuY3Rpb24gYWNvc2goeCl7XG4gICAgcmV0dXJuICh4ID0gK3gpIDwgMSA/IE5hTiA6IHggPiA5NDkwNjI2NS42MjQyNTE1NlxuICAgICAgPyBNYXRoLmxvZyh4KSArIE1hdGguTE4yXG4gICAgICA6IGxvZzFwKHggLSAxICsgc3FydCh4IC0gMSkgKiBzcXJ0KHggKyAxKSk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi41IE1hdGguYXNpbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXNpbmggID0gTWF0aC5hc2luaDtcblxuZnVuY3Rpb24gYXNpbmgoeCl7XG4gIHJldHVybiAhaXNGaW5pdGUoeCA9ICt4KSB8fCB4ID09IDAgPyB4IDogeCA8IDAgPyAtYXNpbmgoLXgpIDogTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCArIDEpKTtcbn1cblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFzaW5oKDApIC0+IC0wIFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhc2luaCAmJiAxIC8gJGFzaW5oKDApID4gMCksICdNYXRoJywge2FzaW5oOiBhc2luaH0pOyIsIi8vIDIwLjIuMi43IE1hdGguYXRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXRhbmggID0gTWF0aC5hdGFuaDtcblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmF0YW5oKC0wKSAtPiAwIFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhdGFuaCAmJiAxIC8gJGF0YW5oKC0wKSA8IDApLCAnTWF0aCcsIHtcbiAgYXRhbmg6IGZ1bmN0aW9uIGF0YW5oKHgpe1xuICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IE1hdGgubG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi45IE1hdGguY2JydCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNpZ24gICAgPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjYnJ0OiBmdW5jdGlvbiBjYnJ0KHgpe1xuICAgIHJldHVybiBzaWduKHggPSAreCkgKiBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMSAvIDMpO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMTEgTWF0aC5jbHozMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjbHozMjogZnVuY3Rpb24gY2x6MzIoeCl7XG4gICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMSAtIE1hdGguZmxvb3IoTWF0aC5sb2coeCArIDAuNSkgKiBNYXRoLkxPRzJFKSA6IDMyO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMTIgTWF0aC5jb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwICAgICA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNvc2g6IGZ1bmN0aW9uIGNvc2goeCl7XG4gICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZXhwbTEgID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICgkZXhwbTEgIT0gTWF0aC5leHBtMSksICdNYXRoJywge2V4cG0xOiAkZXhwbTF9KTsiLCIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNpZ24gICAgICA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpXG4gICwgcG93ICAgICAgID0gTWF0aC5wb3dcbiAgLCBFUFNJTE9OICAgPSBwb3coMiwgLTUyKVxuICAsIEVQU0lMT04zMiA9IHBvdygyLCAtMjMpXG4gICwgTUFYMzIgICAgID0gcG93KDIsIDEyNykgKiAoMiAtIEVQU0lMT04zMilcbiAgLCBNSU4zMiAgICAgPSBwb3coMiwgLTEyNik7XG5cbnZhciByb3VuZFRpZXNUb0V2ZW4gPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIG4gKyAxIC8gRVBTSUxPTiAtIDEgLyBFUFNJTE9OO1xufTtcblxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGZyb3VuZDogZnVuY3Rpb24gZnJvdW5kKHgpe1xuICAgIHZhciAkYWJzICA9IE1hdGguYWJzKHgpXG4gICAgICAsICRzaWduID0gc2lnbih4KVxuICAgICAgLCBhLCByZXN1bHQ7XG4gICAgaWYoJGFicyA8IE1JTjMyKXJldHVybiAkc2lnbiAqIHJvdW5kVGllc1RvRXZlbigkYWJzIC8gTUlOMzIgLyBFUFNJTE9OMzIpICogTUlOMzIgKiBFUFNJTE9OMzI7XG4gICAgYSA9ICgxICsgRVBTSUxPTjMyIC8gRVBTSUxPTikgKiAkYWJzO1xuICAgIHJlc3VsdCA9IGEgLSAoYSAtICRhYnMpO1xuICAgIGlmKHJlc3VsdCA+IE1BWDMyIHx8IHJlc3VsdCAhPSByZXN1bHQpcmV0dXJuICRzaWduICogSW5maW5pdHk7XG4gICAgcmV0dXJuICRzaWduICogcmVzdWx0O1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMTcgTWF0aC5oeXBvdChbdmFsdWUxWywgdmFsdWUyWywg4oCmIF1dXSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhYnMgICAgID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaHlwb3Q6IGZ1bmN0aW9uIGh5cG90KHZhbHVlMSwgdmFsdWUyKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdW0gID0gMFxuICAgICAgLCBpICAgID0gMFxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBsYXJnID0gMFxuICAgICAgLCBhcmcsIGRpdjtcbiAgICB3aGlsZShpIDwgYUxlbil7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuICAgICAgaWYobGFyZyA8IGFyZyl7XG4gICAgICAgIGRpdiAgPSBsYXJnIC8gYXJnO1xuICAgICAgICBzdW0gID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZihhcmcgPiAwKXtcbiAgICAgICAgZGl2ICA9IGFyZyAvIGxhcmc7XG4gICAgICAgIHN1bSArPSBkaXYgKiBkaXY7XG4gICAgICB9IGVsc2Ugc3VtICs9IGFyZztcbiAgICB9XG4gICAgcmV0dXJuIGxhcmcgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBsYXJnICogTWF0aC5zcXJ0KHN1bSk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4xOCBNYXRoLmltdWwoeCwgeSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkaW11bCAgID0gTWF0aC5pbXVsO1xuXG4vLyBzb21lIFdlYktpdCB2ZXJzaW9ucyBmYWlscyB3aXRoIGJpZyBudW1iZXJzLCBzb21lIGhhcyB3cm9uZyBhcml0eVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiAkaW11bCgweGZmZmZmZmZmLCA1KSAhPSAtNSB8fCAkaW11bC5sZW5ndGggIT0gMjtcbn0pLCAnTWF0aCcsIHtcbiAgaW11bDogZnVuY3Rpb24gaW11bCh4LCB5KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsIHhuID0gK3hcbiAgICAgICwgeW4gPSAreVxuICAgICAgLCB4bCA9IFVJTlQxNiAmIHhuXG4gICAgICAsIHlsID0gVUlOVDE2ICYgeW47XG4gICAgcmV0dXJuIDAgfCB4bCAqIHlsICsgKChVSU5UMTYgJiB4biA+Pj4gMTYpICogeWwgKyB4bCAqIChVSU5UMTYgJiB5biA+Pj4gMTYpIDw8IDE2ID4+PiAwKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjIxIE1hdGgubG9nMTAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMTA6IGZ1bmN0aW9uIGxvZzEwKHgpe1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtsb2cxcDogcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpfSk7IiwiLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpe1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4yO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7c2lnbjogcmVxdWlyZSgnLi9fbWF0aC1zaWduJyl9KTsiLCIvLyAyMC4yLjIuMzAgTWF0aC5zaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwbTEgICA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKVxuICAsIGV4cCAgICAgPSBNYXRoLmV4cDtcblxuLy8gVjggbmVhciBDaHJvbWl1bSAzOCBoYXMgYSBwcm9ibGVtIHdpdGggdmVyeSBzbWFsbCBudW1iZXJzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuICFNYXRoLnNpbmgoLTJlLTE3KSAhPSAtMmUtMTc7XG59KSwgJ01hdGgnLCB7XG4gIHNpbmg6IGZ1bmN0aW9uIHNpbmgoeCl7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggPSAreCkgPCAxXG4gICAgICA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyXG4gICAgICA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKE1hdGguRSAvIDIpO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMzMgTWF0aC50YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwbTEgICA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKVxuICAsIGV4cCAgICAgPSBNYXRoLmV4cDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0YW5oOiBmdW5jdGlvbiB0YW5oKHgpe1xuICAgIHZhciBhID0gZXhwbTEoeCA9ICt4KVxuICAgICAgLCBiID0gZXhwbTEoLXgpO1xuICAgIHJldHVybiBhID09IEluZmluaXR5ID8gMSA6IGIgPT0gSW5maW5pdHkgPyAtMSA6IChhIC0gYikgLyAoZXhwKHgpICsgZXhwKC14KSk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4zNCBNYXRoLnRydW5jKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRydW5jOiBmdW5jdGlvbiB0cnVuYyhpdCl7XG4gICAgcmV0dXJuIChpdCA+IDAgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsKShpdCk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIGNvZiAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKVxuICAsIHRvUHJpbWl0aXZlICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBmYWlscyAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBnT1BOICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIGdPUEQgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mXG4gICwgZFAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgJHRyaW0gICAgICAgICAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW1cbiAgLCBOVU1CRVIgICAgICAgICAgICA9ICdOdW1iZXInXG4gICwgJE51bWJlciAgICAgICAgICAgPSBnbG9iYWxbTlVNQkVSXVxuICAsIEJhc2UgICAgICAgICAgICAgID0gJE51bWJlclxuICAsIHByb3RvICAgICAgICAgICAgID0gJE51bWJlci5wcm90b3R5cGVcbiAgLy8gT3BlcmEgfjEyIGhhcyBicm9rZW4gT2JqZWN0I3RvU3RyaW5nXG4gICwgQlJPS0VOX0NPRiAgICAgICAgPSBjb2YocmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpKHByb3RvKSkgPT0gTlVNQkVSXG4gICwgVFJJTSAgICAgICAgICAgICAgPSAndHJpbScgaW4gU3RyaW5nLnByb3RvdHlwZTtcblxuLy8gNy4xLjMgVG9OdW1iZXIoYXJndW1lbnQpXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbihhcmd1bWVudCl7XG4gIHZhciBpdCA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCBmYWxzZSk7XG4gIGlmKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyKXtcbiAgICBpdCA9IFRSSU0gPyBpdC50cmltKCkgOiAkdHJpbShpdCwgMyk7XG4gICAgdmFyIGZpcnN0ID0gaXQuY2hhckNvZGVBdCgwKVxuICAgICAgLCB0aGlyZCwgcmFkaXgsIG1heENvZGU7XG4gICAgaWYoZmlyc3QgPT09IDQzIHx8IGZpcnN0ID09PSA0NSl7XG4gICAgICB0aGlyZCA9IGl0LmNoYXJDb2RlQXQoMik7XG4gICAgICBpZih0aGlyZCA9PT0gODggfHwgdGhpcmQgPT09IDEyMClyZXR1cm4gTmFOOyAvLyBOdW1iZXIoJysweDEnKSBzaG91bGQgYmUgTmFOLCBvbGQgVjggZml4XG4gICAgfSBlbHNlIGlmKGZpcnN0ID09PSA0OCl7XG4gICAgICBzd2l0Y2goaXQuY2hhckNvZGVBdCgxKSl7XG4gICAgICAgIGNhc2UgNjYgOiBjYXNlIDk4ICA6IHJhZGl4ID0gMjsgbWF4Q29kZSA9IDQ5OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBiWzAxXSskL2lcbiAgICAgICAgY2FzZSA3OSA6IGNhc2UgMTExIDogcmFkaXggPSA4OyBtYXhDb2RlID0gNTU7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMG9bMC03XSskL2lcbiAgICAgICAgZGVmYXVsdCA6IHJldHVybiAraXQ7XG4gICAgICB9XG4gICAgICBmb3IodmFyIGRpZ2l0cyA9IGl0LnNsaWNlKDIpLCBpID0gMCwgbCA9IGRpZ2l0cy5sZW5ndGgsIGNvZGU7IGkgPCBsOyBpKyspe1xuICAgICAgICBjb2RlID0gZGlnaXRzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIC8vIHBhcnNlSW50IHBhcnNlcyBhIHN0cmluZyB0byBhIGZpcnN0IHVuYXZhaWxhYmxlIHN5bWJvbFxuICAgICAgICAvLyBidXQgVG9OdW1iZXIgc2hvdWxkIHJldHVybiBOYU4gaWYgYSBzdHJpbmcgY29udGFpbnMgdW5hdmFpbGFibGUgc3ltYm9sc1xuICAgICAgICBpZihjb2RlIDwgNDggfHwgY29kZSA+IG1heENvZGUpcmV0dXJuIE5hTjtcbiAgICAgIH0gcmV0dXJuIHBhcnNlSW50KGRpZ2l0cywgcmFkaXgpO1xuICAgIH1cbiAgfSByZXR1cm4gK2l0O1xufTtcblxuaWYoISROdW1iZXIoJyAwbzEnKSB8fCAhJE51bWJlcignMGIxJykgfHwgJE51bWJlcignKzB4MScpKXtcbiAgJE51bWJlciA9IGZ1bmN0aW9uIE51bWJlcih2YWx1ZSl7XG4gICAgdmFyIGl0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgPyAwIDogdmFsdWVcbiAgICAgICwgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIHRoYXQgaW5zdGFuY2VvZiAkTnVtYmVyXG4gICAgICAvLyBjaGVjayBvbiAxLi5jb25zdHJ1Y3Rvcihmb28pIGNhc2VcbiAgICAgICYmIChCUk9LRU5fQ09GID8gZmFpbHMoZnVuY3Rpb24oKXsgcHJvdG8udmFsdWVPZi5jYWxsKHRoYXQpOyB9KSA6IGNvZih0aGF0KSAhPSBOVU1CRVIpXG4gICAgICAgID8gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UodG9OdW1iZXIoaXQpKSwgdGhhdCwgJE51bWJlcikgOiB0b051bWJlcihpdCk7XG4gIH07XG4gIGZvcih2YXIga2V5cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BOKEJhc2UpIDogKFxuICAgIC8vIEVTMzpcbiAgICAnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFksJyArXG4gICAgLy8gRVM2IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVM2IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICAgJ0VQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUiwnICtcbiAgICAnTUlOX1NBRkVfSU5URUdFUixwYXJzZUZsb2F0LHBhcnNlSW50LGlzSW50ZWdlcidcbiAgKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKyl7XG4gICAgaWYoaGFzKEJhc2UsIGtleSA9IGtleXNbal0pICYmICFoYXMoJE51bWJlciwga2V5KSl7XG4gICAgICBkUCgkTnVtYmVyLCBrZXksIGdPUEQoQmFzZSwga2V5KSk7XG4gICAgfVxuICB9XG4gICROdW1iZXIucHJvdG90eXBlID0gcHJvdG87XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJE51bWJlcjtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsIE5VTUJFUiwgJE51bWJlcik7XG59IiwiLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge0VQU0lMT046IE1hdGgucG93KDIsIC01Mil9KTsiLCIvLyAyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUobnVtYmVyKVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgX2lzRmluaXRlID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuaXNGaW5pdGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpe1xuICAgIHJldHVybiB0eXBlb2YgaXQgPT0gJ251bWJlcicgJiYgX2lzRmluaXRlKGl0KTtcbiAgfVxufSk7IiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtpc0ludGVnZXI6IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKX0pOyIsIi8vIDIwLjEuMi40IE51bWJlci5pc05hTihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcil7XG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pOyIsIi8vIDIwLjEuMi41IE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKVxuICAsIGFicyAgICAgICA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNTYWZlSW50ZWdlcjogZnVuY3Rpb24gaXNTYWZlSW50ZWdlcihudW1iZXIpe1xuICAgIHJldHVybiBpc0ludGVnZXIobnVtYmVyKSAmJiBhYnMobnVtYmVyKSA8PSAweDFmZmZmZmZmZmZmZmZmO1xuICB9XG59KTsiLCIvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7TUFYX1NBRkVfSU5URUdFUjogMHgxZmZmZmZmZmZmZmZmZn0pOyIsIi8vIDIwLjEuMi4xMCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7TUlOX1NBRkVfSU5URUdFUjogLTB4MWZmZmZmZmZmZmZmZmZ9KTsiLCJ2YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDIwLjEuMi4xMiBOdW1iZXIucGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksICdOdW1iZXInLCB7cGFyc2VGbG9hdDogJHBhcnNlRmxvYXR9KTsiLCJ2YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDIwLjEuMi4xMyBOdW1iZXIucGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUludCAhPSAkcGFyc2VJbnQpLCAnTnVtYmVyJywge3BhcnNlSW50OiAkcGFyc2VJbnR9KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0ludGVnZXIgICAgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBhTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL19hLW51bWJlci12YWx1ZScpXG4gICwgcmVwZWF0ICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG4gICwgJHRvRml4ZWQgICAgID0gMS4udG9GaXhlZFxuICAsIGZsb29yICAgICAgICA9IE1hdGguZmxvb3JcbiAgLCBkYXRhICAgICAgICAgPSBbMCwgMCwgMCwgMCwgMCwgMF1cbiAgLCBFUlJPUiAgICAgICAgPSAnTnVtYmVyLnRvRml4ZWQ6IGluY29ycmVjdCBpbnZvY2F0aW9uISdcbiAgLCBaRVJPICAgICAgICAgPSAnMCc7XG5cbnZhciBtdWx0aXBseSA9IGZ1bmN0aW9uKG4sIGMpe1xuICB2YXIgaSAgPSAtMVxuICAgICwgYzIgPSBjO1xuICB3aGlsZSgrK2kgPCA2KXtcbiAgICBjMiArPSBuICogZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gYzIgJSAxZTc7XG4gICAgYzIgPSBmbG9vcihjMiAvIDFlNyk7XG4gIH1cbn07XG52YXIgZGl2aWRlID0gZnVuY3Rpb24obil7XG4gIHZhciBpID0gNlxuICAgICwgYyA9IDA7XG4gIHdoaWxlKC0taSA+PSAwKXtcbiAgICBjICs9IGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGZsb29yKGMgLyBuKTtcbiAgICBjID0gKGMgJSBuKSAqIDFlNztcbiAgfVxufTtcbnZhciBudW1Ub1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpID0gNlxuICAgICwgcyA9ICcnO1xuICB3aGlsZSgtLWkgPj0gMCl7XG4gICAgaWYocyAhPT0gJycgfHwgaSA9PT0gMCB8fCBkYXRhW2ldICE9PSAwKXtcbiAgICAgIHZhciB0ID0gU3RyaW5nKGRhdGFbaV0pO1xuICAgICAgcyA9IHMgPT09ICcnID8gdCA6IHMgKyByZXBlYXQuY2FsbChaRVJPLCA3IC0gdC5sZW5ndGgpICsgdDtcbiAgICB9XG4gIH0gcmV0dXJuIHM7XG59O1xudmFyIHBvdyA9IGZ1bmN0aW9uKHgsIG4sIGFjYyl7XG4gIHJldHVybiBuID09PSAwID8gYWNjIDogbiAlIDIgPT09IDEgPyBwb3coeCwgbiAtIDEsIGFjYyAqIHgpIDogcG93KHggKiB4LCBuIC8gMiwgYWNjKTtcbn07XG52YXIgbG9nID0gZnVuY3Rpb24oeCl7XG4gIHZhciBuICA9IDBcbiAgICAsIHgyID0geDtcbiAgd2hpbGUoeDIgPj0gNDA5Nil7XG4gICAgbiArPSAxMjtcbiAgICB4MiAvPSA0MDk2O1xuICB9XG4gIHdoaWxlKHgyID49IDIpe1xuICAgIG4gICs9IDE7XG4gICAgeDIgLz0gMjtcbiAgfSByZXR1cm4gbjtcbn07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCEhJHRvRml4ZWQgJiYgKFxuICAwLjAwMDA4LnRvRml4ZWQoMykgIT09ICcwLjAwMCcgfHxcbiAgMC45LnRvRml4ZWQoMCkgIT09ICcxJyB8fFxuICAxLjI1NS50b0ZpeGVkKDIpICE9PSAnMS4yNScgfHxcbiAgMTAwMDAwMDAwMDAwMDAwMDEyOC4udG9GaXhlZCgwKSAhPT0gJzEwMDAwMDAwMDAwMDAwMDAxMjgnXG4pIHx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIC8vIFY4IH4gQW5kcm9pZCA0LjMtXG4gICR0b0ZpeGVkLmNhbGwoe30pO1xufSkpLCAnTnVtYmVyJywge1xuICB0b0ZpeGVkOiBmdW5jdGlvbiB0b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKXtcbiAgICB2YXIgeCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCBFUlJPUilcbiAgICAgICwgZiA9IHRvSW50ZWdlcihmcmFjdGlvbkRpZ2l0cylcbiAgICAgICwgcyA9ICcnXG4gICAgICAsIG0gPSBaRVJPXG4gICAgICAsIGUsIHosIGosIGs7XG4gICAgaWYoZiA8IDAgfHwgZiA+IDIwKXRocm93IFJhbmdlRXJyb3IoRVJST1IpO1xuICAgIGlmKHggIT0geClyZXR1cm4gJ05hTic7XG4gICAgaWYoeCA8PSAtMWUyMSB8fCB4ID49IDFlMjEpcmV0dXJuIFN0cmluZyh4KTtcbiAgICBpZih4IDwgMCl7XG4gICAgICBzID0gJy0nO1xuICAgICAgeCA9IC14O1xuICAgIH1cbiAgICBpZih4ID4gMWUtMjEpe1xuICAgICAgZSA9IGxvZyh4ICogcG93KDIsIDY5LCAxKSkgLSA2OTtcbiAgICAgIHogPSBlIDwgMCA/IHggKiBwb3coMiwgLWUsIDEpIDogeCAvIHBvdygyLCBlLCAxKTtcbiAgICAgIHogKj0gMHgxMDAwMDAwMDAwMDAwMDtcbiAgICAgIGUgPSA1MiAtIGU7XG4gICAgICBpZihlID4gMCl7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBqID0gZjtcbiAgICAgICAgd2hpbGUoaiA+PSA3KXtcbiAgICAgICAgICBtdWx0aXBseSgxZTcsIDApO1xuICAgICAgICAgIGogLT0gNztcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseShwb3coMTAsIGosIDEpLCAwKTtcbiAgICAgICAgaiA9IGUgLSAxO1xuICAgICAgICB3aGlsZShqID49IDIzKXtcbiAgICAgICAgICBkaXZpZGUoMSA8PCAyMyk7XG4gICAgICAgICAgaiAtPSAyMztcbiAgICAgICAgfVxuICAgICAgICBkaXZpZGUoMSA8PCBqKTtcbiAgICAgICAgbXVsdGlwbHkoMSwgMSk7XG4gICAgICAgIGRpdmlkZSgyKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgbXVsdGlwbHkoMSA8PCAtZSwgMCk7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpICsgcmVwZWF0LmNhbGwoWkVSTywgZik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKGYgPiAwKXtcbiAgICAgIGsgPSBtLmxlbmd0aDtcbiAgICAgIG0gPSBzICsgKGsgPD0gZiA/ICcwLicgKyByZXBlYXQuY2FsbChaRVJPLCBmIC0gaykgKyBtIDogbS5zbGljZSgwLCBrIC0gZikgKyAnLicgKyBtLnNsaWNlKGsgLSBmKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBzICsgbTtcbiAgICB9IHJldHVybiBtO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmFpbHMgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKVxuICAsICR0b1ByZWNpc2lvbiA9IDEuLnRvUHJlY2lzaW9uO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICgkZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gSUU3LVxuICByZXR1cm4gJHRvUHJlY2lzaW9uLmNhbGwoMSwgdW5kZWZpbmVkKSAhPT0gJzEnO1xufSkgfHwgISRmYWlscyhmdW5jdGlvbigpe1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9QcmVjaXNpb24uY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvUHJlY2lzaW9uOiBmdW5jdGlvbiB0b1ByZWNpc2lvbihwcmVjaXNpb24pe1xuICAgIHZhciB0aGF0ID0gYU51bWJlclZhbHVlKHRoaXMsICdOdW1iZXIjdG9QcmVjaXNpb246IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICAgIHJldHVybiBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQpIDogJHRvUHJlY2lzaW9uLmNhbGwodGhhdCwgcHJlY2lzaW9uKTsgXG4gIH1cbn0pOyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKX0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jylcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7Y3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyl9KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjMgLyAxNS4yLjMuNyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0aWVzOiByZXF1aXJlKCcuL19vYmplY3QtZHBzJyl9KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZ9KTsiLCIvLyAxOS4xLjIuNSBPYmplY3QuZnJlZXplKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIG1ldGEgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2ZyZWV6ZScsIGZ1bmN0aW9uKCRmcmVlemUpe1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KXtcbiAgICByZXR1cm4gJGZyZWV6ZSAmJiBpc09iamVjdChpdCkgPyAkZnJlZXplKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5TmFtZXMnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JykuZjtcbn0pOyIsIi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KXtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTEgT2JqZWN0LmlzRXh0ZW5zaWJsZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNFeHRlbnNpYmxlJywgZnVuY3Rpb24oJGlzRXh0ZW5zaWJsZSl7XG4gIHJldHVybiBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZShpdCkgOiB0cnVlIDogZmFsc2U7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTIgT2JqZWN0LmlzRnJvemVuKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0Zyb3plbicsIGZ1bmN0aW9uKCRpc0Zyb3plbil7XG4gIHJldHVybiBmdW5jdGlvbiBpc0Zyb3plbihpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0Zyb3plbiA/ICRpc0Zyb3plbihpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTMgT2JqZWN0LmlzU2VhbGVkKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc1NlYWxlZCcsIGZ1bmN0aW9uKCRpc1NlYWxlZCl7XG4gIHJldHVybiBmdW5jdGlvbiBpc1NlYWxlZChpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc1NlYWxlZCA/ICRpc1NlYWxlZChpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTsiLCIvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2lzOiByZXF1aXJlKCcuL19zYW1lLXZhbHVlJyl9KTsiLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgJGtleXMgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIG1ldGEgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3ByZXZlbnRFeHRlbnNpb25zJywgZnVuY3Rpb24oJHByZXZlbnRFeHRlbnNpb25zKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKGl0KXtcbiAgICByZXR1cm4gJHByZXZlbnRFeHRlbnNpb25zICYmIGlzT2JqZWN0KGl0KSA/ICRwcmV2ZW50RXh0ZW5zaW9ucyhtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBtZXRhICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdzZWFsJywgZnVuY3Rpb24oJHNlYWwpe1xuICByZXR1cm4gZnVuY3Rpb24gc2VhbChpdCl7XG4gICAgcmV0dXJuICRzZWFsICYmIGlzT2JqZWN0KGl0KSA/ICRzZWFsKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7IiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0fSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIHRlc3QgICAgPSB7fTtcbnRlc3RbcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyldID0gJ3onO1xuaWYodGVzdCArICcnICE9ICdbb2JqZWN0IHpdJyl7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG4gIH0sIHRydWUpO1xufSIsInZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpO1xuLy8gMTguMi40IHBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksIHtwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdH0pOyIsInZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpO1xuLy8gMTguMi41IHBhcnNlSW50KHN0cmluZywgcmFkaXgpXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUludCAhPSAkcGFyc2VJbnQpLCB7cGFyc2VJbnQ6ICRwYXJzZUludH0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2xhc3NvZiAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgJGV4cG9ydCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc09iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuSW5zdGFuY2UgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBmb3JPZiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKVxuICAsIHRhc2sgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBtaWNyb3Rhc2sgICAgICAgICAgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpXG4gICwgUFJPTUlTRSAgICAgICAgICAgID0gJ1Byb21pc2UnXG4gICwgVHlwZUVycm9yICAgICAgICAgID0gZ2xvYmFsLlR5cGVFcnJvclxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgJFByb21pc2UgICAgICAgICAgID0gZ2xvYmFsW1BST01JU0VdXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBpc05vZGUgICAgICAgICAgICAgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJ1xuICAsIGVtcHR5ICAgICAgICAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBJbnRlcm5hbCwgR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSAgICAgPSAkUHJvbWlzZS5yZXNvbHZlKDEpXG4gICAgICAsIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbihleGVjKXsgZXhlYyhlbXB0eSwgZW1wdHkpOyB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgc2FtZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24oYSwgYil7XG4gIC8vIHdpdGggbGlicmFyeSB3cmFwcGVyIHNwZWNpYWwgY2FzZVxuICByZXR1cm4gYSA9PT0gYiB8fCBhID09PSAkUHJvbWlzZSAmJiBiID09PSBXcmFwcGVyO1xufTtcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICByZXR1cm4gc2FtZUNvbnN0cnVjdG9yKCRQcm9taXNlLCBDKVxuICAgID8gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgOiBuZXcgR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IEdlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbigkJHJlc29sdmUsICQkcmVqZWN0KXtcbiAgICBpZihyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ICA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCAgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn07XG52YXIgcGVyZm9ybSA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIGV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4ge2Vycm9yOiBlfTtcbiAgfVxufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbihwcm9taXNlLCBpc1JlamVjdCl7XG4gIGlmKHByb21pc2UuX24pcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBvayAgICA9IHByb21pc2UuX3MgPT0gMVxuICAgICAgLCBpICAgICA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uKHJlYWN0aW9uKXtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWxcbiAgICAgICAgLCByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZVxuICAgICAgICAsIHJlamVjdCAgPSByZWFjdGlvbi5yZWplY3RcbiAgICAgICAgLCBkb21haW4gID0gcmVhY3Rpb24uZG9tYWluXG4gICAgICAgICwgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgICAgaWYoIW9rKXtcbiAgICAgICAgICAgIGlmKHByb21pc2UuX2ggPT0gMilvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihoYW5kbGVyID09PSB0cnVlKXJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYoZG9tYWluKWRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKXtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpe1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbigpe1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3ZcbiAgICAgICwgYWJydXB0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmKGlzVW5oYW5kbGVkKHByb21pc2UpKXtcbiAgICAgIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoaXNOb2RlKXtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pe1xuICAgICAgICAgIGhhbmRsZXIoe3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWV9KTtcbiAgICAgICAgfSBlbHNlIGlmKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3Ipe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZihhYnJ1cHQpdGhyb3cgYWJydXB0LmVycm9yO1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgaWYocHJvbWlzZS5faCA9PSAxKXJldHVybiBmYWxzZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jXG4gICAgLCBpICAgICA9IDBcbiAgICAsIHJlYWN0aW9uO1xuICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXtcbiAgICByZWFjdGlvbiA9IGNoYWluW2krK107XG4gICAgaWYocmVhY3Rpb24uZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3Rpb24ucHJvbWlzZSkpcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbigpe1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmKGlzTm9kZSl7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpe1xuICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92fSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZihwcm9taXNlLl9kKXJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZighcHJvbWlzZS5fYSlwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xuICBub3RpZnkocHJvbWlzZSwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXNcbiAgICAsIHRoZW47XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYocHJvbWlzZSA9PT0gdmFsdWUpdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKXtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgICAgICB2YXIgd3JhcHBlciA9IHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoKGUpe1xuICAgICRyZWplY3QuY2FsbCh7X3c6IHByb21pc2UsIF9kOiBmYWxzZX0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZighVVNFX05BVElWRSl7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcil7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpe1xuICAgICAgdmFyIHJlYWN0aW9uICAgID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayAgICAgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgICA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHRoaXMuX2EpdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHRoaXMuX3Mpbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGVkKXtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHByb21pc2UgID0gbmV3IEludGVybmFsO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcbiAgICB0aGlzLnJlamVjdCAgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtQcm9taXNlOiAkUHJvbWlzZX0pO1xucmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vX2NvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKXtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVqZWN0ICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpe1xuICAgIC8vIGluc3RhbmNlb2YgaW5zdGVhZCBvZiBpbnRlcm5hbCBzbG90IGNoZWNrIGJlY2F1c2Ugd2Ugc2hvdWxkIGZpeCBpdCB3aXRob3V0IHJlcGxhY2VtZW50IG5hdGl2ZSBQcm9taXNlIGNvcmVcbiAgICBpZih4IGluc3RhbmNlb2YgJFByb21pc2UgJiYgc2FtZUNvbnN0cnVjdG9yKHguY29uc3RydWN0b3IsIHRoaXMpKXJldHVybiB4O1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZXNvbHZlICA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICAkJHJlc29sdmUoeCk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpe1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSB0aGlzXG4gICAgICAsIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgLCByZXNvbHZlICAgID0gY2FwYWJpbGl0eS5yZXNvbHZlXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgdmFyIHZhbHVlcyAgICA9IFtdXG4gICAgICAgICwgaW5kZXggICAgID0gMFxuICAgICAgICAsIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICB2YXIgJGluZGV4ICAgICAgICA9IGluZGV4KytcbiAgICAgICAgICAsIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICBpZihhbHJlYWR5Q2FsbGVkKXJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkICA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMSBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5PYmplY3QgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCByQXBwbHkgICAgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuYXBwbHlcbiAgLCBmQXBwbHkgICAgPSBGdW5jdGlvbi5hcHBseTtcbi8vIE1TIEVkZ2UgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByQXBwbHkoZnVuY3Rpb24oKXt9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KXtcbiAgICB2YXIgVCA9IGFGdW5jdGlvbih0YXJnZXQpXG4gICAgICAsIEwgPSBhbk9iamVjdChhcmd1bWVudHNMaXN0KTtcbiAgICByZXR1cm4gckFwcGx5ID8gckFwcGx5KFQsIHRoaXNBcmd1bWVudCwgTCkgOiBmQXBwbHkuY2FsbChULCB0aGlzQXJndW1lbnQsIEwpO1xuICB9XG59KTsiLCIvLyAyNi4xLjIgUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IFssIG5ld1RhcmdldF0pXG52YXIgJGV4cG9ydCAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY3JlYXRlICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbk9iamVjdCAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBmYWlscyAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGJpbmQgICAgICAgPSByZXF1aXJlKCcuL19iaW5kJylcbiAgLCByQ29uc3RydWN0ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmNvbnN0cnVjdDtcblxuLy8gTVMgRWRnZSBzdXBwb3J0cyBvbmx5IDIgYXJndW1lbnRzIGFuZCBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4vLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG52YXIgTkVXX1RBUkdFVF9CVUcgPSBmYWlscyhmdW5jdGlvbigpe1xuICBmdW5jdGlvbiBGKCl7fVxuICByZXR1cm4gIShyQ29uc3RydWN0KGZ1bmN0aW9uKCl7fSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG59KTtcbnZhciBBUkdTX0JVRyA9ICFmYWlscyhmdW5jdGlvbigpe1xuICByQ29uc3RydWN0KGZ1bmN0aW9uKCl7fSk7XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUcpLCAnUmVmbGVjdCcsIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qLCBuZXdUYXJnZXQqLyl7XG4gICAgYUZ1bmN0aW9uKFRhcmdldCk7XG4gICAgYW5PYmplY3QoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUZ1bmN0aW9uKGFyZ3VtZW50c1syXSk7XG4gICAgaWYoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKXJldHVybiByQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcbiAgICBpZihUYXJnZXQgPT0gbmV3VGFyZ2V0KXtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgVGFyZ2V0O1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfVxuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgICRhcmdzLnB1c2guYXBwbHkoJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYmluZC5hcHBseShUYXJnZXQsICRhcmdzKSk7XG4gICAgfVxuICAgIC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuICAgIHZhciBwcm90byAgICA9IG5ld1RhcmdldC5wcm90b3R5cGVcbiAgICAgICwgaW5zdGFuY2UgPSBjcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3QucHJvdG90eXBlKVxuICAgICAgLCByZXN1bHQgICA9IEZ1bmN0aW9uLmFwcGx5LmNhbGwoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7IiwiLy8gMjYuMS4zIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcylcbnZhciBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4vLyBNUyBFZGdlIGhhcyBicm9rZW4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSAtIHRocm93aW5nIGluc3RlYWQgb2YgcmV0dXJuaW5nIGZhbHNlXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShkUC5mKHt9LCAxLCB7dmFsdWU6IDF9KSwgMSwge3ZhbHVlOiAyfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKXtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUocHJvcGVydHlLZXksIHRydWUpO1xuICAgIGFuT2JqZWN0KGF0dHJpYnV0ZXMpO1xuICAgIHRyeSB7XG4gICAgICBkUC5mKHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pOyIsIi8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGdPUEQgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgdmFyIGRlc2MgPSBnT1BEKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgICByZXR1cm4gZGVzYyAmJiAhZGVzYy5jb25maWd1cmFibGUgPyBmYWxzZSA6IGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlLZXldO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyAyNi4xLjUgUmVmbGVjdC5lbnVtZXJhdGUodGFyZ2V0KVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIEVudW1lcmF0ZSA9IGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IGFuT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdmFyIGtleXMgPSB0aGlzLl9rID0gW10gICAgICAgLy8ga2V5c1xuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIGl0ZXJhdGVkKWtleXMucHVzaChrZXkpO1xufTtcbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoRW51bWVyYXRlLCAnT2JqZWN0JywgZnVuY3Rpb24oKXtcbiAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLCBrZXlzID0gdGhhdC5fa1xuICAgICwga2V5O1xuICBkbyB7XG4gICAgaWYodGhhdC5faSA+PSBrZXlzLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICB9IHdoaWxlKCEoKGtleSA9IGtleXNbdGhhdC5faSsrXSkgaW4gdGhhdC5fdCkpO1xuICByZXR1cm4ge3ZhbHVlOiBrZXksIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGVudW1lcmF0ZTogZnVuY3Rpb24gZW51bWVyYXRlKHRhcmdldCl7XG4gICAgcmV0dXJuIG5ldyBFbnVtZXJhdGUodGFyZ2V0KTtcbiAgfVxufSk7IiwiLy8gMjYuMS43IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgZ09QRCAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgcmV0dXJuIGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIH1cbn0pOyIsIi8vIDI2LjEuOCBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZ2V0UHJvdG8gPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZih0YXJnZXQpe1xuICAgIHJldHVybiBnZXRQcm90byhhbk9iamVjdCh0YXJnZXQpKTtcbiAgfVxufSk7IiwiLy8gMjYuMS42IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgWywgcmVjZWl2ZXJdKVxudmFyIGdPUEQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuZnVuY3Rpb24gZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkvKiwgcmVjZWl2ZXIqLyl7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdXG4gICAgLCBkZXNjLCBwcm90bztcbiAgaWYoYW5PYmplY3QodGFyZ2V0KSA9PT0gcmVjZWl2ZXIpcmV0dXJuIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIGlmKGRlc2MgPSBnT1BELmYodGFyZ2V0LCBwcm9wZXJ0eUtleSkpcmV0dXJuIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgID8gZGVzYy52YWx1ZVxuICAgIDogZGVzYy5nZXQgIT09IHVuZGVmaW5lZFxuICAgICAgPyBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIGlmKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpcmV0dXJuIGdldChwcm90bywgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge2dldDogZ2V0fSk7IiwiLy8gMjYuMS45IFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHJldHVybiBwcm9wZXJ0eUtleSBpbiB0YXJnZXQ7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMTAgUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KVxudmFyICRleHBvcnQgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKHRhcmdldCl7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICByZXR1cm4gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUodGFyZ2V0KSA6IHRydWU7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMTEgUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtvd25LZXlzOiByZXF1aXJlKCcuL19vd24ta2V5cycpfSk7IiwiLy8gMjYuMS4xMiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcbnZhciAkZXhwb3J0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgJHByZXZlbnRFeHRlbnNpb25zID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHByZXZlbnRFeHRlbnNpb25zOiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpe1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmKCRwcmV2ZW50RXh0ZW5zaW9ucykkcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTsiLCIvLyAyNi4xLjE0IFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2V0UHJvdG8gPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKTtcblxuaWYoc2V0UHJvdG8pJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90byl7XG4gICAgc2V0UHJvdG8uY2hlY2sodGFyZ2V0LCBwcm90byk7XG4gICAgdHJ5IHtcbiAgICAgIHNldFByb3RvLnNldCh0YXJnZXQsIHByb3RvKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTsiLCIvLyAyNi4xLjEzIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYgWywgcmVjZWl2ZXJdKVxudmFyIGRQICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBnT1BEICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxuZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYvKiwgcmVjZWl2ZXIqLyl7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCA0ID8gdGFyZ2V0IDogYXJndW1lbnRzWzNdXG4gICAgLCBvd25EZXNjICA9IGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSlcbiAgICAsIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG87XG4gIGlmKCFvd25EZXNjKXtcbiAgICBpZihpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKXtcbiAgICAgIHJldHVybiBzZXQocHJvdG8sIHByb3BlcnR5S2V5LCBWLCByZWNlaXZlcik7XG4gICAgfVxuICAgIG93bkRlc2MgPSBjcmVhdGVEZXNjKDApO1xuICB9XG4gIGlmKGhhcyhvd25EZXNjLCAndmFsdWUnKSl7XG4gICAgaWYob3duRGVzYy53cml0YWJsZSA9PT0gZmFsc2UgfHwgIWlzT2JqZWN0KHJlY2VpdmVyKSlyZXR1cm4gZmFsc2U7XG4gICAgZXhpc3RpbmdEZXNjcmlwdG9yID0gZ09QRC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSkgfHwgY3JlYXRlRGVzYygwKTtcbiAgICBleGlzdGluZ0Rlc2NyaXB0b3IudmFsdWUgPSBWO1xuICAgIGRQLmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5LCBleGlzdGluZ0Rlc2NyaXB0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBvd25EZXNjLnNldCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAob3duRGVzYy5zZXQuY2FsbChyZWNlaXZlciwgViksIHRydWUpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7c2V0OiBzZXR9KTsiLCJ2YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpXG4gICwgZFAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgZ09QTiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBpc1JlZ0V4cCAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICwgJGZsYWdzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mbGFncycpXG4gICwgJFJlZ0V4cCAgICAgICAgICAgPSBnbG9iYWwuUmVnRXhwXG4gICwgQmFzZSAgICAgICAgICAgICAgPSAkUmVnRXhwXG4gICwgcHJvdG8gICAgICAgICAgICAgPSAkUmVnRXhwLnByb3RvdHlwZVxuICAsIHJlMSAgICAgICAgICAgICAgID0gL2EvZ1xuICAsIHJlMiAgICAgICAgICAgICAgID0gL2EvZ1xuICAvLyBcIm5ld1wiIGNyZWF0ZXMgYSBuZXcgb2JqZWN0LCBvbGQgd2Via2l0IGJ1Z2d5IGhlcmVcbiAgLCBDT1JSRUNUX05FVyAgICAgICA9IG5ldyAkUmVnRXhwKHJlMSkgIT09IHJlMTtcblxuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAoIUNPUlJFQ1RfTkVXIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmUyW3JlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpXSA9IGZhbHNlO1xuICAvLyBSZWdFeHAgY29uc3RydWN0b3IgY2FuIGFsdGVyIGZsYWdzIGFuZCBJc1JlZ0V4cCB3b3JrcyBjb3JyZWN0IHdpdGggQEBtYXRjaFxuICByZXR1cm4gJFJlZ0V4cChyZTEpICE9IHJlMSB8fCAkUmVnRXhwKHJlMikgPT0gcmUyIHx8ICRSZWdFeHAocmUxLCAnaScpICE9ICcvYS9pJztcbn0pKSl7XG4gICRSZWdFeHAgPSBmdW5jdGlvbiBSZWdFeHAocCwgZil7XG4gICAgdmFyIHRpUkUgPSB0aGlzIGluc3RhbmNlb2YgJFJlZ0V4cFxuICAgICAgLCBwaVJFID0gaXNSZWdFeHAocClcbiAgICAgICwgZmlVICA9IGYgPT09IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gIXRpUkUgJiYgcGlSRSAmJiBwLmNvbnN0cnVjdG9yID09PSAkUmVnRXhwICYmIGZpVSA/IHBcbiAgICAgIDogaW5oZXJpdElmUmVxdWlyZWQoQ09SUkVDVF9ORVdcbiAgICAgICAgPyBuZXcgQmFzZShwaVJFICYmICFmaVUgPyBwLnNvdXJjZSA6IHAsIGYpXG4gICAgICAgIDogQmFzZSgocGlSRSA9IHAgaW5zdGFuY2VvZiAkUmVnRXhwKSA/IHAuc291cmNlIDogcCwgcGlSRSAmJiBmaVUgPyAkZmxhZ3MuY2FsbChwKSA6IGYpXG4gICAgICAsIHRpUkUgPyB0aGlzIDogcHJvdG8sICRSZWdFeHApO1xuICB9O1xuICB2YXIgcHJveHkgPSBmdW5jdGlvbihrZXkpe1xuICAgIGtleSBpbiAkUmVnRXhwIHx8IGRQKCRSZWdFeHAsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gQmFzZVtrZXldOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihpdCl7IEJhc2Vba2V5XSA9IGl0OyB9XG4gICAgfSk7XG4gIH07XG4gIGZvcih2YXIga2V5cyA9IGdPUE4oQmFzZSksIGkgPSAwOyBrZXlzLmxlbmd0aCA+IGk7IClwcm94eShrZXlzW2krK10pO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICRSZWdFeHA7XG4gICRSZWdFeHAucHJvdG90eXBlID0gcHJvdG87XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCAnUmVnRXhwJywgJFJlZ0V4cCk7XG59XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ1JlZ0V4cCcpOyIsIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgLy4vZy5mbGFncyAhPSAnZycpcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihSZWdFeHAucHJvdG90eXBlLCAnZmxhZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiByZXF1aXJlKCcuL19mbGFncycpXG59KTsiLCIvLyBAQG1hdGNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ21hdGNoJywgMSwgZnVuY3Rpb24oZGVmaW5lZCwgTUFUQ0gsICRtYXRjaCl7XG4gIC8vIDIxLjEuMy4xMSBTdHJpbmcucHJvdG90eXBlLm1hdGNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBtYXRjaChyZWdleHApe1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtNQVRDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbTUFUQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRtYXRjaF07XG59KTsiLCIvLyBAQHJlcGxhY2UgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgncmVwbGFjZScsIDIsIGZ1bmN0aW9uKGRlZmluZWQsIFJFUExBQ0UsICRyZXBsYWNlKXtcbiAgLy8gMjEuMS4zLjE0IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKVxuICByZXR1cm4gW2Z1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPICA9IGRlZmluZWQodGhpcylcbiAgICAgICwgZm4gPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxuICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICA6ICRyZXBsYWNlLmNhbGwoU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgfSwgJHJlcGxhY2VdO1xufSk7IiwiLy8gQEBzZWFyY2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc2VhcmNoJywgMSwgZnVuY3Rpb24oZGVmaW5lZCwgU0VBUkNILCAkc2VhcmNoKXtcbiAgLy8gMjEuMS4zLjE1IFN0cmluZy5wcm90b3R5cGUuc2VhcmNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzZWFyY2gocmVnZXhwKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbU0VBUkNIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtTRUFSQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRzZWFyY2hdO1xufSk7IiwiLy8gQEBzcGxpdCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzcGxpdCcsIDIsIGZ1bmN0aW9uKGRlZmluZWQsIFNQTElULCAkc3BsaXQpe1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBpc1JlZ0V4cCAgID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgICAsIF9zcGxpdCAgICAgPSAkc3BsaXRcbiAgICAsICRwdXNoICAgICAgPSBbXS5wdXNoXG4gICAgLCAkU1BMSVQgICAgID0gJ3NwbGl0J1xuICAgICwgTEVOR1RIICAgICA9ICdsZW5ndGgnXG4gICAgLCBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG4gIGlmKFxuICAgICdhYmJjJ1skU1BMSVRdKC8oYikqLylbMV0gPT0gJ2MnIHx8XG4gICAgJ3Rlc3QnWyRTUExJVF0oLyg/OikvLCAtMSlbTEVOR1RIXSAhPSA0IHx8XG4gICAgJ2FiJ1skU1BMSVRdKC8oPzphYikqLylbTEVOR1RIXSAhPSAyIHx8XG4gICAgJy4nWyRTUExJVF0oLyguPykoLj8pLylbTEVOR1RIXSAhPSA0IHx8XG4gICAgJy4nWyRTUExJVF0oLygpKCkvKVtMRU5HVEhdID4gMSB8fFxuICAgICcnWyRTUExJVF0oLy4/LylbTEVOR1RIXVxuICApe1xuICAgIHZhciBOUENHID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB1bmRlZmluZWQ7IC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24oc2VwYXJhdG9yLCBsaW1pdCl7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYoc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDApcmV0dXJuIFtdO1xuICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgIGlmKCFpc1JlZ0V4cChzZXBhcmF0b3IpKXJldHVybiBfc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IDQyOTQ5NjcyOTUgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgdmFyIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGgsIGk7XG4gICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgIGlmKCFOUENHKXNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvckNvcHkuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICB3aGlsZShtYXRjaCA9IHNlcGFyYXRvckNvcHkuZXhlYyhzdHJpbmcpKXtcbiAgICAgICAgLy8gYHNlcGFyYXRvckNvcHkubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgIGlmKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpe1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvciBOUENHXG4gICAgICAgICAgaWYoIU5QQ0cgJiYgbWF0Y2hbTEVOR1RIXSA+IDEpbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgZm9yKGkgPSAxOyBpIDwgYXJndW1lbnRzW0xFTkdUSF0gLSAyOyBpKyspaWYoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYobWF0Y2hbTEVOR1RIXSA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmdbTEVOR1RIXSkkcHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgIGlmKG91dHB1dFtMRU5HVEhdID49IHNwbGl0TGltaXQpYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSA9PT0gbWF0Y2guaW5kZXgpc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgICBpZihsYXN0TGFzdEluZGV4ID09PSBzdHJpbmdbTEVOR1RIXSl7XG4gICAgICAgIGlmKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpb3V0cHV0LnB1c2goJycpO1xuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0W0xFTkdUSF0gPiBzcGxpdExpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmKCcwJ1skU1BMSVRdKHVuZGVmaW5lZCwgMClbTEVOR1RIXSl7XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24oc2VwYXJhdG9yLCBsaW1pdCl7XG4gICAgICByZXR1cm4gc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDAgPyBbXSA6IF9zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG4gIH1cbiAgLy8gMjEuMS4zLjE3IFN0cmluZy5wcm90b3R5cGUuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KXtcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpIDogJHNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgfSwgJHNwbGl0XTtcbn0pOyIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5mbGFncycpO1xudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCAkZmxhZ3MgICAgICA9IHJlcXVpcmUoJy4vX2ZsYWdzJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBUT19TVFJJTkcgICA9ICd0b1N0cmluZydcbiAgLCAkdG9TdHJpbmcgICA9IC8uL1tUT19TVFJJTkddO1xuXG52YXIgZGVmaW5lID0gZnVuY3Rpb24oZm4pe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZm4sIHRydWUpO1xufTtcblxuLy8gMjEuMi41LjE0IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcoKVxuaWYocmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpeyByZXR1cm4gJHRvU3RyaW5nLmNhbGwoe3NvdXJjZTogJ2EnLCBmbGFnczogJ2InfSkgIT0gJy9hL2InOyB9KSl7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgcmV0dXJuICcvJy5jb25jYXQoUi5zb3VyY2UsICcvJyxcbiAgICAgICdmbGFncycgaW4gUiA/IFIuZmxhZ3MgOiAhREVTQ1JJUFRPUlMgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCA/ICRmbGFncy5jYWxsKFIpIDogdW5kZWZpbmVkKTtcbiAgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxufSBlbHNlIGlmKCR0b1N0cmluZy5uYW1lICE9IFRPX1NUUklORyl7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgfSk7XG59IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdTZXQnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4yIFN0cmluZy5wcm90b3R5cGUuYW5jaG9yKG5hbWUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdhbmNob3InLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFuY2hvcihuYW1lKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICduYW1lJywgbmFtZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjMgU3RyaW5nLnByb3RvdHlwZS5iaWcoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmlnJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBiaWcoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmlnJywgJycsICcnKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNCBTdHJpbmcucHJvdG90eXBlLmJsaW5rKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JsaW5rJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBibGluaygpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdibGluaycsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjUgU3RyaW5nLnByb3RvdHlwZS5ib2xkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JvbGQnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJvbGQoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYicsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXQgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykoZmFsc2UpO1xuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4zIFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQocG9zKVxuICBjb2RlUG9pbnRBdDogZnVuY3Rpb24gY29kZVBvaW50QXQocG9zKXtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pOyIsIi8vIDIxLjEuMy42IFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgoc2VhcmNoU3RyaW5nIFssIGVuZFBvc2l0aW9uXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgY29udGV4dCAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKVxuICAsIEVORFNfV0lUSCA9ICdlbmRzV2l0aCdcbiAgLCAkZW5kc1dpdGggPSAnJ1tFTkRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKEVORFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcgLyosIGVuZFBvc2l0aW9uID0gQGxlbmd0aCAqLyl7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgRU5EU19XSVRIKVxuICAgICAgLCBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkXG4gICAgICAsIGxlbiAgICA9IHRvTGVuZ3RoKHRoYXQubGVuZ3RoKVxuICAgICAgLCBlbmQgICAgPSBlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gbGVuIDogTWF0aC5taW4odG9MZW5ndGgoZW5kUG9zaXRpb24pLCBsZW4pXG4gICAgICAsIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkZW5kc1dpdGhcbiAgICAgID8gJGVuZHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBlbmQpXG4gICAgICA6IHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy42IFN0cmluZy5wcm90b3R5cGUuZml4ZWQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZml4ZWQnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZpeGVkKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3R0JywgJycsICcnKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNyBTdHJpbmcucHJvdG90eXBlLmZvbnRjb2xvcihjb2xvcilcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRjb2xvcicsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gZm9udGNvbG9yKGNvbG9yKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdjb2xvcicsIGNvbG9yKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOCBTdHJpbmcucHJvdG90eXBlLmZvbnRzaXplKHNpemUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250c2l6ZScsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gZm9udHNpemUoc2l6ZSl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnc2l6ZScsIHNpemUpO1xuICB9XG59KTsiLCJ2YXIgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSW5kZXggICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIGZyb21DaGFyQ29kZSAgID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuICAsICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cbi8vIGxlbmd0aCBzaG91bGQgYmUgMSwgb2xkIEZGIHByb2JsZW1cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCEhJGZyb21Db2RlUG9pbnQgJiYgJGZyb21Db2RlUG9pbnQubGVuZ3RoICE9IDEpLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KHgpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHJlcyAgPSBbXVxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBpICAgID0gMFxuICAgICAgLCBjb2RlO1xuICAgIHdoaWxlKGFMZW4gPiBpKXtcbiAgICAgIGNvZGUgPSArYXJndW1lbnRzW2krK107XG4gICAgICBpZih0b0luZGV4KGNvZGUsIDB4MTBmZmZmKSAhPT0gY29kZSl0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICAgIHJlcy5wdXNoKGNvZGUgPCAweDEwMDAwXG4gICAgICAgID8gZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMClcbiAgICAgICk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTsiLCIvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb250ZXh0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0JylcbiAgLCBJTkNMVURFUyA9ICdpbmNsdWRlcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoSU5DTFVERVMpLCAnU3RyaW5nJywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qLCBwb3NpdGlvbiA9IDAgKi8pe1xuICAgIHJldHVybiAhIX5jb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgSU5DTFVERVMpXG4gICAgICAuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOSBTdHJpbmcucHJvdG90eXBlLml0YWxpY3MoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnaXRhbGljcycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gaXRhbGljcygpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdpJywgJycsICcnKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMCBTdHJpbmcucHJvdG90eXBlLmxpbmsodXJsKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnbGluaycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gbGluayh1cmwpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ2hyZWYnLCB1cmwpO1xuICB9XG59KTsiLCJ2YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi40IFN0cmluZy5yYXcoY2FsbFNpdGUsIC4uLnN1YnN0aXR1dGlvbnMpXG4gIHJhdzogZnVuY3Rpb24gcmF3KGNhbGxTaXRlKXtcbiAgICB2YXIgdHBsICA9IHRvSU9iamVjdChjYWxsU2l0ZS5yYXcpXG4gICAgICAsIGxlbiAgPSB0b0xlbmd0aCh0cGwubGVuZ3RoKVxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXMgID0gW11cbiAgICAgICwgaSAgICA9IDA7XG4gICAgd2hpbGUobGVuID4gaSl7XG4gICAgICByZXMucHVzaChTdHJpbmcodHBsW2krK10pKTtcbiAgICAgIGlmKGkgPCBhTGVuKXJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoY291bnQpXG4gIHJlcGVhdDogcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMSBTdHJpbmcucHJvdG90eXBlLnNtYWxsKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3NtYWxsJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBzbWFsbCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzbWFsbCcsICcnLCAnJyk7XG4gIH1cbn0pOyIsIi8vIDIxLjEuMy4xOCBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIFssIHBvc2l0aW9uIF0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjb250ZXh0ICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0JylcbiAgLCBTVEFSVFNfV0lUSCA9ICdzdGFydHNXaXRoJ1xuICAsICRzdGFydHNXaXRoID0gJydbU1RBUlRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKFNUQVJUU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XG4gICAgdmFyIHRoYXQgICA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBTVEFSVFNfV0lUSClcbiAgICAgICwgaW5kZXggID0gdG9MZW5ndGgoTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSlcbiAgICAgICwgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRzdGFydHNXaXRoXG4gICAgICA/ICRzdGFydHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBpbmRleClcbiAgICAgIDogdGhhdC5zbGljZShpbmRleCwgaW5kZXggKyBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMiBTdHJpbmcucHJvdG90eXBlLnN0cmlrZSgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdHJpa2UnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0cmlrZSgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdHJpa2UnLCAnJywgJycpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMyBTdHJpbmcucHJvdG90eXBlLnN1YigpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdWInLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1Yigpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdWInLCAnJywgJycpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xNCBTdHJpbmcucHJvdG90eXBlLnN1cCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdXAnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1cCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdXAnLCAnJywgJycpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMS4xLjMuMjUgU3RyaW5nLnByb3RvdHlwZS50cmltKClcbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW0nLCBmdW5jdGlvbigkdHJpbSl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltKCl7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDMpO1xuICB9O1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIE1FVEEgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCB1aWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgd2tzRGVmaW5lICAgICAgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2tleW9mJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgX2NyZWF0ZSAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBnT1BORXh0ICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpXG4gICwgJEdPUEQgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJERQICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRrZXlzICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUEQgICAgICAgICAgID0gJEdPUEQuZlxuICAsIGRQICAgICAgICAgICAgID0gJERQLmZcbiAgLCBnT1BOICAgICAgICAgICA9IGdPUE5FeHQuZlxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cbiAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgVE9fUFJJTUlUSVZFICAgPSB3a3MoJ3RvUHJpbWl0aXZlJylcbiAgLCBpc0VudW0gICAgICAgICA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIE9QU3ltYm9scyAgICAgID0gc2hhcmVkKCdvcC1zeW1ib2xzJylcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG4gICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvKSRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIGl0ICA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ09QTih0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG9cbiAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIVVTRV9OQVRJVkUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKXNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0fSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfVxufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHR5cGVkICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQnKVxuICAsIGJ1ZmZlciAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpXG4gICwgYW5PYmplY3QgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0luZGV4ICAgICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgdG9MZW5ndGggICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBpc09iamVjdCAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIEFycmF5QnVmZmVyICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLkFycmF5QnVmZmVyXG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgJEFycmF5QnVmZmVyID0gYnVmZmVyLkFycmF5QnVmZmVyXG4gICwgJERhdGFWaWV3ICAgID0gYnVmZmVyLkRhdGFWaWV3XG4gICwgJGlzVmlldyAgICAgID0gJHR5cGVkLkFCViAmJiBBcnJheUJ1ZmZlci5pc1ZpZXdcbiAgLCAkc2xpY2UgICAgICAgPSAkQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlXG4gICwgVklFVyAgICAgICAgID0gJHR5cGVkLlZJRVdcbiAgLCBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChBcnJheUJ1ZmZlciAhPT0gJEFycmF5QnVmZmVyKSwge0FycmF5QnVmZmVyOiAkQXJyYXlCdWZmZXJ9KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhJHR5cGVkLkNPTlNUUiwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuMy4xIEFycmF5QnVmZmVyLmlzVmlldyhhcmcpXG4gIGlzVmlldzogZnVuY3Rpb24gaXNWaWV3KGl0KXtcbiAgICByZXR1cm4gJGlzVmlldyAmJiAkaXNWaWV3KGl0KSB8fCBpc09iamVjdChpdCkgJiYgVklFVyBpbiBpdDtcbiAgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5VICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gIW5ldyAkQXJyYXlCdWZmZXIoMikuc2xpY2UoMSwgdW5kZWZpbmVkKS5ieXRlTGVuZ3RoO1xufSksIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjQuMyBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2Uoc3RhcnQsIGVuZClcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpe1xuICAgIGlmKCRzbGljZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA9PT0gdW5kZWZpbmVkKXJldHVybiAkc2xpY2UuY2FsbChhbk9iamVjdCh0aGlzKSwgc3RhcnQpOyAvLyBGRiBmaXhcbiAgICB2YXIgbGVuICAgID0gYW5PYmplY3QodGhpcykuYnl0ZUxlbmd0aFxuICAgICAgLCBmaXJzdCAgPSB0b0luZGV4KHN0YXJ0LCBsZW4pXG4gICAgICAsIGZpbmFsICA9IHRvSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQsIGxlbilcbiAgICAgICwgcmVzdWx0ID0gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJEFycmF5QnVmZmVyKSkodG9MZW5ndGgoZmluYWwgLSBmaXJzdCkpXG4gICAgICAsIHZpZXdTICA9IG5ldyAkRGF0YVZpZXcodGhpcylcbiAgICAgICwgdmlld1QgID0gbmV3ICREYXRhVmlldyhyZXN1bHQpXG4gICAgICAsIGluZGV4ICA9IDA7XG4gICAgd2hpbGUoZmlyc3QgPCBmaW5hbCl7XG4gICAgICB2aWV3VC5zZXRVaW50OChpbmRleCsrLCB2aWV3Uy5nZXRVaW50OChmaXJzdCsrKSk7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShBUlJBWV9CVUZGRVIpOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL190eXBlZCcpLkFCViwge1xuICBEYXRhVmlldzogcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJykuRGF0YVZpZXdcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0MzInLCA0LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDY0JywgOCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDY0QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MTYnLCAyLCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MzInLCA0LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50OCcsIDEsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gSW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDMyJywgNCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhDbGFtcGVkQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSwgdHJ1ZSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVhY2ggICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKVxuICAsIHJlZGVmaW5lICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBtZXRhICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJylcbiAgLCBhc3NpZ24gICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJylcbiAgLCB3ZWFrICAgICAgICAgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKVxuICAsIGlzT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZ2V0V2VhayAgICAgID0gbWV0YS5nZXRXZWFrXG4gICwgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZVxuICAsIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSB3ZWFrLnVmc3RvcmVcbiAgLCB0bXAgICAgICAgICAgPSB7fVxuICAsIEludGVybmFsTWFwO1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCl7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59O1xuXG52YXIgbWV0aG9kcyA9IHtcbiAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KXtcbiAgICBpZihpc09iamVjdChrZXkpKXtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgaWYoZGF0YSA9PT0gdHJ1ZSlyZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGlzKS5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gZGF0YVt0aGlzLl9pXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gd2Vhay5kZWYodGhpcywga2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIDIzLjMgV2Vha01hcCBPYmplY3RzXG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnV2Vha01hcCcsIHdyYXBwZXIsIG1ldGhvZHMsIHdlYWssIHRydWUsIHRydWUpO1xuXG4vLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG5pZihuZXcgJFdlYWtNYXAoKS5zZXQoKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh0bXApLCA3KS5nZXQodG1wKSAhPSA3KXtcbiAgSW50ZXJuYWxNYXAgPSB3ZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIpO1xuICBhc3NpZ24oSW50ZXJuYWxNYXAucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgZWFjaChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBwcm90byAgPSAkV2Vha01hcC5wcm90b3R5cGVcbiAgICAgICwgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZWRlZmluZShwcm90bywga2V5LCBmdW5jdGlvbihhLCBiKXtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSl7XG4gICAgICAgIGlmKCF0aGlzLl9mKXRoaXMuX2YgPSBuZXcgSW50ZXJuYWxNYXA7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mW2tleV0oYSwgYik7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcblxuLy8gMjMuNCBXZWFrU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnV2Vha1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy40LjMuMSBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKXtcbiAgICByZXR1cm4gd2Vhay5kZWYodGhpcywgdmFsdWUsIHRydWUpO1xuICB9XG59LCB3ZWFrLCBmYWxzZSwgdHJ1ZSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkaW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyosIGZyb21JbmRleCA9IDAgKi8pe1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdpbmNsdWRlcycpOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yd2FsZHJvbi90YzM5LW5vdGVzL2Jsb2IvbWFzdGVyL2VzNi8yMDE0LTA5L3NlcHQtMjUubWQjNTEwLWdsb2JhbGFzYXAtZm9yLWVucXVldWluZy1hLW1pY3JvdGFza1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKVxuICAsIHByb2Nlc3MgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnByb2Nlc3NcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7XG4gIGFzYXA6IGZ1bmN0aW9uIGFzYXAoZm4pe1xuICAgIHZhciBkb21haW4gPSBpc05vZGUgJiYgcHJvY2Vzcy5kb21haW47XG4gICAgbWljcm90YXNrKGRvbWFpbiA/IGRvbWFpbi5iaW5kKGZuKSA6IGZuKTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9wcm9wb3NhbC1pcy1lcnJvclxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvZiAgICAgPSByZXF1aXJlKCcuL19jb2YnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdFcnJvcicsIHtcbiAgaXNFcnJvcjogZnVuY3Rpb24gaXNFcnJvcihpdCl7XG4gICAgcmV0dXJuIGNvZihpdCkgPT09ICdFcnJvcic7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ01hcCcsIHt0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKX0pOyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlhZGRoOiBmdW5jdGlvbiBpYWRkaCh4MCwgeDEsIHkwLCB5MSl7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwXG4gICAgICAsICR4MSA9IHgxID4+PiAwXG4gICAgICAsICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgKyAoeTEgPj4+IDApICsgKCgkeDAgJiAkeTAgfCAoJHgwIHwgJHkwKSAmIH4oJHgwICsgJHkwID4+PiAwKSkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGltdWxoOiBmdW5jdGlvbiBpbXVsaCh1LCB2KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsICR1ID0gK3VcbiAgICAgICwgJHYgPSArdlxuICAgICAgLCB1MCA9ICR1ICYgVUlOVDE2XG4gICAgICAsIHYwID0gJHYgJiBVSU5UMTZcbiAgICAgICwgdTEgPSAkdSA+PiAxNlxuICAgICAgLCB2MSA9ICR2ID4+IDE2XG4gICAgICAsIHQgID0gKHUxICogdjAgPj4+IDApICsgKHUwICogdjAgPj4+IDE2KTtcbiAgICByZXR1cm4gdTEgKiB2MSArICh0ID4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4gMTYpO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpc3ViaDogZnVuY3Rpb24gaXN1YmgoeDAsIHgxLCB5MCwgeTEpe1xuICAgIHZhciAkeDAgPSB4MCA+Pj4gMFxuICAgICAgLCAkeDEgPSB4MSA+Pj4gMFxuICAgICAgLCAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxIC0gKHkxID4+PiAwKSAtICgofiR4MCAmICR5MCB8IH4oJHgwIF4gJHkwKSAmICR4MCAtICR5MCA+Pj4gMCkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHVtdWxoOiBmdW5jdGlvbiB1bXVsaCh1LCB2KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsICR1ID0gK3VcbiAgICAgICwgJHYgPSArdlxuICAgICAgLCB1MCA9ICR1ICYgVUlOVDE2XG4gICAgICAsIHYwID0gJHYgJiBVSU5UMTZcbiAgICAgICwgdTEgPSAkdSA+Pj4gMTZcbiAgICAgICwgdjEgPSAkdiA+Pj4gMTZcbiAgICAgICwgdCAgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4+IDE2KTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuLy8gQi4yLjIuMiBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lR2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKXtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwge2dldDogYUZ1bmN0aW9uKGdldHRlciksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4vLyBCLjIuMi4zIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVTZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpe1xuICAgICRkZWZpbmVQcm9wZXJ0eS5mKHRvT2JqZWN0KHRoaXMpLCBQLCB7c2V0OiBhRnVuY3Rpb24oc2V0dGVyKSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSk7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZW50cmllcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhpdCl7XG4gICAgcmV0dXJuICRlbnRyaWVzKGl0KTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbnZhciAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgb3duS2V5cyAgICAgICAgPSByZXF1aXJlKCcuL19vd24ta2V5cycpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBnT1BEICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3Qpe1xuICAgIHZhciBPICAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAgICwgZ2V0RGVzYyA9IGdPUEQuZlxuICAgICAgLCBrZXlzICAgID0gb3duS2V5cyhPKVxuICAgICAgLCByZXN1bHQgID0ge31cbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGtleXMubGVuZ3RoID4gaSljcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGtleSA9IGtleXNbaSsrXSwgZ2V0RGVzYyhPLCBrZXkpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG4vLyBCLjIuMi40IE9iamVjdC5wcm90b3R5cGUuX19sb29rdXBHZXR0ZXJfXyhQKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fbG9va3VwR2V0dGVyX186IGZ1bmN0aW9uIF9fbG9va3VwR2V0dGVyX18oUCl7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKVxuICAgICAgLCBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSlcbiAgICAgICwgRDtcbiAgICBkbyB7XG4gICAgICBpZihEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKXJldHVybiBELmdldDtcbiAgICB9IHdoaWxlKE8gPSBnZXRQcm90b3R5cGVPZihPKSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbi8vIEIuMi4yLjUgT2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cFNldHRlcl9fKFApXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19sb29rdXBTZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBTZXR0ZXJfXyhQKXtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIEsgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKVxuICAgICAgLCBEO1xuICAgIGRvIHtcbiAgICAgIGlmKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpcmV0dXJuIEQuc2V0O1xuICAgIH0gd2hpbGUoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHZhbHVlcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKGZhbHNlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKGl0KXtcbiAgICByZXR1cm4gJHZhbHVlcyhpdCk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZ2xvYmFsICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgbWljcm90YXNrICAgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpXG4gICwgT0JTRVJWQUJMRSAgPSByZXF1aXJlKCcuL193a3MnKSgnb2JzZXJ2YWJsZScpXG4gICwgYUZ1bmN0aW9uICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYW5JbnN0YW5jZSAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGhpZGUgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgZm9yT2YgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIFJFVFVSTiAgICAgID0gZm9yT2YuUkVUVVJOO1xuXG52YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oZm4pe1xuICByZXR1cm4gZm4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFGdW5jdGlvbihmbik7XG59O1xuXG52YXIgY2xlYW51cFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XG4gIHZhciBjbGVhbnVwID0gc3Vic2NyaXB0aW9uLl9jO1xuICBpZihjbGVhbnVwKXtcbiAgICBzdWJzY3JpcHRpb24uX2MgPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cCgpO1xuICB9XG59O1xuXG52YXIgc3Vic2NyaXB0aW9uQ2xvc2VkID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgcmV0dXJuIHN1YnNjcmlwdGlvbi5fbyA9PT0gdW5kZWZpbmVkO1xufTtcblxudmFyIGNsb3NlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgaWYoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXtcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICB9XG59O1xuXG52YXIgU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24ob2JzZXJ2ZXIsIHN1YnNjcmliZXIpe1xuICBhbk9iamVjdChvYnNlcnZlcik7XG4gIHRoaXMuX2MgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX28gPSBvYnNlcnZlcjtcbiAgb2JzZXJ2ZXIgPSBuZXcgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIodGhpcyk7XG4gIHRyeSB7XG4gICAgdmFyIGNsZWFudXAgICAgICA9IHN1YnNjcmliZXIob2JzZXJ2ZXIpXG4gICAgICAsIHN1YnNjcmlwdGlvbiA9IGNsZWFudXA7XG4gICAgaWYoY2xlYW51cCAhPSBudWxsKXtcbiAgICAgIGlmKHR5cGVvZiBjbGVhbnVwLnVuc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nKWNsZWFudXAgPSBmdW5jdGlvbigpeyBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTsgfTtcbiAgICAgIGVsc2UgYUZ1bmN0aW9uKGNsZWFudXApO1xuICAgICAgdGhpcy5fYyA9IGNsZWFudXA7XG4gICAgfVxuICB9IGNhdGNoKGUpe1xuICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgIHJldHVybjtcbiAgfSBpZihzdWJzY3JpcHRpb25DbG9zZWQodGhpcykpY2xlYW51cFN1YnNjcmlwdGlvbih0aGlzKTtcbn07XG5cblN1YnNjcmlwdGlvbi5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICB1bnN1YnNjcmliZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoKXsgY2xvc2VTdWJzY3JpcHRpb24odGhpcyk7IH1cbn0pO1xuXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICB0aGlzLl9zID0gc3Vic2NyaXB0aW9uO1xufTtcblxuU3Vic2NyaXB0aW9uT2JzZXJ2ZXIucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoe30sIHtcbiAgbmV4dDogZnVuY3Rpb24gbmV4dCh2YWx1ZSl7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXtcbiAgICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLm5leHQpO1xuICAgICAgICBpZihtKXJldHVybiBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IodmFsdWUpe1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuICAgIGlmKHN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXRocm93IHZhbHVlO1xuICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmVycm9yKTtcbiAgICAgIGlmKCFtKXRocm93IHZhbHVlO1xuICAgICAgdmFsdWUgPSBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSh2YWx1ZSl7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXtcbiAgICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmNvbXBsZXRlKTtcbiAgICAgICAgdmFsdWUgPSBtID8gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSkgOiB1bmRlZmluZWQ7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgJE9ic2VydmFibGUgPSBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZXIpe1xuICBhbkluc3RhbmNlKHRoaXMsICRPYnNlcnZhYmxlLCAnT2JzZXJ2YWJsZScsICdfZicpLl9mID0gYUZ1bmN0aW9uKHN1YnNjcmliZXIpO1xufTtcblxucmVkZWZpbmVBbGwoJE9ic2VydmFibGUucHJvdG90eXBlLCB7XG4gIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKXtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbihvYnNlcnZlciwgdGhpcy5fZik7XG4gIH0sXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZm4pe1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IChjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBhRnVuY3Rpb24oZm4pO1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoYXQuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dCA6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogcmVqZWN0LFxuICAgICAgICBjb21wbGV0ZTogcmVzb2x2ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZSwge1xuICBmcm9tOiBmdW5jdGlvbiBmcm9tKHgpe1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGU7XG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZChhbk9iamVjdCh4KVtPQlNFUlZBQkxFXSk7XG4gICAgaWYobWV0aG9kKXtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gYW5PYmplY3QobWV0aG9kLmNhbGwoeCkpO1xuICAgICAgcmV0dXJuIG9ic2VydmFibGUuY29uc3RydWN0b3IgPT09IEMgPyBvYnNlcnZhYmxlIDogbmV3IEMoZnVuY3Rpb24ob2JzZXJ2ZXIpe1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZS5zdWJzY3JpYmUob2JzZXJ2ZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbihvYnNlcnZlcil7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCFkb25lKXtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYoZm9yT2YoeCwgZmFsc2UsIGZ1bmN0aW9uKGl0KXtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdCk7XG4gICAgICAgICAgICAgIGlmKGRvbmUpcmV0dXJuIFJFVFVSTjtcbiAgICAgICAgICAgIH0pID09PSBSRVRVUk4pcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICBpZihkb25lKXRocm93IGU7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7IGRvbmUgPSB0cnVlOyB9O1xuICAgIH0pO1xuICB9LFxuICBvZjogZnVuY3Rpb24gb2YoKXtcbiAgICBmb3IodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBBcnJheShsKTsgaSA8IGw7KWl0ZW1zW2ldID0gYXJndW1lbnRzW2krK107XG4gICAgcmV0dXJuIG5ldyAodHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGUpKGZ1bmN0aW9uKG9ic2VydmVyKXtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIWRvbmUpe1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0ZW1zW2ldKTtcbiAgICAgICAgICAgIGlmKGRvbmUpcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXsgZG9uZSA9IHRydWU7IH07XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5oaWRlKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwgT0JTRVJWQUJMRSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuRywge09ic2VydmFibGU6ICRPYnNlcnZhYmxlfSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ09ic2VydmFibGUnKTsiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5XG4gICwgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IG1ldGFkYXRhLnNldDtcblxubWV0YWRhdGEuZXhwKHtkZWZpbmVNZXRhZGF0YTogZnVuY3Rpb24gZGVmaW5lTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgdGFyZ2V0S2V5KXtcbiAgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgYW5PYmplY3QodGFyZ2V0KSwgdG9NZXRhS2V5KHRhcmdldEtleSkpO1xufX0pOyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXlcbiAgLCBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gbWV0YWRhdGEubWFwXG4gICwgc3RvcmUgICAgICAgICAgICAgICAgICA9IG1ldGFkYXRhLnN0b3JlO1xuXG5tZXRhZGF0YS5leHAoe2RlbGV0ZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICB2YXIgdGFyZ2V0S2V5ICAgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pXG4gICAgLCBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoYW5PYmplY3QodGFyZ2V0KSwgdGFyZ2V0S2V5LCBmYWxzZSk7XG4gIGlmKG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgfHwgIW1ldGFkYXRhTWFwWydkZWxldGUnXShtZXRhZGF0YUtleSkpcmV0dXJuIGZhbHNlO1xuICBpZihtZXRhZGF0YU1hcC5zaXplKXJldHVybiB0cnVlO1xuICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcbiAgdGFyZ2V0TWV0YWRhdGFbJ2RlbGV0ZSddKHRhcmdldEtleSk7XG4gIHJldHVybiAhIXRhcmdldE1ldGFkYXRhLnNpemUgfHwgc3RvcmVbJ2RlbGV0ZSddKHRhcmdldCk7XG59fSk7IiwidmFyIFNldCAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9lczYuc2V0JylcbiAgLCBmcm9tICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKVxuICAsIG1ldGFkYXRhICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5c1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlNZXRhZGF0YUtleXMgPSBmdW5jdGlvbihPLCBQKXtcbiAgdmFyIG9LZXlzICA9IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApXG4gICAgLCBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgaWYocGFyZW50ID09PSBudWxsKXJldHVybiBvS2V5cztcbiAgdmFyIHBLZXlzICA9IG9yZGluYXJ5TWV0YWRhdGFLZXlzKHBhcmVudCwgUCk7XG4gIHJldHVybiBwS2V5cy5sZW5ndGggPyBvS2V5cy5sZW5ndGggPyBmcm9tKG5ldyBTZXQob0tleXMuY29uY2F0KHBLZXlzKSkpIDogcEtleXMgOiBvS2V5cztcbn07XG5cbm1ldGFkYXRhLmV4cCh7Z2V0TWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRNZXRhZGF0YUtleXModGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlNZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59fSk7IiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXNcbiAgLCBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gbWV0YWRhdGEuZ2V0XG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5R2V0TWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTywgUCl7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYoaGFzT3duKXJldHVybiBvcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IHVuZGVmaW5lZDtcbn07XG5cbm1ldGFkYXRhLmV4cCh7Z2V0TWV0YWRhdGE6IGZ1bmN0aW9uIGdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTsiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5c1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2dldE93bk1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGFLZXlzKHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xufX0pOyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXRcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2dldE93bk1ldGFkYXRhOiBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KVxuICAgICwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7IiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXNcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlIYXNNZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIGhhc093biA9IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICBpZihoYXNPd24pcmV0dXJuIHRydWU7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiBmYWxzZTtcbn07XG5cbm1ldGFkYXRhLmV4cCh7aGFzTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTsiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHtoYXNPd25NZXRhZGF0YTogZnVuY3Rpb24gaGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldClcbiAgICAsIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pOyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5XG4gICwgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IG1ldGFkYXRhLnNldDtcblxubWV0YWRhdGEuZXhwKHttZXRhZGF0YTogZnVuY3Rpb24gbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpe1xuICByZXR1cm4gZnVuY3Rpb24gZGVjb3JhdG9yKHRhcmdldCwgdGFyZ2V0S2V5KXtcbiAgICBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKFxuICAgICAgbWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsXG4gICAgICAodGFyZ2V0S2V5ICE9PSB1bmRlZmluZWQgPyBhbk9iamVjdCA6IGFGdW5jdGlvbikodGFyZ2V0KSxcbiAgICAgIHRvTWV0YUtleSh0YXJnZXRLZXkpXG4gICAgKTtcbiAgfTtcbn19KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7dG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0Jyl9KTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGF0ICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgYXQ6IGZ1bmN0aW9uIGF0KHBvcyl7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL1N0cmluZy5wcm90b3R5cGUubWF0Y2hBbGwvXG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGRlZmluZWQgICAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGlzUmVnRXhwICAgID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgLCBnZXRGbGFncyAgICA9IHJlcXVpcmUoJy4vX2ZsYWdzJylcbiAgLCBSZWdFeHBQcm90byA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbnZhciAkUmVnRXhwU3RyaW5nSXRlcmF0b3IgPSBmdW5jdGlvbihyZWdleHAsIHN0cmluZyl7XG4gIHRoaXMuX3IgPSByZWdleHA7XG4gIHRoaXMuX3MgPSBzdHJpbmc7XG59O1xuXG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKCRSZWdFeHBTdHJpbmdJdGVyYXRvciwgJ1JlZ0V4cCBTdHJpbmcnLCBmdW5jdGlvbiBuZXh0KCl7XG4gIHZhciBtYXRjaCA9IHRoaXMuX3IuZXhlYyh0aGlzLl9zKTtcbiAgcmV0dXJuIHt2YWx1ZTogbWF0Y2gsIGRvbmU6IG1hdGNoID09PSBudWxsfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgbWF0Y2hBbGw6IGZ1bmN0aW9uIG1hdGNoQWxsKHJlZ2V4cCl7XG4gICAgZGVmaW5lZCh0aGlzKTtcbiAgICBpZighaXNSZWdFeHAocmVnZXhwKSl0aHJvdyBUeXBlRXJyb3IocmVnZXhwICsgJyBpcyBub3QgYSByZWdleHAhJyk7XG4gICAgdmFyIFMgICAgID0gU3RyaW5nKHRoaXMpXG4gICAgICAsIGZsYWdzID0gJ2ZsYWdzJyBpbiBSZWdFeHBQcm90byA/IFN0cmluZyhyZWdleHAuZmxhZ3MpIDogZ2V0RmxhZ3MuY2FsbChyZWdleHApXG4gICAgICAsIHJ4ICAgID0gbmV3IFJlZ0V4cChyZWdleHAuc291cmNlLCB+ZmxhZ3MuaW5kZXhPZignZycpID8gZmxhZ3MgOiAnZycgKyBmbGFncyk7XG4gICAgcngubGFzdEluZGV4ID0gdG9MZW5ndGgocmVnZXhwLmxhc3RJbmRleCk7XG4gICAgcmV0dXJuIG5ldyAkUmVnRXhwU3RyaW5nSXRlcmF0b3IocngsIFMpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYWQgICAgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBwYWRFbmQ6IGZ1bmN0aW9uIHBhZEVuZChtYXhMZW5ndGggLyosIGZpbGxTdHJpbmcgPSAnICcgKi8pe1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGZhbHNlKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFkICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgcGFkU3RhcnQ6IGZ1bmN0aW9uIHBhZFN0YXJ0KG1heExlbmd0aCAvKiwgZmlsbFN0cmluZyA9ICcgJyAqLyl7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWJtYXJrYmFnZS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW1MZWZ0JywgZnVuY3Rpb24oJHRyaW0pe1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbUxlZnQoKXtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMSk7XG4gIH07XG59LCAndHJpbVN0YXJ0Jyk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbVJpZ2h0JywgZnVuY3Rpb24oJHRyaW0pe1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbVJpZ2h0KCl7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDIpO1xuICB9O1xufSwgJ3RyaW1FbmQnKTsiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTsiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL3Byb3Bvc2FsLWdsb2JhbFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTeXN0ZW0nLCB7Z2xvYmFsOiByZXF1aXJlKCcuL19nbG9iYWwnKX0pOyIsInZhciAkaXRlcmF0b3JzICAgID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKVxuICAsIHJlZGVmaW5lICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgZ2xvYmFsICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIEl0ZXJhdG9ycyAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHdrcyAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIElURVJBVE9SICAgICAgPSB3a3MoJ2l0ZXJhdG9yJylcbiAgLCBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpXG4gICwgQXJyYXlWYWx1ZXMgICA9IEl0ZXJhdG9ycy5BcnJheTtcblxuZm9yKHZhciBjb2xsZWN0aW9ucyA9IFsnTm9kZUxpc3QnLCAnRE9NVG9rZW5MaXN0JywgJ01lZGlhTGlzdCcsICdTdHlsZVNoZWV0TGlzdCcsICdDU1NSdWxlTGlzdCddLCBpID0gMDsgaSA8IDU7IGkrKyl7XG4gIHZhciBOQU1FICAgICAgID0gY29sbGVjdGlvbnNbaV1cbiAgICAsIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV1cbiAgICAsIHByb3RvICAgICAgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlXG4gICAgLCBrZXk7XG4gIGlmKHByb3RvKXtcbiAgICBpZighcHJvdG9bSVRFUkFUT1JdKWhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYoIXByb3RvW1RPX1NUUklOR19UQUddKWhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IEFycmF5VmFsdWVzO1xuICAgIGZvcihrZXkgaW4gJGl0ZXJhdG9ycylpZighcHJvdG9ba2V5XSlyZWRlZmluZShwcm90bywga2V5LCAkaXRlcmF0b3JzW2tleV0sIHRydWUpO1xuICB9XG59IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR0YXNrICAgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICAgJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pOyIsIi8vIGllOS0gc2V0VGltZW91dCAmIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbnZhciBnbG9iYWwgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpbnZva2UgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBwYXJ0aWFsICAgID0gcmVxdWlyZSgnLi9fcGFydGlhbCcpXG4gICwgbmF2aWdhdG9yICA9IGdsb2JhbC5uYXZpZ2F0b3JcbiAgLCBNU0lFICAgICAgID0gISFuYXZpZ2F0b3IgJiYgL01TSUUgLlxcLi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gPC0gZGlydHkgaWU5LSBjaGVja1xudmFyIHdyYXAgPSBmdW5jdGlvbihzZXQpe1xuICByZXR1cm4gTVNJRSA/IGZ1bmN0aW9uKGZuLCB0aW1lIC8qLCAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gc2V0KGludm9rZShcbiAgICAgIHBhcnRpYWwsXG4gICAgICBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICB0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pXG4gICAgKSwgdGltZSk7XG4gIH0gOiBzZXQ7XG59O1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIgKyAkZXhwb3J0LkYgKiBNU0lFLCB7XG4gIHNldFRpbWVvdXQ6ICB3cmFwKGdsb2JhbC5zZXRUaW1lb3V0KSxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsLnNldEludGVydmFsKVxufSk7IiwicmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNlYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hY29zaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXRhbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jYnJ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2x6MzInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5mcm91bmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5oeXBvdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmltdWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxMCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRydW5jJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJhdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ibGluaycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udHNpemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1YicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUubm93Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5qb2luJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb21lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstbWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcuYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlhZGRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaXN1YmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pbXVsaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFzYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi50aW1lcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vZHVsZXMvX2NvcmUnKTsiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHRnbG9iYWwuUmFjdGl2ZS50cmFuc2l0aW9ucy5mYWRlID0gZmFjdG9yeSgpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuXHR2YXIgREVGQVVMVFMgPSB7XG5cdFx0ZGVsYXk6IDAsXG5cdFx0ZHVyYXRpb246IDMwMCxcblx0XHRlYXNpbmc6ICdsaW5lYXInXG5cdH07XG5cblx0ZnVuY3Rpb24gZmFkZSh0LCBwYXJhbXMpIHtcblx0XHR2YXIgdGFyZ2V0T3BhY2l0eTtcblxuXHRcdHBhcmFtcyA9IHQucHJvY2Vzc1BhcmFtcyhwYXJhbXMsIERFRkFVTFRTKTtcblxuXHRcdGlmICh0LmlzSW50cm8pIHtcblx0XHRcdHRhcmdldE9wYWNpdHkgPSB0LmdldFN0eWxlKCdvcGFjaXR5Jyk7XG5cdFx0XHR0LnNldFN0eWxlKCdvcGFjaXR5JywgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldE9wYWNpdHkgPSAwO1xuXHRcdH1cblxuXHRcdHQuYW5pbWF0ZVN0eWxlKCdvcGFjaXR5JywgdGFyZ2V0T3BhY2l0eSwgcGFyYW1zKS50aGVuKHQuY29tcGxldGUpO1xuXHR9XG5cblx0cmV0dXJuIGZhZGU7XG5cbn0pKTsiLCIvKlxuXHRSYWN0aXZlLmpzIHYwLjguNVxuXHRTdW4gTm92IDEzIDIwMTYgMTc6NTY6MjcgR01UKzAwMDAgKFVUQykgLSBjb21taXQgZDUzM2Q5MWYxNTVhNGYwNDJjMWFjYzg3MTM2NDU5MTQxYzJjOGFmOVxuXG5cdGh0dHA6Ly9yYWN0aXZlanMub3JnXG5cdGh0dHA6Ly90d2l0dGVyLmNvbS9SYWN0aXZlSlNcblxuXHRSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qL1xuXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKChmdW5jdGlvbigpIHsgdmFyIGN1cnJlbnQgPSBnbG9iYWwuUmFjdGl2ZTsgdmFyIG5leHQgPSBmYWN0b3J5KCk7IG5leHQubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkgeyBnbG9iYWwuUmFjdGl2ZSA9IGN1cnJlbnQ7IHJldHVybiBuZXh0OyB9OyByZXR1cm4gZ2xvYmFsLlJhY3RpdmUgPSBuZXh0OyB9KSgpKTtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICBcdC8vIHJlbmRlciBwbGFjZW1lbnQ6XG4gIFx0ZWw6ICAgICAgICAgICAgICAgICAgICAgdm9pZCAwLFxuICBcdGFwcGVuZDpcdFx0XHRcdCAgICBmYWxzZSxcblxuICBcdC8vIHRlbXBsYXRlOlxuICBcdHRlbXBsYXRlOiAgICAgICAgICAgICAgIG51bGwsXG5cbiAgXHQvLyBwYXJzZTpcbiAgXHRkZWxpbWl0ZXJzOiAgICAgICAgICAgICBbICd7eycsICd9fScgXSxcbiAgXHR0cmlwbGVEZWxpbWl0ZXJzOiAgICAgICBbICd7e3snLCAnfX19JyBdLFxuICBcdHN0YXRpY0RlbGltaXRlcnM6ICAgICAgIFsgJ1tbJywgJ11dJyBdLFxuICBcdHN0YXRpY1RyaXBsZURlbGltaXRlcnM6IFsgJ1tbWycsICddXV0nIF0sXG4gIFx0Y3NwOiBcdFx0XHRcdFx0dHJ1ZSxcbiAgXHRpbnRlcnBvbGF0ZTogICAgICAgICAgICBmYWxzZSxcbiAgXHRwcmVzZXJ2ZVdoaXRlc3BhY2U6ICAgICBmYWxzZSxcbiAgXHRzYW5pdGl6ZTogICAgICAgICAgICAgICBmYWxzZSxcbiAgXHRzdHJpcENvbW1lbnRzOiAgICAgICAgICB0cnVlLFxuICBcdGNvbnRleHRMaW5lczogICAgICAgICAgIDAsXG5cbiAgXHQvLyBkYXRhICYgYmluZGluZzpcbiAgXHRkYXRhOiAgICAgICAgICAgICAgICAgICB7fSxcbiAgXHRjb21wdXRlZDogICAgICAgICAgICAgICB7fSxcbiAgXHRtYWdpYzogICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgXHRtb2RpZnlBcnJheXM6ICAgICAgICAgICBmYWxzZSxcbiAgXHRhZGFwdDogICAgICAgICAgICAgICAgICBbXSxcbiAgXHRpc29sYXRlZDogICAgICAgICAgICAgICBmYWxzZSxcbiAgXHR0d293YXk6ICAgICAgICAgICAgICAgICB0cnVlLFxuICBcdGxhenk6ICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuXG4gIFx0Ly8gdHJhbnNpdGlvbnM6XG4gIFx0bm9JbnRybzogICAgICAgICAgICAgICAgZmFsc2UsXG4gIFx0dHJhbnNpdGlvbnNFbmFibGVkOiAgICAgdHJ1ZSxcbiAgXHRjb21wbGV0ZTogICAgICAgICAgICAgICB2b2lkIDAsXG5cbiAgXHQvLyBjc3M6XG4gIFx0Y3NzOiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgXHRub0Nzc1RyYW5zZm9ybTogICAgICAgICBmYWxzZVxuICB9O1xuXG4gIC8vIFRoZXNlIGFyZSBhIHN1YnNldCBvZiB0aGUgZWFzaW5nIGVxdWF0aW9ucyBmb3VuZCBhdFxuICAvLyBodHRwczovL3Jhdy5naXRodWIuY29tL2RhbnJvL2Vhc2luZy1qcyAtIGxpY2Vuc2UgaW5mb1xuICAvLyBmb2xsb3dzOlxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGVhc2luZy5qcyB2MC41LjRcbiAgLy8gR2VuZXJpYyBzZXQgb2YgZWFzaW5nIGZ1bmN0aW9ucyB3aXRoIEFNRCBzdXBwb3J0XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5yby9lYXNpbmctanNcbiAgLy8gVGhpcyBjb2RlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gIC8vIGh0dHA6Ly9kYW5yby5taXQtbGljZW5zZS5vcmcvXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEFsbCBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFRob21hcyBGdWNocyAmIEplcmVteSBLYWhuXG4gIC8vIEVhc2luZyBFcXVhdGlvbnMgKGMpIDIwMDMgUm9iZXJ0IFBlbm5lciwgQlNEIGxpY2Vuc2VcbiAgLy8gaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9kYW5yby9lYXNpbmctanMvbWFzdGVyL0xJQ0VOU0VcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBJbiB0aGF0IGxpYnJhcnksIHRoZSBmdW5jdGlvbnMgbmFtZWQgZWFzZUluLCBlYXNlT3V0LCBhbmRcbiAgLy8gZWFzZUluT3V0IGJlbG93IGFyZSBuYW1lZCBlYXNlSW5DdWJpYywgZWFzZU91dEN1YmljLCBhbmRcbiAgLy8gKHlvdSBndWVzc2VkIGl0KSBlYXNlSW5PdXRDdWJpYy5cbiAgLy9cbiAgLy8gWW91IGNhbiBhZGQgYWRkaXRpb25hbCBlYXNpbmcgZnVuY3Rpb25zIHRvIHRoaXMgbGlzdCwgYW5kIHRoZXlcbiAgLy8gd2lsbCBiZSBnbG9iYWxseSBhdmFpbGFibGUuXG5cblxuICB2YXIgZWFzaW5nID0ge1xuICBcdGxpbmVhcjogZnVuY3Rpb24gKCBwb3MgKSB7IHJldHVybiBwb3M7IH0sXG4gIFx0ZWFzZUluOiBmdW5jdGlvbiAoIHBvcyApIHsgcmV0dXJuIE1hdGgucG93KCBwb3MsIDMgKTsgfSxcbiAgXHRlYXNlT3V0OiBmdW5jdGlvbiAoIHBvcyApIHsgcmV0dXJuICggTWF0aC5wb3coICggcG9zIC0gMSApLCAzICkgKyAxICk7IH0sXG4gIFx0ZWFzZUluT3V0OiBmdW5jdGlvbiAoIHBvcyApIHtcbiAgXHRcdGlmICggKCBwb3MgLz0gMC41ICkgPCAxICkgeyByZXR1cm4gKCAwLjUgKiBNYXRoLnBvdyggcG9zLCAzICkgKTsgfVxuICBcdFx0cmV0dXJuICggMC41ICogKCBNYXRoLnBvdyggKCBwb3MgLSAyICksIDMgKSArIDIgKSApO1xuICBcdH1cbiAgfTtcblxuICB2YXIgbGVnYWN5ID0gbnVsbDtcblxuICAvKmdsb2JhbCBjb25zb2xlLCBuYXZpZ2F0b3IgKi9cblxuICB2YXIgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBudWxsO1xuICB2YXIgZG9jID0gd2luID8gZG9jdW1lbnQgOiBudWxsO1xuXG4gIHZhciBpc0NsaWVudCA9ICEhZG9jO1xuICB2YXIgaXNKc2RvbSA9ICggdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL2pzRG9tLy50ZXN0KCBuYXZpZ2F0b3IuYXBwTmFtZSApICk7XG4gIHZhciBoYXNDb25zb2xlID0gKCB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY29uc29sZS53YXJuLmFwcGx5ID09PSAnZnVuY3Rpb24nICk7XG5cbiAgdmFyIG1hZ2ljU3VwcG9ydGVkO1xuICB0cnkge1xuICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Rlc3QnLCB7IHZhbHVlOiAwIH0pO1xuICBcdG1hZ2ljU3VwcG9ydGVkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoIGUgKSB7XG4gIFx0bWFnaWNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBzdmcgPSBkb2MgP1xuICBcdGRvYy5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCAnaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNCYXNpY1N0cnVjdHVyZScsICcxLjEnICkgOlxuICBcdGZhbHNlO1xuXG4gIHZhciB2ZW5kb3JzID0gWyAnbycsICdtcycsICdtb3onLCAnd2Via2l0JyBdO1xuXG4gIHZhciBodG1sICAgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG4gIHZhciBtYXRobWwgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCc7XG4gIHZhciBzdmckMSAgICA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gIHZhciB4bGluayAgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG4gIHZhciB4bWwgICAgPSAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJztcbiAgdmFyIHhtbG5zICA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zJztcblxuICB2YXIgbmFtZXNwYWNlcyA9IHsgaHRtbDogaHRtbCwgbWF0aG1sOiBtYXRobWwsIHN2Zzogc3ZnJDEsIHhsaW5rOiB4bGluaywgeG1sOiB4bWwsIHhtbG5zOiB4bWxucyB9O1xuXG4gIHZhciBjcmVhdGVFbGVtZW50O1xuICB2YXIgbWF0Y2hlcztcbiAgdmFyIGRpdjtcbiAgdmFyIG1ldGhvZE5hbWVzO1xuICB2YXIgdW5wcmVmaXhlZDtcbiAgdmFyIHByZWZpeGVkO1xuICB2YXIgaTtcbiAgdmFyIGo7XG4gIHZhciBtYWtlRnVuY3Rpb247XG4gIC8vIFRlc3QgZm9yIFNWRyBzdXBwb3J0XG4gIGlmICggIXN2ZyApIHtcbiAgXHRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKCB0eXBlLCBucywgZXh0ZW5kICkge1xuICBcdFx0aWYgKCBucyAmJiBucyAhPT0gaHRtbCApIHtcbiAgXHRcdFx0dGhyb3cgJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG5hbWVzcGFjZXMgb3RoZXIgdGhhbiBodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sLiBUaGUgbW9zdCBsaWtlbHkgY2F1c2Ugb2YgdGhpcyBlcnJvciBpcyB0aGF0IHlvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgU1ZHIGluIGFuIG9sZGVyIGJyb3dzZXIuIFNlZSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9zdmctYW5kLW9sZGVyLWJyb3dzZXJzIGZvciBtb3JlIGluZm9ybWF0aW9uJztcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGV4dGVuZCA/XG4gIFx0XHRcdGRvYy5jcmVhdGVFbGVtZW50KCB0eXBlLCBleHRlbmQgKSA6XG4gIFx0XHRcdGRvYy5jcmVhdGVFbGVtZW50KCB0eXBlICk7XG4gIFx0fTtcbiAgfSBlbHNlIHtcbiAgXHRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKCB0eXBlLCBucywgZXh0ZW5kICkge1xuICBcdFx0aWYgKCAhbnMgfHwgbnMgPT09IGh0bWwgKSB7XG4gIFx0XHRcdHJldHVybiBleHRlbmQgP1xuICBcdFx0XHRcdGRvYy5jcmVhdGVFbGVtZW50KCB0eXBlLCBleHRlbmQgKSA6XG4gIFx0XHRcdFx0ZG9jLmNyZWF0ZUVsZW1lbnQoIHR5cGUgKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGV4dGVuZCA/XG4gIFx0XHRcdGRvYy5jcmVhdGVFbGVtZW50TlMoIG5zLCB0eXBlLCBleHRlbmQgKSA6XG4gIFx0XHRcdGRvYy5jcmVhdGVFbGVtZW50TlMoIG5zLCB0eXBlICk7XG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQgKCkge1xuICBcdHJldHVybiBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudCAoIGlucHV0ICkge1xuICBcdHZhciBvdXRwdXQ7XG5cbiAgXHRpZiAoICFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgPT09ICdib29sZWFuJyApIHsgcmV0dXJuOyB9XG5cbiAgXHRpZiAoICF3aW4gfHwgIWRvYyB8fCAhaW5wdXQgKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBXZSBhbHJlYWR5IGhhdmUgYSBET00gbm9kZSAtIG5vIHdvcmsgdG8gZG8uIChEdWNrIHR5cGluZyBhbGVydCEpXG4gIFx0aWYgKCBpbnB1dC5ub2RlVHlwZSApIHtcbiAgXHRcdHJldHVybiBpbnB1dDtcbiAgXHR9XG5cbiAgXHQvLyBHZXQgbm9kZSBmcm9tIHN0cmluZ1xuICBcdGlmICggdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyApIHtcbiAgXHRcdC8vIHRyeSBJRCBmaXJzdFxuICBcdFx0b3V0cHV0ID0gZG9jLmdldEVsZW1lbnRCeUlkKCBpbnB1dCApO1xuXG4gIFx0XHQvLyB0aGVuIGFzIHNlbGVjdG9yLCBpZiBwb3NzaWJsZVxuICBcdFx0aWYgKCAhb3V0cHV0ICYmIGRvYy5xdWVyeVNlbGVjdG9yICkge1xuICBcdFx0XHRvdXRwdXQgPSBkb2MucXVlcnlTZWxlY3RvciggaW5wdXQgKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gZGlkIGl0IHdvcms/XG4gIFx0XHRpZiAoIG91dHB1dCAmJiBvdXRwdXQubm9kZVR5cGUgKSB7XG4gIFx0XHRcdHJldHVybiBvdXRwdXQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gSWYgd2UndmUgYmVlbiBnaXZlbiBhIGNvbGxlY3Rpb24gKGpRdWVyeSwgWmVwdG8gZXRjKSwgZXh0cmFjdCB0aGUgZmlyc3QgaXRlbVxuICBcdGlmICggaW5wdXRbMF0gJiYgaW5wdXRbMF0ubm9kZVR5cGUgKSB7XG4gIFx0XHRyZXR1cm4gaW5wdXRbMF07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoICFpc0NsaWVudCApIHtcbiAgXHRtYXRjaGVzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHRkaXYgPSBjcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuICBcdG1ldGhvZE5hbWVzID0gWyAnbWF0Y2hlcycsICdtYXRjaGVzU2VsZWN0b3InIF07XG5cbiAgXHRtYWtlRnVuY3Rpb24gPSBmdW5jdGlvbiAoIG1ldGhvZE5hbWUgKSB7XG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBub2RlLCBzZWxlY3RvciApIHtcbiAgXHRcdFx0cmV0dXJuIG5vZGVbIG1ldGhvZE5hbWUgXSggc2VsZWN0b3IgKTtcbiAgXHRcdH07XG4gIFx0fTtcblxuICBcdGkgPSBtZXRob2ROYW1lcy5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoIGktLSAmJiAhbWF0Y2hlcyApIHtcbiAgXHRcdHVucHJlZml4ZWQgPSBtZXRob2ROYW1lc1tpXTtcblxuICBcdFx0aWYgKCBkaXZbIHVucHJlZml4ZWQgXSApIHtcbiAgXHRcdFx0bWF0Y2hlcyA9IG1ha2VGdW5jdGlvbiggdW5wcmVmaXhlZCApO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0aiA9IHZlbmRvcnMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoIGotLSApIHtcbiAgXHRcdFx0XHRwcmVmaXhlZCA9IHZlbmRvcnNbaV0gKyB1bnByZWZpeGVkLnN1YnN0ciggMCwgMSApLnRvVXBwZXJDYXNlKCkgKyB1bnByZWZpeGVkLnN1YnN0cmluZyggMSApO1xuXG4gIFx0XHRcdFx0aWYgKCBkaXZbIHByZWZpeGVkIF0gKSB7XG4gIFx0XHRcdFx0XHRtYXRjaGVzID0gbWFrZUZ1bmN0aW9uKCBwcmVmaXhlZCApO1xuICBcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gSUU4Li4uXG4gIFx0aWYgKCAhbWF0Y2hlcyApIHtcbiAgXHRcdG1hdGNoZXMgPSBmdW5jdGlvbiAoIG5vZGUsIHNlbGVjdG9yICkge1xuICBcdFx0XHR2YXIgbm9kZXMsIHBhcmVudE5vZGUsIGk7XG5cbiAgXHRcdFx0cGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblxuICBcdFx0XHRpZiAoICFwYXJlbnROb2RlICkge1xuICBcdFx0XHRcdC8vIGVtcHR5IGR1bW15IDxkaXY+XG4gIFx0XHRcdFx0ZGl2LmlubmVySFRNTCA9ICcnO1xuXG4gIFx0XHRcdFx0cGFyZW50Tm9kZSA9IGRpdjtcbiAgXHRcdFx0XHRub2RlID0gbm9kZS5jbG9uZU5vZGUoKTtcblxuICBcdFx0XHRcdGRpdi5hcHBlbmRDaGlsZCggbm9kZSApO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0bm9kZXMgPSBwYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoIHNlbGVjdG9yICk7XG5cbiAgXHRcdFx0aSA9IG5vZGVzLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRcdFx0aWYgKCBub2Rlc1tpXSA9PT0gbm9kZSApIHtcbiAgXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH07XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoTm9kZSAoIG5vZGUgKSB7XG4gIFx0aWYgKCBub2RlICYmIHR5cGVvZiBub2RlLnBhcmVudE5vZGUgIT09ICd1bmtub3duJyAmJiBub2RlLnBhcmVudE5vZGUgKSB7XG4gIFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVUb1N0cmluZ1ZhbHVlICggdmFsdWUgKSB7XG4gIFx0cmV0dXJuICggdmFsdWUgPT0gbnVsbCB8fCAhdmFsdWUudG9TdHJpbmcgKSA/ICcnIDogJycgKyB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVBdHRyaWJ1dGVTdHJpbmcgKCBzdHJpbmcgKSB7XG4gIFx0cmV0dXJuIHNhZmVUb1N0cmluZ1ZhbHVlKCBzdHJpbmcgKVxuICBcdFx0LnJlcGxhY2UoIC8mL2csICcmYW1wOycgKVxuICBcdFx0LnJlcGxhY2UoIC9cIi9nLCAnJnF1b3Q7JyApXG4gIFx0XHQucmVwbGFjZSggLycvZywgJyYjMzk7JyApO1xuICB9XG5cbiAgdmFyIGNhbWVsID0gLygtLikvZztcbiAgZnVuY3Rpb24gY2FtZWxpemUgKCBzdHJpbmcgKSB7XG4gIFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBjYW1lbCwgZnVuY3Rpb24gKCBzICkgeyByZXR1cm4gcy5jaGFyQXQoIDEgKS50b1VwcGVyQ2FzZSgpOyB9ICk7XG4gIH1cblxuICB2YXIgZGVjYW1lbCA9IC9bQS1aXS9nO1xuICBmdW5jdGlvbiBkZWNhbWVsaXplICggc3RyaW5nICkge1xuICBcdHJldHVybiBzdHJpbmcucmVwbGFjZSggZGVjYW1lbCwgZnVuY3Rpb24gKCBzICkgeyByZXR1cm4gKFwiLVwiICsgKHMudG9Mb3dlckNhc2UoKSkpOyB9ICk7XG4gIH1cblxuICB2YXIgY3JlYXRlO1xuICB2YXIgZGVmaW5lUHJvcGVydHk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0aWVzO1xuICB0cnkge1xuICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Rlc3QnLCB7IGdldDogZnVuY3Rpb24oKSB7fSwgc2V0OiBmdW5jdGlvbigpIHt9IH0pO1xuXG4gIFx0aWYgKCBkb2MgKSB7XG4gIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGNyZWF0ZUVsZW1lbnQoICdkaXYnICksICd0ZXN0JywgeyB2YWx1ZTogMCB9KTtcbiAgXHR9XG5cbiAgXHRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgfSBjYXRjaCAoIGVyciApIHtcbiAgXHQvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkgZG9lc24ndCBleGlzdCwgb3Igd2UncmUgaW4gSUU4IHdoZXJlIHlvdSBjYW5cbiAgXHQvLyBvbmx5IHVzZSBpdCB3aXRoIERPTSBvYmplY3RzICh3aGF0IHdlcmUgeW91IHNtb2tpbmcsIE1TRlQ/KVxuICBcdGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKCBvYmosIHByb3AsIGRlc2MgKSB7XG4gIFx0XHRpZiAoIGRlc2MuZ2V0ICkgb2JqWyBwcm9wIF0gPSBkZXNjLmdldCgpO1xuICBcdFx0ZWxzZSBvYmpbIHByb3AgXSA9IGRlc2MudmFsdWU7XG4gIFx0fTtcbiAgfVxuXG4gIHRyeSB7XG4gIFx0dHJ5IHtcbiAgXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHt9LCB7IHRlc3Q6IHsgdmFsdWU6IDAgfSB9KTtcbiAgXHR9IGNhdGNoICggZXJyICkge1xuICBcdFx0Ly8gVE9ETyBob3cgZG8gd2UgYWNjb3VudCBmb3IgdGhpcz8gbm9NYWdpYyA9IHRydWU7XG4gIFx0XHR0aHJvdyBlcnI7XG4gIFx0fVxuXG4gIFx0aWYgKCBkb2MgKSB7XG4gIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggY3JlYXRlRWxlbWVudCggJ2RpdicgKSwgeyB0ZXN0OiB7IHZhbHVlOiAwIH0gfSk7XG4gIFx0fVxuXG4gIFx0ZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xuICB9IGNhdGNoICggZXJyICkge1xuICBcdGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoIG9iaiwgcHJvcHMgKSB7XG4gIFx0XHR2YXIgcHJvcDtcblxuICBcdFx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcbiAgXHRcdFx0aWYgKCBwcm9wcy5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkge1xuICBcdFx0XHRcdGRlZmluZVByb3BlcnR5KCBvYmosIHByb3AsIHByb3BzWyBwcm9wIF0gKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICB0cnkge1xuICBcdE9iamVjdC5jcmVhdGUoIG51bGwgKTtcblxuICBcdGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG4gIH0gY2F0Y2ggKCBlcnIgKSB7XG4gIFx0Ly8gc2lnaFxuICBcdGNyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgRiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwcm90bywgcHJvcHMgKSB7XG4gIFx0XHRcdHZhciBvYmo7XG5cbiAgXHRcdFx0aWYgKCBwcm90byA9PT0gbnVsbCApIHtcbiAgXHRcdFx0XHRyZXR1cm4ge307XG4gIFx0XHRcdH1cblxuICBcdFx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xuICBcdFx0XHRvYmogPSBuZXcgRigpO1xuXG4gIFx0XHRcdGlmICggcHJvcHMgKSB7XG4gIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIG9iaiwgcHJvcHMgKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBvYmo7XG4gIFx0XHR9O1xuICBcdH0oKSk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmRPYmogKCB0YXJnZXQgKSB7XG4gIFx0dmFyIHNvdXJjZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIFx0d2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gIFx0dmFyIHByb3A7XG5cbiAgXHRzb3VyY2VzLmZvckVhY2goIGZ1bmN0aW9uICggc291cmNlICkge1xuICBcdFx0Zm9yICggcHJvcCBpbiBzb3VyY2UgKSB7XG4gIFx0XHRcdGlmICggaGFzT3duLmNhbGwoIHNvdXJjZSwgcHJvcCApICkge1xuICBcdFx0XHRcdHRhcmdldFsgcHJvcCBdID0gc291cmNlWyBwcm9wIF07XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxsR2FwcyAoIHRhcmdldCApIHtcbiAgXHR2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgXHR3aGlsZSAoIGxlbi0tID4gMCApIHNvdXJjZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgXHRzb3VyY2VzLmZvckVhY2goIGZ1bmN0aW9uICggcyApIHtcbiAgXHRcdGZvciAoIHZhciBrZXkgaW4gcyApIHtcbiAgXHRcdFx0aWYgKCBoYXNPd24uY2FsbCggcywga2V5ICkgJiYgISgga2V5IGluIHRhcmdldCApICkge1xuICBcdFx0XHRcdHRhcmdldFsga2V5IF0gPSBzWyBrZXkgXTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0pO1xuXG4gIFx0cmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gIC8vIHRoYW5rcywgaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vaW5zdGFuY2VvZi1jb25zaWRlcmVkLWhhcm1mdWwtb3ItaG93LXRvLXdyaXRlLWEtcm9idXN0LWlzYXJyYXkvXG4gIGZ1bmN0aW9uIGlzQXJyYXkgKCB0aGluZyApIHtcbiAgXHRyZXR1cm4gdG9TdHJpbmcuY2FsbCggdGhpbmcgKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRXF1YWwgKCBhLCBiICkge1xuICBcdGlmICggYSA9PT0gbnVsbCAmJiBiID09PSBudWxsICkge1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuXG4gIFx0aWYgKCB0eXBlb2YgYSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgPT09ICdvYmplY3QnICkge1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdHJldHVybiBhID09PSBiO1xuICB9XG5cbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODA4Mi92YWxpZGF0ZS1udW1iZXJzLWluLWphdmFzY3JpcHQtaXNudW1lcmljXG4gIGZ1bmN0aW9uIGlzTnVtZXJpYyAoIHRoaW5nICkge1xuICBcdHJldHVybiAhaXNOYU4oIHBhcnNlRmxvYXQoIHRoaW5nICkgKSAmJiBpc0Zpbml0ZSggdGhpbmcgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT2JqZWN0ICggdGhpbmcgKSB7XG4gIFx0cmV0dXJuICggdGhpbmcgJiYgdG9TdHJpbmcuY2FsbCggdGhpbmcgKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vb3AgKCkge31cblxuICB2YXIgYWxyZWFkeVdhcm5lZCA9IHt9O1xuICB2YXIgbG9nO1xuICB2YXIgcHJpbnRXYXJuaW5nO1xuICB2YXIgd2VsY29tZTtcbiAgaWYgKCBoYXNDb25zb2xlICkge1xuICBcdHZhciB3ZWxjb21lSW50cm8gPSBbXG4gIFx0XHQoXCIlY1JhY3RpdmUuanMgJWMwLjguNSAlY2luIGRlYnVnIG1vZGUsICVjbW9yZS4uLlwiKSxcbiAgXHRcdCdjb2xvcjogcmdiKDExNCwgMTU3LCA1Mik7IGZvbnQtd2VpZ2h0OiBub3JtYWw7JyxcbiAgXHRcdCdjb2xvcjogcmdiKDg1LCA4NSwgODUpOyBmb250LXdlaWdodDogbm9ybWFsOycsXG4gIFx0XHQnY29sb3I6IHJnYig4NSwgODUsIDg1KTsgZm9udC13ZWlnaHQ6IG5vcm1hbDsnLFxuICBcdFx0J2NvbG9yOiByZ2IoODIsIDE0MCwgMjI0KTsgZm9udC13ZWlnaHQ6IG5vcm1hbDsgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7J1xuICBcdF07XG4gIFx0dmFyIHdlbGNvbWVNZXNzYWdlID0gXCJZb3UncmUgcnVubmluZyBSYWN0aXZlIDAuOC41IGluIGRlYnVnIG1vZGUgLSBtZXNzYWdlcyB3aWxsIGJlIHByaW50ZWQgdG8gdGhlIGNvbnNvbGUgdG8gaGVscCB5b3UgZml4IHByb2JsZW1zIGFuZCBvcHRpbWlzZSB5b3VyIGFwcGxpY2F0aW9uLlxcblxcblRvIGRpc2FibGUgZGVidWcgbW9kZSwgYWRkIHRoaXMgbGluZSBhdCB0aGUgc3RhcnQgb2YgeW91ciBhcHA6XFxuICBSYWN0aXZlLkRFQlVHID0gZmFsc2U7XFxuXFxuVG8gZGlzYWJsZSBkZWJ1ZyBtb2RlIHdoZW4geW91ciBhcHAgaXMgbWluaWZpZWQsIGFkZCB0aGlzIHNuaXBwZXQ6XFxuICBSYWN0aXZlLkRFQlVHID0gL3VubWluaWZpZWQvLnRlc3QoZnVuY3Rpb24oKXsvKnVubWluaWZpZWQqL30pO1xcblxcbkdldCBoZWxwIGFuZCBzdXBwb3J0OlxcbiAgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZ1xcbiAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy90YWdnZWQvcmFjdGl2ZWpzXFxuICBodHRwOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyFmb3J1bS9yYWN0aXZlLWpzXFxuICBodHRwOi8vdHdpdHRlci5jb20vcmFjdGl2ZWpzXFxuXFxuRm91bmQgYSBidWc/IFJhaXNlIGFuIGlzc3VlOlxcbiAgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlc1xcblxcblwiO1xuXG4gIFx0d2VsY29tZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGlmICggUmFjdGl2ZS5XRUxDT01FX01FU1NBR0UgPT09IGZhbHNlICkge1xuICBcdFx0XHR3ZWxjb21lID0gbm9vcDtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuICBcdFx0dmFyIG1lc3NhZ2UgPSAnV0VMQ09NRV9NRVNTQUdFJyBpbiBSYWN0aXZlID8gUmFjdGl2ZS5XRUxDT01FX01FU1NBR0UgOiB3ZWxjb21lTWVzc2FnZTtcbiAgXHRcdHZhciBoYXNHcm91cCA9ICEhY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgXHRcdGlmICggaGFzR3JvdXAgKSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkLmFwcGx5KCBjb25zb2xlLCB3ZWxjb21lSW50cm8gKTtcbiAgXHRcdGNvbnNvbGUubG9nKCBtZXNzYWdlICk7XG4gIFx0XHRpZiAoIGhhc0dyb3VwICkge1xuICBcdFx0XHRjb25zb2xlLmdyb3VwRW5kKCB3ZWxjb21lSW50cm8gKTtcbiAgXHRcdH1cblxuICBcdFx0d2VsY29tZSA9IG5vb3A7XG4gIFx0fTtcblxuICBcdHByaW50V2FybmluZyA9IGZ1bmN0aW9uICggbWVzc2FnZSwgYXJncyApIHtcbiAgXHRcdHdlbGNvbWUoKTtcblxuICBcdFx0Ly8gZXh0cmFjdCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5zdGFuY2UgdGhpcyBtZXNzYWdlIHBlcnRhaW5zIHRvLCBpZiBhcHBsaWNhYmxlXG4gIFx0XHRpZiAoIHR5cGVvZiBhcmdzWyBhcmdzLmxlbmd0aCAtIDEgXSA9PT0gJ29iamVjdCcgKSB7XG4gIFx0XHRcdHZhciBvcHRpb25zID0gYXJncy5wb3AoKTtcbiAgXHRcdFx0dmFyIHJhY3RpdmUgPSBvcHRpb25zID8gb3B0aW9ucy5yYWN0aXZlIDogbnVsbDtcblxuICBcdFx0XHRpZiAoIHJhY3RpdmUgKSB7XG4gIFx0XHRcdFx0Ly8gaWYgdGhpcyBpcyBhbiBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCB0aGF0IHdlIGtub3cgdGhlIG5hbWUgb2YsIGFkZFxuICBcdFx0XHRcdC8vIGl0IHRvIHRoZSBtZXNzYWdlXG4gIFx0XHRcdFx0dmFyIG5hbWU7XG4gIFx0XHRcdFx0aWYgKCByYWN0aXZlLmNvbXBvbmVudCAmJiAoIG5hbWUgPSByYWN0aXZlLmNvbXBvbmVudC5uYW1lICkgKSB7XG4gIFx0XHRcdFx0XHRtZXNzYWdlID0gXCI8XCIgKyBuYW1lICsgXCI+IFwiICsgbWVzc2FnZTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHR2YXIgbm9kZTtcbiAgXHRcdFx0XHRpZiAoIG5vZGUgPSAoIG9wdGlvbnMubm9kZSB8fCAoIHJhY3RpdmUuZnJhZ21lbnQgJiYgcmFjdGl2ZS5mcmFnbWVudC5yZW5kZXJlZCAmJiByYWN0aXZlLmZpbmQoICcqJyApICkgKSApIHtcbiAgXHRcdFx0XHRcdGFyZ3MucHVzaCggbm9kZSApO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRjb25zb2xlLndhcm4uYXBwbHkoIGNvbnNvbGUsIFsgJyVjUmFjdGl2ZS5qczogJWMnICsgbWVzc2FnZSwgJ2NvbG9yOiByZ2IoMTE0LCAxNTcsIDUyKTsnLCAnY29sb3I6IHJnYig4NSwgODUsIDg1KTsnIF0uY29uY2F0KCBhcmdzICkgKTtcbiAgXHR9O1xuXG4gIFx0bG9nID0gZnVuY3Rpb24gKCkge1xuICBcdFx0Y29uc29sZS5sb2cuYXBwbHkoIGNvbnNvbGUsIGFyZ3VtZW50cyApO1xuICBcdH07XG4gIH0gZWxzZSB7XG4gIFx0cHJpbnRXYXJuaW5nID0gbG9nID0gd2VsY29tZSA9IG5vb3A7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQgKCBtZXNzYWdlLCBhcmdzICkge1xuICBcdHJldHVybiBtZXNzYWdlLnJlcGxhY2UoIC8lcy9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBhcmdzLnNoaWZ0KCk7IH0gKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZhdGFsICggbWVzc2FnZSApIHtcbiAgXHR2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgXHR3aGlsZSAoIGxlbi0tID4gMCApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgXHRtZXNzYWdlID0gZm9ybWF0KCBtZXNzYWdlLCBhcmdzICk7XG4gIFx0dGhyb3cgbmV3IEVycm9yKCBtZXNzYWdlICk7XG4gIH1cblxuICBmdW5jdGlvbiBsb2dJZkRlYnVnICgpIHtcbiAgXHRpZiAoIFJhY3RpdmUuREVCVUcgKSB7XG4gIFx0XHRsb2cuYXBwbHkoIG51bGwsIGFyZ3VtZW50cyApO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4gKCBtZXNzYWdlICkge1xuICBcdHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICBcdHdoaWxlICggbGVuLS0gPiAwICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICBcdG1lc3NhZ2UgPSBmb3JtYXQoIG1lc3NhZ2UsIGFyZ3MgKTtcbiAgXHRwcmludFdhcm5pbmcoIG1lc3NhZ2UsIGFyZ3MgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlICggbWVzc2FnZSApIHtcbiAgXHR2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgXHR3aGlsZSAoIGxlbi0tID4gMCApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgXHRtZXNzYWdlID0gZm9ybWF0KCBtZXNzYWdlLCBhcmdzICk7XG5cbiAgXHRpZiAoIGFscmVhZHlXYXJuZWRbIG1lc3NhZ2UgXSApIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRhbHJlYWR5V2FybmVkWyBtZXNzYWdlIF0gPSB0cnVlO1xuICBcdHByaW50V2FybmluZyggbWVzc2FnZSwgYXJncyApO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FybklmRGVidWcgKCkge1xuICBcdGlmICggUmFjdGl2ZS5ERUJVRyApIHtcbiAgXHRcdHdhcm4uYXBwbHkoIG51bGwsIGFyZ3VtZW50cyApO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlSWZEZWJ1ZyAoKSB7XG4gIFx0aWYgKCBSYWN0aXZlLkRFQlVHICkge1xuICBcdFx0d2Fybk9uY2UuYXBwbHkoIG51bGwsIGFyZ3VtZW50cyApO1xuICBcdH1cbiAgfVxuXG4gIC8vIEVycm9yIG1lc3NhZ2VzIHRoYXQgYXJlIHVzZWQgKG9yIGNvdWxkIGJlKSBpbiBtdWx0aXBsZSBwbGFjZXNcbiAgdmFyIGJhZEFyZ3VtZW50cyA9ICdCYWQgYXJndW1lbnRzJztcbiAgdmFyIG5vUmVnaXN0cnlGdW5jdGlvblJldHVybiA9ICdBIGZ1bmN0aW9uIHdhcyBzcGVjaWZpZWQgZm9yIFwiJXNcIiAlcywgYnV0IG5vICVzIHdhcyByZXR1cm5lZCc7XG4gIHZhciBtaXNzaW5nUGx1Z2luID0gZnVuY3Rpb24gKCBuYW1lLCB0eXBlICkgeyByZXR1cm4gKFwiTWlzc2luZyBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIFwiICsgdHlwZSArIFwiIHBsdWdpbi4gWW91IG1heSBuZWVkIHRvIGRvd25sb2FkIGEgcGx1Z2luIHZpYSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9wbHVnaW5zI1wiICsgdHlwZSArIFwic1wiKTsgfTtcblxuICBmdW5jdGlvbiBmaW5kSW5WaWV3SGllcmFyY2h5ICggcmVnaXN0cnlOYW1lLCByYWN0aXZlLCBuYW1lICkge1xuICBcdHZhciBpbnN0YW5jZSA9IGZpbmRJbnN0YW5jZSggcmVnaXN0cnlOYW1lLCByYWN0aXZlLCBuYW1lICk7XG4gIFx0cmV0dXJuIGluc3RhbmNlID8gaW5zdGFuY2VbIHJlZ2lzdHJ5TmFtZSBdWyBuYW1lIF0gOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEluc3RhbmNlICggcmVnaXN0cnlOYW1lLCByYWN0aXZlLCBuYW1lICkge1xuICBcdHdoaWxlICggcmFjdGl2ZSApIHtcbiAgXHRcdGlmICggbmFtZSBpbiByYWN0aXZlWyByZWdpc3RyeU5hbWUgXSApIHtcbiAgXHRcdFx0cmV0dXJuIHJhY3RpdmU7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICggcmFjdGl2ZS5pc29sYXRlZCApIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJhY3RpdmUgPSByYWN0aXZlLnBhcmVudDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZSAoIGZyb20sIHRvLCByYWN0aXZlLCB0eXBlICkge1xuICBcdGlmICggZnJvbSA9PT0gdG8gKSByZXR1cm4gbnVsbDtcblxuICBcdGlmICggdHlwZSApIHtcbiAgXHRcdHZhciBpbnRlcnBvbCA9IGZpbmRJblZpZXdIaWVyYXJjaHkoICdpbnRlcnBvbGF0b3JzJywgcmFjdGl2ZSwgdHlwZSApO1xuICBcdFx0aWYgKCBpbnRlcnBvbCApIHJldHVybiBpbnRlcnBvbCggZnJvbSwgdG8gKSB8fCBudWxsO1xuXG4gIFx0XHRmYXRhbCggbWlzc2luZ1BsdWdpbiggdHlwZSwgJ2ludGVycG9sYXRvcicgKSApO1xuICBcdH1cblxuICBcdHJldHVybiBpbnRlcnBvbGF0b3JzLm51bWJlciggZnJvbSwgdG8gKSB8fFxuICBcdCAgICAgICBpbnRlcnBvbGF0b3JzLmFycmF5KCBmcm9tLCB0byApIHx8XG4gIFx0ICAgICAgIGludGVycG9sYXRvcnMub2JqZWN0KCBmcm9tLCB0byApIHx8XG4gIFx0ICAgICAgIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBzbmFwICggdG8gKSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRvOyB9O1xuICB9XG5cbiAgdmFyIGludGVycG9sYXRvcnMgPSB7XG4gIFx0bnVtYmVyOiBmdW5jdGlvbiAoIGZyb20sIHRvICkge1xuICBcdFx0dmFyIGRlbHRhO1xuXG4gIFx0XHRpZiAoICFpc051bWVyaWMoIGZyb20gKSB8fCAhaXNOdW1lcmljKCB0byApICkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0ZnJvbSA9ICtmcm9tO1xuICBcdFx0dG8gPSArdG87XG5cbiAgXHRcdGRlbHRhID0gdG8gLSBmcm9tO1xuXG4gIFx0XHRpZiAoICFkZWx0YSApIHtcbiAgXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb207IH07XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBmdW5jdGlvbiAoIHQgKSB7XG4gIFx0XHRcdHJldHVybiBmcm9tICsgKCB0ICogZGVsdGEgKTtcbiAgXHRcdH07XG4gIFx0fSxcblxuICBcdGFycmF5OiBmdW5jdGlvbiAoIGZyb20sIHRvICkge1xuICBcdFx0dmFyIGludGVybWVkaWF0ZSwgaW50ZXJwb2xhdG9ycywgbGVuLCBpO1xuXG4gIFx0XHRpZiAoICFpc0FycmF5KCBmcm9tICkgfHwgIWlzQXJyYXkoIHRvICkgKSB7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpbnRlcm1lZGlhdGUgPSBbXTtcbiAgXHRcdGludGVycG9sYXRvcnMgPSBbXTtcblxuICBcdFx0aSA9IGxlbiA9IE1hdGgubWluKCBmcm9tLmxlbmd0aCwgdG8ubGVuZ3RoICk7XG4gIFx0XHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdFx0aW50ZXJwb2xhdG9yc1tpXSA9IGludGVycG9sYXRlKCBmcm9tW2ldLCB0b1tpXSApO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBzdXJwbHVzIHZhbHVlcyAtIGRvbid0IGludGVycG9sYXRlLCBidXQgZG9uJ3QgZXhjbHVkZSB0aGVtIGVpdGhlclxuICBcdFx0Zm9yICggaT1sZW47IGk8ZnJvbS5sZW5ndGg7IGkrPTEgKSB7XG4gIFx0XHRcdGludGVybWVkaWF0ZVtpXSA9IGZyb21baV07XG4gIFx0XHR9XG5cbiAgXHRcdGZvciAoIGk9bGVuOyBpPHRvLmxlbmd0aDsgaSs9MSApIHtcbiAgXHRcdFx0aW50ZXJtZWRpYXRlW2ldID0gdG9baV07XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBmdW5jdGlvbiAoIHQgKSB7XG4gIFx0XHRcdHZhciBpID0gbGVuO1xuXG4gIFx0XHRcdHdoaWxlICggaS0tICkge1xuICBcdFx0XHRcdGludGVybWVkaWF0ZVtpXSA9IGludGVycG9sYXRvcnNbaV0oIHQgKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBpbnRlcm1lZGlhdGU7XG4gIFx0XHR9O1xuICBcdH0sXG5cbiAgXHRvYmplY3Q6IGZ1bmN0aW9uICggZnJvbSwgdG8gKSB7XG4gIFx0XHR2YXIgcHJvcGVydGllcywgbGVuLCBpbnRlcnBvbGF0b3JzLCBpbnRlcm1lZGlhdGUsIHByb3A7XG5cbiAgXHRcdGlmICggIWlzT2JqZWN0KCBmcm9tICkgfHwgIWlzT2JqZWN0KCB0byApICkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cHJvcGVydGllcyA9IFtdO1xuICBcdFx0aW50ZXJtZWRpYXRlID0ge307XG4gIFx0XHRpbnRlcnBvbGF0b3JzID0ge307XG5cbiAgXHRcdGZvciAoIHByb3AgaW4gZnJvbSApIHtcbiAgXHRcdFx0aWYgKCBoYXNPd24uY2FsbCggZnJvbSwgcHJvcCApICkge1xuICBcdFx0XHRcdGlmICggaGFzT3duLmNhbGwoIHRvLCBwcm9wICkgKSB7XG4gIFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2goIHByb3AgKTtcbiAgXHRcdFx0XHRcdGludGVycG9sYXRvcnNbIHByb3AgXSA9IGludGVycG9sYXRlKCBmcm9tWyBwcm9wIF0sIHRvWyBwcm9wIF0gKSB8fCBzbmFwKCB0b1sgcHJvcCBdICk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0ZWxzZSB7XG4gIFx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbIHByb3AgXSA9IGZyb21bIHByb3AgXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Zm9yICggcHJvcCBpbiB0byApIHtcbiAgXHRcdFx0aWYgKCBoYXNPd24uY2FsbCggdG8sIHByb3AgKSAmJiAhaGFzT3duLmNhbGwoIGZyb20sIHByb3AgKSApIHtcbiAgXHRcdFx0XHRpbnRlcm1lZGlhdGVbIHByb3AgXSA9IHRvWyBwcm9wIF07XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0bGVuID0gcHJvcGVydGllcy5sZW5ndGg7XG5cbiAgXHRcdHJldHVybiBmdW5jdGlvbiAoIHQgKSB7XG4gIFx0XHRcdHZhciBpID0gbGVuLCBwcm9wO1xuXG4gIFx0XHRcdHdoaWxlICggaS0tICkge1xuICBcdFx0XHRcdHByb3AgPSBwcm9wZXJ0aWVzW2ldO1xuXG4gIFx0XHRcdFx0aW50ZXJtZWRpYXRlWyBwcm9wIF0gPSBpbnRlcnBvbGF0b3JzWyBwcm9wIF0oIHQgKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBpbnRlcm1lZGlhdGU7XG4gIFx0XHR9O1xuICBcdH1cbiAgfTtcblxuICAvLyBUT0RPOiBkZXByZWNhdGUgaW4gZnV0dXJlIHJlbGVhc2VcbiAgdmFyIGRlcHJlY2F0aW9ucyA9IHtcbiAgXHRjb25zdHJ1Y3Q6IHtcbiAgXHRcdGRlcHJlY2F0ZWQ6ICdiZWZvcmVJbml0JyxcbiAgXHRcdHJlcGxhY2VtZW50OiAnb25jb25zdHJ1Y3QnXG4gIFx0fSxcbiAgXHRyZW5kZXI6IHtcbiAgXHRcdGRlcHJlY2F0ZWQ6ICdpbml0JyxcbiAgXHRcdG1lc3NhZ2U6ICdUaGUgXCJpbml0XCIgbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQgJyArXG4gIFx0XHRcdCdhbmQgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiAnICtcbiAgXHRcdFx0J1lvdSBjYW4gZWl0aGVyIHVzZSB0aGUgXCJvbmluaXRcIiBtZXRob2Qgd2hpY2ggd2lsbCBmaXJlICcgK1xuICBcdFx0XHQnb25seSBvbmNlIHByaW9yIHRvLCBhbmQgcmVnYXJkbGVzcyBvZiwgYW55IGV2ZW50dWFsIHJhY3RpdmUgJyArXG4gIFx0XHRcdCdpbnN0YW5jZSBiZWluZyByZW5kZXJlZCwgb3IgaWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSAnICtcbiAgXHRcdFx0J3JlbmRlcmVkIERPTSwgdXNlIFwib25yZW5kZXJcIiBpbnN0ZWFkLiAnICtcbiAgXHRcdFx0J1NlZSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9taWdyYXRpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJ1xuICBcdH0sXG4gIFx0Y29tcGxldGU6IHtcbiAgXHRcdGRlcHJlY2F0ZWQ6ICdjb21wbGV0ZScsXG4gIFx0XHRyZXBsYWNlbWVudDogJ29uY29tcGxldGUnXG4gIFx0fVxuICB9O1xuXG4gIHZhciBIb29rID0gZnVuY3Rpb24gSG9vayAoIGV2ZW50ICkge1xuICBcdHRoaXMuZXZlbnQgPSBldmVudDtcbiAgXHR0aGlzLm1ldGhvZCA9ICdvbicgKyBldmVudDtcbiAgXHR0aGlzLmRlcHJlY2F0ZSA9IGRlcHJlY2F0aW9uc1sgZXZlbnQgXTtcbiAgfTtcblxuICBIb29rLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gY2FsbCAoIG1ldGhvZCwgcmFjdGl2ZSwgYXJnICkge1xuICBcdGlmICggcmFjdGl2ZVsgbWV0aG9kIF0gKSB7XG4gIFx0XHRhcmcgPyByYWN0aXZlWyBtZXRob2QgXSggYXJnICkgOiByYWN0aXZlWyBtZXRob2QgXSgpO1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuICB9O1xuXG4gIEhvb2sucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbiBmaXJlICggcmFjdGl2ZSwgYXJnICkge1xuICBcdHRoaXMuY2FsbCggdGhpcy5tZXRob2QsIHJhY3RpdmUsIGFyZyApO1xuXG4gIFx0Ly8gaGFuZGxlIGRlcHJlY2F0aW9uc1xuICBcdGlmICggIXJhY3RpdmVbIHRoaXMubWV0aG9kIF0gJiYgdGhpcy5kZXByZWNhdGUgJiYgdGhpcy5jYWxsKCB0aGlzLmRlcHJlY2F0ZS5kZXByZWNhdGVkLCByYWN0aXZlLCBhcmcgKSApIHtcbiAgXHRcdGlmICggdGhpcy5kZXByZWNhdGUubWVzc2FnZSApIHtcbiAgXHRcdFx0d2FybklmRGVidWcoIHRoaXMuZGVwcmVjYXRlLm1lc3NhZ2UgKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKCAnVGhlIG1ldGhvZCBcIiVzXCIgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBcIiVzXCIgYW5kIHdpbGwgbGlrZWx5IGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4gU2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L21pZ3JhdGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCB0aGlzLmRlcHJlY2F0ZS5kZXByZWNhdGVkLCB0aGlzLmRlcHJlY2F0ZS5yZXBsYWNlbWVudCApO1xuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIFRPRE8gc2hvdWxkIHByb2JhYmx5IHVzZSBpbnRlcm5hbCBtZXRob2QsIGluIGNhc2UgcmFjdGl2ZS5maXJlIHdhcyBvdmVyd3JpdHRlblxuICBcdGFyZyA/IHJhY3RpdmUuZmlyZSggdGhpcy5ldmVudCwgYXJnICkgOiByYWN0aXZlLmZpcmUoIHRoaXMuZXZlbnQgKTtcbiAgfTtcblxuICBmdW5jdGlvbiBhZGRUb0FycmF5ICggYXJyYXksIHZhbHVlICkge1xuICBcdHZhciBpbmRleCA9IGFycmF5LmluZGV4T2YoIHZhbHVlICk7XG5cbiAgXHRpZiAoIGluZGV4ID09PSAtMSApIHtcbiAgXHRcdGFycmF5LnB1c2goIHZhbHVlICk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlDb250YWlucyAoIGFycmF5LCB2YWx1ZSApIHtcbiAgXHRmb3IgKCB2YXIgaSA9IDAsIGMgPSBhcnJheS5sZW5ndGg7IGkgPCBjOyBpKysgKSB7XG4gIFx0XHRpZiAoIGFycmF5W2ldID09IHZhbHVlICkge1xuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUNvbnRlbnRzTWF0Y2ggKCBhLCBiICkge1xuICBcdHZhciBpO1xuXG4gIFx0aWYgKCAhaXNBcnJheSggYSApIHx8ICFpc0FycmF5KCBiICkgKSB7XG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuXG4gIFx0aWYgKCBhLmxlbmd0aCAhPT0gYi5sZW5ndGggKSB7XG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fVxuXG4gIFx0aSA9IGEubGVuZ3RoO1xuICBcdHdoaWxlICggaS0tICkge1xuICBcdFx0aWYgKCBhW2ldICE9PSBiW2ldICkge1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVBcnJheSAoIHggKSB7XG4gIFx0aWYgKCB0eXBlb2YgeCA9PT0gJ3N0cmluZycgKSB7XG4gIFx0XHRyZXR1cm4gWyB4IF07XG4gIFx0fVxuXG4gIFx0aWYgKCB4ID09PSB1bmRlZmluZWQgKSB7XG4gIFx0XHRyZXR1cm4gW107XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHg7XG4gIH1cblxuICBmdW5jdGlvbiBsYXN0SXRlbSAoIGFycmF5ICkge1xuICBcdHJldHVybiBhcnJheVsgYXJyYXkubGVuZ3RoIC0gMSBdO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRnJvbUFycmF5ICggYXJyYXksIG1lbWJlciApIHtcbiAgXHRpZiAoICFhcnJheSApIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHR2YXIgaW5kZXggPSBhcnJheS5pbmRleE9mKCBtZW1iZXIgKTtcblxuICBcdGlmICggaW5kZXggIT09IC0xICkge1xuICBcdFx0YXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvQXJyYXkgKCBhcnJheUxpa2UgKSB7XG4gIFx0dmFyIGFycmF5ID0gW10sIGkgPSBhcnJheUxpa2UubGVuZ3RoO1xuICBcdHdoaWxlICggaS0tICkge1xuICBcdFx0YXJyYXlbaV0gPSBhcnJheUxpa2VbaV07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGFycmF5O1xuICB9XG5cbiAgdmFyIF9Qcm9taXNlO1xuICB2YXIgUEVORElORyA9IHt9O1xuICB2YXIgRlVMRklMTEVEID0ge307XG4gIHZhciBSRUpFQ1RFRCA9IHt9O1xuICBpZiAoIHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nICkge1xuICBcdC8vIHVzZSBuYXRpdmUgUHJvbWlzZVxuICBcdF9Qcm9taXNlID0gUHJvbWlzZTtcbiAgfSBlbHNlIHtcbiAgXHRfUHJvbWlzZSA9IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG4gIFx0XHR2YXIgZnVsZmlsbGVkSGFuZGxlcnMgPSBbXSxcbiAgXHRcdFx0cmVqZWN0ZWRIYW5kbGVycyA9IFtdLFxuICBcdFx0XHRzdGF0ZSA9IFBFTkRJTkcsXG5cbiAgXHRcdFx0cmVzdWx0LFxuICBcdFx0XHRkaXNwYXRjaEhhbmRsZXJzLFxuICBcdFx0XHRtYWtlUmVzb2x2ZXIsXG4gIFx0XHRcdGZ1bGZpbCxcbiAgXHRcdFx0cmVqZWN0LFxuXG4gIFx0XHRcdHByb21pc2U7XG5cbiAgXHRcdG1ha2VSZXNvbHZlciA9IGZ1bmN0aW9uICggbmV3U3RhdGUgKSB7XG4gIFx0XHRcdHJldHVybiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICBcdFx0XHRcdGlmICggc3RhdGUgIT09IFBFTkRJTkcgKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0cmVzdWx0ID0gdmFsdWU7XG4gIFx0XHRcdFx0c3RhdGUgPSBuZXdTdGF0ZTtcblxuICBcdFx0XHRcdGRpc3BhdGNoSGFuZGxlcnMgPSBtYWtlRGlzcGF0Y2hlciggKCBzdGF0ZSA9PT0gRlVMRklMTEVEID8gZnVsZmlsbGVkSGFuZGxlcnMgOiByZWplY3RlZEhhbmRsZXJzICksIHJlc3VsdCApO1xuXG4gIFx0XHRcdFx0Ly8gZGlzcGF0Y2ggb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgaGFuZGxlcnMgYXN5bmNocm9ub3VzbHlcbiAgXHRcdFx0XHR3YWl0KCBkaXNwYXRjaEhhbmRsZXJzICk7XG4gIFx0XHRcdH07XG4gIFx0XHR9O1xuXG4gIFx0XHRmdWxmaWwgPSBtYWtlUmVzb2x2ZXIoIEZVTEZJTExFRCApO1xuICBcdFx0cmVqZWN0ID0gbWFrZVJlc29sdmVyKCBSRUpFQ1RFRCApO1xuXG4gIFx0XHR0cnkge1xuICBcdFx0XHRjYWxsYmFjayggZnVsZmlsLCByZWplY3QgKTtcbiAgXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG4gIFx0XHRcdHJlamVjdCggZXJyICk7XG4gIFx0XHR9XG5cbiAgXHRcdHByb21pc2UgPSB7XG4gIFx0XHRcdC8vIGB0aGVuKClgIHJldHVybnMgYSBQcm9taXNlIC0gMi4yLjdcbiAgXHRcdFx0dGhlbjogZnVuY3Rpb24gKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCApIHtcbiAgXHRcdFx0XHR2YXIgcHJvbWlzZTIgPSBuZXcgX1Byb21pc2UoIGZ1bmN0aW9uICggZnVsZmlsLCByZWplY3QgKSB7XG5cbiAgXHRcdFx0XHRcdHZhciBwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAoIGhhbmRsZXIsIGhhbmRsZXJzLCBmb3J3YXJkICkge1xuXG4gIFx0XHRcdFx0XHRcdC8vIDIuMi4xLjFcbiAgXHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgXHRcdFx0XHRcdFx0XHRoYW5kbGVycy5wdXNoKCBmdW5jdGlvbiAoIHAxcmVzdWx0ICkge1xuICBcdFx0XHRcdFx0XHRcdFx0dmFyIHg7XG5cbiAgXHRcdFx0XHRcdFx0XHRcdHRyeSB7XG4gIFx0XHRcdFx0XHRcdFx0XHRcdHggPSBoYW5kbGVyKCBwMXJlc3VsdCApO1xuICBcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBwcm9taXNlMiwgeCwgZnVsZmlsLCByZWplY3QgKTtcbiAgXHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG4gIFx0XHRcdFx0XHRcdFx0XHRcdHJlamVjdCggZXJyICk7XG4gIFx0XHRcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdFx0Ly8gRm9yd2FyZCB0aGUgcmVzdWx0IG9mIHByb21pc2UxIHRvIHByb21pc2UyLCBpZiByZXNvbHV0aW9uIGhhbmRsZXJzXG4gIFx0XHRcdFx0XHRcdFx0Ly8gYXJlIG5vdCBnaXZlblxuICBcdFx0XHRcdFx0XHRcdGhhbmRsZXJzLnB1c2goIGZvcndhcmQgKTtcbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fTtcblxuICBcdFx0XHRcdFx0Ly8gMi4yXG4gIFx0XHRcdFx0XHRwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIoIG9uRnVsZmlsbGVkLCBmdWxmaWxsZWRIYW5kbGVycywgZnVsZmlsICk7XG4gIFx0XHRcdFx0XHRwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIoIG9uUmVqZWN0ZWQsIHJlamVjdGVkSGFuZGxlcnMsIHJlamVjdCApO1xuXG4gIFx0XHRcdFx0XHRpZiAoIHN0YXRlICE9PSBQRU5ESU5HICkge1xuICBcdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJvbWlzZSBoYXMgcmVzb2x2ZWQgYWxyZWFkeSwgZGlzcGF0Y2ggdGhlIGFwcHJvcHJpYXRlIGhhbmRsZXJzIGFzeW5jaHJvbm91c2x5XG4gIFx0XHRcdFx0XHRcdHdhaXQoIGRpc3BhdGNoSGFuZGxlcnMgKTtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdH0pO1xuXG4gIFx0XHRcdFx0cmV0dXJuIHByb21pc2UyO1xuICBcdFx0XHR9XG4gIFx0XHR9O1xuXG4gIFx0XHRwcm9taXNlWyAnY2F0Y2gnIF0gPSBmdW5jdGlvbiAoIG9uUmVqZWN0ZWQgKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLnRoZW4oIG51bGwsIG9uUmVqZWN0ZWQgKTtcbiAgXHRcdH07XG5cbiAgXHRcdHJldHVybiBwcm9taXNlO1xuICBcdH07XG5cbiAgXHRfUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoIHByb21pc2VzICkge1xuICBcdFx0cmV0dXJuIG5ldyBfUHJvbWlzZSggZnVuY3Rpb24gKCBmdWxmaWwsIHJlamVjdCApIHtcbiAgXHRcdFx0dmFyIHJlc3VsdCA9IFtdLCBwZW5kaW5nLCBpLCBwcm9jZXNzUHJvbWlzZTtcblxuICBcdFx0XHRpZiAoICFwcm9taXNlcy5sZW5ndGggKSB7XG4gIFx0XHRcdFx0ZnVsZmlsKCByZXN1bHQgKTtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwcm9jZXNzUHJvbWlzZSA9IGZ1bmN0aW9uICggcHJvbWlzZSwgaSApIHtcbiAgXHRcdFx0XHRpZiAoIHByb21pc2UgJiYgdHlwZW9mIHByb21pc2UudGhlbiA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgXHRcdFx0XHRcdHByb21pc2UudGhlbiggZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgXHRcdFx0XHRcdFx0cmVzdWx0W2ldID0gdmFsdWU7XG4gIFx0XHRcdFx0XHRcdC0tcGVuZGluZyB8fCBmdWxmaWwoIHJlc3VsdCApO1xuICBcdFx0XHRcdFx0fSwgcmVqZWN0ICk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0ZWxzZSB7XG4gIFx0XHRcdFx0XHRyZXN1bHRbaV0gPSBwcm9taXNlO1xuICBcdFx0XHRcdFx0LS1wZW5kaW5nIHx8IGZ1bGZpbCggcmVzdWx0ICk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9O1xuXG4gIFx0XHRcdHBlbmRpbmcgPSBpID0gcHJvbWlzZXMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdFx0XHRwcm9jZXNzUHJvbWlzZSggcHJvbWlzZXNbaV0sIGkgKTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fTtcblxuICBcdF9Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuICBcdFx0cmV0dXJuIG5ldyBfUHJvbWlzZSggZnVuY3Rpb24gKCBmdWxmaWwgKSB7XG4gIFx0XHRcdGZ1bGZpbCggdmFsdWUgKTtcbiAgXHRcdH0pO1xuICBcdH07XG5cbiAgXHRfUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAoIHJlYXNvbiApIHtcbiAgXHRcdHJldHVybiBuZXcgX1Byb21pc2UoIGZ1bmN0aW9uICggZnVsZmlsLCByZWplY3QgKSB7XG4gIFx0XHRcdHJlamVjdCggcmVhc29uICk7XG4gIFx0XHR9KTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIFByb21pc2UkMSA9IF9Qcm9taXNlO1xuXG4gIC8vIFRPRE8gdXNlIE11dGF0aW9uT2JzZXJ2ZXJzIG9yIHNvbWV0aGluZyB0byBzaW11bGF0ZSBzZXRJbW1lZGlhdGVcbiAgZnVuY3Rpb24gd2FpdCAoIGNhbGxiYWNrICkge1xuICBcdHNldFRpbWVvdXQoIGNhbGxiYWNrLCAwICk7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlRGlzcGF0Y2hlciAoIGhhbmRsZXJzLCByZXN1bHQgKSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBoYW5kbGVyO1xuXG4gIFx0XHR3aGlsZSAoIGhhbmRsZXIgPSBoYW5kbGVycy5zaGlmdCgpICkge1xuICBcdFx0XHRoYW5kbGVyKCByZXN1bHQgKTtcbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZSAoIHByb21pc2UsIHgsIGZ1bGZpbCwgcmVqZWN0ICkge1xuICBcdC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmVcbiAgXHR2YXIgdGhlbjtcblxuICBcdC8vIDIuMy4xXG4gIFx0aWYgKCB4ID09PSBwcm9taXNlICkge1xuICBcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ0EgcHJvbWlzZVxcJ3MgZnVsZmlsbG1lbnQgaGFuZGxlciBjYW5ub3QgcmV0dXJuIHRoZSBzYW1lIHByb21pc2UnICk7XG4gIFx0fVxuXG4gIFx0Ly8gMi4zLjJcbiAgXHRpZiAoIHggaW5zdGFuY2VvZiBfUHJvbWlzZSApIHtcbiAgXHRcdHgudGhlbiggZnVsZmlsLCByZWplY3QgKTtcbiAgXHR9XG5cbiAgXHQvLyAyLjMuM1xuICBcdGVsc2UgaWYgKCB4ICYmICggdHlwZW9mIHggPT09ICdvYmplY3QnIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nICkgKSB7XG4gIFx0XHR0cnkge1xuICBcdFx0XHR0aGVuID0geC50aGVuOyAvLyAyLjMuMy4xXG4gIFx0XHR9IGNhdGNoICggZSApIHtcbiAgXHRcdFx0cmVqZWN0KCBlICk7IC8vIDIuMy4zLjJcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHQvLyAyLjMuMy4zXG4gIFx0XHRpZiAoIHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nICkge1xuICBcdFx0XHR2YXIgY2FsbGVkLCByZXNvbHZlUHJvbWlzZSwgcmVqZWN0UHJvbWlzZTtcblxuICBcdFx0XHRyZXNvbHZlUHJvbWlzZSA9IGZ1bmN0aW9uICggeSApIHtcbiAgXHRcdFx0XHRpZiAoIGNhbGxlZCApIHtcbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHRyZXNvbHZlKCBwcm9taXNlLCB5LCBmdWxmaWwsIHJlamVjdCApO1xuICBcdFx0XHR9O1xuXG4gIFx0XHRcdHJlamVjdFByb21pc2UgPSBmdW5jdGlvbiAoIHIgKSB7XG4gIFx0XHRcdFx0aWYgKCBjYWxsZWQgKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdFx0fVxuICBcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG4gIFx0XHRcdFx0cmVqZWN0KCByICk7XG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0dHJ5IHtcbiAgXHRcdFx0XHR0aGVuLmNhbGwoIHgsIHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlICk7XG4gIFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuICBcdFx0XHRcdGlmICggIWNhbGxlZCApIHsgLy8gMi4zLjMuMy40LjFcbiAgXHRcdFx0XHRcdHJlamVjdCggZSApOyAvLyAyLjMuMy4zLjQuMlxuICBcdFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdGZ1bGZpbCggeCApO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGVsc2Uge1xuICBcdFx0ZnVsZmlsKCB4ICk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIFRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24gVHJhbnNpdGlvbk1hbmFnZXIgKCBjYWxsYmFjaywgcGFyZW50ICkge1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgXHR0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICBcdHRoaXMuaW50cm9zID0gW107XG4gIFx0dGhpcy5vdXRyb3MgPSBbXTtcblxuICBcdHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgXHR0aGlzLnRvdGFsQ2hpbGRyZW4gPSB0aGlzLm91dHJvQ2hpbGRyZW4gPSAwO1xuXG4gIFx0dGhpcy5kZXRhY2hRdWV1ZSA9IFtdO1xuICBcdHRoaXMub3V0cm9zQ29tcGxldGUgPSBmYWxzZTtcblxuICBcdGlmICggcGFyZW50ICkge1xuICBcdFx0cGFyZW50LmFkZENoaWxkKCB0aGlzICk7XG4gIFx0fVxuICB9O1xuXG4gIFRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKCB0cmFuc2l0aW9uICkge1xuICBcdHZhciBsaXN0ID0gdHJhbnNpdGlvbi5pc0ludHJvID8gdGhpcy5pbnRyb3MgOiB0aGlzLm91dHJvcztcbiAgXHRsaXN0LnB1c2goIHRyYW5zaXRpb24gKTtcbiAgfTtcblxuICBUcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZCAoIGNoaWxkICkge1xuICBcdHRoaXMuY2hpbGRyZW4ucHVzaCggY2hpbGQgKTtcblxuICBcdHRoaXMudG90YWxDaGlsZHJlbiArPSAxO1xuICBcdHRoaXMub3V0cm9DaGlsZHJlbiArPSAxO1xuICB9O1xuXG4gIFRyYW5zaXRpb25NYW5hZ2VyLnByb3RvdHlwZS5kZWNyZW1lbnRPdXRyb3MgPSBmdW5jdGlvbiBkZWNyZW1lbnRPdXRyb3MgKCkge1xuICBcdHRoaXMub3V0cm9DaGlsZHJlbiAtPSAxO1xuICBcdGNoZWNrKCB0aGlzICk7XG4gIH07XG5cbiAgVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlLmRlY3JlbWVudFRvdGFsID0gZnVuY3Rpb24gZGVjcmVtZW50VG90YWwgKCkge1xuICBcdHRoaXMudG90YWxDaGlsZHJlbiAtPSAxO1xuICBcdGNoZWNrKCB0aGlzICk7XG4gIH07XG5cbiAgVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlLmRldGFjaE5vZGVzID0gZnVuY3Rpb24gZGV0YWNoTm9kZXMgKCkge1xuICBcdHRoaXMuZGV0YWNoUXVldWUuZm9yRWFjaCggZGV0YWNoICk7XG4gIFx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKCBfZGV0YWNoTm9kZXMgKTtcbiAgfTtcblxuICBUcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiByZWFkeSAoKSB7XG4gIFx0ZGV0YWNoSW1tZWRpYXRlKCB0aGlzICk7XG4gIH07XG5cbiAgVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoIHRyYW5zaXRpb24gKSB7XG4gIFx0dmFyIGxpc3QgPSB0cmFuc2l0aW9uLmlzSW50cm8gPyB0aGlzLmludHJvcyA6IHRoaXMub3V0cm9zO1xuICBcdHJlbW92ZUZyb21BcnJheSggbGlzdCwgdHJhbnNpdGlvbiApO1xuICBcdGNoZWNrKCB0aGlzICk7XG4gIH07XG5cbiAgVHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQgKCkge1xuICBcdHRoaXMuY2hpbGRyZW4uZm9yRWFjaCggZnVuY3Rpb24gKCBjICkgeyByZXR1cm4gYy5zdGFydCgpOyB9ICk7XG4gIFx0dGhpcy5pbnRyb3MuY29uY2F0KCB0aGlzLm91dHJvcyApLmZvckVhY2goIGZ1bmN0aW9uICggdCApIHsgcmV0dXJuIHQuc3RhcnQoKTsgfSApO1xuICBcdHRoaXMucmVhZHkgPSB0cnVlO1xuICBcdGNoZWNrKCB0aGlzICk7XG4gIH07XG5cbiAgZnVuY3Rpb24gZGV0YWNoICggZWxlbWVudCApIHtcbiAgXHRlbGVtZW50LmRldGFjaCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2RldGFjaE5vZGVzICggdG0gKSB7IC8vIF8gdG8gYXZvaWQgdHJhbnNwaWxlciBxdWlya1xuICBcdHRtLmRldGFjaE5vZGVzKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVjayAoIHRtICkge1xuICBcdGlmICggIXRtLnJlYWR5IHx8IHRtLm91dHJvcy5sZW5ndGggfHwgdG0ub3V0cm9DaGlsZHJlbiApIHJldHVybjtcblxuICBcdC8vIElmIGFsbCBvdXRyb3MgYXJlIGNvbXBsZXRlLCBhbmQgd2UgaGF2ZW4ndCBhbHJlYWR5IGRvbmUgdGhpcyxcbiAgXHQvLyB3ZSBub3RpZnkgdGhlIHBhcmVudCBpZiB0aGVyZSBpcyBvbmUsIG90aGVyd2lzZVxuICBcdC8vIHN0YXJ0IGRldGFjaGluZyBub2Rlc1xuICBcdGlmICggIXRtLm91dHJvc0NvbXBsZXRlICkge1xuICBcdFx0dG0ub3V0cm9zQ29tcGxldGUgPSB0cnVlO1xuXG4gIFx0XHRpZiAoIHRtLnBhcmVudCAmJiAhdG0ucGFyZW50Lm91dHJvc0NvbXBsZXRlICkge1xuICBcdFx0XHR0bS5wYXJlbnQuZGVjcmVtZW50T3V0cm9zKCB0bSApO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dG0uZGV0YWNoTm9kZXMoKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBPbmNlIGV2ZXJ5dGhpbmcgaXMgZG9uZSwgd2UgY2FuIG5vdGlmeSBwYXJlbnQgdHJhbnNpdGlvblxuICBcdC8vIG1hbmFnZXIgYW5kIGNhbGwgdGhlIGNhbGxiYWNrXG4gIFx0aWYgKCAhdG0uaW50cm9zLmxlbmd0aCAmJiAhdG0udG90YWxDaGlsZHJlbiApIHtcbiAgXHRcdGlmICggdHlwZW9mIHRtLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nICkge1xuICBcdFx0XHR0bS5jYWxsYmFjaygpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIHRtLnBhcmVudCAmJiAhdG0ubm90aWZpZWRUb3RhbCApIHtcbiAgXHRcdFx0dG0ubm90aWZpZWRUb3RhbCA9IHRydWU7XG4gIFx0XHRcdHRtLnBhcmVudC5kZWNyZW1lbnRUb3RhbCgpO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIC8vIGNoZWNrIHRocm91Z2ggdGhlIGRldGFjaCBxdWV1ZSB0byBzZWUgaWYgYSBub2RlIGlzIHVwIG9yIGRvd25zdHJlYW0gZnJvbSBhXG4gIC8vIHRyYW5zaXRpb24gYW5kIGlmIG5vdCwgZ28gYWhlYWQgYW5kIGRldGFjaCBpdFxuICBmdW5jdGlvbiBkZXRhY2hJbW1lZGlhdGUgKCBtYW5hZ2VyICkge1xuICBcdHZhciBxdWV1ZSA9IG1hbmFnZXIuZGV0YWNoUXVldWU7XG4gIFx0dmFyIG91dHJvcyA9IGNvbGxlY3RBbGxPdXRyb3MoIG1hbmFnZXIgKTtcblxuICBcdHZhciBpID0gcXVldWUubGVuZ3RoLCBqID0gMCwgbm9kZSwgdHJhbnM7XG4gIFx0c3RhcnQ6IHdoaWxlICggaS0tICkge1xuICBcdFx0bm9kZSA9IHF1ZXVlW2ldLm5vZGU7XG4gIFx0XHRqID0gb3V0cm9zLmxlbmd0aDtcbiAgXHRcdHdoaWxlICggai0tICkge1xuICBcdFx0XHR0cmFucyA9IG91dHJvc1tqXS5lbGVtZW50Lm5vZGU7XG4gIFx0XHRcdC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgbm9kZSBpcywgY29udGFpbnMsIG9yIGlzIGNvbnRhaW5lZCBieSB0aGUgdHJhbnNpdGlvbmluZyBub2RlXG4gIFx0XHRcdGlmICggdHJhbnMgPT09IG5vZGUgfHwgdHJhbnMuY29udGFpbnMoIG5vZGUgKSB8fCBub2RlLmNvbnRhaW5zKCB0cmFucyApICkgY29udGludWUgc3RhcnQ7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIG5vIG1hdGNoLCB3ZSBjYW4gZHJvcCBpdFxuICBcdFx0cXVldWVbaV0uZGV0YWNoKCk7XG4gIFx0XHRxdWV1ZS5zcGxpY2UoIGksIDEgKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBjb2xsZWN0QWxsT3V0cm9zICggbWFuYWdlciwgbGlzdCApIHtcbiAgXHRpZiAoICFsaXN0ICkge1xuICBcdFx0bGlzdCA9IFtdO1xuICBcdFx0dmFyIHBhcmVudCA9IG1hbmFnZXI7XG4gIFx0XHR3aGlsZSAoIHBhcmVudC5wYXJlbnQgKSBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICBcdFx0cmV0dXJuIGNvbGxlY3RBbGxPdXRyb3MoIHBhcmVudCwgbGlzdCApO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR2YXIgaSA9IG1hbmFnZXIuY2hpbGRyZW4ubGVuZ3RoO1xuICBcdFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRcdGxpc3QgPSBjb2xsZWN0QWxsT3V0cm9zKCBtYW5hZ2VyLmNoaWxkcmVuW2ldLCBsaXN0ICk7XG4gIFx0XHR9XG4gIFx0XHRsaXN0ID0gbGlzdC5jb25jYXQoIG1hbmFnZXIub3V0cm9zICk7XG4gIFx0XHRyZXR1cm4gbGlzdDtcbiAgXHR9XG4gIH1cblxuICB2YXIgY2hhbmdlSG9vayA9IG5ldyBIb29rKCAnY2hhbmdlJyApO1xuXG4gIHZhciBiYXRjaDtcblxuICB2YXIgcnVubG9vcCA9IHtcbiAgXHRzdGFydDogZnVuY3Rpb24gKCBpbnN0YW5jZSwgcmV0dXJuUHJvbWlzZSApIHtcbiAgXHRcdHZhciBwcm9taXNlLCBmdWxmaWxQcm9taXNlO1xuXG4gIFx0XHRpZiAoIHJldHVyblByb21pc2UgKSB7XG4gIFx0XHRcdHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKCBmdW5jdGlvbiAoIGYgKSB7IHJldHVybiAoIGZ1bGZpbFByb21pc2UgPSBmICk7IH0gKTtcbiAgXHRcdH1cblxuICBcdFx0YmF0Y2ggPSB7XG4gIFx0XHRcdHByZXZpb3VzQmF0Y2g6IGJhdGNoLFxuICBcdFx0XHR0cmFuc2l0aW9uTWFuYWdlcjogbmV3IFRyYW5zaXRpb25NYW5hZ2VyKCBmdWxmaWxQcm9taXNlLCBiYXRjaCAmJiBiYXRjaC50cmFuc2l0aW9uTWFuYWdlciApLFxuICBcdFx0XHRmcmFnbWVudHM6IFtdLFxuICBcdFx0XHR0YXNrczogW10sXG4gIFx0XHRcdGltbWVkaWF0ZU9ic2VydmVyczogW10sXG4gIFx0XHRcdGRlZmVycmVkT2JzZXJ2ZXJzOiBbXSxcbiAgXHRcdFx0cmFjdGl2ZXM6IFtdLFxuICBcdFx0XHRpbnN0YW5jZTogaW5zdGFuY2VcbiAgXHRcdH07XG5cbiAgXHRcdHJldHVybiBwcm9taXNlO1xuICBcdH0sXG5cbiAgXHRlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdGZsdXNoQ2hhbmdlcygpO1xuXG4gIFx0XHRpZiAoICFiYXRjaC5wcmV2aW91c0JhdGNoICkgYmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuc3RhcnQoKTtcblxuICBcdFx0YmF0Y2ggPSBiYXRjaC5wcmV2aW91c0JhdGNoO1xuICBcdH0sXG5cbiAgXHRhZGRGcmFnbWVudDogZnVuY3Rpb24gKCBmcmFnbWVudCApIHtcbiAgXHRcdGFkZFRvQXJyYXkoIGJhdGNoLmZyYWdtZW50cywgZnJhZ21lbnQgKTtcbiAgXHR9LFxuXG4gIFx0Ly8gVE9ETzogY29tZSB1cCB3aXRoIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgZnJhZ21lbnRzIHRoYXQgdHJpZ2dlciB0aGVpciBvd24gdXBkYXRlXG4gIFx0YWRkRnJhZ21lbnRUb1Jvb3Q6IGZ1bmN0aW9uICggZnJhZ21lbnQgKSB7XG4gIFx0XHRpZiAoICFiYXRjaCApIHJldHVybjtcblxuICBcdFx0dmFyIGIgPSBiYXRjaDtcbiAgXHRcdHdoaWxlICggYi5wcmV2aW91c0JhdGNoICkge1xuICBcdFx0XHRiID0gYi5wcmV2aW91c0JhdGNoO1xuICBcdFx0fVxuXG4gIFx0XHRhZGRUb0FycmF5KCBiLmZyYWdtZW50cywgZnJhZ21lbnQgKTtcbiAgXHR9LFxuXG4gIFx0YWRkSW5zdGFuY2U6IGZ1bmN0aW9uICggaW5zdGFuY2UgKSB7XG4gIFx0XHRpZiAoIGJhdGNoICkgYWRkVG9BcnJheSggYmF0Y2gucmFjdGl2ZXMsIGluc3RhbmNlICk7XG4gIFx0fSxcblxuICBcdGFkZE9ic2VydmVyOiBmdW5jdGlvbiAoIG9ic2VydmVyLCBkZWZlciApIHtcbiAgXHRcdGFkZFRvQXJyYXkoIGRlZmVyID8gYmF0Y2guZGVmZXJyZWRPYnNlcnZlcnMgOiBiYXRjaC5pbW1lZGlhdGVPYnNlcnZlcnMsIG9ic2VydmVyICk7XG4gIFx0fSxcblxuICBcdHJlZ2lzdGVyVHJhbnNpdGlvbjogZnVuY3Rpb24gKCB0cmFuc2l0aW9uICkge1xuICBcdFx0dHJhbnNpdGlvbi5fbWFuYWdlciA9IGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyO1xuICBcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuYWRkKCB0cmFuc2l0aW9uICk7XG4gIFx0fSxcblxuICBcdC8vIHN5bmNocm9uaXNlIG5vZGUgZGV0YWNobWVudHMgd2l0aCB0cmFuc2l0aW9uIGVuZHNcbiAgXHRkZXRhY2hXaGVuUmVhZHk6IGZ1bmN0aW9uICggdGhpbmcgKSB7XG4gIFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5kZXRhY2hRdWV1ZS5wdXNoKCB0aGluZyApO1xuICBcdH0sXG5cbiAgXHRzY2hlZHVsZVRhc2s6IGZ1bmN0aW9uICggdGFzaywgcG9zdFJlbmRlciApIHtcbiAgXHRcdHZhciBfYmF0Y2g7XG5cbiAgXHRcdGlmICggIWJhdGNoICkge1xuICBcdFx0XHR0YXNrKCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRfYmF0Y2ggPSBiYXRjaDtcbiAgXHRcdFx0d2hpbGUgKCBwb3N0UmVuZGVyICYmIF9iYXRjaC5wcmV2aW91c0JhdGNoICkge1xuICBcdFx0XHRcdC8vIHRoaXMgY2FuJ3QgaGFwcGVuIHVudGlsIHRoZSBET00gaGFzIGJlZW4gZnVsbHkgdXBkYXRlZFxuICBcdFx0XHRcdC8vIG90aGVyd2lzZSBpbiBzb21lIHNpdHVhdGlvbnMgKHdpdGggY29tcG9uZW50cyBpbnNpZGUgZWxlbWVudHMpXG4gIFx0XHRcdFx0Ly8gdHJhbnNpdGlvbnMgYW5kIGRlY29yYXRvcnMgd2lsbCBpbml0aWFsaXNlIHByZW1hdHVyZWx5XG4gIFx0XHRcdFx0X2JhdGNoID0gX2JhdGNoLnByZXZpb3VzQmF0Y2g7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRfYmF0Y2gudGFza3MucHVzaCggdGFzayApO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiBkaXNwYXRjaCAoIG9ic2VydmVyICkge1xuICBcdG9ic2VydmVyLmRpc3BhdGNoKCk7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaENoYW5nZXMgKCkge1xuICBcdHZhciB3aGljaCA9IGJhdGNoLmltbWVkaWF0ZU9ic2VydmVycztcbiAgXHRiYXRjaC5pbW1lZGlhdGVPYnNlcnZlcnMgPSBbXTtcbiAgXHR3aGljaC5mb3JFYWNoKCBkaXNwYXRjaCApO1xuXG4gIFx0Ly8gTm93IHRoYXQgY2hhbmdlcyBoYXZlIGJlZW4gZnVsbHkgcHJvcGFnYXRlZCwgd2UgY2FuIHVwZGF0ZSB0aGUgRE9NXG4gIFx0Ly8gYW5kIGNvbXBsZXRlIG90aGVyIHRhc2tzXG4gIFx0dmFyIGkgPSBiYXRjaC5mcmFnbWVudHMubGVuZ3RoO1xuICBcdHZhciBmcmFnbWVudDtcblxuICBcdHdoaWNoID0gYmF0Y2guZnJhZ21lbnRzO1xuICBcdGJhdGNoLmZyYWdtZW50cyA9IFtdO1xuICBcdHZhciByYWN0aXZlcyA9IGJhdGNoLnJhY3RpdmVzO1xuICBcdGJhdGNoLnJhY3RpdmVzID0gW107XG5cbiAgXHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdGZyYWdtZW50ID0gd2hpY2hbaV07XG5cbiAgXHRcdC8vIFRPRE8gZGVwcmVjYXRlIHRoaXMuIEl0J3MgYW5ub3lpbmcgYW5kIHNlcnZlcyBubyB1c2VmdWwgZnVuY3Rpb25cbiAgXHRcdHZhciByYWN0aXZlID0gZnJhZ21lbnQucmFjdGl2ZTtcbiAgXHRcdGlmICggT2JqZWN0LmtleXMoIHJhY3RpdmUudmlld21vZGVsLmNoYW5nZXMgKS5sZW5ndGggKSB7XG4gIFx0XHRcdGNoYW5nZUhvb2suZmlyZSggcmFjdGl2ZSwgcmFjdGl2ZS52aWV3bW9kZWwuY2hhbmdlcyApO1xuICBcdFx0fVxuICBcdFx0cmFjdGl2ZS52aWV3bW9kZWwuY2hhbmdlcyA9IHt9O1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KCByYWN0aXZlcywgcmFjdGl2ZSApO1xuXG4gIFx0XHRmcmFnbWVudC51cGRhdGUoKTtcbiAgXHR9XG5cbiAgXHRpID0gcmFjdGl2ZXMubGVuZ3RoO1xuICBcdHdoaWxlICggaS0tICkge1xuICBcdFx0dmFyIHJhY3RpdmUkMSA9IHJhY3RpdmVzW2ldO1xuICBcdFx0Y2hhbmdlSG9vay5maXJlKCByYWN0aXZlJDEsIHJhY3RpdmUkMS52aWV3bW9kZWwuY2hhbmdlcyApO1xuICBcdFx0cmFjdGl2ZSQxLnZpZXdtb2RlbC5jaGFuZ2VzID0ge307XG4gIFx0fVxuXG4gIFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIucmVhZHkoKTtcblxuICBcdHdoaWNoID0gYmF0Y2guZGVmZXJyZWRPYnNlcnZlcnM7XG4gIFx0YmF0Y2guZGVmZXJyZWRPYnNlcnZlcnMgPSBbXTtcbiAgXHR3aGljaC5mb3JFYWNoKCBkaXNwYXRjaCApO1xuXG4gIFx0dmFyIHRhc2tzID0gYmF0Y2gudGFza3M7XG4gIFx0YmF0Y2gudGFza3MgPSBbXTtcblxuICBcdGZvciAoIGkgPSAwOyBpIDwgdGFza3MubGVuZ3RoOyBpICs9IDEgKSB7XG4gIFx0XHR0YXNrc1tpXSgpO1xuICBcdH1cblxuICBcdC8vIElmIHVwZGF0aW5nIHRoZSB2aWV3IGNhdXNlZCBzb21lIG1vZGVsIGJsb3diYWNrIC0gZS5nLiBhIHRyaXBsZVxuICBcdC8vIGNvbnRhaW5pbmcgPG9wdGlvbj4gZWxlbWVudHMgY2F1c2VkIHRoZSBiaW5kaW5nIG9uIHRoZSA8c2VsZWN0PlxuICBcdC8vIHRvIHVwZGF0ZSAtIHRoZW4gd2Ugc3RhcnQgb3ZlclxuICBcdGlmICggYmF0Y2guZnJhZ21lbnRzLmxlbmd0aCB8fCBiYXRjaC5pbW1lZGlhdGVPYnNlcnZlcnMubGVuZ3RoIHx8IGJhdGNoLmRlZmVycmVkT2JzZXJ2ZXJzLmxlbmd0aCB8fCBiYXRjaC5yYWN0aXZlcy5sZW5ndGggfHwgYmF0Y2gudGFza3MubGVuZ3RoICkgcmV0dXJuIGZsdXNoQ2hhbmdlcygpO1xuICB9XG5cbiAgdmFyIHJlZlBhdHRlcm4gPSAvXFxbXFxzKihcXCp8WzAtOV18WzEtOV1bMC05XSspXFxzKlxcXS9nO1xuICB2YXIgc3BsaXRQYXR0ZXJuID0gLyhbXlxcXFxdKD86XFxcXFxcXFwpKilcXC4vO1xuICB2YXIgZXNjYXBlS2V5UGF0dGVybiA9IC9cXFxcfFxcLi9nO1xuICB2YXIgdW5lc2NhcGVLZXlQYXR0ZXJuID0gLygoPzpcXFxcKSspXFwxfFxcXFwoXFwuKS9nO1xuXG4gIGZ1bmN0aW9uIGVzY2FwZUtleSAoIGtleSApIHtcbiAgXHRpZiAoIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICkge1xuICBcdFx0cmV0dXJuIGtleS5yZXBsYWNlKCBlc2NhcGVLZXlQYXR0ZXJuLCAnXFxcXCQmJyApO1xuICBcdH1cblxuICBcdHJldHVybiBrZXk7XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpc2UgKCByZWYgKSB7XG4gIFx0cmV0dXJuIHJlZiA/IHJlZi5yZXBsYWNlKCByZWZQYXR0ZXJuLCAnLiQxJyApIDogJyc7XG4gIH1cblxuICBmdW5jdGlvbiBzcGxpdEtleXBhdGhJICgga2V5cGF0aCApIHtcbiAgXHR2YXIgcmVzdWx0ID0gW10sXG4gIFx0XHRtYXRjaDtcblxuICBcdGtleXBhdGggPSBub3JtYWxpc2UoIGtleXBhdGggKTtcblxuICBcdHdoaWxlICggbWF0Y2ggPSBzcGxpdFBhdHRlcm4uZXhlYygga2V5cGF0aCApICkge1xuICBcdFx0dmFyIGluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFsxXS5sZW5ndGg7XG4gIFx0XHRyZXN1bHQucHVzaCgga2V5cGF0aC5zdWJzdHIoIDAsIGluZGV4ICkgKTtcbiAgXHRcdGtleXBhdGggPSBrZXlwYXRoLnN1YnN0ciggaW5kZXggKyAxICk7XG4gIFx0fVxuXG4gIFx0cmVzdWx0LnB1c2goa2V5cGF0aCk7XG5cbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gdW5lc2NhcGVLZXkgKCBrZXkgKSB7XG4gIFx0aWYgKCB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyApIHtcbiAgXHRcdHJldHVybiBrZXkucmVwbGFjZSggdW5lc2NhcGVLZXlQYXR0ZXJuLCAnJDEkMicgKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ga2V5O1xuICB9XG5cbiAgZnVuY3Rpb24gYmluZCAoIGZuLCBjb250ZXh0ICkge1xuICBcdGlmICggIS90aGlzLy50ZXN0KCBmbi50b1N0cmluZygpICkgKSByZXR1cm4gZm47XG5cbiAgXHR2YXIgYm91bmQgPSBmbi5iaW5kKCBjb250ZXh0ICk7XG4gIFx0Zm9yICggdmFyIHByb3AgaW4gZm4gKSBib3VuZFsgcHJvcCBdID0gZm5bIHByb3AgXTtcblxuICBcdHJldHVybiBib3VuZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldCAoIHJhY3RpdmUsIHBhaXJzICkge1xuICBcdHZhciBwcm9taXNlID0gcnVubG9vcC5zdGFydCggcmFjdGl2ZSwgdHJ1ZSApO1xuXG4gIFx0dmFyIGkgPSBwYWlycy5sZW5ndGg7XG4gIFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHR2YXIgcmVmID0gcGFpcnNbaV0sIG1vZGVsID0gcmVmWzBdLCB2YWx1ZSA9IHJlZlsxXTtcbiAgXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICkgdmFsdWUgPSBiaW5kKCB2YWx1ZSwgcmFjdGl2ZSApO1xuICBcdFx0bW9kZWwuc2V0KCB2YWx1ZSApO1xuICBcdH1cblxuICBcdHJ1bmxvb3AuZW5kKCk7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciBzdGFyID0gL1xcKi87XG4gIGZ1bmN0aW9uIGdhdGhlciAoIHJhY3RpdmUsIGtleXBhdGgsIGJhc2UgKSB7XG4gIFx0aWYgKCBiYXNlID09PSB2b2lkIDAgKSBiYXNlID0gcmFjdGl2ZS52aWV3bW9kZWw7XG5cbiAgXHRpZiAoIHN0YXIudGVzdCgga2V5cGF0aCApICkge1xuICBcdFx0cmV0dXJuIGJhc2UuZmluZE1hdGNoZXMoIHNwbGl0S2V5cGF0aEkoIGtleXBhdGggKSApO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gWyBiYXNlLmpvaW5BbGwoIHNwbGl0S2V5cGF0aEkoIGtleXBhdGggKSApIF07XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGQgKCByYWN0aXZlLCBrZXlwYXRoLCB2YWx1ZSApIHtcbiAgXHR2YXIgc2V0cyA9IFtdO1xuXG4gIFx0Ly8gc2V0IG11bHRpcGxlIGtleXBhdGhzIGluIG9uZSBnb1xuICBcdGlmICggaXNPYmplY3QoIGtleXBhdGggKSApIHtcbiAgXHRcdHZhciBsb29wID0gZnVuY3Rpb24gKCBrICkge1xuICBcdFx0XHRpZiAoIGtleXBhdGguaGFzT3duUHJvcGVydHkoIGsgKSApIHtcbiAgXHRcdFx0XHRzZXRzLnB1c2guYXBwbHkoIHNldHMsIGdhdGhlciggcmFjdGl2ZSwgayApLm1hcCggZnVuY3Rpb24gKCBtICkgeyByZXR1cm4gWyBtLCBrZXlwYXRoW2tdIF07IH0gKSApO1xuICBcdFx0XHR9XG4gIFx0XHR9O1xuXG4gIFx0XHRmb3IgKCB2YXIgayBpbiBrZXlwYXRoICkgbG9vcCggayApO1xuXG4gIFx0fVxuICBcdC8vIHNldCBhIHNpbmdsZSBrZXlwYXRoXG4gIFx0ZWxzZSB7XG4gIFx0XHRzZXRzLnB1c2guYXBwbHkoIHNldHMsIGdhdGhlciggcmFjdGl2ZSwga2V5cGF0aCApLm1hcCggZnVuY3Rpb24gKCBtICkgeyByZXR1cm4gWyBtLCB2YWx1ZSBdOyB9ICkgKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc2V0cztcbiAgfVxuXG4gIHZhciBlcnJvck1lc3NhZ2UgPSAnQ2Fubm90IGFkZCB0byBhIG5vbi1udW1lcmljIHZhbHVlJztcblxuICBmdW5jdGlvbiBhZGQgKCByYWN0aXZlLCBrZXlwYXRoLCBkICkge1xuICBcdGlmICggdHlwZW9mIGtleXBhdGggIT09ICdzdHJpbmcnIHx8ICFpc051bWVyaWMoIGQgKSApIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvciggJ0JhZCBhcmd1bWVudHMnICk7XG4gIFx0fVxuXG4gIFx0dmFyIHNldHMgPSBidWlsZCggcmFjdGl2ZSwga2V5cGF0aCwgZCApO1xuXG4gIFx0cmV0dXJuIHNldCggcmFjdGl2ZSwgc2V0cy5tYXAoIGZ1bmN0aW9uICggcGFpciApIHtcbiAgXHRcdHZhciBtb2RlbCA9IHBhaXJbMF0sIGFkZCA9IHBhaXJbMV0sIHZhbHVlID0gbW9kZWwuZ2V0KCk7XG4gIFx0XHRpZiAoICFpc051bWVyaWMoIGFkZCApIHx8ICFpc051bWVyaWMoIHZhbHVlICkgKSB0aHJvdyBuZXcgRXJyb3IoIGVycm9yTWVzc2FnZSApO1xuICBcdFx0cmV0dXJuIFsgbW9kZWwsIHZhbHVlICsgYWRkIF07XG4gIFx0fSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRhZGQgKCBrZXlwYXRoLCBkICkge1xuICBcdHJldHVybiBhZGQoIHRoaXMsIGtleXBhdGgsICggZCA9PT0gdW5kZWZpbmVkID8gMSA6ICtkICkgKTtcbiAgfVxuXG4gIHZhciBub0FuaW1hdGlvbiA9IFByb21pc2UkMS5yZXNvbHZlKCk7XG4gIGRlZmluZVByb3BlcnR5KCBub0FuaW1hdGlvbiwgJ3N0b3AnLCB7IHZhbHVlOiBub29wIH0pO1xuXG4gIHZhciBsaW5lYXIgPSBlYXNpbmcubGluZWFyO1xuXG4gIGZ1bmN0aW9uIGdldE9wdGlvbnMgKCBvcHRpb25zLCBpbnN0YW5jZSApIHtcbiAgXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBcdHZhciBlYXNpbmc7XG4gIFx0aWYgKCBvcHRpb25zLmVhc2luZyApIHtcbiAgXHRcdGVhc2luZyA9IHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gJ2Z1bmN0aW9uJyA/XG4gIFx0XHRcdG9wdGlvbnMuZWFzaW5nIDpcbiAgXHRcdFx0aW5zdGFuY2UuZWFzaW5nWyBvcHRpb25zLmVhc2luZyBdO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHRlYXNpbmc6IGVhc2luZyB8fCBsaW5lYXIsXG4gIFx0XHRkdXJhdGlvbjogJ2R1cmF0aW9uJyBpbiBvcHRpb25zID8gb3B0aW9ucy5kdXJhdGlvbiA6IDQwMCxcbiAgXHRcdGNvbXBsZXRlOiBvcHRpb25zLmNvbXBsZXRlIHx8IG5vb3AsXG4gIFx0XHRzdGVwOiBvcHRpb25zLnN0ZXAgfHwgbm9vcFxuICBcdH07XG4gIH1cblxuICBmdW5jdGlvbiBwcm90b0FuaW1hdGUgKCByYWN0aXZlLCBtb2RlbCwgdG8sIG9wdGlvbnMgKSB7XG4gIFx0b3B0aW9ucyA9IGdldE9wdGlvbnMoIG9wdGlvbnMsIHJhY3RpdmUgKTtcbiAgXHR2YXIgZnJvbSA9IG1vZGVsLmdldCgpO1xuXG4gIFx0Ly8gZG9uJ3QgYm90aGVyIGFuaW1hdGluZyB2YWx1ZXMgdGhhdCBzdGF5IHRoZSBzYW1lXG4gIFx0aWYgKCBpc0VxdWFsKCBmcm9tLCB0byApICkge1xuICBcdFx0b3B0aW9ucy5jb21wbGV0ZSggb3B0aW9ucy50byApO1xuICBcdFx0cmV0dXJuIG5vQW5pbWF0aW9uOyAvLyBUT0RPIHNob3VsZCB0aGlzIGhhdmUgLnRoZW4gYW5kIC5jYXRjaCBtZXRob2RzP1xuICBcdH1cblxuICBcdHZhciBpbnRlcnBvbGF0b3IgPSBpbnRlcnBvbGF0ZSggZnJvbSwgdG8sIHJhY3RpdmUsIG9wdGlvbnMuaW50ZXJwb2xhdG9yICk7XG5cbiAgXHQvLyBpZiB3ZSBjYW4ndCBpbnRlcnBvbGF0ZSB0aGUgdmFsdWUsIHNldCBpdCBpbW1lZGlhdGVseVxuICBcdGlmICggIWludGVycG9sYXRvciApIHtcbiAgXHRcdHJ1bmxvb3Auc3RhcnQoKTtcbiAgXHRcdG1vZGVsLnNldCggdG8gKTtcbiAgXHRcdHJ1bmxvb3AuZW5kKCk7XG5cbiAgXHRcdHJldHVybiBub0FuaW1hdGlvbjtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbW9kZWwuYW5pbWF0ZSggZnJvbSwgdG8sIG9wdGlvbnMsIGludGVycG9sYXRvciApO1xuICB9XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRhbmltYXRlICgga2V5cGF0aCwgdG8sIG9wdGlvbnMgKSB7XG4gIFx0aWYgKCB0eXBlb2Yga2V5cGF0aCA9PT0gJ29iamVjdCcgKSB7XG4gIFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKCBrZXlwYXRoICk7XG5cbiAgXHRcdHRocm93IG5ldyBFcnJvciggKFwicmFjdGl2ZS5hbmltYXRlKC4uLikgbm8gbG9uZ2VyIHN1cHBvcnRzIG9iamVjdHMuIEluc3RlYWQgb2YgcmFjdGl2ZS5hbmltYXRlKHtcXG4gIFwiICsgKGtleXMubWFwKCBmdW5jdGlvbiAoIGtleSApIHsgcmV0dXJuIChcIidcIiArIGtleSArIFwiJzogXCIgKyAoa2V5cGF0aFsga2V5IF0pKTsgfSApLmpvaW4oICdcXG4gICcgKSkgKyBcIlxcbn0sIHsuLi59KSwgZG9cXG5cXG5cIiArIChrZXlzLm1hcCggZnVuY3Rpb24gKCBrZXkgKSB7IHJldHVybiAoXCJyYWN0aXZlLmFuaW1hdGUoJ1wiICsga2V5ICsgXCInLCBcIiArIChrZXlwYXRoWyBrZXkgXSkgKyBcIiwgey4uLn0pO1wiKTsgfSApLmpvaW4oICdcXG4nICkpICsgXCJcXG5cIikgKTtcbiAgXHR9XG5cblxuICBcdHJldHVybiBwcm90b0FuaW1hdGUoIHRoaXMsIHRoaXMudmlld21vZGVsLmpvaW5BbGwoIHNwbGl0S2V5cGF0aEkoIGtleXBhdGggKSApLCB0bywgb3B0aW9ucyApO1xuICB9XG5cbiAgdmFyIGRldGFjaEhvb2sgPSBuZXcgSG9vayggJ2RldGFjaCcgKTtcblxuICBmdW5jdGlvbiBSYWN0aXZlJGRldGFjaCAoKSB7XG4gIFx0aWYgKCB0aGlzLmlzRGV0YWNoZWQgKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5lbDtcbiAgXHR9XG5cbiAgXHRpZiAoIHRoaXMuZWwgKSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzICk7XG4gIFx0fVxuXG4gIFx0dGhpcy5lbCA9IHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG4gIFx0dGhpcy5pc0RldGFjaGVkID0gdHJ1ZTtcblxuICBcdGRldGFjaEhvb2suZmlyZSggdGhpcyApO1xuICBcdHJldHVybiB0aGlzLmVsO1xuICB9XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kICggc2VsZWN0b3IgKSB7XG4gIFx0aWYgKCAhdGhpcy5lbCApIHRocm93IG5ldyBFcnJvciggKFwiQ2Fubm90IGNhbGwgcmFjdGl2ZS5maW5kKCdcIiArIHNlbGVjdG9yICsgXCInKSB1bmxlc3MgaW5zdGFuY2UgaXMgcmVuZGVyZWQgdG8gdGhlIERPTVwiKSApO1xuXG4gIFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZCggc2VsZWN0b3IgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNvcnRCeURvY3VtZW50UG9zaXRpb24gKCBub2RlLCBvdGhlck5vZGUgKSB7XG4gIFx0aWYgKCBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICkge1xuICBcdFx0dmFyIGJpdG1hc2sgPSBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBvdGhlck5vZGUgKTtcbiAgXHRcdHJldHVybiAoIGJpdG1hc2sgJiAyICkgPyAxIDogLTE7XG4gIFx0fVxuXG4gIFx0Ly8gSW4gb2xkIElFLCB3ZSBjYW4gcGlnZ3kgYmFjayBvbiB0aGUgbWVjaGFuaXNtIGZvclxuICBcdC8vIGNvbXBhcmluZyBjb21wb25lbnQgcG9zaXRpb25zXG4gIFx0cmV0dXJuIHNvcnRCeUl0ZW1Qb3NpdGlvbiggbm9kZSwgb3RoZXJOb2RlICk7XG4gIH1cblxuICBmdW5jdGlvbiBzb3J0QnlJdGVtUG9zaXRpb24gKCBhLCBiICkge1xuICBcdHZhciBhbmNlc3RyeUEgPSBnZXRBbmNlc3RyeSggYS5jb21wb25lbnQgfHwgYS5fcmFjdGl2ZS5wcm94eSApO1xuICBcdHZhciBhbmNlc3RyeUIgPSBnZXRBbmNlc3RyeSggYi5jb21wb25lbnQgfHwgYi5fcmFjdGl2ZS5wcm94eSApO1xuXG4gIFx0dmFyIG9sZGVzdEEgPSBsYXN0SXRlbSggYW5jZXN0cnlBICk7XG4gIFx0dmFyIG9sZGVzdEIgPSBsYXN0SXRlbSggYW5jZXN0cnlCICk7XG4gIFx0dmFyIG11dHVhbEFuY2VzdG9yO1xuXG4gIFx0Ly8gcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIGVuZCBvZiBib3RoIGFuY2VzdHJpZXMgYXMgbG9uZyBhcyB0aGV5IGFyZSBpZGVudGljYWxcbiAgXHQvLyAtIHRoZSBmaW5hbCBvbmUgcmVtb3ZlZCBpcyB0aGUgY2xvc2VzdCBtdXR1YWwgYW5jZXN0b3JcbiAgXHR3aGlsZSAoIG9sZGVzdEEgJiYgKCBvbGRlc3RBID09PSBvbGRlc3RCICkgKSB7XG4gIFx0XHRhbmNlc3RyeUEucG9wKCk7XG4gIFx0XHRhbmNlc3RyeUIucG9wKCk7XG5cbiAgXHRcdG11dHVhbEFuY2VzdG9yID0gb2xkZXN0QTtcblxuICBcdFx0b2xkZXN0QSA9IGxhc3RJdGVtKCBhbmNlc3RyeUEgKTtcbiAgXHRcdG9sZGVzdEIgPSBsYXN0SXRlbSggYW5jZXN0cnlCICk7XG4gIFx0fVxuXG4gIFx0Ly8gbm93IHRoYXQgd2UgaGF2ZSB0aGUgbXV0dWFsIGFuY2VzdG9yLCB3ZSBjYW4gZmluZCB3aGljaCBpcyBlYXJsaWVzdFxuICBcdG9sZGVzdEEgPSBvbGRlc3RBLmNvbXBvbmVudCB8fCBvbGRlc3RBO1xuICBcdG9sZGVzdEIgPSBvbGRlc3RCLmNvbXBvbmVudCB8fCBvbGRlc3RCO1xuXG4gIFx0dmFyIGZyYWdtZW50QSA9IG9sZGVzdEEucGFyZW50RnJhZ21lbnQ7XG4gIFx0dmFyIGZyYWdtZW50QiA9IG9sZGVzdEIucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHQvLyBpZiBib3RoIGl0ZW1zIHNoYXJlIGEgcGFyZW50IGZyYWdtZW50LCBvdXIgam9iIGlzIGVhc3lcbiAgXHRpZiAoIGZyYWdtZW50QSA9PT0gZnJhZ21lbnRCICkge1xuICBcdFx0dmFyIGluZGV4QSA9IGZyYWdtZW50QS5pdGVtcy5pbmRleE9mKCBvbGRlc3RBICk7XG4gIFx0XHR2YXIgaW5kZXhCID0gZnJhZ21lbnRCLml0ZW1zLmluZGV4T2YoIG9sZGVzdEIgKTtcblxuICBcdFx0Ly8gaWYgaXQncyB0aGUgc2FtZSBpbmRleCwgaXQgbWVhbnMgb25lIGNvbnRhaW5zIHRoZSBvdGhlcixcbiAgXHRcdC8vIHNvIHdlIHNlZSB3aGljaCBoYXMgdGhlIGxvbmdlc3QgYW5jZXN0cnlcbiAgXHRcdHJldHVybiAoIGluZGV4QSAtIGluZGV4QiApIHx8IGFuY2VzdHJ5QS5sZW5ndGggLSBhbmNlc3RyeUIubGVuZ3RoO1xuICBcdH1cblxuICBcdC8vIGlmIG11dHVhbCBhbmNlc3RvciBpcyBhIHNlY3Rpb24sIHdlIGZpcnN0IHRlc3QgdG8gc2VlIHdoaWNoIHNlY3Rpb25cbiAgXHQvLyBmcmFnbWVudCBjb21lcyBmaXJzdFxuICBcdHZhciBmcmFnbWVudHMgPSBtdXR1YWxBbmNlc3Rvci5pdGVyYXRpb25zO1xuICBcdGlmICggZnJhZ21lbnRzICkge1xuICBcdFx0dmFyIGluZGV4QSQxID0gZnJhZ21lbnRzLmluZGV4T2YoIGZyYWdtZW50QSApO1xuICBcdFx0dmFyIGluZGV4QiQxID0gZnJhZ21lbnRzLmluZGV4T2YoIGZyYWdtZW50QiApO1xuXG4gIFx0XHRyZXR1cm4gKCBpbmRleEEkMSAtIGluZGV4QiQxICkgfHwgYW5jZXN0cnlBLmxlbmd0aCAtIGFuY2VzdHJ5Qi5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0dGhyb3cgbmV3IEVycm9yKCAnQW4gdW5leHBlY3RlZCBjb25kaXRpb24gd2FzIG1ldCB3aGlsZSBjb21wYXJpbmcgdGhlIHBvc2l0aW9uIG9mIHR3byBjb21wb25lbnRzLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIScgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhcmVudCAoIGl0ZW0gKSB7XG4gIFx0dmFyIHBhcmVudEZyYWdtZW50ID0gaXRlbS5wYXJlbnRGcmFnbWVudDtcblxuICBcdGlmICggcGFyZW50RnJhZ21lbnQgKSByZXR1cm4gcGFyZW50RnJhZ21lbnQub3duZXI7XG5cbiAgXHRpZiAoIGl0ZW0uY29tcG9uZW50ICYmICggcGFyZW50RnJhZ21lbnQgPSBpdGVtLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCApICkge1xuICBcdFx0cmV0dXJuIHBhcmVudEZyYWdtZW50Lm93bmVyO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFuY2VzdHJ5ICggaXRlbSApIHtcbiAgXHR2YXIgYW5jZXN0cnkgPSBbIGl0ZW0gXTtcbiAgXHR2YXIgYW5jZXN0b3IgPSBnZXRQYXJlbnQoIGl0ZW0gKTtcblxuICBcdHdoaWxlICggYW5jZXN0b3IgKSB7XG4gIFx0XHRhbmNlc3RyeS5wdXNoKCBhbmNlc3RvciApO1xuICBcdFx0YW5jZXN0b3IgPSBnZXRQYXJlbnQoIGFuY2VzdG9yICk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGFuY2VzdHJ5O1xuICB9XG5cblxuICB2YXIgUXVlcnkgPSBmdW5jdGlvbiBRdWVyeSAoIHJhY3RpdmUsIHNlbGVjdG9yLCBsaXZlLCBpc0NvbXBvbmVudFF1ZXJ5ICkge1xuICBcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG4gIFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICBcdHRoaXMubGl2ZSA9IGxpdmU7XG4gIFx0dGhpcy5pc0NvbXBvbmVudFF1ZXJ5ID0gaXNDb21wb25lbnRRdWVyeTtcblxuICBcdHRoaXMucmVzdWx0ID0gW107XG5cbiAgXHR0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfTtcblxuICBRdWVyeS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkICggaXRlbSApIHtcbiAgXHR0aGlzLnJlc3VsdC5wdXNoKCBpdGVtICk7XG4gIFx0dGhpcy5tYWtlRGlydHkoKTtcbiAgfTtcblxuICBRdWVyeS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsICgpIHtcbiAgXHR2YXIgbGl2ZVF1ZXJpZXMgPSB0aGlzLl9yb290WyB0aGlzLmlzQ29tcG9uZW50UXVlcnkgPyAnbGl2ZUNvbXBvbmVudFF1ZXJpZXMnIDogJ2xpdmVRdWVyaWVzJyBdO1xuICBcdHZhciBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG5cbiAgXHR2YXIgaW5kZXggPSBsaXZlUXVlcmllcy5pbmRleE9mKCBzZWxlY3RvciApO1xuXG4gIFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG4gIFx0XHRsaXZlUXVlcmllcy5zcGxpY2UoIGluZGV4LCAxICk7XG4gIFx0XHRsaXZlUXVlcmllc1sgc2VsZWN0b3IgXSA9IG51bGw7XG4gIFx0fVxuICB9O1xuXG4gIFF1ZXJ5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoKSB7XG4gIFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9O1xuXG4gIFF1ZXJ5LnByb3RvdHlwZS5tYWtlRGlydHkgPSBmdW5jdGlvbiBtYWtlRGlydHkgKCkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHRpZiAoICF0aGlzLmRpcnR5ICkge1xuICBcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgXHRcdC8vIE9uY2UgdGhlIERPTSBoYXMgYmVlbiB1cGRhdGVkLCBlbnN1cmUgdGhlIHF1ZXJ5XG4gIFx0XHQvLyBpcyBjb3JyZWN0bHkgb3JkZXJlZFxuICBcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS51cGRhdGUoKTsgfSApO1xuICBcdH1cbiAgfTtcblxuICBRdWVyeS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICggbm9kZU9yQ29tcG9uZW50ICkge1xuICBcdHZhciBpbmRleCA9IHRoaXMucmVzdWx0LmluZGV4T2YoIHRoaXMuaXNDb21wb25lbnRRdWVyeSA/IG5vZGVPckNvbXBvbmVudC5pbnN0YW5jZSA6IG5vZGVPckNvbXBvbmVudCApO1xuICBcdGlmICggaW5kZXggIT09IC0xICkgdGhpcy5yZXN1bHQuc3BsaWNlKCBpbmRleCwgMSApO1xuICB9O1xuXG4gIFF1ZXJ5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICBcdHRoaXMucmVzdWx0LnNvcnQoIHRoaXMuaXNDb21wb25lbnRRdWVyeSA/IHNvcnRCeUl0ZW1Qb3NpdGlvbiA6IHNvcnRCeURvY3VtZW50UG9zaXRpb24gKTtcbiAgXHR0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH07XG5cbiAgUXVlcnkucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiB0ZXN0ICggaXRlbSApIHtcbiAgXHRyZXR1cm4gdGhpcy5pc0NvbXBvbmVudFF1ZXJ5ID9cbiAgXHRcdCggIXRoaXMuc2VsZWN0b3IgfHwgaXRlbS5uYW1lID09PSB0aGlzLnNlbGVjdG9yICkgOlxuICBcdFx0KCBpdGVtID8gbWF0Y2hlcyggaXRlbSwgdGhpcy5zZWxlY3RvciApIDogbnVsbCApO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZEFsbCAoIHNlbGVjdG9yLCBvcHRpb25zICkge1xuICBcdGlmICggIXRoaXMuZWwgKSB0aHJvdyBuZXcgRXJyb3IoIChcIkNhbm5vdCBjYWxsIHJhY3RpdmUuZmluZEFsbCgnXCIgKyBzZWxlY3RvciArIFwiJywgLi4uKSB1bmxlc3MgaW5zdGFuY2UgaXMgcmVuZGVyZWQgdG8gdGhlIERPTVwiKSApO1xuXG4gIFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFx0dmFyIGxpdmVRdWVyaWVzID0gdGhpcy5fbGl2ZVF1ZXJpZXM7XG5cbiAgXHQvLyBTaG9ydGN1dDogaWYgd2UncmUgbWFpbnRhaW5pbmcgYSBsaXZlIHF1ZXJ5IHdpdGggdGhpc1xuICBcdC8vIHNlbGVjdG9yLCB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSBwYXJhbGxlbCBET01cbiAgXHR2YXIgcXVlcnkgPSBsaXZlUXVlcmllc1sgc2VsZWN0b3IgXTtcbiAgXHRpZiAoIHF1ZXJ5ICkge1xuICBcdFx0Ly8gRWl0aGVyIHJldHVybiB0aGUgZXhhY3Qgc2FtZSBxdWVyeSwgb3IgKGlmIG5vdCBsaXZlKSBhIHNuYXBzaG90XG4gIFx0XHRyZXR1cm4gKCBvcHRpb25zICYmIG9wdGlvbnMubGl2ZSApID8gcXVlcnkgOiBxdWVyeS5zbGljZSgpO1xuICBcdH1cblxuICBcdHF1ZXJ5ID0gbmV3IFF1ZXJ5KCB0aGlzLCBzZWxlY3RvciwgISFvcHRpb25zLmxpdmUsIGZhbHNlICk7XG5cbiAgXHQvLyBBZGQgdGhpcyB0byB0aGUgbGlzdCBvZiBsaXZlIHF1ZXJpZXMgUmFjdGl2ZSBuZWVkcyB0byBtYWludGFpbixcbiAgXHQvLyBpZiBhcHBsaWNhYmxlXG4gIFx0aWYgKCBxdWVyeS5saXZlICkge1xuICBcdFx0bGl2ZVF1ZXJpZXMucHVzaCggc2VsZWN0b3IgKTtcbiAgXHRcdGxpdmVRdWVyaWVzWyAnXycgKyBzZWxlY3RvciBdID0gcXVlcnk7XG4gIFx0fVxuXG4gIFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblxuICBcdHF1ZXJ5LmluaXQoKTtcbiAgXHRyZXR1cm4gcXVlcnkucmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQWxsQ29tcG9uZW50cyAoIHNlbGVjdG9yLCBvcHRpb25zICkge1xuICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBcdHZhciBsaXZlUXVlcmllcyA9IHRoaXMuX2xpdmVDb21wb25lbnRRdWVyaWVzO1xuXG4gIFx0Ly8gU2hvcnRjdXQ6IGlmIHdlJ3JlIG1haW50YWluaW5nIGEgbGl2ZSBxdWVyeSB3aXRoIHRoaXNcbiAgXHQvLyBzZWxlY3Rvciwgd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSB0aGUgcGFyYWxsZWwgRE9NXG4gIFx0dmFyIHF1ZXJ5ID0gbGl2ZVF1ZXJpZXNbIHNlbGVjdG9yIF07XG4gIFx0aWYgKCBxdWVyeSApIHtcbiAgXHRcdC8vIEVpdGhlciByZXR1cm4gdGhlIGV4YWN0IHNhbWUgcXVlcnksIG9yIChpZiBub3QgbGl2ZSkgYSBzbmFwc2hvdFxuICBcdFx0cmV0dXJuICggb3B0aW9ucyAmJiBvcHRpb25zLmxpdmUgKSA/IHF1ZXJ5IDogcXVlcnkuc2xpY2UoKTtcbiAgXHR9XG5cbiAgXHRxdWVyeSA9IG5ldyBRdWVyeSggdGhpcywgc2VsZWN0b3IsICEhb3B0aW9ucy5saXZlLCB0cnVlICk7XG5cbiAgXHQvLyBBZGQgdGhpcyB0byB0aGUgbGlzdCBvZiBsaXZlIHF1ZXJpZXMgUmFjdGl2ZSBuZWVkcyB0byBtYWludGFpbixcbiAgXHQvLyBpZiBhcHBsaWNhYmxlXG4gIFx0aWYgKCBxdWVyeS5saXZlICkge1xuICBcdFx0bGl2ZVF1ZXJpZXMucHVzaCggc2VsZWN0b3IgKTtcbiAgXHRcdGxpdmVRdWVyaWVzWyAnXycgKyBzZWxlY3RvciBdID0gcXVlcnk7XG4gIFx0fVxuXG4gIFx0dGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cbiAgXHRxdWVyeS5pbml0KCk7XG4gIFx0cmV0dXJuIHF1ZXJ5LnJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZENvbXBvbmVudCAoIHNlbGVjdG9yICkge1xuICBcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoIHNlbGVjdG9yICk7XG4gIH1cblxuICBmdW5jdGlvbiBSYWN0aXZlJGZpbmRDb250YWluZXIgKCBzZWxlY3RvciApIHtcbiAgXHRpZiAoIHRoaXMuY29udGFpbmVyICkge1xuICBcdFx0aWYgKCB0aGlzLmNvbnRhaW5lci5jb21wb25lbnQgJiYgdGhpcy5jb250YWluZXIuY29tcG9uZW50Lm5hbWUgPT09IHNlbGVjdG9yICkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXIuZmluZENvbnRhaW5lciggc2VsZWN0b3IgKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkZmluZFBhcmVudCAoIHNlbGVjdG9yICkge1xuXG4gIFx0aWYgKCB0aGlzLnBhcmVudCApIHtcbiAgXHRcdGlmICggdGhpcy5wYXJlbnQuY29tcG9uZW50ICYmIHRoaXMucGFyZW50LmNvbXBvbmVudC5uYW1lID09PSBzZWxlY3RvciApIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMucGFyZW50O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMucGFyZW50LmZpbmRQYXJlbnQgKCBzZWxlY3RvciApO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5xdWV1ZSAoIHJhY3RpdmUsIGV2ZW50ICkge1xuICBcdGlmICggcmFjdGl2ZS5ldmVudCApIHtcbiAgXHRcdHJhY3RpdmUuX2V2ZW50UXVldWUucHVzaCggcmFjdGl2ZS5ldmVudCApO1xuICBcdH1cblxuICBcdHJhY3RpdmUuZXZlbnQgPSBldmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlcXVldWUgKCByYWN0aXZlICkge1xuICBcdGlmICggcmFjdGl2ZS5fZXZlbnRRdWV1ZS5sZW5ndGggKSB7XG4gIFx0XHRyYWN0aXZlLmV2ZW50ID0gcmFjdGl2ZS5fZXZlbnRRdWV1ZS5wb3AoKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmFjdGl2ZS5ldmVudCA9IG51bGw7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHN0YXJNYXBzID0ge307XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIGtleXBhdGggc3VjaCBhcyAnZm9vLmJhci5iYXonLCBhbmQgcmV0dXJuc1xuICAvLyBhbGwgdGhlIHZhcmlhbnRzIG9mIHRoYXQga2V5cGF0aCB0aGF0IGluY2x1ZGUgYSB3aWxkY2FyZCBpbiBwbGFjZVxuICAvLyBvZiBhIGtleSwgc3VjaCBhcyAnZm9vLmJhci4qJywgJ2Zvby4qLmJheicsICdmb28uKi4qJyBhbmQgc28gb24uXG4gIC8vIFRoZXNlIGFyZSB0aGVuIGNoZWNrZWQgYWdhaW5zdCB0aGUgZGVwZW5kYW50cyBtYXAgKHJhY3RpdmUudmlld21vZGVsLmRlcHNNYXApXG4gIC8vIHRvIHNlZSBpZiBhbnkgcGF0dGVybiBvYnNlcnZlcnMgYXJlIGRvd25zdHJlYW0gb2Ygb25lIG9yIG1vcmUgb2ZcbiAgLy8gdGhlc2Ugd2lsZGNhcmQga2V5cGF0aHMgKGUuZy4gJ2Zvby5iYXIuKi5zdGF0dXMnKVxuICBmdW5jdGlvbiBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgKCBrZXlwYXRoICkge1xuICBcdHZhciBrZXlzLCBzdGFyTWFwLCBtYXBwZXIsIGksIHJlc3VsdCwgd2lsZGNhcmRLZXlwYXRoO1xuXG4gIFx0a2V5cyA9IHNwbGl0S2V5cGF0aEkoIGtleXBhdGggKTtcbiAgXHRpZiggISggc3Rhck1hcCA9IHN0YXJNYXBzWyBrZXlzLmxlbmd0aCBdKSApIHtcbiAgXHRcdHN0YXJNYXAgPSBnZXRTdGFyTWFwKCBrZXlzLmxlbmd0aCApO1xuICBcdH1cblxuICBcdHJlc3VsdCA9IFtdO1xuXG4gIFx0bWFwcGVyID0gZnVuY3Rpb24gKCBzdGFyLCBpICkge1xuICBcdFx0cmV0dXJuIHN0YXIgPyAnKicgOiBrZXlzW2ldO1xuICBcdH07XG5cbiAgXHRpID0gc3Rhck1hcC5sZW5ndGg7XG4gIFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHR3aWxkY2FyZEtleXBhdGggPSBzdGFyTWFwW2ldLm1hcCggbWFwcGVyICkuam9pbiggJy4nICk7XG5cbiAgXHRcdGlmICggIXJlc3VsdC5oYXNPd25Qcm9wZXJ0eSggd2lsZGNhcmRLZXlwYXRoICkgKSB7XG4gIFx0XHRcdHJlc3VsdC5wdXNoKCB3aWxkY2FyZEtleXBhdGggKTtcbiAgXHRcdFx0cmVzdWx0WyB3aWxkY2FyZEtleXBhdGggXSA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbGwgdGhlIHBvc3NpYmxlIHRydWUvZmFsc2UgY29tYmluYXRpb25zIGZvclxuICAvLyBhIGdpdmVuIG51bWJlciAtIGUuZy4gZm9yIHR3bywgdGhlIHBvc3NpYmxlIGNvbWJpbmF0aW9ucyBhcmVcbiAgLy8gWyB0cnVlLCB0cnVlIF0sIFsgdHJ1ZSwgZmFsc2UgXSwgWyBmYWxzZSwgdHJ1ZSBdLCBbIGZhbHNlLCBmYWxzZSBdLlxuICAvLyBJdCBkb2VzIHNvIGJ5IGdldHRpbmcgYWxsIHRoZSBiaW5hcnkgdmFsdWVzIGJldHdlZW4gMCBhbmQgZS5nLiAxMVxuICBmdW5jdGlvbiBnZXRTdGFyTWFwICggbnVtICkge1xuICBcdHZhciBvbmVzID0gJycsIG1heCwgYmluYXJ5LCBzdGFyTWFwLCBtYXBwZXIsIGksIGosIGwsIG1hcDtcblxuICBcdGlmICggIXN0YXJNYXBzWyBudW0gXSApIHtcbiAgXHRcdHN0YXJNYXAgPSBbXTtcblxuICBcdFx0d2hpbGUgKCBvbmVzLmxlbmd0aCA8IG51bSApIHtcbiAgXHRcdFx0b25lcyArPSAxO1xuICBcdFx0fVxuXG4gIFx0XHRtYXggPSBwYXJzZUludCggb25lcywgMiApO1xuXG4gIFx0XHRtYXBwZXIgPSBmdW5jdGlvbiAoIGRpZ2l0ICkge1xuICBcdFx0XHRyZXR1cm4gZGlnaXQgPT09ICcxJztcbiAgXHRcdH07XG5cbiAgXHRcdGZvciAoIGkgPSAwOyBpIDw9IG1heDsgaSArPSAxICkge1xuICBcdFx0XHRiaW5hcnkgPSBpLnRvU3RyaW5nKCAyICk7XG4gIFx0XHRcdHdoaWxlICggYmluYXJ5Lmxlbmd0aCA8IG51bSApIHtcbiAgXHRcdFx0XHRiaW5hcnkgPSAnMCcgKyBiaW5hcnk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRtYXAgPSBbXTtcbiAgXHRcdFx0bCA9IGJpbmFyeS5sZW5ndGg7XG4gIFx0XHRcdGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgXHRcdFx0XHRtYXAucHVzaCggbWFwcGVyKCBiaW5hcnlbal0gKSApO1xuICBcdFx0XHR9XG4gIFx0XHRcdHN0YXJNYXBbaV0gPSBtYXA7XG4gIFx0XHR9XG5cbiAgXHRcdHN0YXJNYXBzWyBudW0gXSA9IHN0YXJNYXA7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHN0YXJNYXBzWyBudW0gXTtcbiAgfVxuXG4gIHZhciB3aWxkY2FyZENhY2hlID0ge307XG5cbiAgZnVuY3Rpb24gZmlyZUV2ZW50ICggcmFjdGl2ZSwgZXZlbnROYW1lLCBvcHRpb25zICkge1xuICBcdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIFx0aWYgKCAhZXZlbnROYW1lICkgeyByZXR1cm47IH1cblxuICBcdGlmICggIW9wdGlvbnMuZXZlbnQgKSB7XG4gIFx0XHRvcHRpb25zLmV2ZW50ID0ge1xuICBcdFx0XHRuYW1lOiBldmVudE5hbWUsXG4gIFx0XHRcdC8vIHVudGlsIGV2ZW50IG5vdCBpbmNsdWRlZCBhcyBhcmd1bWVudCBkZWZhdWx0XG4gIFx0XHRcdF9ub0FyZzogdHJ1ZVxuICBcdFx0fTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0b3B0aW9ucy5ldmVudC5uYW1lID0gZXZlbnROYW1lO1xuICBcdH1cblxuICBcdHZhciBldmVudE5hbWVzID0gZ2V0V2lsZGNhcmROYW1lcyggZXZlbnROYW1lICk7XG5cbiAgXHRyZXR1cm4gZmlyZUV2ZW50QXMoIHJhY3RpdmUsIGV2ZW50TmFtZXMsIG9wdGlvbnMuZXZlbnQsIG9wdGlvbnMuYXJncywgdHJ1ZSApO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0V2lsZGNhcmROYW1lcyAoIGV2ZW50TmFtZSApIHtcbiAgXHRpZiAoIHdpbGRjYXJkQ2FjaGUuaGFzT3duUHJvcGVydHkoIGV2ZW50TmFtZSApICkge1xuICBcdFx0cmV0dXJuIHdpbGRjYXJkQ2FjaGVbIGV2ZW50TmFtZSBdO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXR1cm4gd2lsZGNhcmRDYWNoZVsgZXZlbnROYW1lIF0gPSBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMoIGV2ZW50TmFtZSApO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVFdmVudEFzICAoIHJhY3RpdmUsIGV2ZW50TmFtZXMsIGV2ZW50LCBhcmdzLCBpbml0aWFsRmlyZSApIHtcblxuICBcdGlmICggaW5pdGlhbEZpcmUgPT09IHZvaWQgMCApIGluaXRpYWxGaXJlID0gZmFsc2U7XG5cbiAgXHR2YXIgc3Vic2NyaWJlcnMsIGksIGJ1YmJsZSA9IHRydWU7XG5cbiAgXHRlbnF1ZXVlKCByYWN0aXZlLCBldmVudCApO1xuXG4gIFx0Zm9yICggaSA9IGV2ZW50TmFtZXMubGVuZ3RoOyBpID49IDA7IGktLSApIHtcbiAgXHRcdHN1YnNjcmliZXJzID0gcmFjdGl2ZS5fc3Vic1sgZXZlbnROYW1lc1sgaSBdIF07XG5cbiAgXHRcdGlmICggc3Vic2NyaWJlcnMgKSB7XG4gIFx0XHRcdGJ1YmJsZSA9IG5vdGlmeVN1YnNjcmliZXJzKCByYWN0aXZlLCBzdWJzY3JpYmVycywgZXZlbnQsIGFyZ3MgKSAmJiBidWJibGU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0ZGVxdWV1ZSggcmFjdGl2ZSApO1xuXG4gIFx0aWYgKCByYWN0aXZlLnBhcmVudCAmJiBidWJibGUgKSB7XG5cbiAgXHRcdGlmICggaW5pdGlhbEZpcmUgJiYgcmFjdGl2ZS5jb21wb25lbnQgKSB7XG4gIFx0XHRcdHZhciBmdWxsTmFtZSA9IHJhY3RpdmUuY29tcG9uZW50Lm5hbWUgKyAnLicgKyBldmVudE5hbWVzWyBldmVudE5hbWVzLmxlbmd0aC0xIF07XG4gIFx0XHRcdGV2ZW50TmFtZXMgPSBnZXRXaWxkY2FyZE5hbWVzKCBmdWxsTmFtZSApO1xuXG4gIFx0XHRcdGlmKCBldmVudCAmJiAhZXZlbnQuY29tcG9uZW50ICkge1xuICBcdFx0XHRcdGV2ZW50LmNvbXBvbmVudCA9IHJhY3RpdmU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0ZmlyZUV2ZW50QXMoIHJhY3RpdmUucGFyZW50LCBldmVudE5hbWVzLCBldmVudCwgYXJncyApO1xuICBcdH1cblxuICBcdHJldHVybiBidWJibGU7XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlTdWJzY3JpYmVycyAoIHJhY3RpdmUsIHN1YnNjcmliZXJzLCBldmVudCwgYXJncyApIHtcbiAgXHR2YXIgb3JpZ2luYWxFdmVudCA9IG51bGwsIHN0b3BFdmVudCA9IGZhbHNlO1xuXG4gIFx0aWYgKCBldmVudCAmJiAhZXZlbnQuX25vQXJnICkge1xuICBcdFx0YXJncyA9IFsgZXZlbnQgXS5jb25jYXQoIGFyZ3MgKTtcbiAgXHR9XG5cbiAgXHQvLyBzdWJzY3JpYmVycyBjYW4gYmUgbW9kaWZpZWQgaW5mbGlnaHQsIGUuZy4gXCJvbmNlXCIgZnVuY3Rpb25hbGl0eVxuICBcdC8vIHNvIHdlIG5lZWQgdG8gY29weSB0byBtYWtlIHN1cmUgZXZlcnlvbmUgZ2V0cyBjYWxsZWRcbiAgXHRzdWJzY3JpYmVycyA9IHN1YnNjcmliZXJzLnNsaWNlKCk7XG5cbiAgXHRmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IHN1YnNjcmliZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxICkge1xuICBcdFx0aWYgKCAhc3Vic2NyaWJlcnNbIGkgXS5vZmYgJiYgc3Vic2NyaWJlcnNbIGkgXS5hcHBseSggcmFjdGl2ZSwgYXJncyApID09PSBmYWxzZSApIHtcbiAgXHRcdFx0c3RvcEV2ZW50ID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoIGV2ZW50ICYmICFldmVudC5fbm9BcmcgJiYgc3RvcEV2ZW50ICYmICggb3JpZ2luYWxFdmVudCA9IGV2ZW50Lm9yaWdpbmFsICkgKSB7XG4gIFx0XHRvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0ICYmIG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgXHRcdG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uICYmIG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuICFzdG9wRXZlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBSYWN0aXZlJGZpcmUgKCBldmVudE5hbWUgKSB7XG4gIFx0dmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIFx0d2hpbGUgKCBsZW4tLSA+IDAgKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gIFx0cmV0dXJuIGZpcmVFdmVudCggdGhpcywgZXZlbnROYW1lLCB7IGFyZ3M6IGFyZ3MgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBiYWRSZWZlcmVuY2UgKCBrZXkgKSB7XG4gIFx0dGhyb3cgbmV3IEVycm9yKCAoXCJBbiBpbmRleCBvciBrZXkgcmVmZXJlbmNlIChcIiArIGtleSArIFwiKSBjYW5ub3QgaGF2ZSBjaGlsZCBwcm9wZXJ0aWVzXCIpICk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlQW1iaWd1b3VzUmVmZXJlbmNlICggZnJhZ21lbnQsIHJlZiApIHtcbiAgXHR2YXIgbG9jYWxWaWV3bW9kZWwgPSBmcmFnbWVudC5maW5kQ29udGV4dCgpLnJvb3Q7XG4gIFx0dmFyIGtleXMgPSBzcGxpdEtleXBhdGhJKCByZWYgKTtcbiAgXHR2YXIga2V5ID0ga2V5c1swXTtcblxuICBcdHZhciBoYXNDb250ZXh0Q2hhaW47XG4gIFx0dmFyIGNyb3NzZWRDb21wb25lbnRCb3VuZGFyeTtcbiAgXHR2YXIgYWxpYXNlcztcblxuICBcdHdoaWxlICggZnJhZ21lbnQgKSB7XG4gIFx0XHQvLyByZXBlYXRlZCBmcmFnbWVudHNcbiAgXHRcdGlmICggZnJhZ21lbnQuaXNJdGVyYXRpb24gKSB7XG4gIFx0XHRcdGlmICgga2V5ID09PSBmcmFnbWVudC5wYXJlbnQua2V5UmVmICkge1xuICBcdFx0XHRcdGlmICgga2V5cy5sZW5ndGggPiAxICkgYmFkUmVmZXJlbmNlKCBrZXkgKTtcbiAgXHRcdFx0XHRyZXR1cm4gZnJhZ21lbnQuY29udGV4dC5nZXRLZXlNb2RlbCggZnJhZ21lbnQua2V5ICk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIGtleSA9PT0gZnJhZ21lbnQucGFyZW50LmluZGV4UmVmICkge1xuICBcdFx0XHRcdGlmICgga2V5cy5sZW5ndGggPiAxICkgYmFkUmVmZXJlbmNlKCBrZXkgKTtcbiAgXHRcdFx0XHRyZXR1cm4gZnJhZ21lbnQuY29udGV4dC5nZXRLZXlNb2RlbCggZnJhZ21lbnQuaW5kZXggKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBhbGlhcyBub2RlIG9yIGl0ZXJhdGlvblxuICBcdFx0aWYgKCAoICggYWxpYXNlcyA9IGZyYWdtZW50Lm93bmVyLmFsaWFzZXMgKSB8fCAoIGFsaWFzZXMgPSBmcmFnbWVudC5hbGlhc2VzICkgKSAmJiBhbGlhc2VzLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcbiAgXHRcdFx0dmFyIG1vZGVsID0gYWxpYXNlc1sga2V5IF07XG5cbiAgXHRcdFx0aWYgKCBrZXlzLmxlbmd0aCA9PT0gMSApIHJldHVybiBtb2RlbDtcbiAgXHRcdFx0ZWxzZSBpZiAoIHR5cGVvZiBtb2RlbC5qb2luQWxsID09PSAnZnVuY3Rpb24nICkge1xuICBcdFx0XHRcdHJldHVybiBtb2RlbC5qb2luQWxsKCBrZXlzLnNsaWNlKCAxICkgKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRpZiAoIGZyYWdtZW50LmNvbnRleHQgKSB7XG4gIFx0XHRcdC8vIFRPRE8gYmV0dGVyIGVuY2Fwc3VsYXRlIHRoZSBjb21wb25lbnQgY2hlY2tcbiAgXHRcdFx0aWYgKCAhZnJhZ21lbnQuaXNSb290IHx8IGZyYWdtZW50LnJhY3RpdmUuY29tcG9uZW50ICkgaGFzQ29udGV4dENoYWluID0gdHJ1ZTtcblxuICBcdFx0XHRpZiAoIGZyYWdtZW50LmNvbnRleHQuaGFzKCBrZXkgKSApIHtcbiAgXHRcdFx0XHRpZiAoIGNyb3NzZWRDb21wb25lbnRCb3VuZGFyeSApIHtcbiAgXHRcdFx0XHRcdHJldHVybiBsb2NhbFZpZXdtb2RlbC5jcmVhdGVMaW5rKCBrZXksIGZyYWdtZW50LmNvbnRleHQuam9pbktleSgga2V5cy5zaGlmdCgpICksIGtleSApLmpvaW5BbGwoIGtleXMgKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRyZXR1cm4gZnJhZ21lbnQuY29udGV4dC5qb2luQWxsKCBrZXlzICk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0aWYgKCBmcmFnbWVudC5jb21wb25lbnRQYXJlbnQgJiYgIWZyYWdtZW50LnJhY3RpdmUuaXNvbGF0ZWQgKSB7XG4gIFx0XHRcdC8vIGFzY2VuZCB0aHJvdWdoIGNvbXBvbmVudCBib3VuZGFyeVxuICBcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LmNvbXBvbmVudFBhcmVudDtcbiAgXHRcdFx0Y3Jvc3NlZENvbXBvbmVudEJvdW5kYXJ5ID0gdHJ1ZTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICggIWhhc0NvbnRleHRDaGFpbiApIHtcbiAgXHRcdHJldHVybiBsb2NhbFZpZXdtb2RlbC5qb2luQWxsKCBrZXlzICk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBjYXB0dXJlR3JvdXA7XG5cbiAgZnVuY3Rpb24gc3RhcnRDYXB0dXJpbmcgKCkge1xuICBcdHN0YWNrLnB1c2goIGNhcHR1cmVHcm91cCA9IFtdICk7XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wQ2FwdHVyaW5nICgpIHtcbiAgXHR2YXIgZGVwZW5kZW5jaWVzID0gc3RhY2sucG9wKCk7XG4gIFx0Y2FwdHVyZUdyb3VwID0gc3RhY2tbIHN0YWNrLmxlbmd0aCAtIDEgXTtcbiAgXHRyZXR1cm4gZGVwZW5kZW5jaWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FwdHVyZSAoIG1vZGVsICkge1xuICBcdGlmICggY2FwdHVyZUdyb3VwICkge1xuICBcdFx0Y2FwdHVyZUdyb3VwLnB1c2goIG1vZGVsICk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIEtleU1vZGVsID0gZnVuY3Rpb24gS2V5TW9kZWwgKCBrZXksIHBhcmVudCApIHtcbiAgXHR0aGlzLnZhbHVlID0ga2V5O1xuICBcdHRoaXMuaXNSZWFkb25seSA9IHRoaXMuaXNLZXkgPSB0cnVlO1xuICBcdHRoaXMuZGVwcyA9IFtdO1xuICBcdHRoaXMubGlua3MgPSBbXTtcbiAgXHR0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfTtcblxuICBLZXlNb2RlbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICggc2hvdWxkQ2FwdHVyZSApIHtcbiAgXHRpZiAoIHNob3VsZENhcHR1cmUgKSBjYXB0dXJlKCB0aGlzICk7XG4gIFx0cmV0dXJuIHVuZXNjYXBlS2V5KCB0aGlzLnZhbHVlICk7XG4gIH07XG5cbiAgS2V5TW9kZWwucHJvdG90eXBlLmdldEtleXBhdGggPSBmdW5jdGlvbiBnZXRLZXlwYXRoICgpIHtcbiAgXHRyZXR1cm4gdW5lc2NhcGVLZXkoIHRoaXMudmFsdWUgKTtcbiAgfTtcblxuICBLZXlNb2RlbC5wcm90b3R5cGUucmViaW5kaW5nID0gZnVuY3Rpb24gcmViaW5kaW5nICggbmV4dCwgcHJldmlvdXMgKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgXHR3aGlsZSAoIGktLSApIHRoaXMkMS5kZXBzW2ldLnJlYmluZGluZyggbmV4dCwgcHJldmlvdXMsIGZhbHNlICk7XG5cbiAgXHRpID0gdGhpcy5saW5rcy5sZW5ndGg7XG4gIFx0d2hpbGUgKCBpLS0gKSB0aGlzJDEubGlua3NbaV0ucmViaW5kaW5nKCBuZXh0LCBwcmV2aW91cywgZmFsc2UgKTtcbiAgfTtcblxuICBLZXlNb2RlbC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlciAoIGRlcGVuZGFudCApIHtcbiAgXHR0aGlzLmRlcHMucHVzaCggZGVwZW5kYW50ICk7XG4gIH07XG5cbiAgS2V5TW9kZWwucHJvdG90eXBlLnJlZ2lzdGVyTGluayA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGluayAoIGxpbmsgKSB7XG4gIFx0YWRkVG9BcnJheSggdGhpcy5saW5rcywgbGluayApO1xuICB9O1xuXG4gIEtleU1vZGVsLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24gdW5yZWdpc3RlciAoIGRlcGVuZGFudCApIHtcbiAgXHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuZGVwcywgZGVwZW5kYW50ICk7XG4gIH07XG5cbiAgS2V5TW9kZWwucHJvdG90eXBlLnVucmVnaXN0ZXJMaW5rID0gZnVuY3Rpb24gdW5yZWdpc3RlckxpbmsgKCBsaW5rICkge1xuICBcdHJlbW92ZUZyb21BcnJheSggdGhpcy5saW5rcywgbGluayApO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGJpbmQkMSAgICAgICAgICAgICAgICggeCApIHsgeC5iaW5kKCk7IH1cbiAgZnVuY3Rpb24gY2FuY2VsICAgICAgICAgICAgICggeCApIHsgeC5jYW5jZWwoKTsgfVxuICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UgICAgICAgKCB4ICkgeyB4LmhhbmRsZUNoYW5nZSgpOyB9XG4gIGZ1bmN0aW9uIG1hcmsgICAgICAgICAgICAgICAoIHggKSB7IHgubWFyaygpOyB9XG4gIGZ1bmN0aW9uIG1hcmtlZCAgICAgICAgICAgICAoIHggKSB7IHgubWFya2VkKCk7IH1cbiAgZnVuY3Rpb24gbm90aWZpZWRVcHN0cmVhbSAgICggeCApIHsgeC5ub3RpZmllZFVwc3RyZWFtKCk7IH1cbiAgZnVuY3Rpb24gcmVuZGVyICAgICAgICAgICAgICggeCApIHsgeC5yZW5kZXIoKTsgfVxuICBmdW5jdGlvbiB0ZWFyZG93biAgICAgICAgICAgKCB4ICkgeyB4LnRlYXJkb3duKCk7IH1cbiAgZnVuY3Rpb24gdW5iaW5kICAgICAgICAgICAgICggeCApIHsgeC51bmJpbmQoKTsgfVxuICBmdW5jdGlvbiB1bnJlbmRlciAgICAgICAgICAgKCB4ICkgeyB4LnVucmVuZGVyKCk7IH1cbiAgZnVuY3Rpb24gdW5yZW5kZXJBbmREZXN0cm95ICggeCApIHsgeC51bnJlbmRlciggdHJ1ZSApOyB9XG4gIGZ1bmN0aW9uIHVwZGF0ZSAgICAgICAgICAgICAoIHggKSB7IHgudXBkYXRlKCk7IH1cbiAgZnVuY3Rpb24gdG9TdHJpbmckMSAgICAgICAgICAgKCB4ICkgeyByZXR1cm4geC50b1N0cmluZygpOyB9XG4gIGZ1bmN0aW9uIHRvRXNjYXBlZFN0cmluZyAgICAoIHggKSB7IHJldHVybiB4LnRvU3RyaW5nKCB0cnVlICk7IH1cblxuICB2YXIgS2V5cGF0aE1vZGVsID0gZnVuY3Rpb24gS2V5cGF0aE1vZGVsICggcGFyZW50LCByYWN0aXZlICkge1xuICBcdHRoaXMucGFyZW50ID0gcGFyZW50O1xuICBcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG4gIFx0dGhpcy52YWx1ZSA9IHJhY3RpdmUgPyBwYXJlbnQuZ2V0S2V5cGF0aCggcmFjdGl2ZSApIDogcGFyZW50LmdldEtleXBhdGgoKTtcbiAgXHR0aGlzLmRlcHMgPSBbXTtcbiAgXHR0aGlzLmNoaWxkcmVuID0ge307XG4gIFx0dGhpcy5pc1JlYWRvbmx5ID0gdGhpcy5pc0tleXBhdGggPSB0cnVlO1xuICB9O1xuXG4gIEtleXBhdGhNb2RlbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICggc2hvdWxkQ2FwdHVyZSApIHtcbiAgXHRpZiAoIHNob3VsZENhcHR1cmUgKSBjYXB0dXJlKCB0aGlzICk7XG4gIFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIH07XG5cbiAgS2V5cGF0aE1vZGVsLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uIGdldENoaWxkICggcmFjdGl2ZSApIHtcbiAgXHRpZiAoICEoIHJhY3RpdmUuX2d1aWQgaW4gdGhpcy5jaGlsZHJlbiApICkge1xuICBcdFx0dmFyIG1vZGVsID0gbmV3IEtleXBhdGhNb2RlbCggdGhpcy5wYXJlbnQsIHJhY3RpdmUgKTtcbiAgXHRcdHRoaXMuY2hpbGRyZW5bIHJhY3RpdmUuX2d1aWQgXSA9IG1vZGVsO1xuICBcdFx0bW9kZWwub3duZXIgPSB0aGlzO1xuICBcdH1cbiAgXHRyZXR1cm4gdGhpcy5jaGlsZHJlblsgcmFjdGl2ZS5fZ3VpZCBdO1xuICB9O1xuXG4gIEtleXBhdGhNb2RlbC5wcm90b3R5cGUuZ2V0S2V5cGF0aCA9IGZ1bmN0aW9uIGdldEtleXBhdGggKCkge1xuICBcdHJldHVybiB0aGlzLnZhbHVlO1xuICB9O1xuXG4gIEtleXBhdGhNb2RlbC5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlJDEgKCkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKCB0aGlzLmNoaWxkcmVuICk7XG4gIFx0dmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgXHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdHRoaXMkMS5jaGlsZHJlblsga2V5c1tpXSBdLmhhbmRsZUNoYW5nZSgpO1xuICBcdH1cblxuICBcdHRoaXMuZGVwcy5mb3JFYWNoKCBoYW5kbGVDaGFuZ2UgKTtcbiAgfTtcblxuICBLZXlwYXRoTW9kZWwucHJvdG90eXBlLnJlYmluZENoaWxkcmVuID0gZnVuY3Rpb24gcmViaW5kQ2hpbGRyZW4gKCBuZXh0ICkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKCB0aGlzLmNoaWxkcmVuICk7XG4gIFx0dmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgXHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdHZhciBjaGlsZCA9IHRoaXMkMS5jaGlsZHJlbltrZXlzW2ldXTtcbiAgXHRcdGNoaWxkLnZhbHVlID0gbmV4dC5nZXRLZXlwYXRoKCBjaGlsZC5yYWN0aXZlICk7XG4gIFx0XHRjaGlsZC5oYW5kbGVDaGFuZ2UoKTtcbiAgXHR9XG4gIH07XG5cbiAgS2V5cGF0aE1vZGVsLnByb3RvdHlwZS5yZWJpbmRpbmcgPSBmdW5jdGlvbiByZWJpbmRpbmcgKCBuZXh0LCBwcmV2aW91cyApIHtcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dmFyIG1vZGVsID0gbmV4dCA/IG5leHQuZ2V0S2V5cGF0aE1vZGVsKCB0aGlzLnJhY3RpdmUgKSA6IHVuZGVmaW5lZDtcblxuICBcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoIHRoaXMuY2hpbGRyZW4gKTtcbiAgXHR2YXIgaSA9IGtleXMubGVuZ3RoO1xuICBcdHdoaWxlICggaS0tICkge1xuICBcdFx0dGhpcyQxLmNoaWxkcmVuWyBrZXlzW2ldIF0ucmViaW5kaW5nKCBuZXh0LCBwcmV2aW91cywgZmFsc2UgKTtcbiAgXHR9XG5cbiAgXHRpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgXHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdHRoaXMkMS5kZXBzW2ldLnJlYmluZGluZyggbW9kZWwsIHRoaXMkMSwgZmFsc2UgKTtcbiAgXHR9XG4gIH07XG5cbiAgS2V5cGF0aE1vZGVsLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyICggZGVwICkge1xuICBcdHRoaXMuZGVwcy5wdXNoKCBkZXAgKTtcbiAgfTtcblxuICBLZXlwYXRoTW9kZWwucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoIG1vZGVsICkge1xuICBcdGlmICggbW9kZWwucmFjdGl2ZSApIGRlbGV0ZSB0aGlzLmNoaWxkcmVuWyBtb2RlbC5yYWN0aXZlLl9ndWlkIF07XG4gIH07XG5cbiAgS2V5cGF0aE1vZGVsLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0aWYgKCB0aGlzLm93bmVyICkgdGhpcy5vd25lci5yZW1vdmVDaGlsZCggdGhpcyApO1xuXG4gIFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyggdGhpcy5jaGlsZHJlbiApO1xuICBcdHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHR0aGlzJDEuY2hpbGRyZW5bIGtleXNbaV0gXS50ZWFyZG93bigpO1xuICBcdH1cbiAgfTtcblxuICBLZXlwYXRoTW9kZWwucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyICggZGVwICkge1xuICBcdHJlbW92ZUZyb21BcnJheSggdGhpcy5kZXBzLCBkZXAgKTtcbiAgXHRpZiAoICF0aGlzLmRlcHMubGVuZ3RoICkgdGhpcy50ZWFyZG93bigpO1xuICB9O1xuXG4gIHZhciBoYXNQcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICB2YXIgc2h1ZmZsZVRhc2tzID0geyBlYXJseTogW10sIG1hcms6IFtdIH07XG4gIHZhciByZWdpc3RlclF1ZXVlID0geyBlYXJseTogW10sIG1hcms6IFtdIH07XG5cbiAgdmFyIE1vZGVsQmFzZSA9IGZ1bmN0aW9uIE1vZGVsQmFzZSAoIHBhcmVudCApIHtcbiAgXHR0aGlzLmRlcHMgPSBbXTtcblxuICBcdHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgXHR0aGlzLmNoaWxkQnlLZXkgPSB7fTtcbiAgXHR0aGlzLmxpbmtzID0gW107XG5cbiAgXHR0aGlzLmtleU1vZGVscyA9IHt9O1xuXG4gIFx0dGhpcy51bnJlc29sdmVkID0gW107XG4gIFx0dGhpcy51bnJlc29sdmVkQnlLZXkgPSB7fTtcblxuICBcdHRoaXMuYmluZGluZ3MgPSBbXTtcbiAgXHR0aGlzLnBhdHRlcm5PYnNlcnZlcnMgPSBbXTtcblxuICBcdGlmICggcGFyZW50ICkge1xuICBcdFx0dGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIFx0XHR0aGlzLnJvb3QgPSBwYXJlbnQucm9vdDtcbiAgXHR9XG4gIH07XG5cbiAgTW9kZWxCYXNlLnByb3RvdHlwZS5hZGRVbnJlc29sdmVkID0gZnVuY3Rpb24gYWRkVW5yZXNvbHZlZCAoIGtleSwgcmVzb2x2ZXIgKSB7XG4gIFx0aWYgKCAhdGhpcy51bnJlc29sdmVkQnlLZXlbIGtleSBdICkge1xuICBcdFx0dGhpcy51bnJlc29sdmVkLnB1c2goIGtleSApO1xuICBcdFx0dGhpcy51bnJlc29sdmVkQnlLZXlbIGtleSBdID0gW107XG4gIFx0fVxuXG4gIFx0dGhpcy51bnJlc29sdmVkQnlLZXlbIGtleSBdLnB1c2goIHJlc29sdmVyICk7XG4gIH07XG5cbiAgTW9kZWxCYXNlLnByb3RvdHlwZS5hZGRTaHVmZmxlVGFzayA9IGZ1bmN0aW9uIGFkZFNodWZmbGVUYXNrICggdGFzaywgc3RhZ2UgKSB7IGlmICggc3RhZ2UgPT09IHZvaWQgMCApIHN0YWdlID0gJ2Vhcmx5JztcblxuICBcdHNodWZmbGVUYXNrc1tzdGFnZV0ucHVzaCggdGFzayApOyB9O1xuICBNb2RlbEJhc2UucHJvdG90eXBlLmFkZFNodWZmbGVSZWdpc3RlciA9IGZ1bmN0aW9uIGFkZFNodWZmbGVSZWdpc3RlciAoIGl0ZW0sIHN0YWdlICkgeyBpZiAoIHN0YWdlID09PSB2b2lkIDAgKSBzdGFnZSA9ICdlYXJseSc7XG5cbiAgXHRyZWdpc3RlclF1ZXVlW3N0YWdlXS5wdXNoKHsgbW9kZWw6IHRoaXMsIGl0ZW06IGl0ZW0gfSk7IH07XG5cbiAgTW9kZWxCYXNlLnByb3RvdHlwZS5jbGVhclVucmVzb2x2ZWRzID0gZnVuY3Rpb24gY2xlYXJVbnJlc29sdmVkcyAoIHNwZWNpZmljS2V5ICkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHR2YXIgaSA9IHRoaXMudW5yZXNvbHZlZC5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdHZhciBrZXkgPSB0aGlzJDEudW5yZXNvbHZlZFtpXTtcblxuICBcdFx0aWYgKCBzcGVjaWZpY0tleSAmJiBrZXkgIT09IHNwZWNpZmljS2V5ICkgY29udGludWU7XG5cbiAgXHRcdHZhciByZXNvbHZlcnMgPSB0aGlzJDEudW5yZXNvbHZlZEJ5S2V5WyBrZXkgXTtcbiAgXHRcdHZhciBoYXNLZXkgPSB0aGlzJDEuaGFzKCBrZXkgKTtcblxuICBcdFx0dmFyIGogPSByZXNvbHZlcnMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKCBqLS0gKSB7XG4gIFx0XHRcdGlmICggaGFzS2V5ICkgcmVzb2x2ZXJzW2pdLmF0dGVtcHRSZXNvbHV0aW9uKCk7XG4gIFx0XHRcdGlmICggcmVzb2x2ZXJzW2pdLnJlc29sdmVkICkgcmVzb2x2ZXJzLnNwbGljZSggaiwgMSApO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoICFyZXNvbHZlcnMubGVuZ3RoICkge1xuICBcdFx0XHR0aGlzJDEudW5yZXNvbHZlZC5zcGxpY2UoIGksIDEgKTtcbiAgXHRcdFx0dGhpcyQxLnVucmVzb2x2ZWRCeUtleVsga2V5IF0gPSBudWxsO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICBNb2RlbEJhc2UucHJvdG90eXBlLmZpbmRNYXRjaGVzID0gZnVuY3Rpb24gZmluZE1hdGNoZXMgKCBrZXlzICkge1xuICBcdHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcblxuICBcdHZhciBleGlzdGluZ01hdGNoZXMgPSBbIHRoaXMgXTtcbiAgXHR2YXIgbWF0Y2hlcztcbiAgXHR2YXIgaTtcblxuICBcdHZhciBsb29wID0gZnVuY3Rpb24gKCAgKSB7XG4gIFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblxuICBcdFx0aWYgKCBrZXkgPT09ICcqJyApIHtcbiAgXHRcdFx0bWF0Y2hlcyA9IFtdO1xuICBcdFx0XHRleGlzdGluZ01hdGNoZXMuZm9yRWFjaCggZnVuY3Rpb24gKCBtb2RlbCApIHtcbiAgXHRcdFx0XHRtYXRjaGVzLnB1c2guYXBwbHkoIG1hdGNoZXMsIG1vZGVsLmdldFZhbHVlQ2hpbGRyZW4oIG1vZGVsLmdldCgpICkgKTtcbiAgXHRcdFx0fSk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRtYXRjaGVzID0gZXhpc3RpbmdNYXRjaGVzLm1hcCggZnVuY3Rpb24gKCBtb2RlbCApIHsgcmV0dXJuIG1vZGVsLmpvaW5LZXkoIGtleSApOyB9ICk7XG4gIFx0XHR9XG5cbiAgXHRcdGV4aXN0aW5nTWF0Y2hlcyA9IG1hdGNoZXM7XG4gIFx0fTtcblxuICBcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIGxvb3AoICApO1xuXG4gIFx0cmV0dXJuIG1hdGNoZXM7XG4gIH07XG5cbiAgTW9kZWxCYXNlLnByb3RvdHlwZS5nZXRLZXlNb2RlbCA9IGZ1bmN0aW9uIGdldEtleU1vZGVsICgga2V5LCBza2lwICkge1xuICBcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgJiYgIXNraXAgKSByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0S2V5TW9kZWwoIGtleSwgdHJ1ZSApO1xuXG4gIFx0aWYgKCAhKCBrZXkgaW4gdGhpcy5rZXlNb2RlbHMgKSApIHRoaXMua2V5TW9kZWxzWyBrZXkgXSA9IG5ldyBLZXlNb2RlbCggZXNjYXBlS2V5KCBrZXkgKSwgdGhpcyApO1xuXG4gIFx0cmV0dXJuIHRoaXMua2V5TW9kZWxzWyBrZXkgXTtcbiAgfTtcblxuICBNb2RlbEJhc2UucHJvdG90eXBlLmdldEtleXBhdGggPSBmdW5jdGlvbiBnZXRLZXlwYXRoICggcmFjdGl2ZSApIHtcbiAgXHRpZiAoIHJhY3RpdmUgIT09IHRoaXMucmFjdGl2ZSAmJiB0aGlzLl9saW5rICkgcmV0dXJuIHRoaXMuX2xpbmsudGFyZ2V0LmdldEtleXBhdGgoIHJhY3RpdmUgKTtcblxuICBcdGlmICggIXRoaXMua2V5cGF0aCApIHtcbiAgXHRcdHRoaXMua2V5cGF0aCA9IHRoaXMucGFyZW50LmlzUm9vdCA/IHRoaXMua2V5IDogKFwiXCIgKyAodGhpcy5wYXJlbnQuZ2V0S2V5cGF0aCggcmFjdGl2ZSApKSArIFwiLlwiICsgKGVzY2FwZUtleSggdGhpcy5rZXkgKSkpO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLmtleXBhdGg7XG4gIH07XG5cbiAgTW9kZWxCYXNlLnByb3RvdHlwZS5nZXRWYWx1ZUNoaWxkcmVuID0gZnVuY3Rpb24gZ2V0VmFsdWVDaGlsZHJlbiAoIHZhbHVlICkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHR2YXIgY2hpbGRyZW47XG4gIFx0aWYgKCBpc0FycmF5KCB2YWx1ZSApICkge1xuICBcdFx0Y2hpbGRyZW4gPSBbXTtcbiAgXHRcdGlmICggJ2xlbmd0aCcgaW4gdGhpcyAmJiB0aGlzLmxlbmd0aCAhPT0gdmFsdWUubGVuZ3RoICkge1xuICBcdFx0XHRjaGlsZHJlbi5wdXNoKCB0aGlzLmpvaW5LZXkoICdsZW5ndGgnICkgKTtcbiAgXHRcdH1cbiAgXHRcdHZhbHVlLmZvckVhY2goIGZ1bmN0aW9uICggbSwgaSApIHtcbiAgXHRcdFx0Y2hpbGRyZW4ucHVzaCggdGhpcyQxLmpvaW5LZXkoIGkgKSApO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0ZWxzZSBpZiAoIGlzT2JqZWN0KCB2YWx1ZSApIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgXHRcdGNoaWxkcmVuID0gT2JqZWN0LmtleXMoIHZhbHVlICkubWFwKCBmdW5jdGlvbiAoIGtleSApIHsgcmV0dXJuIHRoaXMkMS5qb2luS2V5KCBrZXkgKTsgfSApO1xuICBcdH1cblxuICBcdGVsc2UgaWYgKCB2YWx1ZSAhPSBudWxsICkge1xuICBcdFx0cmV0dXJuIFtdO1xuICBcdH1cblxuICBcdHJldHVybiBjaGlsZHJlbjtcbiAgfTtcblxuICBNb2RlbEJhc2UucHJvdG90eXBlLmdldFZpcnR1YWwgPSBmdW5jdGlvbiBnZXRWaXJ0dWFsICggc2hvdWxkQ2FwdHVyZSApIHtcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dmFyIHZhbHVlID0gdGhpcy5nZXQoIHNob3VsZENhcHR1cmUsIHsgdmlydHVhbDogZmFsc2UgfSApO1xuICBcdGlmICggaXNPYmplY3QoIHZhbHVlICkgKSB7XG4gIFx0XHR2YXIgcmVzdWx0ID0gaXNBcnJheSggdmFsdWUgKSA/IFtdIDoge307XG5cbiAgXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoIHZhbHVlICk7XG4gIFx0XHR2YXIgaSA9IGtleXMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRcdHZhciBjaGlsZCA9IHRoaXMkMS5jaGlsZEJ5S2V5WyBrZXlzW2ldIF07XG4gIFx0XHRcdGlmICggIWNoaWxkICkgcmVzdWx0WyBrZXlzW2ldIF0gPSB2YWx1ZVsga2V5c1tpXSBdO1xuICBcdFx0XHRlbHNlIGlmICggY2hpbGQuX2xpbmsgKSByZXN1bHRbIGtleXNbaV0gXSA9IGNoaWxkLl9saW5rLmdldFZpcnR1YWwoKTtcbiAgXHRcdFx0ZWxzZSByZXN1bHRbIGtleXNbaV0gXSA9IGNoaWxkLmdldFZpcnR1YWwoKTtcbiAgXHRcdH1cblxuICBcdFx0aSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICBcdFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRcdHZhciBjaGlsZCQxID0gdGhpcyQxLmNoaWxkcmVuW2ldO1xuICBcdFx0XHRpZiAoICEoIGNoaWxkJDEua2V5IGluIHJlc3VsdCApICYmIGNoaWxkJDEuX2xpbmsgKSB7XG4gIFx0XHRcdFx0cmVzdWx0WyBjaGlsZCQxLmtleSBdID0gY2hpbGQkMS5fbGluay5nZXRWaXJ0dWFsKCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9IGVsc2UgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIE1vZGVsQmFzZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzICgga2V5ICkge1xuICBcdGlmICggdGhpcy5fbGluayApIHJldHVybiB0aGlzLl9saW5rLmhhcygga2V5ICk7XG5cbiAgXHR2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICBcdGlmICggIXZhbHVlICkgcmV0dXJuIGZhbHNlO1xuXG4gIFx0a2V5ID0gdW5lc2NhcGVLZXkoIGtleSApO1xuICBcdGlmICggaGFzUHJvcC5jYWxsKCB2YWx1ZSwga2V5ICkgKSByZXR1cm4gdHJ1ZTtcblxuICBcdC8vIFdlIGNsaW1iIHVwIHRoZSBjb25zdHJ1Y3RvciBjaGFpbiB0byBmaW5kIGlmIG9uZSBvZiB0aGVtIGNvbnRhaW5zIHRoZSBrZXlcbiAgXHR2YXIgY29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgXHR3aGlsZSAoIGNvbnN0cnVjdG9yICE9PSBGdW5jdGlvbiAmJiBjb25zdHJ1Y3RvciAhPT0gQXJyYXkgJiYgY29uc3RydWN0b3IgIT09IE9iamVjdCApIHtcbiAgXHRcdGlmICggaGFzUHJvcC5jYWxsKCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIGtleSApICkgcmV0dXJuIHRydWU7XG4gIFx0XHRjb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yLmNvbnN0cnVjdG9yO1xuICBcdH1cblxuICBcdHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBNb2RlbEJhc2UucHJvdG90eXBlLmpvaW5BbGwgPSBmdW5jdGlvbiBqb2luQWxsICgga2V5cywgb3B0cyApIHtcbiAgXHR2YXIgbW9kZWwgPSB0aGlzO1xuICBcdGZvciAoIHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpICs9IDEgKSB7XG4gIFx0XHRpZiAoIG9wdHMgJiYgb3B0cy5sYXN0TGluayA9PT0gZmFsc2UgJiYgaSArIDEgPT09IGtleXMubGVuZ3RoICYmIG1vZGVsLmNoaWxkQnlLZXlba2V5c1tpXV0gJiYgbW9kZWwuY2hpbGRCeUtleVtrZXlzW2ldXS5fbGluayApIHJldHVybiBtb2RlbC5jaGlsZEJ5S2V5W2tleXNbaV1dO1xuICBcdFx0bW9kZWwgPSBtb2RlbC5qb2luS2V5KCBrZXlzW2ldLCBvcHRzICk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG1vZGVsO1xuICB9O1xuXG4gIE1vZGVsQmFzZS5wcm90b3R5cGUubm90aWZ5VXBzdHJlYW0gPSBmdW5jdGlvbiBub3RpZnlVcHN0cmVhbSAoKSB7XG4gIFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50LCBwYXRoID0gWyB0aGlzLmtleSBdO1xuICBcdHdoaWxlICggcGFyZW50ICkge1xuICBcdFx0aWYgKCBwYXJlbnQucGF0dGVybk9ic2VydmVycy5sZW5ndGggKSBwYXJlbnQucGF0dGVybk9ic2VydmVycy5mb3JFYWNoKCBmdW5jdGlvbiAoIG8gKSB7IHJldHVybiBvLm5vdGlmeSggcGF0aC5zbGljZSgpICk7IH0gKTtcbiAgXHRcdHBhdGgudW5zaGlmdCggcGFyZW50LmtleSApO1xuICBcdFx0cGFyZW50LmxpbmtzLmZvckVhY2goIG5vdGlmaWVkVXBzdHJlYW0gKTtcbiAgXHRcdHBhcmVudC5kZXBzLmZvckVhY2goIGhhbmRsZUNoYW5nZSApO1xuICBcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgXHR9XG4gIH07XG5cbiAgTW9kZWxCYXNlLnByb3RvdHlwZS5yZWJpbmRpbmcgPSBmdW5jdGlvbiByZWJpbmRpbmcgKCBuZXh0LCBwcmV2aW91cywgc2FmZSApIHtcbiAgXHQvLyB0ZWxsIHRoZSBkZXBzIHRvIG1vdmUgdG8gdGhlIG5ldyB0YXJnZXRcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICBcdHdoaWxlICggaS0tICkge1xuICBcdFx0aWYgKCB0aGlzJDEuZGVwc1tpXS5yZWJpbmRpbmcgKSB0aGlzJDEuZGVwc1tpXS5yZWJpbmRpbmcoIG5leHQsIHByZXZpb3VzLCBzYWZlICk7XG4gIFx0fVxuXG4gIFx0aSA9IHRoaXMubGlua3MubGVuZ3RoO1xuICBcdHdoaWxlICggaS0tICkge1xuICBcdFx0dmFyIGxpbmsgPSB0aGlzJDEubGlua3NbaV07XG4gIFx0XHQvLyBvbmx5IHJlbGluayB0aGUgcm9vdCBvZiB0aGUgbGluayB0cmVlXG4gIFx0XHRpZiAoIGxpbmsub3duZXIuX2xpbmsgKSBsaW5rLnJlbGlua2luZyggbmV4dCwgdHJ1ZSwgc2FmZSApO1xuICBcdH1cblxuICBcdGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgXHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdHZhciBjaGlsZCA9IHRoaXMkMS5jaGlsZHJlbltpXTtcbiAgXHRcdGNoaWxkLnJlYmluZGluZyggbmV4dCA/IG5leHQuam9pbktleSggY2hpbGQua2V5ICkgOiB1bmRlZmluZWQsIGNoaWxkLCBzYWZlICk7XG4gIFx0fVxuXG4gIFx0aSA9IHRoaXMudW5yZXNvbHZlZC5sZW5ndGg7XG4gIFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHR2YXIgdW5yZXNvbHZlZCA9IHRoaXMkMS51bnJlc29sdmVkQnlLZXlbIHRoaXMkMS51bnJlc29sdmVkW2ldIF07XG4gIFx0XHR2YXIgYyA9IHVucmVzb2x2ZWQubGVuZ3RoO1xuICBcdFx0d2hpbGUgKCBjLS0gKSB7XG4gIFx0XHRcdHVucmVzb2x2ZWRbY10ucmViaW5kaW5nKCBuZXh0LCBwcmV2aW91cyApO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICggdGhpcy5rZXlwYXRoTW9kZWwgKSB0aGlzLmtleXBhdGhNb2RlbC5yZWJpbmRpbmcoIG5leHQsIHByZXZpb3VzLCBmYWxzZSApO1xuXG4gIFx0aSA9IHRoaXMuYmluZGluZ3MubGVuZ3RoO1xuICBcdHdoaWxlICggaS0tICkge1xuICBcdFx0dGhpcyQxLmJpbmRpbmdzW2ldLnJlYmluZGluZyggbmV4dCwgcHJldmlvdXMsIHNhZmUgKTtcbiAgXHR9XG4gIH07XG5cbiAgTW9kZWxCYXNlLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyICggZGVwICkge1xuICBcdHRoaXMuZGVwcy5wdXNoKCBkZXAgKTtcbiAgfTtcblxuICBNb2RlbEJhc2UucHJvdG90eXBlLnJlZ2lzdGVyQ2hhbmdlID0gZnVuY3Rpb24gcmVnaXN0ZXJDaGFuZ2UgKCBrZXksIHZhbHVlICkge1xuICBcdGlmICggIXRoaXMuaXNSb290ICkge1xuICBcdFx0dGhpcy5yb290LnJlZ2lzdGVyQ2hhbmdlKCBrZXksIHZhbHVlICk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHRoaXMuY2hhbmdlc1sga2V5IF0gPSB2YWx1ZTtcbiAgXHRcdHJ1bmxvb3AuYWRkSW5zdGFuY2UoIHRoaXMucm9vdC5yYWN0aXZlICk7XG4gIFx0fVxuICB9O1xuXG4gIE1vZGVsQmFzZS5wcm90b3R5cGUucmVnaXN0ZXJMaW5rID0gZnVuY3Rpb24gcmVnaXN0ZXJMaW5rICggbGluayApIHtcbiAgXHRhZGRUb0FycmF5KCB0aGlzLmxpbmtzLCBsaW5rICk7XG4gIH07XG5cbiAgTW9kZWxCYXNlLnByb3RvdHlwZS5yZWdpc3RlclBhdHRlcm5PYnNlcnZlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyUGF0dGVybk9ic2VydmVyICggb2JzZXJ2ZXIgKSB7XG4gIFx0dGhpcy5wYXR0ZXJuT2JzZXJ2ZXJzLnB1c2goIG9ic2VydmVyICk7XG4gIFx0dGhpcy5yZWdpc3Rlciggb2JzZXJ2ZXIgKTtcbiAgfTtcblxuICBNb2RlbEJhc2UucHJvdG90eXBlLnJlZ2lzdGVyVHdvd2F5QmluZGluZyA9IGZ1bmN0aW9uIHJlZ2lzdGVyVHdvd2F5QmluZGluZyAoIGJpbmRpbmcgKSB7XG4gIFx0dGhpcy5iaW5kaW5ncy5wdXNoKCBiaW5kaW5nICk7XG4gIH07XG5cbiAgTW9kZWxCYXNlLnByb3RvdHlwZS5yZW1vdmVVbnJlc29sdmVkID0gZnVuY3Rpb24gcmVtb3ZlVW5yZXNvbHZlZCAoIGtleSwgcmVzb2x2ZXIgKSB7XG4gIFx0dmFyIHJlc29sdmVycyA9IHRoaXMudW5yZXNvbHZlZEJ5S2V5WyBrZXkgXTtcblxuICBcdGlmICggcmVzb2x2ZXJzICkge1xuICBcdFx0cmVtb3ZlRnJvbUFycmF5KCByZXNvbHZlcnMsIHJlc29sdmVyICk7XG4gIFx0fVxuICB9O1xuXG4gIE1vZGVsQmFzZS5wcm90b3R5cGUuc2h1ZmZsZWQgPSBmdW5jdGlvbiBzaHVmZmxlZCAoKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHZhciBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gIFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHR0aGlzJDEuY2hpbGRyZW5baV0uc2h1ZmZsZWQoKTtcbiAgXHR9XG4gIFx0aWYgKCB0aGlzLndyYXBwZXIgKSB7XG4gIFx0XHR0aGlzLndyYXBwZXIudGVhcmRvd24oKTtcbiAgXHRcdHRoaXMud3JhcHBlciA9IG51bGw7XG4gIFx0XHR0aGlzLnJld3JhcCA9IHRydWU7XG4gIFx0fVxuICB9O1xuXG4gIE1vZGVsQmFzZS5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uIHVucmVnaXN0ZXIgKCBkZXBlbmRhbnQgKSB7XG4gIFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLmRlcHMsIGRlcGVuZGFudCApO1xuICB9O1xuXG4gIE1vZGVsQmFzZS5wcm90b3R5cGUudW5yZWdpc3RlckxpbmsgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGluayAoIGxpbmsgKSB7XG4gIFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLmxpbmtzLCBsaW5rICk7XG4gIH07XG5cbiAgTW9kZWxCYXNlLnByb3RvdHlwZS51bnJlZ2lzdGVyUGF0dGVybk9ic2VydmVyID0gZnVuY3Rpb24gdW5yZWdpc3RlclBhdHRlcm5PYnNlcnZlciAoIG9ic2VydmVyICkge1xuICBcdHJlbW92ZUZyb21BcnJheSggdGhpcy5wYXR0ZXJuT2JzZXJ2ZXJzLCBvYnNlcnZlciApO1xuICBcdHRoaXMudW5yZWdpc3Rlciggb2JzZXJ2ZXIgKTtcbiAgfTtcblxuICBNb2RlbEJhc2UucHJvdG90eXBlLnVucmVnaXN0ZXJUd293YXlCaW5kaW5nID0gZnVuY3Rpb24gdW5yZWdpc3RlclR3b3dheUJpbmRpbmcgKCBiaW5kaW5nICkge1xuICBcdHJlbW92ZUZyb21BcnJheSggdGhpcy5iaW5kaW5ncywgYmluZGluZyApO1xuICB9O1xuXG4gIE1vZGVsQmFzZS5wcm90b3R5cGUudXBkYXRlRnJvbUJpbmRpbmdzID0gZnVuY3Rpb24gdXBkYXRlRnJvbUJpbmRpbmdzJDEgKCBjYXNjYWRlICkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHR2YXIgaSA9IHRoaXMuYmluZGluZ3MubGVuZ3RoO1xuICBcdHdoaWxlICggaS0tICkge1xuICBcdFx0dmFyIHZhbHVlID0gdGhpcyQxLmJpbmRpbmdzW2ldLmdldFZhbHVlKCk7XG4gIFx0XHRpZiAoIHZhbHVlICE9PSB0aGlzJDEudmFsdWUgKSB0aGlzJDEuc2V0KCB2YWx1ZSApO1xuICBcdH1cblxuICBcdC8vIGNoZWNrIGZvciBvbmUtd2F5IGJpbmRpbmdzIGlmIHRoZXJlIGFyZSBubyB0d28td2F5c1xuICBcdGlmICggIXRoaXMuYmluZGluZ3MubGVuZ3RoICkge1xuICBcdFx0dmFyIG9uZXdheSA9IGZpbmRCb3VuZFZhbHVlKCB0aGlzLmRlcHMgKTtcbiAgXHRcdGlmICggb25ld2F5ICYmIG9uZXdheS52YWx1ZSAhPT0gdGhpcy52YWx1ZSApIHRoaXMuc2V0KCBvbmV3YXkudmFsdWUgKTtcbiAgXHR9XG5cbiAgXHRpZiAoIGNhc2NhZGUgKSB7XG4gIFx0XHR0aGlzLmNoaWxkcmVuLmZvckVhY2goIHVwZGF0ZUZyb21CaW5kaW5ncyApO1xuICBcdFx0dGhpcy5saW5rcy5mb3JFYWNoKCB1cGRhdGVGcm9tQmluZGluZ3MgKTtcbiAgXHRcdGlmICggdGhpcy5fbGluayApIHRoaXMuX2xpbmsudXBkYXRlRnJvbUJpbmRpbmdzKCBjYXNjYWRlICk7XG4gIFx0fVxuICB9O1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21CaW5kaW5ncyAoIG1vZGVsICkge1xuICBcdG1vZGVsLnVwZGF0ZUZyb21CaW5kaW5ncyggdHJ1ZSApO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEJvdW5kVmFsdWUoIGxpc3QgKSB7XG4gIFx0dmFyIGkgPSBsaXN0Lmxlbmd0aDtcbiAgXHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdGlmICggbGlzdFtpXS5ib3VuZCApIHtcbiAgXHRcdFx0dmFyIG93bmVyID0gbGlzdFtpXS5vd25lcjtcbiAgXHRcdFx0aWYgKCBvd25lciApIHtcbiAgXHRcdFx0XHR2YXIgdmFsdWUgPSBvd25lci5uYW1lID09PSAnY2hlY2tlZCcgP1xuICBcdFx0XHRcdFx0b3duZXIubm9kZS5jaGVja2VkIDpcbiAgXHRcdFx0XHRcdG93bmVyLm5vZGUudmFsdWU7XG4gIFx0XHRcdFx0cmV0dXJuIHsgdmFsdWU6IHZhbHVlIH07XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlU2h1ZmZsZVRhc2tzICggc3RhZ2UgKSB7XG4gIFx0aWYgKCAhc3RhZ2UgKSB7XG4gIFx0XHRmaXJlU2h1ZmZsZVRhc2tzKCAnZWFybHknICk7XG4gIFx0XHRmaXJlU2h1ZmZsZVRhc2tzKCAnbWFyaycgKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0dmFyIHRhc2tzID0gc2h1ZmZsZVRhc2tzW3N0YWdlXTtcbiAgXHRcdHNodWZmbGVUYXNrc1tzdGFnZV0gPSBbXTtcbiAgXHRcdHZhciBpID0gdGFza3MubGVuZ3RoO1xuICBcdFx0d2hpbGUgKCBpLS0gKSB0YXNrc1tpXSgpO1xuXG4gIFx0XHR2YXIgcmVnaXN0ZXIgPSByZWdpc3RlclF1ZXVlW3N0YWdlXTtcbiAgXHRcdHJlZ2lzdGVyUXVldWVbc3RhZ2VdID0gW107XG4gIFx0XHRpID0gcmVnaXN0ZXIubGVuZ3RoO1xuICBcdFx0d2hpbGUgKCBpLS0gKSByZWdpc3RlcltpXS5tb2RlbC5yZWdpc3RlciggcmVnaXN0ZXJbaV0uaXRlbSApO1xuICBcdH1cbiAgfVxuXG4gIEtleU1vZGVsLnByb3RvdHlwZS5hZGRTaHVmZmxlVGFzayA9IE1vZGVsQmFzZS5wcm90b3R5cGUuYWRkU2h1ZmZsZVRhc2s7XG4gIEtleU1vZGVsLnByb3RvdHlwZS5hZGRTaHVmZmxlUmVnaXN0ZXIgPSBNb2RlbEJhc2UucHJvdG90eXBlLmFkZFNodWZmbGVSZWdpc3RlcjtcbiAgS2V5cGF0aE1vZGVsLnByb3RvdHlwZS5hZGRTaHVmZmxlVGFzayA9IE1vZGVsQmFzZS5wcm90b3R5cGUuYWRkU2h1ZmZsZVRhc2s7XG4gIEtleXBhdGhNb2RlbC5wcm90b3R5cGUuYWRkU2h1ZmZsZVJlZ2lzdGVyID0gTW9kZWxCYXNlLnByb3RvdHlwZS5hZGRTaHVmZmxlUmVnaXN0ZXI7XG5cbiAgLy8gdGhpcyBpcyB0aGUgZHJ5IG1ldGhvZCBvZiBjaGVja2luZyB0byBzZWUgaWYgYSByZWJpbmQgYXBwbGllcyB0b1xuICAvLyBhIHBhcnRpY3VsYXIga2V5cGF0aCBiZWNhdXNlIGluIHNvbWUgY2FzZXMsIGEgZGVwIG1heSBiZSBib3VuZFxuICAvLyBkaXJlY3RseSB0byBhIHBhcnRpY3VsYXIga2V5cGF0aCBlLmcuIGZvby5iYXJzLjAuYmF6IGFuZCBuZWVkXG4gIC8vIHRvIGF2b2lkIGdldHRpbmcga2lja2VkIHRvIGZvby5iYXJzLjEuYmF6IGlmIGZvby5iYXJzIGlzIHVuc2hpZnRlZFxuICBmdW5jdGlvbiByZWJpbmRNYXRjaCAoIHRlbXBsYXRlLCBuZXh0LCBwcmV2aW91cyApIHtcbiAgXHR2YXIga2V5cGF0aCA9IHRlbXBsYXRlLnIgfHwgdGVtcGxhdGU7XG5cbiAgXHQvLyBubyB2YWxpZCBrZXlwYXRoLCBnbyB3aXRoIG5leHRcbiAgXHRpZiAoICFrZXlwYXRoIHx8IHR5cGVvZiBrZXlwYXRoICE9PSAnc3RyaW5nJyApIHJldHVybiBuZXh0O1xuXG4gIFx0Ly8gY29tcGxldGVseSBjb250ZXh0dWFsIHJlZiwgZ28gd2l0aCBuZXh0XG4gIFx0aWYgKCBrZXlwYXRoID09PSAnLicgfHwga2V5cGF0aFswXSA9PT0gJ0AnIHx8IChuZXh0IHx8IHByZXZpb3VzKS5pc0tleSB8fCAobmV4dCB8fCBwcmV2aW91cykuaXNLZXlwYXRoICkgcmV0dXJuIG5leHQ7XG5cbiAgXHR2YXIgcGFydHMgPSBrZXlwYXRoLnNwbGl0KCAnLycgKTtcbiAgXHR2YXIga2V5cyA9IHNwbGl0S2V5cGF0aEkoIHBhcnRzWyBwYXJ0cy5sZW5ndGggLSAxIF0gKTtcblxuICBcdC8vIGNoZWNrIHRoZSBrZXlwYXRoIGFnYWluc3QgdGhlIG1vZGVsIGtleXBhdGggdG8gc2VlIGlmIGl0IG1hdGNoZXNcbiAgXHR2YXIgbW9kZWwgPSBuZXh0IHx8IHByZXZpb3VzO1xuICBcdHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIFx0dmFyIG1hdGNoID0gdHJ1ZSwgc2h1ZmZsaW5nID0gZmFsc2U7XG5cbiAgXHR3aGlsZSAoIG1vZGVsICYmIGktLSApIHtcbiAgXHRcdGlmICggbW9kZWwuc2h1ZmZsaW5nICkgc2h1ZmZsaW5nID0gdHJ1ZTtcbiAgXHRcdC8vIG5vbi1zdHJpY3QgY29tcGFyaXNvbiB0byBhY2NvdW50IGZvciBpbmRpY2VzIGluIGtleXBhdGhzXG4gIFx0XHRpZiAoIGtleXNbaV0gIT0gbW9kZWwua2V5ICkgbWF0Y2ggPSBmYWxzZTtcbiAgXHRcdG1vZGVsID0gbW9kZWwucGFyZW50O1xuICBcdH1cblxuICBcdC8vIG5leHQgaXMgdW5kZWZpbmVkLCBidXQga2V5cGF0aCBpcyBzaHVmZmxpbmcgYW5kIHByZXZpb3VzIG1hdGNoZXNcbiAgXHRpZiAoICFuZXh0ICYmIG1hdGNoICYmIHNodWZmbGluZyApIHJldHVybiBwcmV2aW91cztcbiAgXHQvLyBuZXh0IGlzIGRlZmluZWQsIGJ1dCBkb2Vzbid0IG1hdGNoIHRoZSBrZXlwYXRoXG4gIFx0ZWxzZSBpZiAoIG5leHQgJiYgIW1hdGNoICYmIHNodWZmbGluZyApIHJldHVybiBwcmV2aW91cztcbiAgXHRlbHNlIHJldHVybiBuZXh0O1xuICB9XG5cbiAgdmFyIExpbmtNb2RlbCA9IChmdW5jdGlvbiAoTW9kZWxCYXNlKSB7XG4gIFx0ZnVuY3Rpb24gTGlua01vZGVsICggcGFyZW50LCBvd25lciwgdGFyZ2V0LCBrZXkgKSB7XG4gIFx0XHRNb2RlbEJhc2UuY2FsbCggdGhpcywgcGFyZW50ICk7XG5cbiAgXHRcdHRoaXMub3duZXIgPSBvd25lcjtcbiAgXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICBcdFx0dGhpcy5rZXkgPSBrZXkgPT09IHVuZGVmaW5lZCA/IG93bmVyLmtleSA6IGtleTtcbiAgXHRcdGlmICggb3duZXIuaXNMaW5rICkgdGhpcy5zb3VyY2VQYXRoID0gXCJcIiArIChvd25lci5zb3VyY2VQYXRoKSArIFwiLlwiICsgKHRoaXMua2V5KTtcblxuICBcdFx0dGFyZ2V0LnJlZ2lzdGVyTGluayggdGhpcyApO1xuXG4gIFx0XHR0aGlzLmlzUmVhZG9ubHkgPSBwYXJlbnQuaXNSZWFkb25seTtcblxuICBcdFx0dGhpcy5pc0xpbmsgPSB0cnVlO1xuICBcdH1cblxuICBcdExpbmtNb2RlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNb2RlbEJhc2UgJiYgTW9kZWxCYXNlLnByb3RvdHlwZSApO1xuICBcdExpbmtNb2RlbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5rTW9kZWw7XG5cbiAgXHRMaW5rTW9kZWwucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiBhbmltYXRlICggZnJvbSwgdG8sIG9wdGlvbnMsIGludGVycG9sYXRvciApIHtcbiAgXHRcdHRoaXMudGFyZ2V0LmFuaW1hdGUoIGZyb20sIHRvLCBvcHRpb25zLCBpbnRlcnBvbGF0b3IgKTtcbiAgXHR9O1xuXG4gIFx0TGlua01vZGVsLnByb3RvdHlwZS5hcHBseVZhbHVlID0gZnVuY3Rpb24gYXBwbHlWYWx1ZSAoIHZhbHVlICkge1xuICBcdFx0dGhpcy50YXJnZXQuYXBwbHlWYWx1ZSggdmFsdWUgKTtcbiAgXHR9O1xuXG4gIFx0TGlua01vZGVsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCBzaG91bGRDYXB0dXJlLCBvcHRzICkge1xuICBcdFx0aWYgKCBzaG91bGRDYXB0dXJlICkge1xuICBcdFx0XHRjYXB0dXJlKCB0aGlzICk7XG5cbiAgXHRcdFx0Ly8gbWF5IG5lZWQgdG8gdGVsbCB0aGUgdGFyZ2V0IHRvIHVud3JhcFxuICBcdFx0XHRvcHRzID0gb3B0cyB8fCB7fTtcbiAgXHRcdFx0b3B0cy51bndyYXAgPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy50YXJnZXQuZ2V0KCBmYWxzZSwgb3B0cyApO1xuICBcdH07XG5cbiAgXHRMaW5rTW9kZWwucHJvdG90eXBlLmdldEtleXBhdGggPSBmdW5jdGlvbiBnZXRLZXlwYXRoICggcmFjdGl2ZSApIHtcbiAgXHRcdGlmICggcmFjdGl2ZSAmJiByYWN0aXZlICE9PSB0aGlzLnJvb3QucmFjdGl2ZSApIHJldHVybiB0aGlzLnRhcmdldC5nZXRLZXlwYXRoKCByYWN0aXZlICk7XG5cbiAgXHRcdHJldHVybiBNb2RlbEJhc2UucHJvdG90eXBlLmdldEtleXBhdGguY2FsbCggdGhpcywgcmFjdGl2ZSApO1xuICBcdH07XG5cbiAgXHRMaW5rTW9kZWwucHJvdG90eXBlLmdldEtleXBhdGhNb2RlbCA9IGZ1bmN0aW9uIGdldEtleXBhdGhNb2RlbCAoIHJhY3RpdmUgKSB7XG4gIFx0XHRpZiAoICF0aGlzLmtleXBhdGhNb2RlbCApIHRoaXMua2V5cGF0aE1vZGVsID0gbmV3IEtleXBhdGhNb2RlbCggdGhpcyApO1xuICBcdFx0aWYgKCByYWN0aXZlICYmIHJhY3RpdmUgIT09IHRoaXMucm9vdC5yYWN0aXZlICkgcmV0dXJuIHRoaXMua2V5cGF0aE1vZGVsLmdldENoaWxkKCByYWN0aXZlICk7XG4gIFx0XHRyZXR1cm4gdGhpcy5rZXlwYXRoTW9kZWw7XG4gIFx0fTtcblxuICBcdExpbmtNb2RlbC5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlJDEgKCkge1xuICBcdFx0dGhpcy5kZXBzLmZvckVhY2goIGhhbmRsZUNoYW5nZSApO1xuICBcdFx0dGhpcy5saW5rcy5mb3JFYWNoKCBoYW5kbGVDaGFuZ2UgKTtcbiAgXHRcdHRoaXMubm90aWZ5VXBzdHJlYW0oKTtcbiAgXHR9O1xuXG4gIFx0TGlua01vZGVsLnByb3RvdHlwZS5qb2luS2V5ID0gZnVuY3Rpb24gam9pbktleSAoIGtleSApIHtcbiAgXHRcdC8vIFRPRE86IGhhbmRsZSBuZXN0ZWQgbGlua3NcbiAgXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwga2V5ID09PSAnJyApIHJldHVybiB0aGlzO1xuXG4gIFx0XHRpZiAoICF0aGlzLmNoaWxkQnlLZXkuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuICBcdFx0XHR2YXIgY2hpbGQgPSBuZXcgTGlua01vZGVsKCB0aGlzLCB0aGlzLCB0aGlzLnRhcmdldC5qb2luS2V5KCBrZXkgKSwga2V5ICk7XG4gIFx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggY2hpbGQgKTtcbiAgXHRcdFx0dGhpcy5jaGlsZEJ5S2V5WyBrZXkgXSA9IGNoaWxkO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5jaGlsZEJ5S2V5WyBrZXkgXTtcbiAgXHR9O1xuXG4gIFx0TGlua01vZGVsLnByb3RvdHlwZS5tYXJrID0gZnVuY3Rpb24gbWFyayAoKSB7XG4gIFx0XHR0aGlzLnRhcmdldC5tYXJrKCk7XG4gIFx0fTtcblxuICBcdExpbmtNb2RlbC5wcm90b3R5cGUubWFya2VkID0gZnVuY3Rpb24gbWFya2VkJDEgKCkge1xuICBcdFx0dGhpcy5saW5rcy5mb3JFYWNoKCBtYXJrZWQgKTtcblxuICBcdFx0dGhpcy5kZXBzLmZvckVhY2goIGhhbmRsZUNoYW5nZSApO1xuICBcdFx0dGhpcy5jbGVhclVucmVzb2x2ZWRzKCk7XG4gIFx0fTtcblxuICBcdExpbmtNb2RlbC5wcm90b3R5cGUubm90aWZpZWRVcHN0cmVhbSA9IGZ1bmN0aW9uIG5vdGlmaWVkVXBzdHJlYW0kMSAoKSB7XG4gIFx0XHR0aGlzLmxpbmtzLmZvckVhY2goIG5vdGlmaWVkVXBzdHJlYW0gKTtcbiAgXHRcdHRoaXMuZGVwcy5mb3JFYWNoKCBoYW5kbGVDaGFuZ2UgKTtcbiAgXHR9O1xuXG4gIFx0TGlua01vZGVsLnByb3RvdHlwZS5yZWxpbmtlZCA9IGZ1bmN0aW9uIHJlbGlua2VkICgpIHtcbiAgXHRcdHRoaXMudGFyZ2V0LnJlZ2lzdGVyTGluayggdGhpcyApO1xuICBcdFx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKCBmdW5jdGlvbiAoIGMgKSB7IHJldHVybiBjLnJlbGlua2VkKCk7IH0gKTtcbiAgXHR9O1xuXG4gIFx0TGlua01vZGVsLnByb3RvdHlwZS5yZWxpbmtpbmcgPSBmdW5jdGlvbiByZWxpbmtpbmcgKCB0YXJnZXQsIHJvb3QsIHNhZmUgKSB7XG4gIFx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0aWYgKCByb290ICYmIHRoaXMuc291cmNlUGF0aCApIHRhcmdldCA9IHJlYmluZE1hdGNoKCB0aGlzLnNvdXJjZVBhdGgsIHRhcmdldCwgdGhpcy50YXJnZXQgKTtcbiAgXHRcdGlmICggIXRhcmdldCB8fCB0aGlzLnRhcmdldCA9PT0gdGFyZ2V0ICkgcmV0dXJuO1xuXG4gIFx0XHR0aGlzLnRhcmdldC51bnJlZ2lzdGVyTGluayggdGhpcyApO1xuICBcdFx0aWYgKCB0aGlzLmtleXBhdGhNb2RlbCApIHRoaXMua2V5cGF0aE1vZGVsLnJlYmluZENoaWxkcmVuKCB0YXJnZXQgKTtcblxuICBcdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIFx0XHR0aGlzLmNoaWxkcmVuLmZvckVhY2goIGZ1bmN0aW9uICggYyApIHtcbiAgXHRcdFx0Yy5yZWxpbmtpbmcoIHRhcmdldC5qb2luS2V5KCBjLmtleSApLCBmYWxzZSwgc2FmZSApO1xuICBcdFx0fSk7XG5cbiAgXHRcdGlmICggcm9vdCApIHRoaXMuYWRkU2h1ZmZsZVRhc2soIGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0dGhpcyQxLnJlbGlua2VkKCk7XG4gIFx0XHRcdGlmICggIXNhZmUgKSB0aGlzJDEubm90aWZ5VXBzdHJlYW0oKTtcbiAgXHRcdH0pO1xuICBcdH07XG5cbiAgXHRMaW5rTW9kZWwucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoIHZhbHVlICkge1xuICBcdFx0dGhpcy50YXJnZXQuc2V0KCB2YWx1ZSApO1xuICBcdH07XG5cbiAgXHRMaW5rTW9kZWwucHJvdG90eXBlLnNodWZmbGUgPSBmdW5jdGlvbiBzaHVmZmxlICggbmV3SW5kaWNlcyApIHtcbiAgXHRcdC8vIHdhdGNoIGZvciBleHRyYSBzaHVmZmxlcyBjYXVzZWQgYnkgYSBzaHVmZmxlIGluIGEgZG93bnN0cmVhbSBsaW5rXG4gIFx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0aWYgKCB0aGlzLnNodWZmbGluZyApIHJldHVybjtcblxuICBcdFx0Ly8gbGV0IHRoZSByZWFsIG1vZGVsIGhhbmRsZSBmaXJpbmcgb2ZmIHNodWZmbGVzXG4gIFx0XHRpZiAoICF0aGlzLnRhcmdldC5zaHVmZmxpbmcgKSB7XG4gIFx0XHRcdHRoaXMudGFyZ2V0LnNodWZmbGUoIG5ld0luZGljZXMgKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMuc2h1ZmZsaW5nID0gdHJ1ZTtcblxuICBcdFx0XHR2YXIgaSA9IG5ld0luZGljZXMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdFx0XHR2YXIgaWR4ID0gbmV3SW5kaWNlc1sgaSBdO1xuICBcdFx0XHRcdC8vIG5vdGhpbmcgaXMgYWN0dWFsbHkgY2hhbmdpbmcsIHNvIG1vdmUgaW4gdGhlIGluZGV4IGFuZCByb2xsIG9uXG4gIFx0XHRcdFx0aWYgKCBpID09PSBpZHggKSB7XG4gIFx0XHRcdFx0XHRjb250aW51ZTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyByZWJpbmQgdGhlIGNoaWxkcmVuIG9uIGkgdG8gaWR4XG4gIFx0XHRcdFx0aWYgKCBpIGluIHRoaXMkMS5jaGlsZEJ5S2V5ICkgdGhpcyQxLmNoaWxkQnlLZXlbIGkgXS5yZWJpbmRpbmcoICF+aWR4ID8gdW5kZWZpbmVkIDogdGhpcyQxLmpvaW5LZXkoIGlkeCApLCB0aGlzJDEuY2hpbGRCeUtleVsgaSBdLCB0cnVlICk7XG5cbiAgXHRcdFx0XHRpZiAoICF+aWR4ICYmIHRoaXMkMS5rZXlNb2RlbHNbIGkgXSApIHtcbiAgXHRcdFx0XHRcdHRoaXMkMS5rZXlNb2RlbHNbaV0ucmViaW5kaW5nKCB1bmRlZmluZWQsIHRoaXMkMS5rZXlNb2RlbHNbaV0sIGZhbHNlICk7XG4gIFx0XHRcdFx0fSBlbHNlIGlmICggfmlkeCAmJiB0aGlzJDEua2V5TW9kZWxzWyBpIF0gKSB7XG4gIFx0XHRcdFx0XHRpZiAoICF0aGlzJDEua2V5TW9kZWxzWyBpZHggXSApIHRoaXMkMS5jaGlsZEJ5S2V5WyBpZHggXS5nZXRLZXlNb2RlbCggaWR4ICk7XG4gIFx0XHRcdFx0XHR0aGlzJDEua2V5TW9kZWxzW2ldLnJlYmluZGluZyggdGhpcyQxLmtleU1vZGVsc1sgaWR4IF0sIHRoaXMkMS5rZXlNb2RlbHNbaV0sIGZhbHNlICk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0dmFyIHVwc3RyZWFtID0gdGhpcy5zb3VyY2UoKS5sZW5ndGggIT09IHRoaXMuc291cmNlKCkudmFsdWUubGVuZ3RoO1xuXG4gIFx0XHRcdHRoaXMubGlua3MuZm9yRWFjaCggZnVuY3Rpb24gKCBsICkgeyByZXR1cm4gbC5zaHVmZmxlKCBuZXdJbmRpY2VzICk7IH0gKTtcblxuICBcdFx0XHRpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRcdFx0aWYgKCB0aGlzJDEuZGVwc1tpXS5zaHVmZmxlICkgdGhpcyQxLmRlcHNbaV0uc2h1ZmZsZSggbmV3SW5kaWNlcyApO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5tYXJrZWQoKTtcblxuICBcdFx0XHRpZiAoIHVwc3RyZWFtICkgdGhpcy5ub3RpZnlVcHN0cmVhbSgpO1xuXG4gIFx0XHRcdHRoaXMuc2h1ZmZsaW5nID0gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHR9O1xuXG4gIFx0TGlua01vZGVsLnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UgKCkge1xuICBcdFx0aWYgKCB0aGlzLnRhcmdldC5zb3VyY2UgKSByZXR1cm4gdGhpcy50YXJnZXQuc291cmNlKCk7XG4gIFx0XHRlbHNlIHJldHVybiB0aGlzLnRhcmdldDtcbiAgXHR9O1xuXG4gIFx0TGlua01vZGVsLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duJDEgKCkge1xuICBcdFx0aWYgKCB0aGlzLl9saW5rICkgdGhpcy5fbGluay50ZWFyZG93bigpO1xuICBcdFx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKCB0ZWFyZG93biApO1xuICBcdH07XG5cbiAgXHRyZXR1cm4gTGlua01vZGVsO1xuICB9KE1vZGVsQmFzZSkpO1xuXG4gIE1vZGVsQmFzZS5wcm90b3R5cGUubGluayA9IGZ1bmN0aW9uIGxpbmsgKCBtb2RlbCwga2V5cGF0aCApIHtcbiAgXHR2YXIgbG5rID0gdGhpcy5fbGluayB8fCBuZXcgTGlua01vZGVsKCB0aGlzLnBhcmVudCwgdGhpcywgbW9kZWwsIHRoaXMua2V5ICk7XG4gIFx0bG5rLnNvdXJjZVBhdGggPSBrZXlwYXRoO1xuICBcdGlmICggdGhpcy5fbGluayApIHRoaXMuX2xpbmsucmVsaW5raW5nKCBtb2RlbCwgdHJ1ZSwgZmFsc2UgKTtcbiAgXHR0aGlzLnJlYmluZGluZyggbG5rLCB0aGlzLCBmYWxzZSApO1xuICBcdGZpcmVTaHVmZmxlVGFza3MoKTtcblxuICBcdHZhciB1bnJlc29sdmVkID0gIXRoaXMuX2xpbms7XG4gIFx0dGhpcy5fbGluayA9IGxuaztcbiAgXHRpZiAoIHVucmVzb2x2ZWQgKSB0aGlzLnBhcmVudC5jbGVhclVucmVzb2x2ZWRzKCk7XG4gIFx0bG5rLm1hcmtlZCgpO1xuICBcdHJldHVybiBsbms7XG4gIH07XG5cbiAgTW9kZWxCYXNlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbiB1bmxpbmsgKCkge1xuICBcdGlmICggdGhpcy5fbGluayApIHtcbiAgXHRcdHZhciBsbiA9IHRoaXMuX2xpbms7XG4gIFx0XHR0aGlzLl9saW5rID0gdW5kZWZpbmVkO1xuICBcdFx0bG4ucmViaW5kaW5nKCB0aGlzLCB0aGlzLl9saW5rICk7XG4gIFx0XHRmaXJlU2h1ZmZsZVRhc2tzKCk7XG4gIFx0XHRsbi50ZWFyZG93bigpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG4gIC8vIElmIHdpbmRvdyBkb2Vzbid0IGV4aXN0LCB3ZSBkb24ndCBuZWVkIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICBpZiAoICF3aW4gKSB7XG4gIFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHQvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvMTU3OTY3MVxuICBcdChmdW5jdGlvbih2ZW5kb3JzLCBsYXN0VGltZSwgd2luKSB7XG5cbiAgXHRcdHZhciB4LCBzZXRUaW1lb3V0O1xuXG4gIFx0XHRpZiAoIHdpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Zm9yICggeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luLnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4ICkge1xuICBcdFx0XHR3aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luW3ZlbmRvcnNbeF0rJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoICF3aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuICBcdFx0XHRzZXRUaW1lb3V0ID0gd2luLnNldFRpbWVvdXQ7XG5cbiAgXHRcdFx0d2luLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIFx0XHRcdFx0dmFyIGN1cnJUaW1lLCB0aW1lVG9DYWxsLCBpZDtcblxuICBcdFx0XHRcdGN1cnJUaW1lID0gRGF0ZS5ub3coKTtcbiAgXHRcdFx0XHR0aW1lVG9DYWxsID0gTWF0aC5tYXgoIDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUgKSApO1xuICBcdFx0XHRcdGlkID0gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7IH0sIHRpbWVUb0NhbGwgKTtcblxuICBcdFx0XHRcdGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICBcdFx0XHRcdHJldHVybiBpZDtcbiAgXHRcdFx0fTtcbiAgXHRcdH1cblxuICBcdH0oIHZlbmRvcnMsIDAsIHdpbiApKTtcblxuICBcdHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gIH1cblxuICB2YXIgckFGID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG4gIHZhciBnZXRUaW1lID0gKCB3aW4gJiYgd2luLnBlcmZvcm1hbmNlICYmIHR5cGVvZiB3aW4ucGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nICkgP1xuICBcdGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbi5wZXJmb3JtYW5jZS5ub3coKTsgfSA6XG4gIFx0ZnVuY3Rpb24gKCkgeyByZXR1cm4gRGF0ZS5ub3coKTsgfTtcblxuICAvLyBUT0RPIHdoYXQgaGFwcGVucyBpZiBhIHRyYW5zaXRpb24gaXMgYWJvcnRlZD9cblxuICB2YXIgdGlja2VycyA9IFtdO1xuICB2YXIgcnVubmluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHRpY2sgKCkge1xuICBcdHJ1bmxvb3Auc3RhcnQoKTtcblxuICBcdHZhciBub3cgPSBnZXRUaW1lKCk7XG5cbiAgXHR2YXIgaTtcbiAgXHR2YXIgdGlja2VyO1xuXG4gIFx0Zm9yICggaSA9IDA7IGkgPCB0aWNrZXJzLmxlbmd0aDsgaSArPSAxICkge1xuICBcdFx0dGlja2VyID0gdGlja2Vyc1tpXTtcblxuICBcdFx0aWYgKCAhdGlja2VyLnRpY2soIG5vdyApICkge1xuICBcdFx0XHQvLyB0aWNrZXIgaXMgY29tcGxldGUsIHJlbW92ZSBpdCBmcm9tIHRoZSBzdGFjaywgYW5kIGRlY3JlbWVudCBpIHNvIHdlIGRvbid0IG1pc3Mgb25lXG4gIFx0XHRcdHRpY2tlcnMuc3BsaWNlKCBpLS0sIDEgKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRydW5sb29wLmVuZCgpO1xuXG4gIFx0aWYgKCB0aWNrZXJzLmxlbmd0aCApIHtcbiAgXHRcdHJBRiggdGljayApO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRydW5uaW5nID0gZmFsc2U7XG4gIFx0fVxuICB9XG5cbiAgdmFyIFRpY2tlciA9IGZ1bmN0aW9uIFRpY2tlciAoIG9wdGlvbnMgKSB7XG4gIFx0dGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG4gIFx0dGhpcy5zdGVwID0gb3B0aW9ucy5zdGVwO1xuICBcdHRoaXMuY29tcGxldGUgPSBvcHRpb25zLmNvbXBsZXRlO1xuICBcdHRoaXMuZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG5cbiAgXHR0aGlzLnN0YXJ0ID0gZ2V0VGltZSgpO1xuICBcdHRoaXMuZW5kID0gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XG5cbiAgXHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXG4gIFx0dGlja2Vycy5wdXNoKCB0aGlzICk7XG4gIFx0aWYgKCAhcnVubmluZyApIHJBRiggdGljayApO1xuICB9O1xuXG4gIFRpY2tlci5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uIHRpY2skMSAoIG5vdyApIHtcbiAgXHRpZiAoICF0aGlzLnJ1bm5pbmcgKSByZXR1cm4gZmFsc2U7XG5cbiAgXHRpZiAoIG5vdyA+IHRoaXMuZW5kICkge1xuICBcdFx0aWYgKCB0aGlzLnN0ZXAgKSB0aGlzLnN0ZXAoIDEgKTtcbiAgXHRcdGlmICggdGhpcy5jb21wbGV0ZSApIHRoaXMuY29tcGxldGUoIDEgKTtcblxuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdHZhciBlbGFwc2VkID0gbm93IC0gdGhpcy5zdGFydDtcbiAgXHR2YXIgZWFzZWQgPSB0aGlzLmVhc2luZyggZWxhcHNlZCAvIHRoaXMuZHVyYXRpb24gKTtcblxuICBcdGlmICggdGhpcy5zdGVwICkgdGhpcy5zdGVwKCBlYXNlZCApO1xuXG4gIFx0cmV0dXJuIHRydWU7XG4gIH07XG5cbiAgVGlja2VyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gc3RvcCAoKSB7XG4gIFx0aWYgKCB0aGlzLmFib3J0ICkgdGhpcy5hYm9ydCgpO1xuICBcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBwcmVmaXhlcnMgPSB7fTtcblxuICAvLyBUT0RPIHRoaXMgaXMgbGVnYWN5LiBzb29uZXIgd2UgY2FuIHJlcGxhY2UgdGhlIG9sZCBhZGFwdG9yIEFQSSB0aGUgYmV0dGVyXG4gIGZ1bmN0aW9uIHByZWZpeEtleXBhdGggKCBvYmosIHByZWZpeCApIHtcbiAgXHR2YXIgcHJlZml4ZWQgPSB7fSwga2V5O1xuXG4gIFx0aWYgKCAhcHJlZml4ICkge1xuICBcdFx0cmV0dXJuIG9iajtcbiAgXHR9XG5cbiAgXHRwcmVmaXggKz0gJy4nO1xuXG4gIFx0Zm9yICgga2V5IGluIG9iaiApIHtcbiAgXHRcdGlmICggb2JqLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcbiAgXHRcdFx0cHJlZml4ZWRbIHByZWZpeCArIGtleSBdID0gb2JqWyBrZXkgXTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gcHJlZml4ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcmVmaXhlciAoIHJvb3RLZXlwYXRoICkge1xuICBcdHZhciByb290RG90O1xuXG4gIFx0aWYgKCAhcHJlZml4ZXJzWyByb290S2V5cGF0aCBdICkge1xuICBcdFx0cm9vdERvdCA9IHJvb3RLZXlwYXRoID8gcm9vdEtleXBhdGggKyAnLicgOiAnJztcblxuICBcdFx0cHJlZml4ZXJzWyByb290S2V5cGF0aCBdID0gZnVuY3Rpb24gKCByZWxhdGl2ZUtleXBhdGgsIHZhbHVlICkge1xuICBcdFx0XHR2YXIgb2JqO1xuXG4gIFx0XHRcdGlmICggdHlwZW9mIHJlbGF0aXZlS2V5cGF0aCA9PT0gJ3N0cmluZycgKSB7XG4gIFx0XHRcdFx0b2JqID0ge307XG4gIFx0XHRcdFx0b2JqWyByb290RG90ICsgcmVsYXRpdmVLZXlwYXRoIF0gPSB2YWx1ZTtcbiAgXHRcdFx0XHRyZXR1cm4gb2JqO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCB0eXBlb2YgcmVsYXRpdmVLZXlwYXRoID09PSAnb2JqZWN0JyApIHtcbiAgXHRcdFx0XHQvLyAncmVsYXRpdmVLZXlwYXRoJyBpcyBpbiBmYWN0IGEgaGFzaCwgbm90IGEga2V5cGF0aFxuICBcdFx0XHRcdHJldHVybiByb290RG90ID8gcHJlZml4S2V5cGF0aCggcmVsYXRpdmVLZXlwYXRoLCByb290S2V5cGF0aCApIDogcmVsYXRpdmVLZXlwYXRoO1xuICBcdFx0XHR9XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBwcmVmaXhlcnNbIHJvb3RLZXlwYXRoIF07XG4gIH1cblxuICB2YXIgTW9kZWwgPSAoZnVuY3Rpb24gKE1vZGVsQmFzZSkge1xuICBcdGZ1bmN0aW9uIE1vZGVsICggcGFyZW50LCBrZXkgKSB7XG4gIFx0XHRNb2RlbEJhc2UuY2FsbCggdGhpcywgcGFyZW50ICk7XG5cbiAgXHRcdHRoaXMudGlja2VyID0gbnVsbDtcblxuICBcdFx0aWYgKCBwYXJlbnQgKSB7XG4gIFx0XHRcdHRoaXMua2V5ID0gdW5lc2NhcGVLZXkoIGtleSApO1xuICBcdFx0XHR0aGlzLmlzUmVhZG9ubHkgPSBwYXJlbnQuaXNSZWFkb25seTtcblxuICBcdFx0XHRpZiAoIHBhcmVudC52YWx1ZSApIHtcbiAgXHRcdFx0XHR0aGlzLnZhbHVlID0gcGFyZW50LnZhbHVlWyB0aGlzLmtleSBdO1xuICBcdFx0XHRcdGlmICggaXNBcnJheSggdGhpcy52YWx1ZSApICkgdGhpcy5sZW5ndGggPSB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgXHRcdFx0XHR0aGlzLmFkYXB0KCk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRNb2RlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNb2RlbEJhc2UgJiYgTW9kZWxCYXNlLnByb3RvdHlwZSApO1xuICBcdE1vZGVsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vZGVsO1xuXG4gIFx0TW9kZWwucHJvdG90eXBlLmFkYXB0ID0gZnVuY3Rpb24gYWRhcHQgKCkge1xuICBcdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHZhciBhZGFwdG9ycyA9IHRoaXMucm9vdC5hZGFwdG9ycztcbiAgXHRcdHZhciBsZW4gPSBhZGFwdG9ycy5sZW5ndGg7XG5cbiAgXHRcdHRoaXMucmV3cmFwID0gZmFsc2U7XG5cbiAgXHRcdC8vIEV4aXQgZWFybHkgaWYgbm8gYWRhcHRvcnNcbiAgXHRcdGlmICggbGVuID09PSAwICkgcmV0dXJuO1xuXG4gIFx0XHR2YXIgdmFsdWUgPSB0aGlzLndyYXBwZXIgPyAoICduZXdXcmFwcGVyVmFsdWUnIGluIHRoaXMgPyB0aGlzLm5ld1dyYXBwZXJWYWx1ZSA6IHRoaXMud3JhcHBlclZhbHVlICkgOiB0aGlzLnZhbHVlO1xuXG4gIFx0XHQvLyBUT0RPIHJlbW92ZSB0aGlzIGxlZ2FjeSBub25zZW5zZVxuICBcdFx0dmFyIHJhY3RpdmUgPSB0aGlzLnJvb3QucmFjdGl2ZTtcbiAgXHRcdHZhciBrZXlwYXRoID0gdGhpcy5nZXRLZXlwYXRoKCk7XG5cbiAgXHRcdC8vIHRlYXIgcHJldmlvdXMgYWRhcHRvciBkb3duIGlmIHByZXNlbnRcbiAgXHRcdGlmICggdGhpcy53cmFwcGVyICkge1xuICBcdFx0XHR2YXIgc2hvdWxkVGVhcmRvd24gPSB0aGlzLndyYXBwZXJWYWx1ZSA9PT0gdmFsdWUgPyBmYWxzZSA6ICF0aGlzLndyYXBwZXIucmVzZXQgfHwgdGhpcy53cmFwcGVyLnJlc2V0KCB2YWx1ZSApID09PSBmYWxzZTtcblxuICBcdFx0XHRpZiAoIHNob3VsZFRlYXJkb3duICkge1xuICBcdFx0XHRcdHRoaXMud3JhcHBlci50ZWFyZG93bigpO1xuICBcdFx0XHRcdHRoaXMud3JhcHBlciA9IG51bGw7XG5cbiAgXHRcdFx0XHQvLyBkb24ndCBicmFuY2ggZm9yIHVuZGVmaW5lZCB2YWx1ZXNcbiAgXHRcdFx0XHRpZiAoIHRoaXMudmFsdWUgIT09IHVuZGVmaW5lZCApIHtcbiAgXHRcdFx0XHRcdHZhciBwYXJlbnRWYWx1ZSA9IHRoaXMucGFyZW50LnZhbHVlIHx8IHRoaXMucGFyZW50LmNyZWF0ZUJyYW5jaCggdGhpcy5rZXkgKTtcbiAgXHRcdFx0XHRcdGlmICggcGFyZW50VmFsdWVbIHRoaXMua2V5IF0gIT09IHZhbHVlICkgcGFyZW50VmFsdWVbIHRoaXMua2V5IF0gPSB2YWx1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0ZGVsZXRlIHRoaXMubmV3V3JhcHBlclZhbHVlO1xuICBcdFx0XHRcdHRoaXMud3JhcHBlclZhbHVlID0gdmFsdWU7XG4gIFx0XHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMud3JhcHBlci5nZXQoKTtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dmFyIGk7XG5cbiAgXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG4gIFx0XHRcdHZhciBhZGFwdG9yID0gYWRhcHRvcnNbaV07XG4gIFx0XHRcdGlmICggYWRhcHRvci5maWx0ZXIoIHZhbHVlLCBrZXlwYXRoLCByYWN0aXZlICkgKSB7XG4gIFx0XHRcdFx0dGhpcyQxLndyYXBwZXIgPSBhZGFwdG9yLndyYXAoIHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoLCBnZXRQcmVmaXhlcigga2V5cGF0aCApICk7XG4gIFx0XHRcdFx0dGhpcyQxLndyYXBwZXJWYWx1ZSA9IHZhbHVlO1xuICBcdFx0XHRcdHRoaXMkMS53cmFwcGVyLl9fbW9kZWwgPSB0aGlzJDE7IC8vIG1hc3NpdmUgdGVtcG9yYXJ5IGhhY2sgdG8gZW5hYmxlIGFycmF5IGFkYXB0b3JcblxuICBcdFx0XHRcdHRoaXMkMS52YWx1ZSA9IHRoaXMkMS53cmFwcGVyLmdldCgpO1xuXG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0TW9kZWwucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiBhbmltYXRlICggZnJvbSwgdG8sIG9wdGlvbnMsIGludGVycG9sYXRvciApIHtcbiAgXHRcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHRpZiAoIHRoaXMudGlja2VyICkgdGhpcy50aWNrZXIuc3RvcCgpO1xuXG4gIFx0XHR2YXIgZnVsZmlsUHJvbWlzZTtcbiAgXHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMSggZnVuY3Rpb24gKCBmdWxmaWwgKSB7IHJldHVybiBmdWxmaWxQcm9taXNlID0gZnVsZmlsOyB9ICk7XG5cbiAgXHRcdHRoaXMudGlja2VyID0gbmV3IFRpY2tlcih7XG4gIFx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICBcdFx0XHRlYXNpbmc6IG9wdGlvbnMuZWFzaW5nLFxuICBcdFx0XHRzdGVwOiBmdW5jdGlvbiAoIHQgKSB7XG4gIFx0XHRcdFx0dmFyIHZhbHVlID0gaW50ZXJwb2xhdG9yKCB0ICk7XG4gIFx0XHRcdFx0dGhpcyQxLmFwcGx5VmFsdWUoIHZhbHVlICk7XG4gIFx0XHRcdFx0aWYgKCBvcHRpb25zLnN0ZXAgKSBvcHRpb25zLnN0ZXAoIHQsIHZhbHVlICk7XG4gIFx0XHRcdH0sXG4gIFx0XHRcdGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0dGhpcyQxLmFwcGx5VmFsdWUoIHRvICk7XG4gIFx0XHRcdFx0aWYgKCBvcHRpb25zLmNvbXBsZXRlICkgb3B0aW9ucy5jb21wbGV0ZSggdG8gKTtcblxuICBcdFx0XHRcdHRoaXMkMS50aWNrZXIgPSBudWxsO1xuICBcdFx0XHRcdGZ1bGZpbFByb21pc2UoKTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG5cbiAgXHRcdHByb21pc2Uuc3RvcCA9IHRoaXMudGlja2VyLnN0b3A7XG4gIFx0XHRyZXR1cm4gcHJvbWlzZTtcbiAgXHR9O1xuXG4gIFx0TW9kZWwucHJvdG90eXBlLmFwcGx5VmFsdWUgPSBmdW5jdGlvbiBhcHBseVZhbHVlICggdmFsdWUgKSB7XG4gIFx0XHRpZiAoIGlzRXF1YWwoIHZhbHVlLCB0aGlzLnZhbHVlICkgKSByZXR1cm47XG5cbiAgXHRcdC8vIFRPRE8gZGVwcmVjYXRlIHRoaXMgbm9uc2Vuc2VcbiAgXHRcdHRoaXMucmVnaXN0ZXJDaGFuZ2UoIHRoaXMuZ2V0S2V5cGF0aCgpLCB2YWx1ZSApO1xuXG4gIFx0XHRpZiAoIHRoaXMucGFyZW50LndyYXBwZXIgJiYgdGhpcy5wYXJlbnQud3JhcHBlci5zZXQgKSB7XG4gIFx0XHRcdHRoaXMucGFyZW50LndyYXBwZXIuc2V0KCB0aGlzLmtleSwgdmFsdWUgKTtcbiAgXHRcdFx0dGhpcy5wYXJlbnQudmFsdWUgPSB0aGlzLnBhcmVudC53cmFwcGVyLmdldCgpO1xuXG4gIFx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLnBhcmVudC52YWx1ZVsgdGhpcy5rZXkgXTtcbiAgXHRcdFx0aWYgKCB0aGlzLndyYXBwZXIgKSB0aGlzLm5ld1dyYXBwZXJWYWx1ZSA9IHRoaXMudmFsdWU7XG4gIFx0XHRcdHRoaXMuYWRhcHQoKTtcbiAgXHRcdH0gZWxzZSBpZiAoIHRoaXMud3JhcHBlciApIHtcbiAgXHRcdFx0dGhpcy5uZXdXcmFwcGVyVmFsdWUgPSB2YWx1ZTtcbiAgXHRcdFx0dGhpcy5hZGFwdCgpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dmFyIHBhcmVudFZhbHVlID0gdGhpcy5wYXJlbnQudmFsdWUgfHwgdGhpcy5wYXJlbnQuY3JlYXRlQnJhbmNoKCB0aGlzLmtleSApO1xuICBcdFx0XHRwYXJlbnRWYWx1ZVsgdGhpcy5rZXkgXSA9IHZhbHVlO1xuXG4gIFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdFx0dGhpcy5hZGFwdCgpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnBhcmVudC5jbGVhclVucmVzb2x2ZWRzKCk7XG4gIFx0XHR0aGlzLmNsZWFyVW5yZXNvbHZlZHMoKTtcblxuICBcdFx0Ly8ga2VlcCB0cmFjayBvZiBhcnJheSBsZW5ndGhcbiAgXHRcdGlmICggaXNBcnJheSggdmFsdWUgKSApIHRoaXMubGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXG4gIFx0XHQvLyBub3RpZnkgZGVwZW5kYW50c1xuICBcdFx0dGhpcy5saW5rcy5mb3JFYWNoKCBoYW5kbGVDaGFuZ2UgKTtcbiAgXHRcdHRoaXMuY2hpbGRyZW4uZm9yRWFjaCggbWFyayApO1xuICBcdFx0dGhpcy5kZXBzLmZvckVhY2goIGhhbmRsZUNoYW5nZSApO1xuXG4gIFx0XHR0aGlzLm5vdGlmeVVwc3RyZWFtKCk7XG5cbiAgXHRcdGlmICggdGhpcy5rZXkgPT09ICdsZW5ndGgnICYmIGlzQXJyYXkoIHRoaXMucGFyZW50LnZhbHVlICkgKSB0aGlzLnBhcmVudC5sZW5ndGggPSB0aGlzLnBhcmVudC52YWx1ZS5sZW5ndGg7XG4gIFx0fTtcblxuICBcdE1vZGVsLnByb3RvdHlwZS5jcmVhdGVCcmFuY2ggPSBmdW5jdGlvbiBjcmVhdGVCcmFuY2ggKCBrZXkgKSB7XG4gIFx0XHR2YXIgYnJhbmNoID0gaXNOdW1lcmljKCBrZXkgKSA/IFtdIDoge307XG4gIFx0XHR0aGlzLnNldCggYnJhbmNoICk7XG5cbiAgXHRcdHJldHVybiBicmFuY2g7XG4gIFx0fTtcblxuICBcdE1vZGVsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCBzaG91bGRDYXB0dXJlLCBvcHRzICkge1xuICBcdFx0aWYgKCB0aGlzLl9saW5rICkgcmV0dXJuIHRoaXMuX2xpbmsuZ2V0KCBzaG91bGRDYXB0dXJlLCBvcHRzICk7XG4gIFx0XHRpZiAoIHNob3VsZENhcHR1cmUgKSBjYXB0dXJlKCB0aGlzICk7XG4gIFx0XHQvLyBpZiBjYXB0dXJpbmcsIHRoaXMgdmFsdWUgbmVlZHMgdG8gYmUgdW53cmFwcGVkIGJlY2F1c2UgaXQncyBmb3IgZXh0ZXJuYWwgdXNlXG4gIFx0XHRpZiAoIG9wdHMgJiYgb3B0cy52aXJ0dWFsICkgcmV0dXJuIHRoaXMuZ2V0VmlydHVhbCggZmFsc2UgKTtcbiAgXHRcdHJldHVybiAoIHNob3VsZENhcHR1cmUgfHwgKCBvcHRzICYmIG9wdHMudW53cmFwICkgKSAmJiB0aGlzLndyYXBwZXIgPyB0aGlzLndyYXBwZXJWYWx1ZSA6IHRoaXMudmFsdWU7XG4gIFx0fTtcblxuICBcdE1vZGVsLnByb3RvdHlwZS5nZXRLZXlwYXRoTW9kZWwgPSBmdW5jdGlvbiBnZXRLZXlwYXRoTW9kZWwgKCByYWN0aXZlICkge1xuICBcdFx0aWYgKCAhdGhpcy5rZXlwYXRoTW9kZWwgKSB0aGlzLmtleXBhdGhNb2RlbCA9IG5ldyBLZXlwYXRoTW9kZWwoIHRoaXMgKTtcbiAgXHRcdHJldHVybiB0aGlzLmtleXBhdGhNb2RlbDtcbiAgXHR9O1xuXG4gIFx0TW9kZWwucHJvdG90eXBlLmpvaW5LZXkgPSBmdW5jdGlvbiBqb2luS2V5ICgga2V5LCBvcHRzICkge1xuICBcdFx0aWYgKCB0aGlzLl9saW5rICkge1xuICBcdFx0XHRpZiAoIG9wdHMgJiYgIW9wdHMubGFzdExpbmsgPT09IGZhbHNlICYmICgga2V5ID09PSB1bmRlZmluZWQgfHwga2V5ID09PSAnJyApICkgcmV0dXJuIHRoaXM7XG4gIFx0XHRcdHJldHVybiB0aGlzLl9saW5rLmpvaW5LZXkoIGtleSApO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gJycgKSByZXR1cm4gdGhpcztcblxuXG4gIFx0XHRpZiAoICF0aGlzLmNoaWxkQnlLZXkuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuICBcdFx0XHR2YXIgY2hpbGQgPSBuZXcgTW9kZWwoIHRoaXMsIGtleSApO1xuICBcdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goIGNoaWxkICk7XG4gIFx0XHRcdHRoaXMuY2hpbGRCeUtleVsga2V5IF0gPSBjaGlsZDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCB0aGlzLmNoaWxkQnlLZXlbIGtleSBdLl9saW5rICkgcmV0dXJuIHRoaXMuY2hpbGRCeUtleVsga2V5IF0uX2xpbms7XG4gIFx0XHRyZXR1cm4gdGhpcy5jaGlsZEJ5S2V5WyBrZXkgXTtcbiAgXHR9O1xuXG4gIFx0TW9kZWwucHJvdG90eXBlLm1hcmsgPSBmdW5jdGlvbiBtYXJrJDEgKCkge1xuICBcdFx0aWYgKCB0aGlzLl9saW5rICkgcmV0dXJuIHRoaXMuX2xpbmsubWFyaygpO1xuXG4gIFx0XHR2YXIgdmFsdWUgPSB0aGlzLnJldHJpZXZlKCk7XG5cbiAgXHRcdGlmICggIWlzRXF1YWwoIHZhbHVlLCB0aGlzLnZhbHVlICkgKSB7XG4gIFx0XHRcdHZhciBvbGQgPSB0aGlzLnZhbHVlO1xuICBcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdFx0Ly8gbWFrZSBzdXJlIHRoZSB3cmFwcGVyIHN0YXlzIGluIHN5bmNcbiAgXHRcdFx0aWYgKCBvbGQgIT09IHZhbHVlIHx8IHRoaXMucmV3cmFwICkge1xuICBcdFx0XHRcdGlmICggdGhpcy53cmFwcGVyICkgdGhpcy5uZXdXcmFwcGVyVmFsdWUgPSB2YWx1ZTtcbiAgXHRcdFx0XHR0aGlzLmFkYXB0KCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBrZWVwIHRyYWNrIG9mIGFycmF5IGxlbmd0aHNcbiAgXHRcdFx0aWYgKCBpc0FycmF5KCB2YWx1ZSApICkgdGhpcy5sZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgXHRcdFx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKCBtYXJrICk7XG4gIFx0XHRcdHRoaXMubGlua3MuZm9yRWFjaCggbWFya2VkICk7XG5cbiAgXHRcdFx0dGhpcy5kZXBzLmZvckVhY2goIGhhbmRsZUNoYW5nZSApO1xuICBcdFx0XHR0aGlzLmNsZWFyVW5yZXNvbHZlZHMoKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0TW9kZWwucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2UgKCBhcnJheSwgY29tcGFyYXRvciApIHtcbiAgXHRcdHZhciBvbGRBcnJheSA9IHRoaXMudmFsdWUsIG5ld0FycmF5ID0gYXJyYXk7XG4gIFx0XHRpZiAoIG9sZEFycmF5ID09PSBuZXdBcnJheSApIG9sZEFycmF5ID0gcmVjcmVhdGVBcnJheSggdGhpcyApO1xuICBcdFx0aWYgKCBjb21wYXJhdG9yICkge1xuICBcdFx0XHRvbGRBcnJheSA9IG9sZEFycmF5Lm1hcCggY29tcGFyYXRvciApO1xuICBcdFx0XHRuZXdBcnJheSA9IG5ld0FycmF5Lm1hcCggY29tcGFyYXRvciApO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgb2xkTGVuZ3RoID0gb2xkQXJyYXkubGVuZ3RoO1xuXG4gIFx0XHR2YXIgdXNlZEluZGljZXMgPSB7fTtcbiAgXHRcdHZhciBmaXJzdFVudXNlZEluZGV4ID0gMDtcblxuICBcdFx0dmFyIG5ld0luZGljZXMgPSBvbGRBcnJheS5tYXAoIGZ1bmN0aW9uICggaXRlbSApIHtcbiAgXHRcdFx0dmFyIGluZGV4O1xuICBcdFx0XHR2YXIgc3RhcnQgPSBmaXJzdFVudXNlZEluZGV4O1xuXG4gIFx0XHRcdGRvIHtcbiAgXHRcdFx0XHRpbmRleCA9IG5ld0FycmF5LmluZGV4T2YoIGl0ZW0sIHN0YXJ0ICk7XG5cbiAgXHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcbiAgXHRcdFx0XHRcdHJldHVybiAtMTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRzdGFydCA9IGluZGV4ICsgMTtcbiAgXHRcdFx0fSB3aGlsZSAoICggdXNlZEluZGljZXNbIGluZGV4IF0gPT09IHRydWUgKSAmJiBzdGFydCA8IG9sZExlbmd0aCApO1xuXG4gIFx0XHRcdC8vIGtlZXAgdHJhY2sgb2YgdGhlIGZpcnN0IHVudXNlZCBpbmRleCwgc28gd2UgZG9uJ3Qgc2VhcmNoXG4gIFx0XHRcdC8vIHRoZSB3aG9sZSBvZiBuZXdBcnJheSBmb3IgZWFjaCBpdGVtIGluIG9sZEFycmF5IHVubmVjZXNzYXJpbHlcbiAgXHRcdFx0aWYgKCBpbmRleCA9PT0gZmlyc3RVbnVzZWRJbmRleCApIHtcbiAgXHRcdFx0XHRmaXJzdFVudXNlZEluZGV4ICs9IDE7XG4gIFx0XHRcdH1cbiAgXHRcdFx0Ly8gYWxsb3cgbmV4dCBpbnN0YW5jZSBvZiBuZXh0IFwiZXF1YWxcIiB0byBiZSBmb3VuZCBpdGVtXG4gIFx0XHRcdHVzZWRJbmRpY2VzWyBpbmRleCBdID0gdHJ1ZTtcbiAgXHRcdFx0cmV0dXJuIGluZGV4O1xuICBcdFx0fSk7XG5cbiAgXHRcdHRoaXMucGFyZW50LnZhbHVlWyB0aGlzLmtleSBdID0gYXJyYXk7XG4gIFx0XHR0aGlzLnNodWZmbGUoIG5ld0luZGljZXMgKTtcbiAgXHR9O1xuXG4gIFx0TW9kZWwucHJvdG90eXBlLnJldHJpZXZlID0gZnVuY3Rpb24gcmV0cmlldmUgKCkge1xuICBcdFx0cmV0dXJuIHRoaXMucGFyZW50LnZhbHVlID8gdGhpcy5wYXJlbnQudmFsdWVbIHRoaXMua2V5IF0gOiB1bmRlZmluZWQ7XG4gIFx0fTtcblxuICBcdE1vZGVsLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKCB2YWx1ZSApIHtcbiAgXHRcdGlmICggdGhpcy50aWNrZXIgKSB0aGlzLnRpY2tlci5zdG9wKCk7XG4gIFx0XHR0aGlzLmFwcGx5VmFsdWUoIHZhbHVlICk7XG4gIFx0fTtcblxuICBcdE1vZGVsLnByb3RvdHlwZS5zaHVmZmxlID0gZnVuY3Rpb24gc2h1ZmZsZSAoIG5ld0luZGljZXMgKSB7XG4gIFx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dGhpcy5zaHVmZmxpbmcgPSB0cnVlO1xuICBcdFx0dmFyIGkgPSBuZXdJbmRpY2VzLmxlbmd0aDtcbiAgXHRcdHdoaWxlICggaS0tICkge1xuICBcdFx0XHR2YXIgaWR4ID0gbmV3SW5kaWNlc1sgaSBdO1xuICBcdFx0XHQvLyBub3RoaW5nIGlzIGFjdHVhbGx5IGNoYW5naW5nLCBzbyBtb3ZlIGluIHRoZSBpbmRleCBhbmQgcm9sbCBvblxuICBcdFx0XHRpZiAoIGkgPT09IGlkeCApIHtcbiAgXHRcdFx0XHRjb250aW51ZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIHJlYmluZCB0aGUgY2hpbGRyZW4gb24gaSB0byBpZHhcbiAgXHRcdFx0aWYgKCBpIGluIHRoaXMkMS5jaGlsZEJ5S2V5ICkgdGhpcyQxLmNoaWxkQnlLZXlbIGkgXS5yZWJpbmRpbmcoICF+aWR4ID8gdW5kZWZpbmVkIDogdGhpcyQxLmpvaW5LZXkoIGlkeCApLCB0aGlzJDEuY2hpbGRCeUtleVsgaSBdLCB0cnVlICk7XG5cbiAgXHRcdFx0aWYgKCAhfmlkeCAmJiB0aGlzJDEua2V5TW9kZWxzWyBpIF0gKSB7XG4gIFx0XHRcdFx0dGhpcyQxLmtleU1vZGVsc1tpXS5yZWJpbmRpbmcoIHVuZGVmaW5lZCwgdGhpcyQxLmtleU1vZGVsc1tpXSwgZmFsc2UgKTtcbiAgXHRcdFx0fSBlbHNlIGlmICggfmlkeCAmJiB0aGlzJDEua2V5TW9kZWxzWyBpIF0gKSB7XG4gIFx0XHRcdFx0aWYgKCAhdGhpcyQxLmtleU1vZGVsc1sgaWR4IF0gKSB0aGlzJDEuY2hpbGRCeUtleVsgaWR4IF0uZ2V0S2V5TW9kZWwoIGlkeCApO1xuICBcdFx0XHRcdHRoaXMkMS5rZXlNb2RlbHNbaV0ucmViaW5kaW5nKCB0aGlzJDEua2V5TW9kZWxzWyBpZHggXSwgdGhpcyQxLmtleU1vZGVsc1tpXSwgZmFsc2UgKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR2YXIgdXBzdHJlYW0gPSB0aGlzLmxlbmd0aCAhPT0gdGhpcy52YWx1ZS5sZW5ndGg7XG5cbiAgXHRcdHRoaXMubGlua3MuZm9yRWFjaCggZnVuY3Rpb24gKCBsICkgeyByZXR1cm4gbC5zaHVmZmxlKCBuZXdJbmRpY2VzICk7IH0gKTtcbiAgXHRcdGZpcmVTaHVmZmxlVGFza3MoICdlYXJseScgKTtcblxuICBcdFx0aSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdFx0aWYgKCB0aGlzJDEuZGVwc1tpXS5zaHVmZmxlICkgdGhpcyQxLmRlcHNbaV0uc2h1ZmZsZSggbmV3SW5kaWNlcyApO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLm1hcmsoKTtcbiAgXHRcdGZpcmVTaHVmZmxlVGFza3MoICdtYXJrJyApO1xuXG4gIFx0XHRpZiAoIHVwc3RyZWFtICkgdGhpcy5ub3RpZnlVcHN0cmVhbSgpO1xuICBcdFx0dGhpcy5zaHVmZmxpbmcgPSBmYWxzZTtcbiAgXHR9O1xuXG4gIFx0TW9kZWwucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24kMSAoKSB7XG4gIFx0XHRpZiAoIHRoaXMuX2xpbmsgKSB0aGlzLl9saW5rLnRlYXJkb3duKCk7XG4gIFx0XHR0aGlzLmNoaWxkcmVuLmZvckVhY2goIHRlYXJkb3duICk7XG4gIFx0XHRpZiAoIHRoaXMud3JhcHBlciApIHRoaXMud3JhcHBlci50ZWFyZG93bigpO1xuICBcdFx0aWYgKCB0aGlzLmtleXBhdGhNb2RlbCApIHRoaXMua2V5cGF0aE1vZGVsLnRlYXJkb3duKCk7XG4gIFx0fTtcblxuICBcdHJldHVybiBNb2RlbDtcbiAgfShNb2RlbEJhc2UpKTtcblxuICBmdW5jdGlvbiByZWNyZWF0ZUFycmF5KCBtb2RlbCApIHtcbiAgXHR2YXIgYXJyYXkgPSBbXTtcblxuICBcdGZvciAoIHZhciBpID0gMDsgaSA8IG1vZGVsLmxlbmd0aDsgaSsrICkge1xuICBcdFx0YXJyYXlbIGkgXSA9IChtb2RlbC5jaGlsZEJ5S2V5W2ldIHx8IHt9KS52YWx1ZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gYXJyYXk7XG4gIH1cblxuICB2YXIgR2xvYmFsTW9kZWwgPSAoZnVuY3Rpb24gKE1vZGVsKSB7XG4gIFx0ZnVuY3Rpb24gR2xvYmFsTW9kZWwgKCApIHtcbiAgXHRcdE1vZGVsLmNhbGwoIHRoaXMsIG51bGwsICdAZ2xvYmFsJyApO1xuICBcdFx0dGhpcy52YWx1ZSA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93O1xuICBcdFx0dGhpcy5pc1Jvb3QgPSB0cnVlO1xuICBcdFx0dGhpcy5yb290ID0gdGhpcztcbiAgXHRcdHRoaXMuYWRhcHRvcnMgPSBbXTtcbiAgXHR9XG5cbiAgXHRHbG9iYWxNb2RlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNb2RlbCAmJiBNb2RlbC5wcm90b3R5cGUgKTtcbiAgXHRHbG9iYWxNb2RlbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHbG9iYWxNb2RlbDtcblxuICBcdEdsb2JhbE1vZGVsLnByb3RvdHlwZS5nZXRLZXlwYXRoID0gZnVuY3Rpb24gZ2V0S2V5cGF0aCgpIHtcbiAgXHRcdHJldHVybiAnQGdsb2JhbCc7XG4gIFx0fTtcblxuICBcdC8vIGdsb2JhbCBtb2RlbCBkb2Vzbid0IGNvbnRyaWJ1dGUgY2hhbmdlcyBldmVudHMgYmVjYXVzZSBpdCBoYXMgbm8gaW5zdGFuY2VcbiAgXHRHbG9iYWxNb2RlbC5wcm90b3R5cGUucmVnaXN0ZXJDaGFuZ2UgPSBmdW5jdGlvbiByZWdpc3RlckNoYW5nZSAoKSB7fTtcblxuICBcdHJldHVybiBHbG9iYWxNb2RlbDtcbiAgfShNb2RlbCkpO1xuXG4gIHZhciBHbG9iYWxNb2RlbCQxID0gbmV3IEdsb2JhbE1vZGVsKCk7XG5cbiAgdmFyIGtleXBhdGhFeHByID0gL15AW15cXChdK1xcKChbXlxcKV0rKVxcKS87XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVJlZmVyZW5jZSAoIGZyYWdtZW50LCByZWYgKSB7XG4gIFx0dmFyIGNvbnRleHQgPSBmcmFnbWVudC5maW5kQ29udGV4dCgpO1xuXG4gIFx0Ly8gc3BlY2lhbCByZWZlcmVuY2VzXG4gIFx0Ly8gVE9ETyBkb2VzIGB0aGlzYCBiZWNvbWUgYC5gIGF0IHBhcnNlIHRpbWU/XG4gIFx0aWYgKCByZWYgPT09ICcuJyB8fCByZWYgPT09ICd0aGlzJyApIHJldHVybiBjb250ZXh0O1xuICBcdGlmICggcmVmLmluZGV4T2YoICdAa2V5cGF0aCcgKSA9PT0gMCApIHtcbiAgXHRcdHZhciBtYXRjaCA9IGtleXBhdGhFeHByLmV4ZWMoIHJlZiApO1xuICBcdFx0aWYgKCBtYXRjaCAmJiBtYXRjaFsxXSApIHtcbiAgXHRcdFx0dmFyIG1vZGVsID0gcmVzb2x2ZVJlZmVyZW5jZSggZnJhZ21lbnQsIG1hdGNoWzFdICk7XG4gIFx0XHRcdGlmICggbW9kZWwgKSByZXR1cm4gbW9kZWwuZ2V0S2V5cGF0aE1vZGVsKCk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gY29udGV4dC5nZXRLZXlwYXRoTW9kZWwoKTtcbiAgXHR9XG4gIFx0aWYgKCByZWYuaW5kZXhPZiggJ0Byb290cGF0aCcgKSA9PT0gMCApIHtcbiAgXHRcdC8vIGNoZWNrIHRvIHNlZSBpZiB0aGlzIGlzIGFuIGVtcHR5IGNvbXBvbmVudCByb290XG4gIFx0XHR3aGlsZSAoIGNvbnRleHQuaXNSb290ICYmIGNvbnRleHQucmFjdGl2ZS5jb21wb25lbnQgKSB7XG4gIFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnJhY3RpdmUuY29tcG9uZW50LnBhcmVudEZyYWdtZW50LmZpbmRDb250ZXh0KCk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBtYXRjaCQxID0ga2V5cGF0aEV4cHIuZXhlYyggcmVmICk7XG4gIFx0XHRpZiAoIG1hdGNoJDEgJiYgbWF0Y2gkMVsxXSApIHtcbiAgXHRcdFx0dmFyIG1vZGVsJDEgPSByZXNvbHZlUmVmZXJlbmNlKCBmcmFnbWVudCwgbWF0Y2gkMVsxXSApO1xuICBcdFx0XHRpZiAoIG1vZGVsJDEgKSByZXR1cm4gbW9kZWwkMS5nZXRLZXlwYXRoTW9kZWwoIGZyYWdtZW50LnJhY3RpdmUucm9vdCApO1xuICBcdFx0fVxuICBcdFx0cmV0dXJuIGNvbnRleHQuZ2V0S2V5cGF0aE1vZGVsKCBmcmFnbWVudC5yYWN0aXZlLnJvb3QgKTtcbiAgXHR9XG4gIFx0aWYgKCByZWYgPT09ICdAaW5kZXgnIHx8IHJlZiA9PT0gJ0BrZXknICkge1xuICBcdFx0dmFyIHJlcGVhdGVyID0gZnJhZ21lbnQuZmluZFJlcGVhdGluZ0ZyYWdtZW50KCk7XG4gIFx0XHQvLyBtYWtlIHN1cmUgdGhlIGZvdW5kIGZyYWdtZW50IGlzIGFjdHVhbGx5IGFuIGl0ZXJhdGlvblxuICBcdFx0aWYgKCAhcmVwZWF0ZXIuaXNJdGVyYXRpb24gKSByZXR1cm47XG4gIFx0XHRyZXR1cm4gcmVwZWF0ZXIuY29udGV4dC5nZXRLZXlNb2RlbCggcmVwZWF0ZXJbIHJlZlsxXSA9PT0gJ2knID8gJ2luZGV4JyA6ICdrZXknIF0gKTtcbiAgXHR9XG4gIFx0aWYgKCByZWYgPT09ICdAdGhpcycgKSB7XG4gIFx0XHRyZXR1cm4gZnJhZ21lbnQucmFjdGl2ZS52aWV3bW9kZWwuZ2V0UmFjdGl2ZU1vZGVsKCk7XG4gIFx0fVxuICBcdGlmICggcmVmID09PSAnQGdsb2JhbCcgKSB7XG4gIFx0XHRyZXR1cm4gR2xvYmFsTW9kZWwkMTtcbiAgXHR9XG5cbiAgXHQvLyBhbmNlc3RvciByZWZlcmVuY2VzXG4gIFx0aWYgKCByZWZbMF0gPT09ICd+JyApIHJldHVybiBmcmFnbWVudC5yYWN0aXZlLnZpZXdtb2RlbC5qb2luQWxsKCBzcGxpdEtleXBhdGhJKCByZWYuc2xpY2UoIDIgKSApICk7XG4gIFx0aWYgKCByZWZbMF0gPT09ICcuJyApIHtcbiAgXHRcdHZhciBwYXJ0cyA9IHJlZi5zcGxpdCggJy8nICk7XG5cbiAgXHRcdHdoaWxlICggcGFydHNbMF0gPT09ICcuJyB8fCBwYXJ0c1swXSA9PT0gJy4uJyApIHtcbiAgXHRcdFx0dmFyIHBhcnQgPSBwYXJ0cy5zaGlmdCgpO1xuXG4gIFx0XHRcdGlmICggcGFydCA9PT0gJy4uJyApIHtcbiAgXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnQ7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmVmID0gcGFydHMuam9pbiggJy8nICk7XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGB7ey5mb299fWAgbWVhbnMgdGhlIHNhbWUgYXMgYHt7Li9mb299fWBcbiAgXHRcdGlmICggcmVmWzBdID09PSAnLicgKSByZWYgPSByZWYuc2xpY2UoIDEgKTtcbiAgXHRcdHJldHVybiBjb250ZXh0LmpvaW5BbGwoIHNwbGl0S2V5cGF0aEkoIHJlZiApICk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlc29sdmVBbWJpZ3VvdXNSZWZlcmVuY2UoIGZyYWdtZW50LCByZWYgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkZ2V0ICgga2V5cGF0aCwgb3B0cyApIHtcbiAgXHRpZiAoIHR5cGVvZiBrZXlwYXRoICE9PSAnc3RyaW5nJyApIHJldHVybiB0aGlzLnZpZXdtb2RlbC5nZXQoIHRydWUsIGtleXBhdGggKTtcblxuICBcdHZhciBrZXlzID0gc3BsaXRLZXlwYXRoSSgga2V5cGF0aCApO1xuICBcdHZhciBrZXkgPSBrZXlzWzBdO1xuXG4gIFx0dmFyIG1vZGVsO1xuXG4gIFx0aWYgKCAhdGhpcy52aWV3bW9kZWwuaGFzKCBrZXkgKSApIHtcbiAgXHRcdC8vIGlmIHRoaXMgaXMgYW4gaW5saW5lIGNvbXBvbmVudCwgd2UgbWF5IG5lZWQgdG8gY3JlYXRlXG4gIFx0XHQvLyBhbiBpbXBsaWNpdCBtYXBwaW5nXG4gIFx0XHRpZiAoIHRoaXMuY29tcG9uZW50ICYmICF0aGlzLmlzb2xhdGVkICkge1xuICBcdFx0XHRtb2RlbCA9IHJlc29sdmVSZWZlcmVuY2UoIHRoaXMuY29tcG9uZW50LnBhcmVudEZyYWdtZW50LCBrZXkgKTtcblxuICBcdFx0XHRpZiAoIG1vZGVsICkge1xuICBcdFx0XHRcdHRoaXMudmlld21vZGVsLm1hcCgga2V5LCBtb2RlbCApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0bW9kZWwgPSB0aGlzLnZpZXdtb2RlbC5qb2luQWxsKCBrZXlzICk7XG4gIFx0cmV0dXJuIG1vZGVsLmdldCggdHJ1ZSwgb3B0cyApO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2F0aGVyUmVmcyggZnJhZ21lbnQgKSB7XG4gIFx0dmFyIGtleSA9IHt9LCBpbmRleCA9IHt9O1xuXG4gIFx0Ly8gd2FsayB1cCB0aGUgdGVtcGxhdGUgZ2F0aGVyIHJlZnMgYXMgd2UgZ29cbiAgXHR3aGlsZSAoIGZyYWdtZW50ICkge1xuICBcdFx0aWYgKCBmcmFnbWVudC5wYXJlbnQgJiYgKCBmcmFnbWVudC5wYXJlbnQuaW5kZXhSZWYgfHwgZnJhZ21lbnQucGFyZW50LmtleVJlZiApICkge1xuICBcdFx0XHR2YXIgcmVmID0gZnJhZ21lbnQucGFyZW50LmluZGV4UmVmO1xuICBcdFx0XHRpZiAoIHJlZiAmJiAhKCByZWYgaW4gaW5kZXggKSApIGluZGV4W3JlZl0gPSBmcmFnbWVudC5pbmRleDtcbiAgXHRcdFx0cmVmID0gZnJhZ21lbnQucGFyZW50LmtleVJlZjtcbiAgXHRcdFx0aWYgKCByZWYgJiYgISggcmVmIGluIGtleSApICkga2V5W3JlZl0gPSBmcmFnbWVudC5rZXk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICggZnJhZ21lbnQuY29tcG9uZW50UGFyZW50ICYmICFmcmFnbWVudC5yYWN0aXZlLmlzb2xhdGVkICkge1xuICBcdFx0XHRmcmFnbWVudCA9IGZyYWdtZW50LmNvbXBvbmVudFBhcmVudDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB7IGtleToga2V5LCBpbmRleDogaW5kZXggfTtcbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4gYXJyYXksIHRoZSBuYW1lIG9mIGEgbXV0YXRvciBtZXRob2QsIGFuZCB0aGVcbiAgLy8gYXJndW1lbnRzIHRvIGNhbGwgdGhhdCBtdXRhdG9yIG1ldGhvZCB3aXRoLCBhbmQgcmV0dXJucyBhbiBhcnJheSB0aGF0XG4gIC8vIG1hcHMgdGhlIG9sZCBpbmRpY2VzIHRvIHRoZWlyIG5ldyBpbmRpY2VzLlxuXG4gIC8vIFNvIGlmIHlvdSBoYWQgc29tZXRoaW5nIGxpa2UgdGhpcy4uLlxuICAvL1xuICAvLyAgICAgYXJyYXkgPSBbICdhJywgJ2InLCAnYycsICdkJyBdO1xuICAvLyAgICAgYXJyYXkucHVzaCggJ2UnICk7XG4gIC8vXG4gIC8vIC4uLnlvdSdkIGdldCBgWyAwLCAxLCAyLCAzIF1gIC0gaW4gb3RoZXIgd29yZHMsIG5vbmUgb2YgdGhlIG9sZCBpbmRpY2VzXG4gIC8vIGhhdmUgY2hhbmdlZC4gSWYgeW91IHRoZW4gZGlkIHRoaXMuLi5cbiAgLy9cbiAgLy8gICAgIGFycmF5LnVuc2hpZnQoICd6JyApO1xuICAvL1xuICAvLyAuLi50aGUgaW5kaWNlcyB3b3VsZCBiZSBgWyAxLCAyLCAzLCA0LCA1IF1gIC0gZXZlcnkgaXRlbSBoYXMgYmVlbiBtb3ZlZFxuICAvLyBvbmUgaGlnaGVyIHRvIG1ha2Ugcm9vbSBmb3IgdGhlICd6Jy4gSWYgeW91IHJlbW92ZWQgYW4gaXRlbSwgdGhlIG5ldyBpbmRleFxuICAvLyB3b3VsZCBiZSAtMS4uLlxuICAvL1xuICAvLyAgICAgYXJyYXkuc3BsaWNlKCAyLCAyICk7XG4gIC8vXG4gIC8vIC4uLnRoaXMgd291bGQgcmVzdWx0IGluIFsgMCwgMSwgLTEsIC0xLCAyLCAzIF0uXG4gIC8vXG4gIC8vIFRoaXMgaW5mb3JtYXRpb24gaXMgdXNlZCB0byBlbmFibGUgZmFzdCwgbm9uLWRlc3RydWN0aXZlIHNodWZmbGluZyBvZiBsaXN0XG4gIC8vIHNlY3Rpb25zIHdoZW4geW91IGRvIGUuZy4gYHJhY3RpdmUuc3BsaWNlKCAnaXRlbXMnLCAyLCAyICk7XG5cbiAgZnVuY3Rpb24gZ2V0TmV3SW5kaWNlcyAoIGxlbmd0aCwgbWV0aG9kTmFtZSwgYXJncyApIHtcbiAgXHR2YXIgc3BsaWNlQXJndW1lbnRzLCBuZXdJbmRpY2VzID0gW10sIHJlbW92ZVN0YXJ0LCByZW1vdmVFbmQsIGJhbGFuY2UsIGk7XG5cbiAgXHRzcGxpY2VBcmd1bWVudHMgPSBnZXRTcGxpY2VFcXVpdmFsZW50KCBsZW5ndGgsIG1ldGhvZE5hbWUsIGFyZ3MgKTtcblxuICBcdGlmICggIXNwbGljZUFyZ3VtZW50cyApIHtcbiAgXHRcdHJldHVybiBudWxsOyAvLyBUT0RPIHN1cHBvcnQgcmV2ZXJzZSBhbmQgc29ydD9cbiAgXHR9XG5cbiAgXHRiYWxhbmNlID0gKCBzcGxpY2VBcmd1bWVudHMubGVuZ3RoIC0gMiApIC0gc3BsaWNlQXJndW1lbnRzWzFdO1xuXG4gIFx0cmVtb3ZlU3RhcnQgPSBNYXRoLm1pbiggbGVuZ3RoLCBzcGxpY2VBcmd1bWVudHNbMF0gKTtcbiAgXHRyZW1vdmVFbmQgPSByZW1vdmVTdGFydCArIHNwbGljZUFyZ3VtZW50c1sxXTtcbiAgXHRuZXdJbmRpY2VzLnN0YXJ0SW5kZXggPSByZW1vdmVTdGFydDtcblxuICBcdGZvciAoIGkgPSAwOyBpIDwgcmVtb3ZlU3RhcnQ7IGkgKz0gMSApIHtcbiAgXHRcdG5ld0luZGljZXMucHVzaCggaSApO1xuICBcdH1cblxuICBcdGZvciAoIDsgaSA8IHJlbW92ZUVuZDsgaSArPSAxICkge1xuICBcdFx0bmV3SW5kaWNlcy5wdXNoKCAtMSApO1xuICBcdH1cblxuICBcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAxICkge1xuICBcdFx0bmV3SW5kaWNlcy5wdXNoKCBpICsgYmFsYW5jZSApO1xuICBcdH1cblxuICBcdC8vIHRoZXJlIGlzIGEgbmV0IHNoaWZ0IGZvciB0aGUgcmVzdCBvZiB0aGUgYXJyYXkgc3RhcnRpbmcgd2l0aCBpbmRleCArIGJhbGFuY2VcbiAgXHRpZiAoIGJhbGFuY2UgIT09IDAgKSB7XG4gIFx0XHRuZXdJbmRpY2VzLnRvdWNoZWRGcm9tID0gc3BsaWNlQXJndW1lbnRzWzBdO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRuZXdJbmRpY2VzLnRvdWNoZWRGcm9tID0gbGVuZ3RoO1xuICBcdH1cblxuICBcdHJldHVybiBuZXdJbmRpY2VzO1xuICB9XG5cblxuICAvLyBUaGUgcG9wLCBwdXNoLCBzaGlmdCBhbiB1bnNoaWZ0IG1ldGhvZHMgY2FuIGFsbCBiZSByZXByZXNlbnRlZFxuICAvLyBhcyBhbiBlcXVpdmFsZW50IHNwbGljZVxuICBmdW5jdGlvbiBnZXRTcGxpY2VFcXVpdmFsZW50ICggbGVuZ3RoLCBtZXRob2ROYW1lLCBhcmdzICkge1xuICBcdHN3aXRjaCAoIG1ldGhvZE5hbWUgKSB7XG4gIFx0XHRjYXNlICdzcGxpY2UnOlxuICBcdFx0XHRpZiAoIGFyZ3NbMF0gIT09IHVuZGVmaW5lZCAmJiBhcmdzWzBdIDwgMCApIHtcbiAgXHRcdFx0XHRhcmdzWzBdID0gbGVuZ3RoICsgTWF0aC5tYXgoIGFyZ3NbMF0sIC1sZW5ndGggKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICggYXJnc1swXSA9PT0gdW5kZWZpbmVkICkgYXJnc1swXSA9IDA7XG5cbiAgXHRcdFx0d2hpbGUgKCBhcmdzLmxlbmd0aCA8IDIgKSB7XG4gIFx0XHRcdFx0YXJncy5wdXNoKCBsZW5ndGggLSBhcmdzWzBdICk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIHR5cGVvZiBhcmdzWzFdICE9PSAnbnVtYmVyJyApIHtcbiAgXHRcdFx0XHRhcmdzWzFdID0gbGVuZ3RoIC0gYXJnc1swXTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGVuc3VyZSB3ZSBvbmx5IHJlbW92ZSBlbGVtZW50cyB0aGF0IGV4aXN0XG4gIFx0XHRcdGFyZ3NbMV0gPSBNYXRoLm1pbiggYXJnc1sxXSwgbGVuZ3RoIC0gYXJnc1swXSApO1xuXG4gIFx0XHRcdHJldHVybiBhcmdzO1xuXG4gIFx0XHRjYXNlICdzb3J0JzpcbiAgXHRcdGNhc2UgJ3JldmVyc2UnOlxuICBcdFx0XHRyZXR1cm4gbnVsbDtcblxuICBcdFx0Y2FzZSAncG9wJzpcbiAgXHRcdFx0aWYgKCBsZW5ndGggKSB7XG4gIFx0XHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSwgMSBdO1xuICBcdFx0XHR9XG4gIFx0XHRcdHJldHVybiBbIDAsIDAgXTtcblxuICBcdFx0Y2FzZSAncHVzaCc6XG4gIFx0XHRcdHJldHVybiBbIGxlbmd0aCwgMCBdLmNvbmNhdCggYXJncyApO1xuXG4gIFx0XHRjYXNlICdzaGlmdCc6XG4gIFx0XHRcdHJldHVybiBbIDAsIGxlbmd0aCA/IDEgOiAwIF07XG5cbiAgXHRcdGNhc2UgJ3Vuc2hpZnQnOlxuICBcdFx0XHRyZXR1cm4gWyAwLCAwIF0uY29uY2F0KCBhcmdzICk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gbWFrZUFycmF5TWV0aG9kICggbWV0aG9kTmFtZSApIHtcbiAgXHRmdW5jdGlvbiBwYXRoICgga2V5cGF0aCApIHtcbiAgXHRcdHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICBcdFx0d2hpbGUgKCBsZW4tLSA+IDAgKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gIFx0XHRyZXR1cm4gbW9kZWwoIHRoaXMudmlld21vZGVsLmpvaW5BbGwoIHNwbGl0S2V5cGF0aEkoIGtleXBhdGggKSApLCBhcmdzICk7XG4gIFx0fVxuXG4gIFx0ZnVuY3Rpb24gbW9kZWwgKCBtZGwsIGFyZ3MgKSB7XG4gIFx0XHR2YXIgYXJyYXkgPSBtZGwuZ2V0KCk7XG5cbiAgXHRcdGlmICggIWlzQXJyYXkoIGFycmF5ICkgKSB7XG4gIFx0XHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcbiAgXHRcdFx0XHRhcnJheSA9IFtdO1xuICBcdFx0XHRcdHZhciByZXN1bHQkMSA9IGFycmF5UHJvdG9bIG1ldGhvZE5hbWUgXS5hcHBseSggYXJyYXksIGFyZ3MgKTtcbiAgXHRcdFx0XHR2YXIgcHJvbWlzZSQxID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApLnRoZW4oIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3VsdCQxOyB9ICk7XG4gIFx0XHRcdFx0bWRsLnNldCggYXJyYXkgKTtcbiAgXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuICBcdFx0XHRcdHJldHVybiBwcm9taXNlJDE7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAoXCJzaHVmZmxlIGFycmF5IG1ldGhvZCBcIiArIG1ldGhvZE5hbWUgKyBcIiBjYWxsZWQgb24gbm9uLWFycmF5IGF0IFwiICsgKG1kbC5nZXRLZXlwYXRoKCkpKSApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBuZXdJbmRpY2VzID0gZ2V0TmV3SW5kaWNlcyggYXJyYXkubGVuZ3RoLCBtZXRob2ROYW1lLCBhcmdzICk7XG4gIFx0XHR2YXIgcmVzdWx0ID0gYXJyYXlQcm90b1sgbWV0aG9kTmFtZSBdLmFwcGx5KCBhcnJheSwgYXJncyApO1xuXG4gIFx0XHR2YXIgcHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKS50aGVuKCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXN1bHQ7IH0gKTtcbiAgXHRcdHByb21pc2UucmVzdWx0ID0gcmVzdWx0O1xuXG4gIFx0XHRpZiAoIG5ld0luZGljZXMgKSB7XG4gIFx0XHRcdG1kbC5zaHVmZmxlKCBuZXdJbmRpY2VzICk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRtZGwuc2V0KCByZXN1bHQgKTtcbiAgXHRcdH1cblxuICBcdFx0cnVubG9vcC5lbmQoKTtcblxuICBcdFx0cmV0dXJuIHByb21pc2U7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHsgcGF0aDogcGF0aCwgbW9kZWw6IG1vZGVsIH07XG4gIH1cblxuICB2YXIgY29tcGFyYXRvcnMgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRDb21wYXJhdG9yICggb3B0aW9uICkge1xuICBcdGlmICggIW9wdGlvbiApIHJldHVybiBudWxsOyAvLyB1c2UgZXhpc3RpbmcgYXJyYXlzXG4gIFx0aWYgKCBvcHRpb24gPT09IHRydWUgKSByZXR1cm4gSlNPTi5zdHJpbmdpZnk7XG4gIFx0aWYgKCB0eXBlb2Ygb3B0aW9uID09PSAnZnVuY3Rpb24nICkgcmV0dXJuIG9wdGlvbjtcblxuICBcdGlmICggdHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycgKSB7XG4gIFx0XHRyZXR1cm4gY29tcGFyYXRvcnNbIG9wdGlvbiBdIHx8ICggY29tcGFyYXRvcnNbIG9wdGlvbiBdID0gZnVuY3Rpb24gKCB0aGluZyApIHsgcmV0dXJuIHRoaW5nWyBvcHRpb24gXTsgfSApO1xuICBcdH1cblxuICBcdHRocm93IG5ldyBFcnJvciggJ0lmIHN1cHBsaWVkLCBvcHRpb25zLmNvbXBhcmUgbXVzdCBiZSBhIHN0cmluZywgZnVuY3Rpb24sIG9yIGB0cnVlYCcgKTsgLy8gVE9ETyBsaW5rIHRvIGRvY3NcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlJDEgKCByYWN0aXZlLCBtb2RlbCwgYXJyYXksIG9wdGlvbnMgKSB7XG4gIFx0dmFyIHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCByYWN0aXZlLCB0cnVlICk7XG4gIFx0dmFyIHZhbHVlID0gbW9kZWwuZ2V0KCk7XG5cbiAgXHRpZiAoICFpc0FycmF5KCB2YWx1ZSApIHx8ICFpc0FycmF5KCBhcnJheSApICkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKCAnWW91IGNhbm5vdCBtZXJnZSBhbiBhcnJheSB3aXRoIGEgbm9uLWFycmF5JyApO1xuICBcdH1cblxuICBcdHZhciBjb21wYXJhdG9yID0gZ2V0Q29tcGFyYXRvciggb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBhcmUgKTtcbiAgXHRtb2RlbC5tZXJnZSggYXJyYXksIGNvbXBhcmF0b3IgKTtcblxuICBcdHJ1bmxvb3AuZW5kKCk7XG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiB0aGlzUmFjdGl2ZSRtZXJnZSAoIGtleXBhdGgsIGFycmF5LCBvcHRpb25zICkge1xuICBcdHJldHVybiBtZXJnZSQxKCB0aGlzLCB0aGlzLnZpZXdtb2RlbC5qb2luQWxsKCBzcGxpdEtleXBhdGhJKCBrZXlwYXRoICkgKSwgYXJyYXksIG9wdGlvbnMgKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVIb29rID0gbmV3IEhvb2soICd1cGRhdGUnICk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlJDIgKCByYWN0aXZlLCBtb2RlbCApIHtcbiAgXHQvLyBpZiB0aGUgcGFyZW50IGlzIHdyYXBwZWQsIHRoZSBhZGFwdG9yIHdpbGwgbmVlZCB0byBiZSB1cGRhdGVkIGJlZm9yZVxuICBcdC8vIHVwZGF0aW5nIG9uIHRoaXMga2V5cGF0aFxuICBcdGlmICggbW9kZWwucGFyZW50ICYmIG1vZGVsLnBhcmVudC53cmFwcGVyICkge1xuICBcdFx0bW9kZWwucGFyZW50LmFkYXB0KCk7XG4gIFx0fVxuXG4gIFx0dmFyIHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCByYWN0aXZlLCB0cnVlICk7XG5cbiAgXHRtb2RlbC5tYXJrKCk7XG4gIFx0bW9kZWwucmVnaXN0ZXJDaGFuZ2UoIG1vZGVsLmdldEtleXBhdGgoKSwgbW9kZWwuZ2V0KCkgKTtcblxuICBcdGlmICggIW1vZGVsLmlzUm9vdCApIHtcbiAgXHRcdC8vIHRoZXJlIG1heSBiZSB1bnJlc29sdmVkIHJlZnMgdGhhdCBhcmUgbm93IHJlc29sdmFibGUgdXAgdGhlIGNvbnRleHQgdHJlZVxuICBcdFx0dmFyIHBhcmVudCA9IG1vZGVsLnBhcmVudCwga2V5ID0gbW9kZWwua2V5O1xuICBcdFx0d2hpbGUgKCBwYXJlbnQgJiYgIXBhcmVudC5pc1Jvb3QgKSB7XG4gIFx0XHRcdGlmICggcGFyZW50LmNsZWFyVW5yZXNvbHZlZHMgKSBwYXJlbnQuY2xlYXJVbnJlc29sdmVkcygga2V5ICk7XG4gIFx0XHRcdGtleSA9IHBhcmVudC5rZXk7XG4gIFx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gbm90aWZ5IHVwc3RyZWFtIG9mIGNoYW5nZXNcbiAgXHRtb2RlbC5ub3RpZnlVcHN0cmVhbSgpO1xuXG4gIFx0cnVubG9vcC5lbmQoKTtcblxuICBcdHVwZGF0ZUhvb2suZmlyZSggcmFjdGl2ZSwgbW9kZWwgKTtcblxuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSR1cGRhdGUgKCBrZXlwYXRoICkge1xuICBcdGlmICgga2V5cGF0aCApIGtleXBhdGggPSBzcGxpdEtleXBhdGhJKCBrZXlwYXRoICk7XG5cbiAgXHRyZXR1cm4gdXBkYXRlJDIoIHRoaXMsIGtleXBhdGggPyB0aGlzLnZpZXdtb2RlbC5qb2luQWxsKCBrZXlwYXRoICkgOiB0aGlzLnZpZXdtb2RlbCApO1xuICB9XG5cbiAgdmFyIG1vZGVsUHVzaCA9IG1ha2VBcnJheU1ldGhvZCggJ3B1c2gnICkubW9kZWw7XG4gIHZhciBtb2RlbFBvcCA9IG1ha2VBcnJheU1ldGhvZCggJ3BvcCcgKS5tb2RlbDtcbiAgdmFyIG1vZGVsU2hpZnQgPSBtYWtlQXJyYXlNZXRob2QoICdzaGlmdCcgKS5tb2RlbDtcbiAgdmFyIG1vZGVsVW5zaGlmdCA9IG1ha2VBcnJheU1ldGhvZCggJ3Vuc2hpZnQnICkubW9kZWw7XG4gIHZhciBtb2RlbFNvcnQgPSBtYWtlQXJyYXlNZXRob2QoICdzb3J0JyApLm1vZGVsO1xuICB2YXIgbW9kZWxTcGxpY2UgPSBtYWtlQXJyYXlNZXRob2QoICdzcGxpY2UnICkubW9kZWw7XG4gIHZhciBtb2RlbFJldmVyc2UgPSBtYWtlQXJyYXlNZXRob2QoICdyZXZlcnNlJyApLm1vZGVsO1xuXG4gIC8vIFRPRE86IGF0IHNvbWUgcG9pbnQgcGVyaGFwcyB0aGlzIGNvdWxkIHN1cHBvcnQgcmVsYXRpdmUgKiBrZXlwYXRocz9cbiAgZnVuY3Rpb24gYnVpbGQkMSAoIGVsLCBrZXlwYXRoLCB2YWx1ZSApIHtcbiAgXHR2YXIgc2V0cyA9IFtdO1xuXG4gIFx0Ly8gc2V0IG11bHRpcGxlIGtleXBhdGhzIGluIG9uZSBnb1xuICBcdGlmICggaXNPYmplY3QoIGtleXBhdGggKSApIHtcbiAgXHRcdGZvciAoIHZhciBrIGluIGtleXBhdGggKSB7XG4gIFx0XHRcdGlmICgga2V5cGF0aC5oYXNPd25Qcm9wZXJ0eSggayApICkge1xuICBcdFx0XHRcdHNldHMucHVzaCggWyBmaW5kTW9kZWwoIGVsLCBrICkubW9kZWwsIGtleXBhdGhba10gXSApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHR9XG4gIFx0Ly8gc2V0IGEgc2luZ2xlIGtleXBhdGhcbiAgXHRlbHNlIHtcbiAgXHRcdHNldHMucHVzaCggWyBmaW5kTW9kZWwoIGVsLCBrZXlwYXRoICkubW9kZWwsIHZhbHVlIF0gKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc2V0cztcbiAgfVxuXG4gIC8vIGdldCByZWxhdGl2ZSBrZXlwYXRocyBhbmQgdmFsdWVzXG4gIGZ1bmN0aW9uIGdldCAoIGtleXBhdGggKSB7XG4gIFx0aWYgKCAha2V5cGF0aCApIHJldHVybiB0aGlzLl9lbGVtZW50LnBhcmVudEZyYWdtZW50LmZpbmRDb250ZXh0KCkuZ2V0KCB0cnVlICk7XG5cbiAgXHR2YXIgbW9kZWwgPSByZXNvbHZlUmVmZXJlbmNlKCB0aGlzLl9lbGVtZW50LnBhcmVudEZyYWdtZW50LCBrZXlwYXRoICk7XG5cbiAgXHRyZXR1cm4gbW9kZWwgPyBtb2RlbC5nZXQoIHRydWUgKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmUkMSAoIHBhdGgsIHJhY3RpdmUgKSB7XG4gIFx0dmFyIHJlZiA9IGZpbmRNb2RlbCggdGhpcywgcGF0aCApLCBtb2RlbCA9IHJlZi5tb2RlbCwgaW5zdGFuY2UgPSByZWYuaW5zdGFuY2U7XG4gIFx0cmV0dXJuIG1vZGVsID8gbW9kZWwuZ2V0S2V5cGF0aCggcmFjdGl2ZSB8fCBpbnN0YW5jZSApIDogcGF0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRNb2RlbCAoIGVsLCBwYXRoICkge1xuICBcdHZhciBmcmFnID0gZWwuX2VsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHRpZiAoIHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJyApIHtcbiAgXHRcdHJldHVybiB7IG1vZGVsOiBmcmFnLmZpbmRDb250ZXh0KCksIGluc3RhbmNlOiBwYXRoIH07XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHsgbW9kZWw6IHJlc29sdmVSZWZlcmVuY2UoIGZyYWcsIHBhdGggKSwgaW5zdGFuY2U6IGZyYWcucmFjdGl2ZSB9O1xuICB9XG5cbiAgLy8gdGhlIHVzdWFsIG11dGF0aW9uIHN1c3BlY3RzXG4gIGZ1bmN0aW9uIGFkZCQxICgga2V5cGF0aCwgdmFsdWUgKSB7XG4gIFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgdmFsdWUgPSAxO1xuICBcdGlmICggIWlzTnVtZXJpYyggdmFsdWUgKSApIHRocm93IG5ldyBFcnJvciggJ0JhZCBhcmd1bWVudHMnICk7XG4gIFx0cmV0dXJuIHNldCggdGhpcy5yYWN0aXZlLCBidWlsZCQxKCB0aGlzLCBrZXlwYXRoLCB2YWx1ZSApLm1hcCggZnVuY3Rpb24gKCBwYWlyICkge1xuICBcdFx0dmFyIG1vZGVsID0gcGFpclswXSwgdmFsID0gcGFpclsxXSwgdmFsdWUgPSBtb2RlbC5nZXQoKTtcbiAgXHRcdGlmICggIWlzTnVtZXJpYyggdmFsICkgfHwgIWlzTnVtZXJpYyggdmFsdWUgKSApIHRocm93IG5ldyBFcnJvciggJ0Nhbm5vdCBhZGQgbm9uLW51bWVyaWMgdmFsdWUnICk7XG4gIFx0XHRyZXR1cm4gWyBtb2RlbCwgdmFsdWUgKyB2YWwgXTtcbiAgXHR9KSApO1xuICB9XG5cbiAgZnVuY3Rpb24gYW5pbWF0ZSAoIGtleXBhdGgsIHZhbHVlLCBvcHRpb25zICkge1xuICBcdHZhciBtb2RlbCA9IGZpbmRNb2RlbCggdGhpcywga2V5cGF0aCApLm1vZGVsO1xuICBcdHJldHVybiBwcm90b0FuaW1hdGUoIHRoaXMucmFjdGl2ZSwgbW9kZWwsIHZhbHVlLCBvcHRpb25zICk7XG4gIH1cblxuICBmdW5jdGlvbiBsaW5rICggc291cmNlLCBkZXN0ICkge1xuICBcdHZhciB0aGVyZSA9IGZpbmRNb2RlbCggdGhpcywgc291cmNlICkubW9kZWwsIGhlcmUgPSBmaW5kTW9kZWwoIHRoaXMsIGRlc3QgKS5tb2RlbDtcbiAgXHR2YXIgcHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMucmFjdGl2ZSwgdHJ1ZSApO1xuICBcdGhlcmUubGluayggdGhlcmUsIHNvdXJjZSApO1xuICBcdHJ1bmxvb3AuZW5kKCk7XG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZSAoIGtleXBhdGgsIGFycmF5LCBvcHRpb25zICkge1xuICBcdHJldHVybiBtZXJnZSQxKCB0aGlzLnJhY3RpdmUsIGZpbmRNb2RlbCggdGhpcywga2V5cGF0aCApLm1vZGVsLCBhcnJheSwgb3B0aW9ucyApO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wICgga2V5cGF0aCApIHtcbiAgXHRyZXR1cm4gbW9kZWxQb3AoIGZpbmRNb2RlbCggdGhpcywga2V5cGF0aCApLm1vZGVsLCBbXSApO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaCAoIGtleXBhdGggKSB7XG4gIFx0dmFyIHZhbHVlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgXHR3aGlsZSAoIGxlbi0tID4gMCApIHZhbHVlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICBcdHJldHVybiBtb2RlbFB1c2goIGZpbmRNb2RlbCggdGhpcywga2V5cGF0aCApLm1vZGVsLCB2YWx1ZXMgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldmVyc2UgKCBrZXlwYXRoICkge1xuICBcdHJldHVybiBtb2RlbFJldmVyc2UoIGZpbmRNb2RlbCggdGhpcywga2V5cGF0aCApLm1vZGVsLCBbXSApO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0JDEgKCBrZXlwYXRoLCB2YWx1ZSApIHtcbiAgXHRyZXR1cm4gc2V0KCB0aGlzLnJhY3RpdmUsIGJ1aWxkJDEoIHRoaXMsIGtleXBhdGgsIHZhbHVlICkgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNoaWZ0ICgga2V5cGF0aCApIHtcbiAgXHRyZXR1cm4gbW9kZWxTaGlmdCggZmluZE1vZGVsKCB0aGlzLCBrZXlwYXRoICkubW9kZWwsIFtdICk7XG4gIH1cblxuICBmdW5jdGlvbiBzcGxpY2UgKCBrZXlwYXRoLCBpbmRleCwgZHJvcCApIHtcbiAgXHR2YXIgYWRkID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAzO1xuICBcdHdoaWxlICggbGVuLS0gPiAwICkgYWRkWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMyBdO1xuXG4gIFx0YWRkLnVuc2hpZnQoIGluZGV4LCBkcm9wICk7XG4gIFx0cmV0dXJuIG1vZGVsU3BsaWNlKCBmaW5kTW9kZWwoIHRoaXMsIGtleXBhdGggKS5tb2RlbCwgYWRkICk7XG4gIH1cblxuICBmdW5jdGlvbiBzb3J0ICgga2V5cGF0aCApIHtcbiAgXHRyZXR1cm4gbW9kZWxTb3J0KCBmaW5kTW9kZWwoIHRoaXMsIGtleXBhdGggKS5tb2RlbCwgW10gKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN1YnRyYWN0ICgga2V5cGF0aCwgdmFsdWUgKSB7XG4gIFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgdmFsdWUgPSAxO1xuICBcdGlmICggIWlzTnVtZXJpYyggdmFsdWUgKSApIHRocm93IG5ldyBFcnJvciggJ0JhZCBhcmd1bWVudHMnICk7XG4gIFx0cmV0dXJuIHNldCggdGhpcy5yYWN0aXZlLCBidWlsZCQxKCB0aGlzLCBrZXlwYXRoLCB2YWx1ZSApLm1hcCggZnVuY3Rpb24gKCBwYWlyICkge1xuICBcdFx0dmFyIG1vZGVsID0gcGFpclswXSwgdmFsID0gcGFpclsxXSwgdmFsdWUgPSBtb2RlbC5nZXQoKTtcbiAgXHRcdGlmICggIWlzTnVtZXJpYyggdmFsICkgfHwgIWlzTnVtZXJpYyggdmFsdWUgKSApIHRocm93IG5ldyBFcnJvciggJ0Nhbm5vdCBhZGQgbm9uLW51bWVyaWMgdmFsdWUnICk7XG4gIFx0XHRyZXR1cm4gWyBtb2RlbCwgdmFsdWUgLSB2YWwgXTtcbiAgXHR9KSApO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9nZ2xlICgga2V5cGF0aCApIHtcbiAgXHR2YXIgcmVmID0gZmluZE1vZGVsKCB0aGlzLCBrZXlwYXRoICksIG1vZGVsID0gcmVmLm1vZGVsO1xuICBcdHJldHVybiBzZXQoIHRoaXMucmFjdGl2ZSwgWyBbIG1vZGVsLCAhbW9kZWwuZ2V0KCkgXSBdICk7XG4gIH1cblxuICBmdW5jdGlvbiB1bmxpbmsgKCBkZXN0ICkge1xuICBcdHZhciBoZXJlID0gZmluZE1vZGVsKCB0aGlzLCBkZXN0ICkubW9kZWw7XG4gIFx0dmFyIHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLnJhY3RpdmUsIHRydWUgKTtcbiAgXHRpZiAoIGhlcmUub3duZXIgJiYgaGVyZS5vd25lci5fbGluayApIGhlcmUub3duZXIudW5saW5rKCk7XG4gIFx0cnVubG9vcC5lbmQoKTtcbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuc2hpZnQgKCBrZXlwYXRoICkge1xuICBcdHZhciBhZGQgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIFx0d2hpbGUgKCBsZW4tLSA+IDAgKSBhZGRbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgXHRyZXR1cm4gbW9kZWxVbnNoaWZ0KCBmaW5kTW9kZWwoIHRoaXMsIGtleXBhdGggKS5tb2RlbCwgYWRkICk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGUkMSAoIGtleXBhdGggKSB7XG4gIFx0cmV0dXJuIHVwZGF0ZSQyKCB0aGlzLnJhY3RpdmUsIGZpbmRNb2RlbCggdGhpcywga2V5cGF0aCApLm1vZGVsICk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNb2RlbCAoIGtleXBhdGgsIGNhc2NhZGUgKSB7XG4gIFx0dmFyIHJlZiA9IGZpbmRNb2RlbCggdGhpcywga2V5cGF0aCApLCBtb2RlbCA9IHJlZi5tb2RlbDtcbiAgXHR2YXIgcHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMucmFjdGl2ZSwgdHJ1ZSApO1xuICBcdG1vZGVsLnVwZGF0ZUZyb21CaW5kaW5ncyggY2FzY2FkZSApO1xuICBcdHJ1bmxvb3AuZW5kKCk7XG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICAvLyB0d28td2F5IGJpbmRpbmcgcmVsYXRlZCBoZWxwZXJzXG4gIGZ1bmN0aW9uIGlzQm91bmQgKCkge1xuICBcdHZhciByZWYgPSBnZXRCaW5kaW5nTW9kZWwoIHRoaXMgKSwgbW9kZWwgPSByZWYubW9kZWw7XG4gIFx0cmV0dXJuICEhbW9kZWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCaW5kaW5nUGF0aCAoIHJhY3RpdmUgKSB7XG4gIFx0dmFyIHJlZiA9IGdldEJpbmRpbmdNb2RlbCggdGhpcyApLCBtb2RlbCA9IHJlZi5tb2RlbCwgaW5zdGFuY2UgPSByZWYuaW5zdGFuY2U7XG4gIFx0aWYgKCBtb2RlbCApIHJldHVybiBtb2RlbC5nZXRLZXlwYXRoKCByYWN0aXZlIHx8IGluc3RhbmNlICk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCaW5kaW5nICgpIHtcbiAgXHR2YXIgcmVmID0gZ2V0QmluZGluZ01vZGVsKCB0aGlzICksIG1vZGVsID0gcmVmLm1vZGVsO1xuICBcdGlmICggbW9kZWwgKSByZXR1cm4gbW9kZWwuZ2V0KCB0cnVlICk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCaW5kaW5nTW9kZWwgKCBjdHggKSB7XG4gIFx0dmFyIGVsID0gY3R4Ll9lbGVtZW50O1xuICBcdHJldHVybiB7IG1vZGVsOiBlbC5iaW5kaW5nICYmIGVsLmJpbmRpbmcubW9kZWwsIGluc3RhbmNlOiBlbC5wYXJlbnRGcmFnbWVudC5yYWN0aXZlIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZXRCaW5kaW5nICggdmFsdWUgKSB7XG4gIFx0dmFyIHJlZiA9IGdldEJpbmRpbmdNb2RlbCggdGhpcyApLCBtb2RlbCA9IHJlZi5tb2RlbDtcbiAgXHRyZXR1cm4gc2V0KCB0aGlzLnJhY3RpdmUsIFsgWyBtb2RlbCwgdmFsdWUgXSBdICk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkIGdldHRlcnNcbiAgZnVuY3Rpb24ga2V5cGF0aCAoKSB7XG4gIFx0d2Fybk9uY2VJZkRlYnVnKCAoXCJPYmplY3QgcHJvcGVydHkga2V5cGF0aCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHJlc29sdmUoKSBpbnN0ZWFkLlwiKSApO1xuICBcdHJldHVybiB0aGlzLnJlc29sdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJvb3RwYXRoICgpIHtcbiAgXHR3YXJuT25jZUlmRGVidWcoIChcIk9iamVjdCBwcm9wZXJ0eSByb290cGF0aCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHJlc29sdmUoIHJhY3RpdmUucm9vdCApIGluc3RlYWQuXCIpICk7XG4gIFx0cmV0dXJuIHRoaXMucmVzb2x2ZSggdGhpcy5yYWN0aXZlLnJvb3QgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnRleHQgKCkge1xuICBcdHdhcm5PbmNlSWZEZWJ1ZyggKFwiT2JqZWN0IHByb3BlcnR5IGNvbnRleHQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBnZXQoKSBpbnN0ZWFkLlwiKSApO1xuICBcdHJldHVybiB0aGlzLmdldCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5kZXggKCkge1xuICBcdHdhcm5PbmNlSWZEZWJ1ZyggKFwiT2JqZWN0IHByb3BlcnR5IGluZGV4IGlzIGRlcHJlY2F0ZWQsIHlvdSBjYW4gdXNlIGdldCggXFxcImluZGV4TmFtZVxcXCIgKSBpbnN0ZWFkLlwiKSApO1xuICBcdHJldHVybiBnYXRoZXJSZWZzKCB0aGlzLl9lbGVtZW50LnBhcmVudEZyYWdtZW50ICkuaW5kZXg7XG4gIH1cblxuICBmdW5jdGlvbiBrZXkgKCkge1xuICBcdHdhcm5PbmNlSWZEZWJ1ZyggKFwiT2JqZWN0IHByb3BlcnR5IGtleSBpcyBkZXByZWNhdGVkLCB5b3UgY2FuIHVzZSBnZXQoIFxcXCJrZXlOYW1lXFxcIiApIGluc3RlYWQuXCIpICk7XG4gIFx0cmV0dXJuIGdhdGhlclJlZnMoIHRoaXMuX2VsZW1lbnQucGFyZW50RnJhZ21lbnQgKS5rZXk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRIZWxwZXJzICggb2JqLCBlbGVtZW50ICkge1xuICBcdGRlZmluZVByb3BlcnRpZXMoIG9iaiwge1xuICBcdFx0X2VsZW1lbnQ6IHsgdmFsdWU6IGVsZW1lbnQgfSxcbiAgXHRcdHJhY3RpdmU6IHsgdmFsdWU6IGVsZW1lbnQucGFyZW50RnJhZ21lbnQucmFjdGl2ZSB9LFxuICBcdFx0cmVzb2x2ZTogeyB2YWx1ZTogcmVzb2x2ZSQxIH0sXG4gIFx0XHRnZXQ6IHsgdmFsdWU6IGdldCB9LFxuXG4gIFx0XHRhZGQ6IHsgdmFsdWU6IGFkZCQxIH0sXG4gIFx0XHRhbmltYXRlOiB7IHZhbHVlOiBhbmltYXRlIH0sXG4gIFx0XHRsaW5rOiB7IHZhbHVlOiBsaW5rIH0sXG4gIFx0XHRtZXJnZTogeyB2YWx1ZTogbWVyZ2UgfSxcbiAgXHRcdHBvcDogeyB2YWx1ZTogcG9wIH0sXG4gIFx0XHRwdXNoOiB7IHZhbHVlOiBwdXNoIH0sXG4gIFx0XHRyZXZlcnNlOiB7IHZhbHVlOiByZXZlcnNlIH0sXG4gIFx0XHRzZXQ6IHsgdmFsdWU6IHNldCQxIH0sXG4gIFx0XHRzaGlmdDogeyB2YWx1ZTogc2hpZnQgfSxcbiAgXHRcdHNvcnQ6IHsgdmFsdWU6IHNvcnQgfSxcbiAgXHRcdHNwbGljZTogeyB2YWx1ZTogc3BsaWNlIH0sXG4gIFx0XHRzdWJ0cmFjdDogeyB2YWx1ZTogc3VidHJhY3QgfSxcbiAgXHRcdHRvZ2dsZTogeyB2YWx1ZTogdG9nZ2xlIH0sXG4gIFx0XHR1bmxpbms6IHsgdmFsdWU6IHVubGluayB9LFxuICBcdFx0dW5zaGlmdDogeyB2YWx1ZTogdW5zaGlmdCB9LFxuICBcdFx0dXBkYXRlOiB7IHZhbHVlOiB1cGRhdGUkMSB9LFxuICBcdFx0dXBkYXRlTW9kZWw6IHsgdmFsdWU6IHVwZGF0ZU1vZGVsIH0sXG5cbiAgXHRcdGlzQm91bmQ6IHsgdmFsdWU6IGlzQm91bmQgfSxcbiAgXHRcdGdldEJpbmRpbmdQYXRoOiB7IHZhbHVlOiBnZXRCaW5kaW5nUGF0aCB9LFxuICBcdFx0Z2V0QmluZGluZzogeyB2YWx1ZTogZ2V0QmluZGluZyB9LFxuICBcdFx0c2V0QmluZGluZzogeyB2YWx1ZTogc2V0QmluZGluZyB9LFxuXG4gIFx0XHRrZXlwYXRoOiB7IGdldDoga2V5cGF0aCB9LFxuICBcdFx0cm9vdHBhdGg6IHsgZ2V0OiByb290cGF0aCB9LFxuICBcdFx0Y29udGV4dDogeyBnZXQ6IGNvbnRleHQgfSxcbiAgXHRcdGluZGV4OiB7IGdldDogaW5kZXggfSxcbiAgXHRcdGtleTogeyBnZXQ6IGtleSB9XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHF1ZXJ5ID0gZG9jICYmIGRvYy5xdWVyeVNlbGVjdG9yO1xuXG4gIGZ1bmN0aW9uIHN0YXRpY0luZm8oIG5vZGUgKSB7XG4gIFx0aWYgKCB0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycgJiYgcXVlcnkgKSB7XG4gIFx0XHRub2RlID0gcXVlcnkuY2FsbCggZG9jdW1lbnQsIG5vZGUgKTtcbiAgXHR9XG5cbiAgXHRpZiAoICFub2RlIHx8ICFub2RlLl9yYWN0aXZlICkgcmV0dXJuIHt9O1xuXG4gIFx0dmFyIHN0b3JhZ2UgPSBub2RlLl9yYWN0aXZlO1xuXG4gIFx0cmV0dXJuIGFkZEhlbHBlcnMoIHt9LCBzdG9yYWdlLnByb3h5ICk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROb2RlSW5mbyggbm9kZSApIHtcbiAgXHRpZiAoIHR5cGVvZiBub2RlID09PSAnc3RyaW5nJyApIHtcbiAgXHRcdG5vZGUgPSB0aGlzLmZpbmQoIG5vZGUgKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc3RhdGljSW5mbyggbm9kZSApO1xuICB9XG5cbiAgdmFyIGluc2VydEhvb2sgPSBuZXcgSG9vayggJ2luc2VydCcgKTtcblxuICBmdW5jdGlvbiBSYWN0aXZlJGluc2VydCAoIHRhcmdldCwgYW5jaG9yICkge1xuICBcdGlmICggIXRoaXMuZnJhZ21lbnQucmVuZGVyZWQgKSB7XG4gIFx0XHQvLyBUT0RPIGNyZWF0ZSwgYW5kIGxpbmsgdG8sIGRvY3VtZW50YXRpb24gZXhwbGFpbmluZyB0aGlzXG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUaGUgQVBJIGhhcyBjaGFuZ2VkIC0geW91IG11c3QgY2FsbCBgcmFjdGl2ZS5yZW5kZXIodGFyZ2V0WywgYW5jaG9yXSlgIHRvIHJlbmRlciB5b3VyIFJhY3RpdmUgaW5zdGFuY2UuIE9uY2UgcmVuZGVyZWQgeW91IGNhbiB1c2UgYHJhY3RpdmUuaW5zZXJ0KClgLicgKTtcbiAgXHR9XG5cbiAgXHR0YXJnZXQgPSBnZXRFbGVtZW50KCB0YXJnZXQgKTtcbiAgXHRhbmNob3IgPSBnZXRFbGVtZW50KCBhbmNob3IgKSB8fCBudWxsO1xuXG4gIFx0aWYgKCAhdGFyZ2V0ICkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKCAnWW91IG11c3Qgc3BlY2lmeSBhIHZhbGlkIHRhcmdldCB0byBpbnNlcnQgaW50bycgKTtcbiAgXHR9XG5cbiAgXHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCB0aGlzLmRldGFjaCgpLCBhbmNob3IgKTtcbiAgXHR0aGlzLmVsID0gdGFyZ2V0O1xuXG4gIFx0KCB0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fIHx8ICggdGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyA9IFtdICkgKS5wdXNoKCB0aGlzICk7XG4gIFx0dGhpcy5pc0RldGFjaGVkID0gZmFsc2U7XG5cbiAgXHRmaXJlSW5zZXJ0SG9vayggdGhpcyApO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUluc2VydEhvb2soIHJhY3RpdmUgKSB7XG4gIFx0aW5zZXJ0SG9vay5maXJlKCByYWN0aXZlICk7XG5cbiAgXHRyYWN0aXZlLmZpbmRBbGxDb21wb25lbnRzKCcqJykuZm9yRWFjaCggZnVuY3Rpb24gKCBjaGlsZCApIHtcbiAgXHRcdGZpcmVJbnNlcnRIb29rKCBjaGlsZC5pbnN0YW5jZSApO1xuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbGluayQxKCB0aGVyZSwgaGVyZSApIHtcbiAgXHRpZiAoIGhlcmUgPT09IHRoZXJlIHx8ICh0aGVyZSArICcuJykuaW5kZXhPZiggaGVyZSArICcuJyApID09PSAwIHx8IChoZXJlICsgJy4nKS5pbmRleE9mKCB0aGVyZSArICcuJyApID09PSAwICkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKCAnQSBrZXlwYXRoIGNhbm5vdCBiZSBsaW5rZWQgdG8gaXRzZWxmLicgKTtcbiAgXHR9XG5cbiAgXHR2YXIgcHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoKTtcbiAgXHR2YXIgbW9kZWw7XG5cbiAgXHQvLyBtYXkgbmVlZCB0byBhbGxvdyBhIG1hcHBpbmcgdG8gcmVzb2x2ZSBpbXBsaWNpdGx5XG4gIFx0dmFyIHNvdXJjZVBhdGggPSBzcGxpdEtleXBhdGhJKCB0aGVyZSApO1xuICBcdGlmICggIXRoaXMudmlld21vZGVsLmhhcyggc291cmNlUGF0aFswXSApICYmIHRoaXMuY29tcG9uZW50ICkge1xuICBcdFx0bW9kZWwgPSByZXNvbHZlUmVmZXJlbmNlKCB0aGlzLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCwgc291cmNlUGF0aFswXSApO1xuICBcdFx0bW9kZWwgPSBtb2RlbC5qb2luQWxsKCBzb3VyY2VQYXRoLnNsaWNlKCAxICkgKTtcbiAgXHR9XG5cbiAgXHR0aGlzLnZpZXdtb2RlbC5qb2luQWxsKCBzcGxpdEtleXBhdGhJKCBoZXJlICkgKS5saW5rKCBtb2RlbCB8fCB0aGlzLnZpZXdtb2RlbC5qb2luQWxsKCBzb3VyY2VQYXRoICksIHRoZXJlICk7XG5cbiAgXHRydW5sb29wLmVuZCgpO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgUmVmZXJlbmNlUmVzb2x2ZXIgPSBmdW5jdGlvbiBSZWZlcmVuY2VSZXNvbHZlciAoIGZyYWdtZW50LCByZWZlcmVuY2UsIGNhbGxiYWNrICkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHR0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gIFx0dGhpcy5yZWZlcmVuY2UgPSBub3JtYWxpc2UoIHJlZmVyZW5jZSApO1xuICBcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBcdHRoaXMua2V5cyA9IHNwbGl0S2V5cGF0aEkoIHJlZmVyZW5jZSApO1xuICBcdHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcblxuICBcdHRoaXMuY29udGV4dHMgPSBbXTtcblxuICBcdC8vIFRPRE8gdGhlIGNvbnN1bWVyIHNob3VsZCB0YWtlIGNhcmUgb2YgYWRkVW5yZXNvbHZlZFxuICBcdC8vIHdlIGF0dGFjaCB0byBhbGwgdGhlIGNvbnRleHRzIGJldHdlZW4gaGVyZSBhbmQgdGhlIHJvb3RcbiAgXHQvLyAtIHdoZW5ldmVyIHRoZWlyIHZhbHVlcyBjaGFuZ2UsIHRoZXkgY2FuIHF1aWNrbHlcbiAgXHQvLyBjaGVjayB0byBzZWUgaWYgd2UgY2FuIHJlc29sdmVcbiAgXHR3aGlsZSAoIGZyYWdtZW50ICkge1xuICBcdFx0aWYgKCBmcmFnbWVudC5jb250ZXh0ICkge1xuICBcdFx0XHRmcmFnbWVudC5jb250ZXh0LmFkZFVucmVzb2x2ZWQoIHRoaXMkMS5rZXlzWzBdLCB0aGlzJDEgKTtcbiAgXHRcdFx0dGhpcyQxLmNvbnRleHRzLnB1c2goIGZyYWdtZW50LmNvbnRleHQgKTtcbiAgXHRcdH1cblxuICBcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5jb21wb25lbnRQYXJlbnQgfHwgZnJhZ21lbnQucGFyZW50O1xuICBcdH1cbiAgfTtcblxuICBSZWZlcmVuY2VSZXNvbHZlci5wcm90b3R5cGUuYXR0ZW1wdFJlc29sdXRpb24gPSBmdW5jdGlvbiBhdHRlbXB0UmVzb2x1dGlvbiAoKSB7XG4gIFx0aWYgKCB0aGlzLnJlc29sdmVkICkgcmV0dXJuO1xuXG4gIFx0dmFyIG1vZGVsID0gcmVzb2x2ZUFtYmlndW91c1JlZmVyZW5jZSggdGhpcy5mcmFnbWVudCwgdGhpcy5yZWZlcmVuY2UgKTtcblxuICBcdGlmICggbW9kZWwgKSB7XG4gIFx0XHR0aGlzLnJlc29sdmVkID0gdHJ1ZTtcbiAgXHRcdHRoaXMuY2FsbGJhY2soIG1vZGVsICk7XG4gIFx0fVxuICB9O1xuXG4gIFJlZmVyZW5jZVJlc29sdmVyLnByb3RvdHlwZS5mb3JjZVJlc29sdXRpb24gPSBmdW5jdGlvbiBmb3JjZVJlc29sdXRpb24gKCkge1xuICBcdGlmICggdGhpcy5yZXNvbHZlZCApIHJldHVybjtcblxuICBcdHZhciBtb2RlbCA9IHRoaXMuZnJhZ21lbnQuZmluZENvbnRleHQoKS5qb2luQWxsKCB0aGlzLmtleXMgKTtcbiAgXHR0aGlzLmNhbGxiYWNrKCBtb2RlbCApO1xuICBcdHRoaXMucmVzb2x2ZWQgPSB0cnVlO1xuICB9O1xuXG4gIFJlZmVyZW5jZVJlc29sdmVyLnByb3RvdHlwZS5yZWJpbmRpbmcgPSBmdW5jdGlvbiByZWJpbmRpbmcgKCBuZXh0LCBwcmV2aW91cyApIHtcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0aWYgKCBwcmV2aW91cyApIHByZXZpb3VzLnJlbW92ZVVucmVzb2x2ZWQoIHRoaXMua2V5c1swXSwgdGhpcyApO1xuICBcdGlmICggbmV4dCApIHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXh0LmFkZFVucmVzb2x2ZWQoIHRoaXMkMS5rZXlzWzBdLCB0aGlzJDEgKTsgfSApO1xuICB9O1xuXG4gIFJlZmVyZW5jZVJlc29sdmVyLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiB1bmJpbmQgKCkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSByZW1vdmVGcm9tQXJyYXkoIHRoaXMuZnJhZ21lbnQudW5yZXNvbHZlZCwgdGhpcyApO1xuXG4gIFx0aWYgKCB0aGlzLnJlc29sdmVkICkgcmV0dXJuO1xuXG4gIFx0dGhpcy5jb250ZXh0cy5mb3JFYWNoKCBmdW5jdGlvbiAoIGMgKSB7IHJldHVybiBjLnJlbW92ZVVucmVzb2x2ZWQoIHRoaXMkMS5rZXlzWzBdLCB0aGlzJDEgKTsgfSApO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG9ic2VydmUgKCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApIHtcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdHZhciBvYnNlcnZlcnMgPSBbXTtcbiAgXHR2YXIgbWFwO1xuXG4gIFx0aWYgKCBpc09iamVjdCgga2V5cGF0aCApICkge1xuICBcdFx0bWFwID0ga2V5cGF0aDtcbiAgXHRcdG9wdGlvbnMgPSBjYWxsYmFjayB8fCB7fTtcblxuICBcdFx0T2JqZWN0LmtleXMoIG1hcCApLmZvckVhY2goIGZ1bmN0aW9uICgga2V5cGF0aCApIHtcbiAgXHRcdFx0dmFyIGNhbGxiYWNrID0gbWFwWyBrZXlwYXRoIF07XG5cbiAgXHRcdFx0dmFyIGtleXBhdGhzID0ga2V5cGF0aC5zcGxpdCggJyAnICk7XG4gIFx0XHRcdGlmICgga2V5cGF0aHMubGVuZ3RoID4gMSApIGtleXBhdGhzID0ga2V5cGF0aHMuZmlsdGVyKCBmdW5jdGlvbiAoIGsgKSB7IHJldHVybiBrOyB9ICk7XG5cbiAgXHRcdFx0a2V5cGF0aHMuZm9yRWFjaCggZnVuY3Rpb24gKCBrZXlwYXRoICkge1xuICBcdFx0XHRcdG9ic2VydmVycy5wdXNoKCBjcmVhdGVPYnNlcnZlciggdGhpcyQxLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApICk7XG4gIFx0XHRcdH0pO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0ZWxzZSB7XG4gIFx0XHR2YXIga2V5cGF0aHM7XG5cbiAgXHRcdGlmICggdHlwZW9mIGtleXBhdGggPT09ICdmdW5jdGlvbicgKSB7XG4gIFx0XHRcdG9wdGlvbnMgPSBjYWxsYmFjaztcbiAgXHRcdFx0Y2FsbGJhY2sgPSBrZXlwYXRoO1xuICBcdFx0XHRrZXlwYXRocyA9IFsgJycgXTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGtleXBhdGhzID0ga2V5cGF0aC5zcGxpdCggJyAnICk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICgga2V5cGF0aHMubGVuZ3RoID4gMSApIGtleXBhdGhzID0ga2V5cGF0aHMuZmlsdGVyKCBmdW5jdGlvbiAoIGsgKSB7IHJldHVybiBrOyB9ICk7XG5cbiAgXHRcdGtleXBhdGhzLmZvckVhY2goIGZ1bmN0aW9uICgga2V5cGF0aCApIHtcbiAgXHRcdFx0b2JzZXJ2ZXJzLnB1c2goIGNyZWF0ZU9ic2VydmVyKCB0aGlzJDEsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zIHx8IHt9ICkgKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdC8vIGFkZCBvYnNlcnZlcnMgdG8gdGhlIFJhY3RpdmUgaW5zdGFuY2UsIHNvIHRoZXkgY2FuIGJlXG4gIFx0Ly8gY2FuY2VsbGVkIG9uIHJhY3RpdmUudGVhcmRvd24oKVxuICBcdHRoaXMuX29ic2VydmVycy5wdXNoLmFwcGx5KCB0aGlzLl9vYnNlcnZlcnMsIG9ic2VydmVycyApO1xuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRvYnNlcnZlcnMuZm9yRWFjaCggZnVuY3Rpb24gKCBvYnNlcnZlciApIHtcbiAgXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkgKCB0aGlzJDEuX29ic2VydmVycywgb2JzZXJ2ZXIgKTtcbiAgXHRcdFx0XHRvYnNlcnZlci5jYW5jZWwoKTtcbiAgXHRcdFx0fSApO1xuICBcdFx0fVxuICBcdH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYnNlcnZlciAoIHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkge1xuICBcdHZhciB2aWV3bW9kZWwgPSByYWN0aXZlLnZpZXdtb2RlbDtcblxuICBcdHZhciBrZXlzID0gc3BsaXRLZXlwYXRoSSgga2V5cGF0aCApO1xuICBcdHZhciB3aWxkY2FyZEluZGV4ID0ga2V5cy5pbmRleE9mKCAnKicgKTtcbiAgXHRvcHRpb25zLmtleXBhdGggPSBrZXlwYXRoO1xuXG4gIFx0Ly8gbm9ybWFsIGtleXBhdGggLSBubyB3aWxkY2FyZHNcbiAgXHRpZiAoICF+d2lsZGNhcmRJbmRleCApIHtcbiAgXHRcdHZhciBrZXkgPSBrZXlzWzBdO1xuICBcdFx0dmFyIG1vZGVsO1xuXG4gIFx0XHQvLyBpZiBub3QgdGhlIHJvb3QgbW9kZWwgaXRzZWxmLCBjaGVjayBpZiB2aWV3bW9kZWwgaGFzIGtleS5cbiAgXHRcdGlmICgga2V5ICE9PSAnJyAmJiAhdmlld21vZGVsLmhhcygga2V5ICkgKSB7XG4gIFx0XHRcdC8vIGlmIHRoaXMgaXMgYW4gaW5saW5lIGNvbXBvbmVudCwgd2UgbWF5IG5lZWQgdG8gY3JlYXRlIGFuIGltcGxpY2l0IG1hcHBpbmdcbiAgXHRcdFx0aWYgKCByYWN0aXZlLmNvbXBvbmVudCAmJiAhcmFjdGl2ZS5pc29sYXRlZCApIHtcbiAgXHRcdFx0XHRtb2RlbCA9IHJlc29sdmVSZWZlcmVuY2UoIHJhY3RpdmUuY29tcG9uZW50LnBhcmVudEZyYWdtZW50LCBrZXkgKTtcbiAgXHRcdFx0XHRpZiAoIG1vZGVsICkge1xuICBcdFx0XHRcdFx0dmlld21vZGVsLm1hcCgga2V5LCBtb2RlbCApO1xuICBcdFx0XHRcdFx0bW9kZWwgPSB2aWV3bW9kZWwuam9pbkFsbCgga2V5cyApO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0bW9kZWwgPSB2aWV3bW9kZWwuam9pbkFsbCgga2V5cyApO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbmV3IE9ic2VydmVyKCByYWN0aXZlLCBtb2RlbCwgY2FsbGJhY2ssIG9wdGlvbnMgKTtcbiAgXHR9XG5cbiAgXHQvLyBwYXR0ZXJuIG9ic2VydmVycyAtIG1vcmUgY29tcGxleCBjYXNlXG4gIFx0dmFyIGJhc2VNb2RlbCA9IHdpbGRjYXJkSW5kZXggPT09IDAgP1xuICBcdFx0dmlld21vZGVsIDpcbiAgXHRcdHZpZXdtb2RlbC5qb2luQWxsKCBrZXlzLnNsaWNlKCAwLCB3aWxkY2FyZEluZGV4ICkgKTtcblxuICBcdHJldHVybiBuZXcgUGF0dGVybk9ic2VydmVyKCByYWN0aXZlLCBiYXNlTW9kZWwsIGtleXMuc3BsaWNlKCB3aWxkY2FyZEluZGV4ICksIGNhbGxiYWNrLCBvcHRpb25zICk7XG4gIH1cblxuICB2YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAoIHJhY3RpdmUsIG1vZGVsLCBjYWxsYmFjaywgb3B0aW9ucyApIHtcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dGhpcy5jb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0IHx8IHJhY3RpdmU7XG4gIFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICBcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG5cbiAgXHRpZiAoIG1vZGVsICkgdGhpcy5yZXNvbHZlZCggbW9kZWwgKTtcbiAgXHRlbHNlIHtcbiAgXHRcdHRoaXMua2V5cGF0aCA9IG9wdGlvbnMua2V5cGF0aDtcbiAgXHRcdHRoaXMucmVzb2x2ZXIgPSBuZXcgUmVmZXJlbmNlUmVzb2x2ZXIoIHJhY3RpdmUuZnJhZ21lbnQsIG9wdGlvbnMua2V5cGF0aCwgZnVuY3Rpb24gKCBtb2RlbCApIHtcbiAgXHRcdFx0dGhpcyQxLnJlc29sdmVkKCBtb2RlbCApO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0aWYgKCBvcHRpb25zLmluaXQgIT09IGZhbHNlICkge1xuICBcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG4gIFx0XHR0aGlzLmRpc3BhdGNoKCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHRoaXMub2xkVmFsdWUgPSB0aGlzLm5ld1ZhbHVlO1xuICBcdH1cblxuICBcdHRoaXMuZGVmZXIgPSBvcHRpb25zLmRlZmVyO1xuICBcdHRoaXMub25jZSA9IG9wdGlvbnMub25jZTtcbiAgXHR0aGlzLnN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuXG4gIFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9O1xuXG4gIE9ic2VydmVyLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwgKCkge1xuICBcdHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgXHRpZiAoIHRoaXMubW9kZWwgKSB7XG4gIFx0XHR0aGlzLm1vZGVsLnVucmVnaXN0ZXIoIHRoaXMgKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0dGhpcy5yZXNvbHZlci51bmJpbmQoKTtcbiAgXHR9XG4gIH07XG5cbiAgT2JzZXJ2ZXIucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2ggKCkge1xuICBcdGlmICggIXRoaXMuY2FuY2VsbGVkICkge1xuICBcdFx0dGhpcy5jYWxsYmFjay5jYWxsKCB0aGlzLmNvbnRleHQsIHRoaXMubmV3VmFsdWUsIHRoaXMub2xkVmFsdWUsIHRoaXMua2V5cGF0aCApO1xuICBcdFx0dGhpcy5vbGRWYWx1ZSA9IHRoaXMubW9kZWwgPyB0aGlzLm1vZGVsLmdldCgpIDogdGhpcy5uZXdWYWx1ZTtcbiAgXHRcdHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgXHR9XG4gIH07XG5cbiAgT2JzZXJ2ZXIucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSAoKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdGlmICggIXRoaXMuZGlydHkgKSB7XG4gIFx0XHR2YXIgbmV3VmFsdWUgPSB0aGlzLm1vZGVsLmdldCgpO1xuICBcdFx0aWYgKCBpc0VxdWFsKCBuZXdWYWx1ZSwgdGhpcy5vbGRWYWx1ZSApICkgcmV0dXJuO1xuXG4gIFx0XHR0aGlzLm5ld1ZhbHVlID0gbmV3VmFsdWU7XG5cbiAgXHRcdGlmICggdGhpcy5zdHJpY3QgJiYgdGhpcy5uZXdWYWx1ZSA9PT0gdGhpcy5vbGRWYWx1ZSApIHJldHVybjtcblxuICBcdFx0cnVubG9vcC5hZGRPYnNlcnZlciggdGhpcywgdGhpcy5kZWZlciApO1xuICBcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgXHRcdGlmICggdGhpcy5vbmNlICkgcnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5jYW5jZWwoKTsgfSApO1xuICBcdH1cbiAgfTtcblxuICBPYnNlcnZlci5wcm90b3R5cGUucmViaW5kaW5nID0gZnVuY3Rpb24gcmViaW5kaW5nICggbmV4dCwgcHJldmlvdXMgKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdG5leHQgPSByZWJpbmRNYXRjaCggdGhpcy5rZXlwYXRoLCBuZXh0LCBwcmV2aW91cyApO1xuICBcdC8vIFRPRE86IHNldCB1cCBhIHJlc29sdmVyIGlmIG5leHQgaXMgdW5kZWZpbmVkP1xuICBcdGlmICggbmV4dCA9PT0gdGhpcy5tb2RlbCApIHJldHVybiBmYWxzZTtcblxuICBcdGlmICggdGhpcy5tb2RlbCApIHRoaXMubW9kZWwudW5yZWdpc3RlciggdGhpcyApO1xuICBcdGlmICggbmV4dCApIG5leHQuYWRkU2h1ZmZsZVRhc2soIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5yZXNvbHZlZCggbmV4dCApOyB9ICk7XG4gIH07XG5cbiAgT2JzZXJ2ZXIucHJvdG90eXBlLnJlc29sdmVkID0gZnVuY3Rpb24gcmVzb2x2ZWQgKCBtb2RlbCApIHtcbiAgXHR0aGlzLm1vZGVsID0gbW9kZWw7XG4gIFx0dGhpcy5rZXlwYXRoID0gbW9kZWwuZ2V0S2V5cGF0aCggdGhpcy5yYWN0aXZlICk7XG5cbiAgXHR0aGlzLm9sZFZhbHVlID0gdW5kZWZpbmVkO1xuICBcdHRoaXMubmV3VmFsdWUgPSBtb2RlbC5nZXQoKTtcblxuICBcdG1vZGVsLnJlZ2lzdGVyKCB0aGlzICk7XG4gIH07XG5cbiAgdmFyIFBhdHRlcm5PYnNlcnZlciA9IGZ1bmN0aW9uIFBhdHRlcm5PYnNlcnZlciAoIHJhY3RpdmUsIGJhc2VNb2RlbCwga2V5cywgY2FsbGJhY2ssIG9wdGlvbnMgKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCB8fCByYWN0aXZlO1xuICBcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG4gIFx0dGhpcy5iYXNlTW9kZWwgPSBiYXNlTW9kZWw7XG4gIFx0dGhpcy5rZXlzID0ga2V5cztcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgXHR2YXIgcGF0dGVybiA9IGtleXMuam9pbiggJ1xcXFwuJyApLnJlcGxhY2UoIC9cXCovZywgJyguKyknICk7XG4gIFx0dmFyIGJhc2VLZXlwYXRoID0gYmFzZU1vZGVsLmdldEtleXBhdGgoIHJhY3RpdmUgKTtcbiAgXHR0aGlzLnBhdHRlcm4gPSBuZXcgUmVnRXhwKCAoXCJeXCIgKyAoYmFzZUtleXBhdGggPyBiYXNlS2V5cGF0aCArICdcXFxcLicgOiAnJykgKyBcIlwiICsgcGF0dGVybiArIFwiJFwiKSApO1xuXG4gIFx0dGhpcy5vbGRWYWx1ZXMgPSB7fTtcbiAgXHR0aGlzLm5ld1ZhbHVlcyA9IHt9O1xuXG4gIFx0dGhpcy5kZWZlciA9IG9wdGlvbnMuZGVmZXI7XG4gIFx0dGhpcy5vbmNlID0gb3B0aW9ucy5vbmNlO1xuICBcdHRoaXMuc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG5cbiAgXHR0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIFx0dGhpcy5jaGFuZ2VkID0gW107XG4gIFx0dGhpcy5wYXJ0aWFsID0gZmFsc2U7XG5cbiAgXHR2YXIgbW9kZWxzID0gYmFzZU1vZGVsLmZpbmRNYXRjaGVzKCB0aGlzLmtleXMgKTtcblxuICBcdG1vZGVscy5mb3JFYWNoKCBmdW5jdGlvbiAoIG1vZGVsICkge1xuICBcdFx0dGhpcyQxLm5ld1ZhbHVlc1sgbW9kZWwuZ2V0S2V5cGF0aCggdGhpcyQxLnJhY3RpdmUgKSBdID0gbW9kZWwuZ2V0KCk7XG4gIFx0fSk7XG5cbiAgXHRpZiAoIG9wdGlvbnMuaW5pdCAhPT0gZmFsc2UgKSB7XG4gIFx0XHR0aGlzLmRpc3BhdGNoKCk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHRoaXMub2xkVmFsdWVzID0gdGhpcy5uZXdWYWx1ZXM7XG4gIFx0fVxuXG4gIFx0YmFzZU1vZGVsLnJlZ2lzdGVyUGF0dGVybk9ic2VydmVyKCB0aGlzICk7XG4gIH07XG5cbiAgUGF0dGVybk9ic2VydmVyLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwgKCkge1xuICBcdHRoaXMuYmFzZU1vZGVsLnVucmVnaXN0ZXJQYXR0ZXJuT2JzZXJ2ZXIoIHRoaXMgKTtcbiAgfTtcblxuICBQYXR0ZXJuT2JzZXJ2ZXIucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2ggKCkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHRPYmplY3Qua2V5cyggdGhpcy5uZXdWYWx1ZXMgKS5mb3JFYWNoKCBmdW5jdGlvbiAoIGtleXBhdGggKSB7XG4gIFx0XHRpZiAoIHRoaXMkMS5uZXdLZXlzICYmICF0aGlzJDEubmV3S2V5c1sga2V5cGF0aCBdICkgcmV0dXJuO1xuXG4gIFx0XHR2YXIgbmV3VmFsdWUgPSB0aGlzJDEubmV3VmFsdWVzWyBrZXlwYXRoIF07XG4gIFx0XHR2YXIgb2xkVmFsdWUgPSB0aGlzJDEub2xkVmFsdWVzWyBrZXlwYXRoIF07XG5cbiAgXHRcdGlmICggdGhpcyQxLnN0cmljdCAmJiBuZXdWYWx1ZSA9PT0gb2xkVmFsdWUgKSByZXR1cm47XG4gIFx0XHRpZiAoIGlzRXF1YWwoIG5ld1ZhbHVlLCBvbGRWYWx1ZSApICkgcmV0dXJuO1xuXG4gIFx0XHR2YXIgYXJncyA9IFsgbmV3VmFsdWUsIG9sZFZhbHVlLCBrZXlwYXRoIF07XG4gIFx0XHRpZiAoIGtleXBhdGggKSB7XG4gIFx0XHRcdHZhciB3aWxkY2FyZHMgPSB0aGlzJDEucGF0dGVybi5leGVjKCBrZXlwYXRoICk7XG4gIFx0XHRcdGlmICggd2lsZGNhcmRzICkge1xuICBcdFx0XHRcdGFyZ3MgPSBhcmdzLmNvbmNhdCggd2lsZGNhcmRzLnNsaWNlKCAxICkgKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzJDEuY2FsbGJhY2suYXBwbHkoIHRoaXMkMS5jb250ZXh0LCBhcmdzICk7XG4gIFx0fSk7XG5cbiAgXHRpZiAoIHRoaXMucGFydGlhbCApIHtcbiAgXHRcdGZvciAoIHZhciBrIGluIHRoaXMubmV3VmFsdWVzICkge1xuICBcdFx0XHR0aGlzLm9sZFZhbHVlc1trXSA9IHRoaXMubmV3VmFsdWVzW2tdO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHR0aGlzLm9sZFZhbHVlcyA9IHRoaXMubmV3VmFsdWVzO1xuICBcdH1cblxuICBcdHRoaXMubmV3S2V5cyA9IG51bGw7XG4gIFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9O1xuXG4gIFBhdHRlcm5PYnNlcnZlci5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgga2V5ICkge1xuICBcdHRoaXMuY2hhbmdlZC5wdXNoKCBrZXkgKTtcbiAgfTtcblxuICBQYXR0ZXJuT2JzZXJ2ZXIucHJvdG90eXBlLnNodWZmbGUgPSBmdW5jdGlvbiBzaHVmZmxlICggbmV3SW5kaWNlcyApIHtcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0aWYgKCAhaXNBcnJheSggdGhpcy5iYXNlTW9kZWwudmFsdWUgKSApIHJldHVybjtcblxuICBcdHZhciBiYXNlID0gdGhpcy5iYXNlTW9kZWwuZ2V0S2V5cGF0aCggdGhpcy5yYWN0aXZlICk7XG4gIFx0dmFyIG1heCA9IHRoaXMuYmFzZU1vZGVsLnZhbHVlLmxlbmd0aDtcbiAgXHR2YXIgc3VmZml4ID0gdGhpcy5rZXlzLmxlbmd0aCA+IDEgPyAnLicgKyB0aGlzLmtleXMuc2xpY2UoIDEgKS5qb2luKCAnLicgKSA6ICcnO1xuXG4gIFx0dGhpcy5uZXdLZXlzID0ge307XG4gIFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbmV3SW5kaWNlcy5sZW5ndGg7IGkrKyApIHtcbiAgXHRcdGlmICggbmV3SW5kaWNlc1sgaSBdID09PSAtMSB8fCBuZXdJbmRpY2VzWyBpIF0gPT09IGkgKSBjb250aW51ZTtcbiAgXHRcdHRoaXMkMS5uZXdLZXlzWyAoXCJcIiArIGJhc2UgKyBcIi5cIiArIGkgKyBcIlwiICsgc3VmZml4KSBdID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHRmb3IgKCB2YXIgaSQxID0gbmV3SW5kaWNlcy50b3VjaGVkRnJvbTsgaSQxIDwgbWF4OyBpJDErKyApIHtcbiAgXHRcdHRoaXMkMS5uZXdLZXlzWyAoXCJcIiArIGJhc2UgKyBcIi5cIiArIGkkMSArIFwiXCIgKyBzdWZmaXgpIF0gPSB0cnVlO1xuICBcdH1cbiAgfTtcblxuICBQYXR0ZXJuT2JzZXJ2ZXIucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSAoKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdGlmICggIXRoaXMuZGlydHkgfHwgdGhpcy5jaGFuZ2VkLmxlbmd0aCApIHtcbiAgXHRcdGlmICggIXRoaXMuZGlydHkgKSB0aGlzLm5ld1ZhbHVlcyA9IHt9O1xuXG4gIFx0XHQvLyBoYW5kbGUgY2FzZSB3aGVyZSBwcmV2aW91c2x5IGV4dGFudCBrZXlwYXRoIG5vIGxvbmdlciBleGlzdHMgLVxuICBcdFx0Ly8gb2JzZXJ2ZXIgc2hvdWxkIHN0aWxsIGZpcmUsIHdpdGggdW5kZWZpbmVkIGFzIG5ldyB2YWx1ZVxuICBcdFx0Ly8gVE9ETyBodWguIGFjY29yZGluZyB0byB0aGUgdGVzdCBzdWl0ZSB0aGF0J3Mgbm90IHRoZSBjYXNlLi4uXG4gIFx0XHQvLyBOT1RFOiBJIGRvbid0IHRoaW5rIHRoaXMgd2lsbCB3b3JrIHdpdGggcGFydGlhbCB1cGRhdGVzXG4gIFx0XHQvLyBPYmplY3Qua2V5cyggdGhpcy5vbGRWYWx1ZXMgKS5mb3JFYWNoKCBrZXlwYXRoID0+IHtcbiAgXHRcdC8vIHRoaXMubmV3VmFsdWVzWyBrZXlwYXRoIF0gPSB1bmRlZmluZWQ7XG4gIFx0XHQvLyB9KTtcblxuICBcdFx0aWYgKCAhdGhpcy5jaGFuZ2VkLmxlbmd0aCApIHtcbiAgXHRcdFx0dGhpcy5iYXNlTW9kZWwuZmluZE1hdGNoZXMoIHRoaXMua2V5cyApLmZvckVhY2goIGZ1bmN0aW9uICggbW9kZWwgKSB7XG4gIFx0XHRcdFx0dmFyIGtleXBhdGggPSBtb2RlbC5nZXRLZXlwYXRoKCB0aGlzJDEucmFjdGl2ZSApO1xuICBcdFx0XHRcdHRoaXMkMS5uZXdWYWx1ZXNbIGtleXBhdGggXSA9IG1vZGVsLmdldCgpO1xuICBcdFx0XHR9KTtcbiAgXHRcdFx0dGhpcy5wYXJ0aWFsID0gZmFsc2U7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR2YXIgY291bnQgPSAwO1xuICBcdFx0XHR2YXIgb2sgPSB0aGlzLmJhc2VNb2RlbC5pc1Jvb3QgP1xuICBcdFx0XHRcdHRoaXMuY2hhbmdlZC5tYXAoIGZ1bmN0aW9uICgga2V5cyApIHsgcmV0dXJuIGtleXMubWFwKCBlc2NhcGVLZXkgKS5qb2luKCAnLicgKTsgfSApIDpcbiAgXHRcdFx0XHR0aGlzLmNoYW5nZWQubWFwKCBmdW5jdGlvbiAoIGtleXMgKSB7IHJldHVybiB0aGlzJDEuYmFzZU1vZGVsLmdldEtleXBhdGgoIHRoaXMkMS5yYWN0aXZlICkgKyAnLicgKyBrZXlzLm1hcCggZXNjYXBlS2V5ICkuam9pbiggJy4nICk7IH0gKTtcblxuICBcdFx0XHR0aGlzLmJhc2VNb2RlbC5maW5kTWF0Y2hlcyggdGhpcy5rZXlzICkuZm9yRWFjaCggZnVuY3Rpb24gKCBtb2RlbCApIHtcbiAgXHRcdFx0XHR2YXIga2V5cGF0aCA9IG1vZGVsLmdldEtleXBhdGgoIHRoaXMkMS5yYWN0aXZlICk7XG4gIFx0XHRcdFx0Ly8gaXMgdGhpcyBtb2RlbCBvbiBhIGNoYW5nZWQga2V5cGF0aD9cbiAgXHRcdFx0XHRpZiAoIG9rLmZpbHRlciggZnVuY3Rpb24gKCBrICkgeyByZXR1cm4ga2V5cGF0aC5pbmRleE9mKCBrICkgPT09IDAgfHwgay5pbmRleE9mKCBrZXlwYXRoICkgPT09IDA7IH0gKS5sZW5ndGggKSB7XG4gIFx0XHRcdFx0XHRjb3VudCsrO1xuICBcdFx0XHRcdFx0dGhpcyQxLm5ld1ZhbHVlc1sga2V5cGF0aCBdID0gbW9kZWwuZ2V0KCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9KTtcblxuICBcdFx0XHQvLyBubyB2YWxpZCBjaGFuZ2UgdHJpZ2dlcmVkLCBzbyBiYWlsIHRvIGF2b2lkIGJyZWFrYWdlXG4gIFx0XHRcdGlmICggIWNvdW50ICkgcmV0dXJuO1xuXG4gIFx0XHRcdHRoaXMucGFydGlhbCA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdHJ1bmxvb3AuYWRkT2JzZXJ2ZXIoIHRoaXMsIHRoaXMuZGVmZXIgKTtcbiAgXHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuICBcdFx0dGhpcy5jaGFuZ2VkLmxlbmd0aCA9IDA7XG5cbiAgXHRcdGlmICggdGhpcy5vbmNlICkgdGhpcy5jYW5jZWwoKTtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gb2JzZXJ2ZUxpc3QgKCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApIHtcbiAgXHRpZiAoIHR5cGVvZiBrZXlwYXRoICE9PSAnc3RyaW5nJyApIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvciggJ3JhY3RpdmUub2JzZXJ2ZUxpc3QoKSBtdXN0IGJlIHBhc3NlZCBhIHN0cmluZyBhcyBpdHMgZmlyc3QgYXJndW1lbnQnICk7XG4gIFx0fVxuXG4gIFx0dmFyIG1vZGVsID0gdGhpcy52aWV3bW9kZWwuam9pbkFsbCggc3BsaXRLZXlwYXRoSSgga2V5cGF0aCApICk7XG4gIFx0dmFyIG9ic2VydmVyID0gbmV3IExpc3RPYnNlcnZlciggdGhpcywgbW9kZWwsIGNhbGxiYWNrLCBvcHRpb25zIHx8IHt9ICk7XG5cbiAgXHQvLyBhZGQgb2JzZXJ2ZXIgdG8gdGhlIFJhY3RpdmUgaW5zdGFuY2UsIHNvIGl0IGNhbiBiZVxuICBcdC8vIGNhbmNlbGxlZCBvbiByYWN0aXZlLnRlYXJkb3duKClcbiAgXHR0aGlzLl9vYnNlcnZlcnMucHVzaCggb2JzZXJ2ZXIgKTtcblxuICBcdHJldHVybiB7XG4gIFx0XHRjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0b2JzZXJ2ZXIuY2FuY2VsKCk7XG4gIFx0XHR9XG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5lZ2F0aXZlT25lICgpIHtcbiAgXHRyZXR1cm4gLTE7XG4gIH1cblxuICB2YXIgTGlzdE9ic2VydmVyID0gZnVuY3Rpb24gTGlzdE9ic2VydmVyICggY29udGV4dCwgbW9kZWwsIGNhbGxiYWNrLCBvcHRpb25zICkge1xuICBcdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIFx0dGhpcy5tb2RlbCA9IG1vZGVsO1xuICBcdHRoaXMua2V5cGF0aCA9IG1vZGVsLmdldEtleXBhdGgoKTtcbiAgXHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgXHR0aGlzLnBlbmRpbmcgPSBudWxsO1xuXG4gIFx0bW9kZWwucmVnaXN0ZXIoIHRoaXMgKTtcblxuICBcdGlmICggb3B0aW9ucy5pbml0ICE9PSBmYWxzZSApIHtcbiAgXHRcdHRoaXMuc2xpY2VkID0gW107XG4gIFx0XHR0aGlzLnNodWZmbGUoW10pO1xuICBcdFx0dGhpcy5oYW5kbGVDaGFuZ2UoKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0dGhpcy5zbGljZWQgPSB0aGlzLnNsaWNlKCk7XG4gIFx0fVxuICB9O1xuXG4gIExpc3RPYnNlcnZlci5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlICgpIHtcbiAgXHRpZiAoIHRoaXMucGVuZGluZyApIHtcbiAgXHRcdC8vIHBvc3Qtc2h1ZmZsZVxuICBcdFx0dGhpcy5jYWxsYmFjayggdGhpcy5wZW5kaW5nICk7XG4gIFx0XHR0aGlzLnBlbmRpbmcgPSBudWxsO1xuICBcdH1cblxuICBcdGVsc2Uge1xuICBcdFx0Ly8gZW50aXJlIGFycmF5IGNoYW5nZWRcbiAgXHRcdHRoaXMuc2h1ZmZsZSggdGhpcy5zbGljZWQubWFwKCBuZWdhdGl2ZU9uZSApICk7XG4gIFx0XHR0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICBcdH1cbiAgfTtcblxuICBMaXN0T2JzZXJ2ZXIucHJvdG90eXBlLnNodWZmbGUgPSBmdW5jdGlvbiBzaHVmZmxlICggbmV3SW5kaWNlcyApIHtcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dmFyIG5ld1ZhbHVlID0gdGhpcy5zbGljZSgpO1xuXG4gIFx0dmFyIGluc2VydGVkID0gW107XG4gIFx0dmFyIGRlbGV0ZWQgPSBbXTtcbiAgXHR2YXIgc3RhcnQ7XG5cbiAgXHR2YXIgaGFkSW5kZXggPSB7fTtcblxuICBcdG5ld0luZGljZXMuZm9yRWFjaCggZnVuY3Rpb24gKCBuZXdJbmRleCwgb2xkSW5kZXggKSB7XG4gIFx0XHRoYWRJbmRleFsgbmV3SW5kZXggXSA9IHRydWU7XG5cbiAgXHRcdGlmICggbmV3SW5kZXggIT09IG9sZEluZGV4ICYmIHN0YXJ0ID09PSB1bmRlZmluZWQgKSB7XG4gIFx0XHRcdHN0YXJ0ID0gb2xkSW5kZXg7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICggbmV3SW5kZXggPT09IC0xICkge1xuICBcdFx0XHRkZWxldGVkLnB1c2goIHRoaXMkMS5zbGljZWRbIG9sZEluZGV4IF0gKTtcbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdGlmICggc3RhcnQgPT09IHVuZGVmaW5lZCApIHN0YXJ0ID0gbmV3SW5kaWNlcy5sZW5ndGg7XG5cbiAgXHR2YXIgbGVuID0gbmV3VmFsdWUubGVuZ3RoO1xuICBcdGZvciAoIHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuICBcdFx0aWYgKCAhaGFkSW5kZXhbaV0gKSBpbnNlcnRlZC5wdXNoKCBuZXdWYWx1ZVtpXSApO1xuICBcdH1cblxuICBcdHRoaXMucGVuZGluZyA9IHsgaW5zZXJ0ZWQ6IGluc2VydGVkLCBkZWxldGVkOiBkZWxldGVkLCBzdGFydDogc3RhcnQgfTtcbiAgXHR0aGlzLnNsaWNlZCA9IG5ld1ZhbHVlO1xuICB9O1xuXG4gIExpc3RPYnNlcnZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoKSB7XG4gIFx0dmFyIHZhbHVlID0gdGhpcy5tb2RlbC5nZXQoKTtcbiAgXHRyZXR1cm4gaXNBcnJheSggdmFsdWUgKSA/IHZhbHVlLnNsaWNlKCkgOiBbXTtcbiAgfTtcblxuICB2YXIgb25jZU9wdGlvbnMgPSB7IGluaXQ6IGZhbHNlLCBvbmNlOiB0cnVlIH07XG5cbiAgZnVuY3Rpb24gb2JzZXJ2ZU9uY2UgKCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApIHtcbiAgXHRpZiAoIGlzT2JqZWN0KCBrZXlwYXRoICkgfHwgdHlwZW9mIGtleXBhdGggPT09ICdmdW5jdGlvbicgKSB7XG4gIFx0XHRvcHRpb25zID0gZXh0ZW5kT2JqKCBjYWxsYmFjayB8fCB7fSwgb25jZU9wdGlvbnMgKTtcbiAgXHRcdHJldHVybiB0aGlzLm9ic2VydmUoIGtleXBhdGgsIG9wdGlvbnMgKTtcbiAgXHR9XG5cbiAgXHRvcHRpb25zID0gZXh0ZW5kT2JqKCBvcHRpb25zIHx8IHt9LCBvbmNlT3B0aW9ucyApO1xuICBcdHJldHVybiB0aGlzLm9ic2VydmUoIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmltICggc3RyICkgeyByZXR1cm4gc3RyLnRyaW0oKTsgfTtcblxuICBmdW5jdGlvbiBub3RFbXB0eVN0cmluZyAoIHN0ciApIHsgcmV0dXJuIHN0ciAhPT0gJyc7IH07XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRvZmYgKCBldmVudE5hbWUsIGNhbGxiYWNrICkge1xuICBcdC8vIGlmIG5vIGFyZ3VtZW50cyBzcGVjaWZpZWQsIHJlbW92ZSBhbGwgY2FsbGJhY2tzXG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRpZiAoICFldmVudE5hbWUgKSB7XG4gIFx0XHQvLyBUT0RPIHVzZSB0aGlzIGNvZGUgaW5zdGVhZCwgb25jZSB0aGUgZm9sbG93aW5nIGlzc3VlIGhhcyBiZWVuIHJlc29sdmVkXG4gIFx0XHQvLyBpbiBQaGFudG9tSlMgKHRlc3RzIGFyZSB1bnBhc3NhYmxlIG90aGVyd2lzZSEpXG4gIFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTg1NlxuICBcdFx0Ly8gZGVmaW5lUHJvcGVydHkoIHRoaXMsICdfc3VicycsIHsgdmFsdWU6IGNyZWF0ZSggbnVsbCApLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIFx0XHRmb3IgKCBldmVudE5hbWUgaW4gdGhpcy5fc3VicyApIHtcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuX3N1YnNbIGV2ZW50TmFtZSBdO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGVsc2Uge1xuICBcdFx0Ly8gSGFuZGxlIG11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lc1xuICBcdFx0dmFyIGV2ZW50TmFtZXMgPSBldmVudE5hbWUuc3BsaXQoICcgJyApLm1hcCggdHJpbSApLmZpbHRlciggbm90RW1wdHlTdHJpbmcgKTtcblxuICBcdFx0ZXZlbnROYW1lcy5mb3JFYWNoKCBmdW5jdGlvbiAoIGV2ZW50TmFtZSApIHtcbiAgXHRcdFx0dmFyIHN1YnNjcmliZXJzID0gdGhpcyQxLl9zdWJzWyBldmVudE5hbWUgXTtcblxuICBcdFx0XHQvLyBJZiB3ZSBoYXZlIHN1YnNjcmliZXJzIGZvciB0aGlzIGV2ZW50Li4uXG4gIFx0XHRcdGlmICggc3Vic2NyaWJlcnMgKSB7XG4gIFx0XHRcdFx0Ly8gLi4uaWYgYSBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCBvbmx5IHJlbW92ZSB0aGF0XG4gIFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcbiAgXHRcdFx0XHRcdC8vIGZsYWcgdGhpcyBjYWxsYmFjayBhcyBvZmYgc28gdGhhdCBhbnkgaW4tZmxpZ2h0IGZpcmluZ3MgZG9uJ3QgY2FsbFxuICBcdFx0XHRcdFx0Ly8gYSBjYW5jZWxsZWQgaGFuZGxlciAtIHRoaXMgaXMgX3NsaWdodGx5XyBoYWNreVxuICBcdFx0XHRcdFx0Y2FsbGJhY2sub2ZmID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdHZhciBpbmRleCA9IHN1YnNjcmliZXJzLmluZGV4T2YoIGNhbGxiYWNrICk7XG4gIFx0XHRcdFx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcbiAgXHRcdFx0XHRcdFx0c3Vic2NyaWJlcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSByZW1vdmUgYWxsIGNhbGxiYWNrc1xuICBcdFx0XHRcdGVsc2Uge1xuICBcdFx0XHRcdFx0dGhpcyQxLl9zdWJzWyBldmVudE5hbWUgXSA9IFtdO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiBSYWN0aXZlJG9uICggZXZlbnROYW1lLCBjYWxsYmFjayApIHtcbiAgXHQvLyBhbGxvdyBtdWx0aXBsZSBsaXN0ZW5lcnMgdG8gYmUgYm91bmQgaW4gb25lIGdvXG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRpZiAoIHR5cGVvZiBldmVudE5hbWUgPT09ICdvYmplY3QnICkge1xuICBcdFx0dmFyIGxpc3RlbmVycyA9IFtdO1xuICBcdFx0dmFyIG47XG5cbiAgXHRcdGZvciAoIG4gaW4gZXZlbnROYW1lICkge1xuICBcdFx0XHRpZiAoIGV2ZW50TmFtZS5oYXNPd25Qcm9wZXJ0eSggbiApICkge1xuICBcdFx0XHRcdGxpc3RlbmVycy5wdXNoKCB0aGlzLm9uKCBuLCBldmVudE5hbWVbIG4gXSApICk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0Y2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0dmFyIGxpc3RlbmVyO1xuICBcdFx0XHRcdHdoaWxlICggbGlzdGVuZXIgPSBsaXN0ZW5lcnMucG9wKCkgKSBsaXN0ZW5lci5jYW5jZWwoKTtcbiAgXHRcdFx0fVxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHQvLyBIYW5kbGUgbXVsdGlwbGUgc3BhY2Utc2VwYXJhdGVkIGV2ZW50IG5hbWVzXG4gIFx0dmFyIGV2ZW50TmFtZXMgPSBldmVudE5hbWUuc3BsaXQoICcgJyApLm1hcCggdHJpbSApLmZpbHRlciggbm90RW1wdHlTdHJpbmcgKTtcblxuICBcdGV2ZW50TmFtZXMuZm9yRWFjaCggZnVuY3Rpb24gKCBldmVudE5hbWUgKSB7XG4gIFx0XHQoIHRoaXMkMS5fc3Vic1sgZXZlbnROYW1lIF0gfHwgKCB0aGlzJDEuX3N1YnNbIGV2ZW50TmFtZSBdID0gW10gKSApLnB1c2goIGNhbGxiYWNrICk7XG4gIFx0fSk7XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0Y2FuY2VsOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEub2ZmKCBldmVudE5hbWUsIGNhbGxiYWNrICk7IH1cbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSRvbmNlICggZXZlbnROYW1lLCBoYW5kbGVyICkge1xuICBcdHZhciBsaXN0ZW5lciA9IHRoaXMub24oIGV2ZW50TmFtZSwgZnVuY3Rpb24gKCkge1xuICBcdFx0aGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG4gIFx0XHRsaXN0ZW5lci5jYW5jZWwoKTtcbiAgXHR9KTtcblxuICBcdC8vIHNvIHdlIGNhbiBzdGlsbCBkbyBsaXN0ZW5lci5jYW5jZWwoKSBtYW51YWxseVxuICBcdHJldHVybiBsaXN0ZW5lcjtcbiAgfVxuXG4gIHZhciBwb3AkMSA9IG1ha2VBcnJheU1ldGhvZCggJ3BvcCcgKS5wYXRoO1xuXG4gIHZhciBwdXNoJDEgPSBtYWtlQXJyYXlNZXRob2QoICdwdXNoJyApLnBhdGg7XG5cbiAgdmFyIFBSRUZJWCA9ICcvKiBSYWN0aXZlLmpzIGNvbXBvbmVudCBzdHlsZXMgKi8nO1xuXG4gIC8vIEhvbGRzIGN1cnJlbnQgZGVmaW5pdGlvbnMgb2Ygc3R5bGVzLlxuICB2YXIgc3R5bGVEZWZpbml0aW9ucyA9IFtdO1xuXG4gIC8vIEZsYWcgdG8gdGVsbCBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgQ1NTXG4gIHZhciBpc0RpcnR5ID0gZmFsc2U7XG5cbiAgLy8gVGhlc2Ugb25seSBtYWtlIHNlbnNlIG9uIHRoZSBicm93c2VyLiBTZWUgYWRkaXRpb25hbCBzZXR1cCBiZWxvdy5cbiAgdmFyIHN0eWxlRWxlbWVudCA9IG51bGw7XG4gIHZhciB1c2VDc3NUZXh0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBhZGRDU1MoIHN0eWxlRGVmaW5pdGlvbiApIHtcbiAgXHRzdHlsZURlZmluaXRpb25zLnB1c2goIHN0eWxlRGVmaW5pdGlvbiApO1xuICBcdGlzRGlydHkgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlDU1MoKSB7XG5cbiAgXHQvLyBBcHBseSBvbmx5IHNlZW1zIHRvIG1ha2Ugc2Vuc2Ugd2hlbiB3ZSdyZSBpbiB0aGUgRE9NLiBTZXJ2ZXItc2lkZSByZW5kZXJzXG4gIFx0Ly8gY2FuIGNhbGwgdG9DU1MgdG8gZ2V0IHRoZSB1cGRhdGVkIENTUy5cbiAgXHRpZiAoICFkb2MgfHwgIWlzRGlydHkgKSByZXR1cm47XG5cbiAgXHRpZiAoIHVzZUNzc1RleHQgKSB7XG4gIFx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gZ2V0Q1NTKCBudWxsICk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSBnZXRDU1MoIG51bGwgKTtcbiAgXHR9XG5cbiAgXHRpc0RpcnR5ID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDU1MoIGNzc0lkcyApIHtcblxuICBcdHZhciBmaWx0ZXJlZFN0eWxlRGVmaW5pdGlvbnMgPSBjc3NJZHMgPyBzdHlsZURlZmluaXRpb25zLmZpbHRlciggZnVuY3Rpb24gKCBzdHlsZSApIHsgcmV0dXJuIH5jc3NJZHMuaW5kZXhPZiggc3R5bGUuaWQgKTsgfSApIDogc3R5bGVEZWZpbml0aW9ucztcblxuICBcdHJldHVybiBmaWx0ZXJlZFN0eWxlRGVmaW5pdGlvbnMucmVkdWNlKCBmdW5jdGlvbiAoIHN0eWxlcywgc3R5bGUgKSB7IHJldHVybiAoXCJcIiArIHN0eWxlcyArIFwiXFxuXFxuLyoge1wiICsgKHN0eWxlLmlkKSArIFwifSAqL1xcblwiICsgKHN0eWxlLnN0eWxlcykpOyB9LCBQUkVGSVggKTtcblxuICB9XG5cbiAgLy8gSWYgd2UncmUgb24gdGhlIGJyb3dzZXIsIGFkZGl0aW9uYWwgc2V0dXAgbmVlZGVkLlxuICBpZiAoIGRvYyAmJiAoICFzdHlsZUVsZW1lbnQgfHwgIXN0eWxlRWxlbWVudC5wYXJlbnROb2RlICkgKSB7XG5cbiAgXHRzdHlsZUVsZW1lbnQgPSBkb2MuY3JlYXRlRWxlbWVudCggJ3N0eWxlJyApO1xuICBcdHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJztcblxuICBcdGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ2hlYWQnIClbIDAgXS5hcHBlbmRDaGlsZCggc3R5bGVFbGVtZW50ICk7XG5cbiAgXHR1c2VDc3NUZXh0ID0gISFzdHlsZUVsZW1lbnQuc3R5bGVTaGVldDtcbiAgfVxuXG4gIHZhciByZW5kZXJIb29rID0gbmV3IEhvb2soICdyZW5kZXInICk7XG4gIHZhciBjb21wbGV0ZUhvb2sgPSBuZXcgSG9vayggJ2NvbXBsZXRlJyApO1xuXG4gIGZ1bmN0aW9uIHJlbmRlciQxICggcmFjdGl2ZSwgdGFyZ2V0LCBhbmNob3IsIG9jY3VwYW50cyApIHtcbiAgXHQvLyBpZiBgbm9JbnRyb2AgaXMgYHRydWVgLCB0ZW1wb3JhcmlseSBkaXNhYmxlIHRyYW5zaXRpb25zXG4gIFx0dmFyIHRyYW5zaXRpb25zRW5hYmxlZCA9IHJhY3RpdmUudHJhbnNpdGlvbnNFbmFibGVkO1xuICBcdGlmICggcmFjdGl2ZS5ub0ludHJvICkgcmFjdGl2ZS50cmFuc2l0aW9uc0VuYWJsZWQgPSBmYWxzZTtcblxuICBcdHZhciBwcm9taXNlID0gcnVubG9vcC5zdGFydCggcmFjdGl2ZSwgdHJ1ZSApO1xuICBcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbiAoKSB7IHJldHVybiByZW5kZXJIb29rLmZpcmUoIHJhY3RpdmUgKTsgfSwgdHJ1ZSApO1xuXG4gIFx0aWYgKCByYWN0aXZlLmZyYWdtZW50LnJlbmRlcmVkICkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKCAnWW91IGNhbm5vdCBjYWxsIHJhY3RpdmUucmVuZGVyKCkgb24gYW4gYWxyZWFkeSByZW5kZXJlZCBpbnN0YW5jZSEgQ2FsbCByYWN0aXZlLnVucmVuZGVyKCkgZmlyc3QnICk7XG4gIFx0fVxuXG4gIFx0YW5jaG9yID0gZ2V0RWxlbWVudCggYW5jaG9yICkgfHwgcmFjdGl2ZS5hbmNob3I7XG5cbiAgXHRyYWN0aXZlLmVsID0gdGFyZ2V0O1xuICBcdHJhY3RpdmUuYW5jaG9yID0gYW5jaG9yO1xuXG4gIFx0Ly8gZW5zdXJlIGVuY2Fwc3VsYXRlZCBDU1MgaXMgdXAtdG8tZGF0ZVxuICBcdGlmICggcmFjdGl2ZS5jc3NJZCApIGFwcGx5Q1NTKCk7XG5cbiAgXHRpZiAoIHRhcmdldCApIHtcbiAgXHRcdCggdGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyB8fCAoIHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gPSBbXSApICkucHVzaCggcmFjdGl2ZSApO1xuXG4gIFx0XHRpZiAoIGFuY2hvciApIHtcbiAgXHRcdFx0dmFyIGRvY0ZyYWcgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBcdFx0XHRyYWN0aXZlLmZyYWdtZW50LnJlbmRlciggZG9jRnJhZyApO1xuICBcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBkb2NGcmFnLCBhbmNob3IgKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJhY3RpdmUuZnJhZ21lbnQucmVuZGVyKCB0YXJnZXQsIG9jY3VwYW50cyApO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJ1bmxvb3AuZW5kKCk7XG4gIFx0cmFjdGl2ZS50cmFuc2l0aW9uc0VuYWJsZWQgPSB0cmFuc2l0aW9uc0VuYWJsZWQ7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZS50aGVuKCBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wbGV0ZUhvb2suZmlyZSggcmFjdGl2ZSApOyB9ICk7XG4gIH1cblxuICBmdW5jdGlvbiBSYWN0aXZlJHJlbmRlciAoIHRhcmdldCwgYW5jaG9yICkge1xuICBcdGlmICggdGhpcy50b3JuZG93biApIHtcbiAgXHRcdHdhcm5JZkRlYnVnKCAncmFjdGl2ZS5yZW5kZXIoKSB3YXMgY2FsbGVkIG9uIGEgUmFjdGl2ZSBpbnN0YW5jZSB0aGF0IHdhcyBhbHJlYWR5IHRvcm4gZG93bicgKTtcbiAgXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgXHR9XG5cbiAgXHR0YXJnZXQgPSBnZXRFbGVtZW50KCB0YXJnZXQgKSB8fCB0aGlzLmVsO1xuXG4gIFx0aWYgKCAhdGhpcy5hcHBlbmQgJiYgdGFyZ2V0ICkge1xuICBcdFx0Ly8gVGVhcmRvd24gYW55IGV4aXN0aW5nIGluc3RhbmNlcyAqYmVmb3JlKiB0cnlpbmcgdG8gc2V0IHVwIHRoZSBuZXcgb25lIC1cbiAgXHRcdC8vIGF2b2lkcyBjZXJ0YWluIHdlaXJkIGJ1Z3NcbiAgXHRcdHZhciBvdGhlcnMgPSB0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fO1xuICBcdFx0aWYgKCBvdGhlcnMgKSBvdGhlcnMuZm9yRWFjaCggdGVhcmRvd24gKTtcblxuICBcdFx0Ly8gbWFrZSBzdXJlIHdlIGFyZSB0aGUgb25seSBvY2N1cGFudHNcbiAgXHRcdGlmICggIXRoaXMuZW5oYW5jZSApIHtcbiAgXHRcdFx0dGFyZ2V0LmlubmVySFRNTCA9ICcnOyAvLyBUT0RPIGlzIHRoaXMgcXVpY2tlciB0aGFuIHJlbW92ZUNoaWxkPyBJbml0aWFsIHJlc2VhcmNoIGluY29uY2x1c2l2ZVxuICBcdFx0fVxuICBcdH1cblxuICBcdHZhciBvY2N1cGFudHMgPSB0aGlzLmVuaGFuY2UgPyB0b0FycmF5KCB0YXJnZXQuY2hpbGROb2RlcyApIDogbnVsbDtcbiAgXHR2YXIgcHJvbWlzZSA9IHJlbmRlciQxKCB0aGlzLCB0YXJnZXQsIGFuY2hvciwgb2NjdXBhbnRzICk7XG5cbiAgXHRpZiAoIG9jY3VwYW50cyApIHtcbiAgXHRcdHdoaWxlICggb2NjdXBhbnRzLmxlbmd0aCApIHRhcmdldC5yZW1vdmVDaGlsZCggb2NjdXBhbnRzLnBvcCgpICk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgYWRhcHRDb25maWd1cmF0b3IgPSB7XG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAoIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKSB7XG4gIFx0XHRwcm90by5hZGFwdCA9IGNvbWJpbmUoIHByb3RvLmFkYXB0LCBlbnN1cmVBcnJheSggb3B0aW9ucy5hZGFwdCApICk7XG4gIFx0fSxcblxuICBcdGluaXQ6IGZ1bmN0aW9uICgpIHt9XG4gIH07XG5cbiAgZnVuY3Rpb24gY29tYmluZSAoIGEsIGIgKSB7XG4gIFx0dmFyIGMgPSBhLnNsaWNlKCk7XG4gIFx0dmFyIGkgPSBiLmxlbmd0aDtcblxuICBcdHdoaWxlICggaS0tICkge1xuICBcdFx0aWYgKCAhfmMuaW5kZXhPZiggYltpXSApICkge1xuICBcdFx0XHRjLnB1c2goIGJbaV0gKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gYztcbiAgfVxuXG4gIHZhciBzZWxlY3RvcnNQYXR0ZXJuID0gLyg/Ol58XFx9KT9cXHMqKFteXFx7XFx9XSspXFxzKlxcey9nO1xuICB2YXIgY29tbWVudHNQYXR0ZXJuID0gL1xcL1xcKltcXHNcXFNdKj9cXCpcXC8vZztcbiAgdmFyIHNlbGVjdG9yVW5pdFBhdHRlcm4gPSAvKCg/Oig/OlxcW1teXFxdK11cXF0pfCg/OlteXFxzXFwrXFw+fjpdKSkrKSgoPzo6Oj9bXlxcc1xcK1xcPlxcflxcKDpdKyg/OlxcKFteXFwpXStcXCkpPykqXFxzKltcXHNcXCtcXD5cXH5dPylcXHMqL2c7XG4gIHZhciBleGNsdWRlUGF0dGVybiA9IC9eKD86QHxcXGQrJSkvO1xuICB2YXIgZGF0YVJ2Y0d1aWRQYXR0ZXJuID0gL1xcW2RhdGEtcmFjdGl2ZS1jc3N+PVwiXFx7W2EtejAtOS1dK1xcfVwiXS9nO1xuXG4gIGZ1bmN0aW9uIHRyaW0kMSAoIHN0ciApIHtcbiAgXHRyZXR1cm4gc3RyLnRyaW0oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RTdHJpbmcgKCB1bml0ICkge1xuICBcdHJldHVybiB1bml0LnN0cjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVNlbGVjdG9yICggc2VsZWN0b3IsIHBhcmVudCApIHtcbiAgXHR2YXIgc2VsZWN0b3JVbml0cyA9IFtdO1xuICBcdHZhciBtYXRjaDtcblxuICBcdHdoaWxlICggbWF0Y2ggPSBzZWxlY3RvclVuaXRQYXR0ZXJuLmV4ZWMoIHNlbGVjdG9yICkgKSB7XG4gIFx0XHRzZWxlY3RvclVuaXRzLnB1c2goe1xuICBcdFx0XHRzdHI6IG1hdGNoWzBdLFxuICBcdFx0XHRiYXNlOiBtYXRjaFsxXSxcbiAgXHRcdFx0bW9kaWZpZXJzOiBtYXRjaFsyXVxuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Ly8gRm9yIGVhY2ggc2ltcGxlIHNlbGVjdG9yIHdpdGhpbiB0aGUgc2VsZWN0b3IsIHdlIG5lZWQgdG8gY3JlYXRlIGEgdmVyc2lvblxuICBcdC8vIHRoYXQgYSkgY29tYmluZXMgd2l0aCB0aGUgaWQsIGFuZCBiKSBpcyBpbnNpZGUgdGhlIGlkXG4gIFx0dmFyIGJhc2UgPSBzZWxlY3RvclVuaXRzLm1hcCggZXh0cmFjdFN0cmluZyApO1xuXG4gIFx0dmFyIHRyYW5zZm9ybWVkID0gW107XG4gIFx0dmFyIGkgPSBzZWxlY3RvclVuaXRzLmxlbmd0aDtcblxuICBcdHdoaWxlICggaS0tICkge1xuICBcdFx0dmFyIGFwcGVuZGVkID0gYmFzZS5zbGljZSgpO1xuXG4gIFx0XHQvLyBQc2V1ZG8tc2VsZWN0b3JzIHNob3VsZCBnbyBhZnRlciB0aGUgYXR0cmlidXRlIHNlbGVjdG9yXG4gIFx0XHR2YXIgdW5pdCA9IHNlbGVjdG9yVW5pdHNbaV07XG4gIFx0XHRhcHBlbmRlZFtpXSA9IHVuaXQuYmFzZSArIHBhcmVudCArIHVuaXQubW9kaWZpZXJzIHx8ICcnO1xuXG4gIFx0XHR2YXIgcHJlcGVuZGVkID0gYmFzZS5zbGljZSgpO1xuICBcdFx0cHJlcGVuZGVkW2ldID0gcGFyZW50ICsgJyAnICsgcHJlcGVuZGVkW2ldO1xuXG4gIFx0XHR0cmFuc2Zvcm1lZC5wdXNoKCBhcHBlbmRlZC5qb2luKCAnICcgKSwgcHJlcGVuZGVkLmpvaW4oICcgJyApICk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRyYW5zZm9ybWVkLmpvaW4oICcsICcgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUNzcyAoIGNzcywgaWQgKSB7XG4gIFx0dmFyIGRhdGFBdHRyID0gXCJbZGF0YS1yYWN0aXZlLWNzc349XFxcIntcIiArIGlkICsgXCJ9XFxcIl1cIjtcblxuICBcdHZhciB0cmFuc2Zvcm1lZDtcblxuICBcdGlmICggZGF0YVJ2Y0d1aWRQYXR0ZXJuLnRlc3QoIGNzcyApICkge1xuICBcdFx0dHJhbnNmb3JtZWQgPSBjc3MucmVwbGFjZSggZGF0YVJ2Y0d1aWRQYXR0ZXJuLCBkYXRhQXR0ciApO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR0cmFuc2Zvcm1lZCA9IGNzc1xuICBcdFx0LnJlcGxhY2UoIGNvbW1lbnRzUGF0dGVybiwgJycgKVxuICBcdFx0LnJlcGxhY2UoIHNlbGVjdG9yc1BhdHRlcm4sIGZ1bmN0aW9uICggbWF0Y2gsICQxICkge1xuICBcdFx0XHQvLyBkb24ndCB0cmFuc2Zvcm0gYXQtcnVsZXMgYW5kIGtleWZyYW1lIGRlY2xhcmF0aW9uc1xuICBcdFx0XHRpZiAoIGV4Y2x1ZGVQYXR0ZXJuLnRlc3QoICQxICkgKSByZXR1cm4gbWF0Y2g7XG5cbiAgXHRcdFx0dmFyIHNlbGVjdG9ycyA9ICQxLnNwbGl0KCAnLCcgKS5tYXAoIHRyaW0kMSApO1xuICBcdFx0XHR2YXIgdHJhbnNmb3JtZWQgPSBzZWxlY3RvcnNcbiAgXHRcdFx0XHQubWFwKCBmdW5jdGlvbiAoIHNlbGVjdG9yICkgeyByZXR1cm4gdHJhbnNmb3JtU2VsZWN0b3IoIHNlbGVjdG9yLCBkYXRhQXR0ciApOyB9IClcbiAgXHRcdFx0XHQuam9pbiggJywgJyApICsgJyAnO1xuXG4gIFx0XHRcdHJldHVybiBtYXRjaC5yZXBsYWNlKCAkMSwgdHJhbnNmb3JtZWQgKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHM0KCkge1xuICBcdHJldHVybiBNYXRoLmZsb29yKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXVpZCgpIHtcbiAgXHRyZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG4gIH1cblxuICB2YXIgY3NzQ29uZmlndXJhdG9yID0ge1xuICBcdG5hbWU6ICdjc3MnLFxuXG4gIFx0Ly8gQ2FsbGVkIHdoZW4gY3JlYXRpbmcgYSBuZXcgY29tcG9uZW50IGRlZmluaXRpb25cbiAgXHRleHRlbmQ6IGZ1bmN0aW9uICggUGFyZW50LCBwcm90bywgb3B0aW9ucyApIHtcbiAgXHRcdGlmICggIW9wdGlvbnMuY3NzICkgcmV0dXJuO1xuXG4gIFx0XHR2YXIgaWQgPSB1dWlkKCk7XG4gIFx0XHR2YXIgc3R5bGVzID0gb3B0aW9ucy5ub0Nzc1RyYW5zZm9ybSA/IG9wdGlvbnMuY3NzIDogdHJhbnNmb3JtQ3NzKCBvcHRpb25zLmNzcywgaWQgKTtcblxuICBcdFx0cHJvdG8uY3NzSWQgPSBpZDtcblxuICBcdFx0YWRkQ1NTKCB7IGlkOiBpZCwgc3R5bGVzOiBzdHlsZXMgfSApO1xuXG4gIFx0fSxcblxuICBcdC8vIENhbGxlZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbXBvbmVudCBpbnN0YW5jZVxuICBcdGluaXQ6IGZ1bmN0aW9uICggUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMgKSB7XG4gIFx0XHRpZiAoICFvcHRpb25zLmNzcyApIHJldHVybjtcblxuICBcdFx0d2FybklmRGVidWcoIChcIlxcblRoZSBjc3Mgb3B0aW9uIGlzIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIG9uIGEgcGVyLWluc3RhbmNlIGJhc2lzIGFuZCB3aWxsIGJlIGRpc2NhcmRlZC4gSW5zdGVhZCwgd2UgcmVjb21tZW5kIGluc3RhbnRpYXRpbmcgZnJvbSBhIGNvbXBvbmVudCBkZWZpbml0aW9uIHdpdGggYSBjc3Mgb3B0aW9uLlxcblxcbmNvbnN0IENvbXBvbmVudCA9IFJhY3RpdmUuZXh0ZW5kKHtcXG5cXHQuLi5cXG5cXHRjc3M6ICcvKiB5b3VyIGNzcyAqLycsXFxuXFx0Li4uXFxufSk7XFxuXFxuY29uc3QgY29tcG9uZW50SW5zdGFuY2UgPSBuZXcgQ29tcG9uZW50KHsgLi4uIH0pXFxuXFx0XFx0XCIpICk7XG4gIFx0fVxuXG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUgKCBkYXRhICkge1xuICBcdC8vIFdhcm4gaWYgdXNlck9wdGlvbnMuZGF0YSBpcyBhIG5vbi1QT0pPXG4gIFx0aWYgKCBkYXRhICYmIGRhdGEuY29uc3RydWN0b3IgIT09IE9iamVjdCApIHtcbiAgXHRcdGlmICggdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicgKSB7XG4gIFx0XHRcdC8vIFRPRE8gZG8gd2UgbmVlZCB0byBzdXBwb3J0IHRoaXMgaW4gdGhlIG5ldyBSYWN0aXZlKCkgY2FzZT9cbiAgXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyApIHtcbiAgXHRcdFx0ZmF0YWwoIChcImRhdGEgb3B0aW9uIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGBcIiArIGRhdGEgKyBcImAgaXMgbm90IHZhbGlkXCIpICk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR3YXJuSWZEZWJ1ZyggJ0lmIHN1cHBsaWVkLCBvcHRpb25zLmRhdGEgc2hvdWxkIGJlIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QgLSB1c2luZyBhIG5vbi1QT0pPIGFzIHRoZSByb290IG9iamVjdCBtYXkgd29yaywgYnV0IGlzIGRpc2NvdXJhZ2VkJyApO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBkYXRhQ29uZmlndXJhdG9yID0ge1xuICBcdG5hbWU6ICdkYXRhJyxcblxuICBcdGV4dGVuZDogZnVuY3Rpb24gKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICkge1xuICBcdFx0dmFyIGtleTtcbiAgXHRcdHZhciB2YWx1ZTtcblxuICBcdFx0Ly8gY2hlY2sgZm9yIG5vbi1wcmltaXRpdmVzLCB3aGljaCBjb3VsZCBjYXVzZSBtdXRhdGlvbi1yZWxhdGVkIGJ1Z3NcbiAgXHRcdGlmICggb3B0aW9ucy5kYXRhICYmIGlzT2JqZWN0KCBvcHRpb25zLmRhdGEgKSApIHtcbiAgXHRcdFx0Zm9yICgga2V5IGluIG9wdGlvbnMuZGF0YSApIHtcbiAgXHRcdFx0XHR2YWx1ZSA9IG9wdGlvbnMuZGF0YVsga2V5IF07XG5cbiAgXHRcdFx0XHRpZiAoIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgKSB7XG4gIFx0XHRcdFx0XHRpZiAoIGlzT2JqZWN0KCB2YWx1ZSApIHx8IGlzQXJyYXkoIHZhbHVlICkgKSB7XG4gIFx0XHRcdFx0XHRcdHdhcm5JZkRlYnVnKCAoXCJQYXNzaW5nIGEgYGRhdGFgIG9wdGlvbiB3aXRoIG9iamVjdCBhbmQgYXJyYXkgcHJvcGVydGllcyB0byBSYWN0aXZlLmV4dGVuZCgpIGlzIGRpc2NvdXJhZ2VkLCBhcyBtdXRhdGluZyB0aGVtIGlzIGxpa2VseSB0byBjYXVzZSBidWdzLiBDb25zaWRlciB1c2luZyBhIGRhdGEgZnVuY3Rpb24gaW5zdGVhZDpcXG5cXG4gIC8vIHRoaXMuLi5cXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBteU9iamVjdDoge31cXG4gICAgfTtcXG4gIH0pXFxuXFxuICAvLyBpbnN0ZWFkIG9mIHRoaXM6XFxuICBkYXRhOiB7XFxuICAgIG15T2JqZWN0OiB7fVxcbiAgfVwiKSApO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRwcm90by5kYXRhID0gY29tYmluZSQxKCBwcm90by5kYXRhLCBvcHRpb25zLmRhdGEgKTtcbiAgXHR9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG4gIFx0XHR2YXIgcmVzdWx0ID0gY29tYmluZSQxKCBQYXJlbnQucHJvdG90eXBlLmRhdGEsIG9wdGlvbnMuZGF0YSApO1xuXG4gIFx0XHRpZiAoIHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbicgKSByZXN1bHQgPSByZXN1bHQuY2FsbCggcmFjdGl2ZSApO1xuXG4gIFx0XHQvLyBiaW5kIGZ1bmN0aW9ucyB0byB0aGUgcmFjdGl2ZSBpbnN0YW5jZSBhdCB0aGUgdG9wIGxldmVsLFxuICBcdFx0Ly8gdW5sZXNzIGl0J3MgYSBub24tUE9KTyAoaW4gd2hpY2ggY2FzZSBhbGFybSBiZWxscyBzaG91bGQgcmluZylcbiAgXHRcdGlmICggcmVzdWx0ICYmIHJlc3VsdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICkge1xuICBcdFx0XHRmb3IgKCB2YXIgcHJvcCBpbiByZXN1bHQgKSB7XG4gIFx0XHRcdFx0aWYgKCB0eXBlb2YgcmVzdWx0WyBwcm9wIF0gPT09ICdmdW5jdGlvbicgKSByZXN1bHRbIHByb3AgXSA9IGJpbmQoIHJlc3VsdFsgcHJvcCBdLCByYWN0aXZlICk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHJlc3VsdCB8fCB7fTtcbiAgXHR9LFxuXG4gIFx0cmVzZXQ6IGZ1bmN0aW9uICggcmFjdGl2ZSApIHtcbiAgXHRcdHZhciByZXN1bHQgPSB0aGlzLmluaXQoIHJhY3RpdmUuY29uc3RydWN0b3IsIHJhY3RpdmUsIHJhY3RpdmUudmlld21vZGVsICk7XG4gIFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5yb290LnNldCggcmVzdWx0ICk7XG4gIFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH07XG5cbiAgZnVuY3Rpb24gY29tYmluZSQxICggcGFyZW50VmFsdWUsIGNoaWxkVmFsdWUgKSB7XG4gIFx0dmFsaWRhdGUoIGNoaWxkVmFsdWUgKTtcblxuICBcdHZhciBwYXJlbnRJc0ZuID0gdHlwZW9mIHBhcmVudFZhbHVlID09PSAnZnVuY3Rpb24nO1xuICBcdHZhciBjaGlsZElzRm4gPSB0eXBlb2YgY2hpbGRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJztcblxuICBcdC8vIFZlcnkgaW1wb3J0YW50LCBvdGhlcndpc2UgY2hpbGQgaW5zdGFuY2UgY2FuIGJlY29tZVxuICBcdC8vIHRoZSBkZWZhdWx0IGRhdGEgb2JqZWN0IG9uIFJhY3RpdmUgb3IgYSBjb21wb25lbnQuXG4gIFx0Ly8gdGhlbiByYWN0aXZlLnNldCgpIGVuZHMgdXAgc2V0dGluZyBvbiB0aGUgcHJvdG90eXBlIVxuICBcdGlmICggIWNoaWxkVmFsdWUgJiYgIXBhcmVudElzRm4gKSB7XG4gIFx0XHRjaGlsZFZhbHVlID0ge307XG4gIFx0fVxuXG4gIFx0Ly8gRmFzdCBwYXRoLCB3aGVyZSB3ZSBqdXN0IG5lZWQgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAgXHQvLyBwYXJlbnQgdG8gY2hpbGRcbiAgXHRpZiAoICFwYXJlbnRJc0ZuICYmICFjaGlsZElzRm4gKSB7XG4gIFx0XHRyZXR1cm4gZnJvbVByb3BlcnRpZXMoIGNoaWxkVmFsdWUsIHBhcmVudFZhbHVlICk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBjaGlsZCA9IGNoaWxkSXNGbiA/IGNhbGxEYXRhRnVuY3Rpb24oIGNoaWxkVmFsdWUsIHRoaXMgKSA6IGNoaWxkVmFsdWU7XG4gIFx0XHR2YXIgcGFyZW50ID0gcGFyZW50SXNGbiA/IGNhbGxEYXRhRnVuY3Rpb24oIHBhcmVudFZhbHVlLCB0aGlzICkgOiBwYXJlbnRWYWx1ZTtcblxuICBcdFx0cmV0dXJuIGZyb21Qcm9wZXJ0aWVzKCBjaGlsZCwgcGFyZW50ICk7XG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxEYXRhRnVuY3Rpb24gKCBmbiwgY29udGV4dCApIHtcbiAgXHR2YXIgZGF0YSA9IGZuLmNhbGwoIGNvbnRleHQgKTtcblxuICBcdGlmICggIWRhdGEgKSByZXR1cm47XG5cbiAgXHRpZiAoIHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyApIHtcbiAgXHRcdGZhdGFsKCAnRGF0YSBmdW5jdGlvbiBtdXN0IHJldHVybiBhbiBvYmplY3QnICk7XG4gIFx0fVxuXG4gIFx0aWYgKCBkYXRhLmNvbnN0cnVjdG9yICE9PSBPYmplY3QgKSB7XG4gIFx0XHR3YXJuT25jZUlmRGVidWcoICdEYXRhIGZ1bmN0aW9uIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QuIFRoaXMgbWlnaHQgd29yaywgYnV0IGlzIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkJyApO1xuICBcdH1cblxuICBcdHJldHVybiBkYXRhO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbVByb3BlcnRpZXMgKCBwcmltYXJ5LCBzZWNvbmRhcnkgKSB7XG4gIFx0aWYgKCBwcmltYXJ5ICYmIHNlY29uZGFyeSApIHtcbiAgXHRcdGZvciAoIHZhciBrZXkgaW4gc2Vjb25kYXJ5ICkge1xuICBcdFx0XHRpZiAoICEoIGtleSBpbiBwcmltYXJ5ICkgKSB7XG4gIFx0XHRcdFx0cHJpbWFyeVsga2V5IF0gPSBzZWNvbmRhcnlbIGtleSBdO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBwcmltYXJ5O1xuICBcdH1cblxuICBcdHJldHVybiBwcmltYXJ5IHx8IHNlY29uZGFyeTtcbiAgfVxuXG4gIHZhciBURU1QTEFURV9WRVJTSU9OID0gNDtcblxuICB2YXIgcGF0dGVybiA9IC9cXCRcXHsoW15cXH1dKylcXH0vZztcblxuICBmdW5jdGlvbiBmcm9tRXhwcmVzc2lvbiAoIGJvZHksIGxlbmd0aCApIHtcbiAgXHRpZiAoIGxlbmd0aCA9PT0gdm9pZCAwICkgbGVuZ3RoID0gMDtcblxuICBcdHZhciBhcmdzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblxuICBcdHdoaWxlICggbGVuZ3RoLS0gKSB7XG4gIFx0XHRhcmdzW2xlbmd0aF0gPSBcIl9cIiArIGxlbmd0aDtcbiAgXHR9XG5cbiAgXHQvLyBGdW5jdGlvbnMgY3JlYXRlZCBkaXJlY3RseSB3aXRoIG5ldyBGdW5jdGlvbigpIGxvb2sgbGlrZSB0aGlzOlxuICBcdC8vICAgICBmdW5jdGlvbiBhbm9ueW1vdXMgKF8wIC8qKi8pIHsgcmV0dXJuIF8wKjIgfVxuICBcdC8vXG4gIFx0Ly8gV2l0aCB0aGlzIHdvcmthcm91bmQsIHdlIGdldCBhIGxpdHRsZSBtb3JlIGNvbXBhY3Q6XG4gIFx0Ly8gICAgIGZ1bmN0aW9uIChfMCl7cmV0dXJuIF8wKjJ9XG4gIFx0cmV0dXJuIG5ldyBGdW5jdGlvbiggW10sIChcInJldHVybiBmdW5jdGlvbiAoXCIgKyAoYXJncy5qb2luKCcsJykpICsgXCIpe3JldHVybihcIiArIGJvZHkgKyBcIik7fTtcIikgKSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUNvbXB1dGF0aW9uU3RyaW5nICggc3RyLCBiaW5kVG8gKSB7XG4gIFx0dmFyIGhhc1RoaXM7XG5cbiAgXHR2YXIgZnVuY3Rpb25Cb2R5ID0gJ3JldHVybiAoJyArIHN0ci5yZXBsYWNlKCBwYXR0ZXJuLCBmdW5jdGlvbiAoIG1hdGNoLCBrZXlwYXRoICkge1xuICBcdFx0aGFzVGhpcyA9IHRydWU7XG4gIFx0XHRyZXR1cm4gKFwiX19yYWN0aXZlLmdldChcXFwiXCIgKyBrZXlwYXRoICsgXCJcXFwiKVwiKTtcbiAgXHR9KSArICcpOyc7XG5cbiAgXHRpZiAoIGhhc1RoaXMgKSBmdW5jdGlvbkJvZHkgPSBcInZhciBfX3JhY3RpdmUgPSB0aGlzOyBcIiArIGZ1bmN0aW9uQm9keTtcbiAgXHR2YXIgZm4gPSBuZXcgRnVuY3Rpb24oIGZ1bmN0aW9uQm9keSApO1xuICBcdHJldHVybiBoYXNUaGlzID8gZm4uYmluZCggYmluZFRvICkgOiBmbjtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbnMgPSBjcmVhdGUoIG51bGwgKTtcblxuICBmdW5jdGlvbiBnZXRGdW5jdGlvbiAoIHN0ciwgaSApIHtcbiAgXHRpZiAoIGZ1bmN0aW9uc1sgc3RyIF0gKSByZXR1cm4gZnVuY3Rpb25zWyBzdHIgXTtcbiAgXHRyZXR1cm4gZnVuY3Rpb25zWyBzdHIgXSA9IGNyZWF0ZUZ1bmN0aW9uKCBzdHIsIGkgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEZ1bmN0aW9ucyggdGVtcGxhdGUgKSB7XG4gIFx0aWYgKCAhdGVtcGxhdGUgKSByZXR1cm47XG5cbiAgXHR2YXIgZXhwID0gdGVtcGxhdGUuZTtcblxuICBcdGlmICggIWV4cCApIHJldHVybjtcblxuICBcdE9iamVjdC5rZXlzKCBleHAgKS5mb3JFYWNoKCBmdW5jdGlvbiAoIHN0ciApIHtcbiAgXHRcdGlmICggZnVuY3Rpb25zWyBzdHIgXSApIHJldHVybjtcbiAgXHRcdGZ1bmN0aW9uc1sgc3RyIF0gPSBleHBbIHN0ciBdO1xuICBcdH0pO1xuICB9XG5cbiAgdmFyIFBhcnNlcjtcbiAgdmFyIFBhcnNlRXJyb3I7XG4gIHZhciBsZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKy87XG4gIFBhcnNlRXJyb3IgPSBmdW5jdGlvbiAoIG1lc3NhZ2UgKSB7XG4gIFx0dGhpcy5uYW1lID0gJ1BhcnNlRXJyb3InO1xuICBcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIFx0dHJ5IHtcbiAgXHRcdHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgXHR9IGNhdGNoIChlKSB7XG4gIFx0XHR0aGlzLnN0YWNrID0gZS5zdGFjaztcbiAgXHR9XG4gIH07XG5cbiAgUGFyc2VFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgUGFyc2VyID0gZnVuY3Rpb24gKCBzdHIsIG9wdGlvbnMgKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHR2YXIgaXRlbXMsIGl0ZW0sIGxpbmVTdGFydCA9IDA7XG5cbiAgXHR0aGlzLnN0ciA9IHN0cjtcbiAgXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBcdHRoaXMucG9zID0gMDtcblxuICBcdHRoaXMubGluZXMgPSB0aGlzLnN0ci5zcGxpdCggJ1xcbicgKTtcbiAgXHR0aGlzLmxpbmVFbmRzID0gdGhpcy5saW5lcy5tYXAoIGZ1bmN0aW9uICggbGluZSApIHtcbiAgXHRcdHZhciBsaW5lRW5kID0gbGluZVN0YXJ0ICsgbGluZS5sZW5ndGggKyAxOyAvLyArMSBmb3IgdGhlIG5ld2xpbmVcblxuICBcdFx0bGluZVN0YXJ0ID0gbGluZUVuZDtcbiAgXHRcdHJldHVybiBsaW5lRW5kO1xuICBcdH0sIDAgKTtcblxuICBcdC8vIEN1c3RvbSBpbml0IGxvZ2ljXG4gIFx0aWYgKCB0aGlzLmluaXQgKSB0aGlzLmluaXQoIHN0ciwgb3B0aW9ucyApO1xuXG4gIFx0aXRlbXMgPSBbXTtcblxuICBcdHdoaWxlICggKCB0aGlzJDEucG9zIDwgdGhpcyQxLnN0ci5sZW5ndGggKSAmJiAoIGl0ZW0gPSB0aGlzJDEucmVhZCgpICkgKSB7XG4gIFx0XHRpdGVtcy5wdXNoKCBpdGVtICk7XG4gIFx0fVxuXG4gIFx0dGhpcy5sZWZ0b3ZlciA9IHRoaXMucmVtYWluaW5nKCk7XG4gIFx0dGhpcy5yZXN1bHQgPSB0aGlzLnBvc3RQcm9jZXNzID8gdGhpcy5wb3N0UHJvY2VzcyggaXRlbXMsIG9wdGlvbnMgKSA6IGl0ZW1zO1xuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUgPSB7XG4gIFx0cmVhZDogZnVuY3Rpb24gKCBjb252ZXJ0ZXJzICkge1xuICBcdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHZhciBwb3MsIGksIGxlbiwgaXRlbTtcblxuICBcdFx0aWYgKCAhY29udmVydGVycyApIGNvbnZlcnRlcnMgPSB0aGlzLmNvbnZlcnRlcnM7XG5cbiAgXHRcdHBvcyA9IHRoaXMucG9zO1xuXG4gIFx0XHRsZW4gPSBjb252ZXJ0ZXJzLmxlbmd0aDtcbiAgXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG4gIFx0XHRcdHRoaXMkMS5wb3MgPSBwb3M7IC8vIHJlc2V0IGZvciBlYWNoIGF0dGVtcHRcblxuICBcdFx0XHRpZiAoIGl0ZW0gPSBjb252ZXJ0ZXJzW2ldKCB0aGlzJDEgKSApIHtcbiAgXHRcdFx0XHRyZXR1cm4gaXRlbTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9LFxuXG4gIFx0Z2V0Q29udGV4dE1lc3NhZ2U6IGZ1bmN0aW9uICggcG9zLCBtZXNzYWdlICkge1xuICBcdFx0dmFyIHJlZiA9IHRoaXMuZ2V0TGluZVBvcyggcG9zICksIGxpbmVOdW0gPSByZWZbMF0sIGNvbHVtbk51bSA9IHJlZlsxXTtcbiAgXHRcdGlmICggdGhpcy5vcHRpb25zLmNvbnRleHRMaW5lcyA9PT0gLTEgKSB7XG4gIFx0XHRcdHJldHVybiBbIGxpbmVOdW0sIGNvbHVtbk51bSwgKFwiXCIgKyBtZXNzYWdlICsgXCIgYXQgbGluZSBcIiArIGxpbmVOdW0gKyBcIiBjaGFyYWN0ZXIgXCIgKyBjb2x1bW5OdW0pIF07XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBsaW5lID0gdGhpcy5saW5lc1sgbGluZU51bSAtIDEgXTtcblxuICBcdFx0dmFyIGNvbnRleHRVcCA9ICcnO1xuICBcdFx0dmFyIGNvbnRleHREb3duID0gJyc7XG4gIFx0XHRpZiAoIHRoaXMub3B0aW9ucy5jb250ZXh0TGluZXMgKSB7XG4gIFx0XHRcdHZhciBzdGFydCA9IGxpbmVOdW0gLSAxIC0gdGhpcy5vcHRpb25zLmNvbnRleHRMaW5lcyA8IDAgPyAwIDogbGluZU51bSAtIDEgLSB0aGlzLm9wdGlvbnMuY29udGV4dExpbmVzO1xuICBcdFx0XHRjb250ZXh0VXAgPSB0aGlzLmxpbmVzLnNsaWNlKCBzdGFydCwgbGluZU51bSAtIDEgLSBzdGFydCApLmpvaW4oICdcXG4nICkucmVwbGFjZSggL1xcdC9nLCAnICAnICk7XG4gIFx0XHRcdGNvbnRleHREb3duID0gdGhpcy5saW5lcy5zbGljZSggbGluZU51bSwgbGluZU51bSArIHRoaXMub3B0aW9ucy5jb250ZXh0TGluZXMgKS5qb2luKCAnXFxuJyApLnJlcGxhY2UoIC9cXHQvZywgJyAgJyApO1xuICBcdFx0XHRpZiAoIGNvbnRleHRVcCApIHtcbiAgXHRcdFx0XHRjb250ZXh0VXAgKz0gJ1xcbic7XG4gIFx0XHRcdH1cbiAgXHRcdFx0aWYgKCBjb250ZXh0RG93biApIHtcbiAgXHRcdFx0XHRjb250ZXh0RG93biA9ICdcXG4nICsgY29udGV4dERvd247XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dmFyIG51bVRhYnMgPSAwO1xuICBcdFx0dmFyIGFubm90YXRpb24gPSBjb250ZXh0VXAgKyBsaW5lLnJlcGxhY2UoIC9cXHQvZywgZnVuY3Rpb24gKCBtYXRjaCwgY2hhciApIHtcbiAgXHRcdFx0aWYgKCBjaGFyIDwgY29sdW1uTnVtICkge1xuICBcdFx0XHRcdG51bVRhYnMgKz0gMTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiAnICAnO1xuICBcdFx0fSkgKyAnXFxuJyArIG5ldyBBcnJheSggY29sdW1uTnVtICsgbnVtVGFicyApLmpvaW4oICcgJyApICsgJ14tLS0tJyArIGNvbnRleHREb3duO1xuXG4gIFx0XHRyZXR1cm4gWyBsaW5lTnVtLCBjb2x1bW5OdW0sIChcIlwiICsgbWVzc2FnZSArIFwiIGF0IGxpbmUgXCIgKyBsaW5lTnVtICsgXCIgY2hhcmFjdGVyIFwiICsgY29sdW1uTnVtICsgXCI6XFxuXCIgKyBhbm5vdGF0aW9uKSBdO1xuICBcdH0sXG5cbiAgXHRnZXRMaW5lUG9zOiBmdW5jdGlvbiAoIGNoYXIgKSB7XG4gIFx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dmFyIGxpbmVOdW0gPSAwLCBsaW5lU3RhcnQgPSAwLCBjb2x1bW5OdW07XG5cbiAgXHRcdHdoaWxlICggY2hhciA+PSB0aGlzJDEubGluZUVuZHNbIGxpbmVOdW0gXSApIHtcbiAgXHRcdFx0bGluZVN0YXJ0ID0gdGhpcyQxLmxpbmVFbmRzWyBsaW5lTnVtIF07XG4gIFx0XHRcdGxpbmVOdW0gKz0gMTtcbiAgXHRcdH1cblxuICBcdFx0Y29sdW1uTnVtID0gY2hhciAtIGxpbmVTdGFydDtcbiAgXHRcdHJldHVybiBbIGxpbmVOdW0gKyAxLCBjb2x1bW5OdW0gKyAxLCBjaGFyIF07IC8vIGxpbmUvY29sIHNob3VsZCBiZSBvbmUtYmFzZWQsIG5vdCB6ZXJvLWJhc2VkIVxuICBcdH0sXG5cbiAgXHRlcnJvcjogZnVuY3Rpb24gKCBtZXNzYWdlICkge1xuICBcdFx0dmFyIHJlZiA9IHRoaXMuZ2V0Q29udGV4dE1lc3NhZ2UoIHRoaXMucG9zLCBtZXNzYWdlICksIGxpbmVOdW0gPSByZWZbMF0sIGNvbHVtbk51bSA9IHJlZlsxXSwgbXNnID0gcmVmWzJdO1xuXG4gIFx0XHR2YXIgZXJyb3IgPSBuZXcgUGFyc2VFcnJvciggbXNnICk7XG5cbiAgXHRcdGVycm9yLmxpbmUgPSBsaW5lTnVtO1xuICBcdFx0ZXJyb3IuY2hhcmFjdGVyID0gY29sdW1uTnVtO1xuICBcdFx0ZXJyb3Iuc2hvcnRNZXNzYWdlID0gbWVzc2FnZTtcblxuICBcdFx0dGhyb3cgZXJyb3I7XG4gIFx0fSxcblxuICBcdG1hdGNoU3RyaW5nOiBmdW5jdGlvbiAoIHN0cmluZyApIHtcbiAgXHRcdGlmICggdGhpcy5zdHIuc3Vic3RyKCB0aGlzLnBvcywgc3RyaW5nLmxlbmd0aCApID09PSBzdHJpbmcgKSB7XG4gIFx0XHRcdHRoaXMucG9zICs9IHN0cmluZy5sZW5ndGg7XG4gIFx0XHRcdHJldHVybiBzdHJpbmc7XG4gIFx0XHR9XG4gIFx0fSxcblxuICBcdG1hdGNoUGF0dGVybjogZnVuY3Rpb24gKCBwYXR0ZXJuICkge1xuICBcdFx0dmFyIG1hdGNoO1xuXG4gIFx0XHRpZiAoIG1hdGNoID0gcGF0dGVybi5leGVjKCB0aGlzLnJlbWFpbmluZygpICkgKSB7XG4gIFx0XHRcdHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgXHRcdFx0cmV0dXJuIG1hdGNoWzFdIHx8IG1hdGNoWzBdO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRhbGxvd1doaXRlc3BhY2U6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMubWF0Y2hQYXR0ZXJuKCBsZWFkaW5nV2hpdGVzcGFjZSApO1xuICBcdH0sXG5cbiAgXHRyZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLnN0ci5zdWJzdHJpbmcoIHRoaXMucG9zICk7XG4gIFx0fSxcblxuICBcdG5leHRDaGFyOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5zdHIuY2hhckF0KCB0aGlzLnBvcyApO1xuICBcdH1cbiAgfTtcblxuICBQYXJzZXIuZXh0ZW5kID0gZnVuY3Rpb24gKCBwcm90byApIHtcbiAgXHR2YXIgUGFyZW50ID0gdGhpcywgQ2hpbGQsIGtleTtcblxuICBcdENoaWxkID0gZnVuY3Rpb24gKCBzdHIsIG9wdGlvbnMgKSB7XG4gIFx0XHRQYXJzZXIuY2FsbCggdGhpcywgc3RyLCBvcHRpb25zICk7XG4gIFx0fTtcblxuICBcdENoaWxkLnByb3RvdHlwZSA9IGNyZWF0ZSggUGFyZW50LnByb3RvdHlwZSApO1xuXG4gIFx0Zm9yICgga2V5IGluIHByb3RvICkge1xuICBcdFx0aWYgKCBoYXNPd24uY2FsbCggcHJvdG8sIGtleSApICkge1xuICBcdFx0XHRDaGlsZC5wcm90b3R5cGVbIGtleSBdID0gcHJvdG9bIGtleSBdO1xuICBcdFx0fVxuICBcdH1cblxuICBcdENoaWxkLmV4dGVuZCA9IFBhcnNlci5leHRlbmQ7XG4gIFx0cmV0dXJuIENoaWxkO1xuICB9O1xuXG4gIHZhciBQYXJzZXIkMSA9IFBhcnNlcjtcblxuICB2YXIgVEVYVCAgICAgICAgICAgICAgPSAxO1xuICB2YXIgSU5URVJQT0xBVE9SICAgICAgPSAyO1xuICB2YXIgVFJJUExFICAgICAgICAgICAgPSAzO1xuICB2YXIgU0VDVElPTiAgICAgICAgICAgPSA0O1xuICB2YXIgSU5WRVJURUQgICAgICAgICAgPSA1O1xuICB2YXIgQ0xPU0lORyAgICAgICAgICAgPSA2O1xuICB2YXIgRUxFTUVOVCAgICAgICAgICAgPSA3O1xuICB2YXIgUEFSVElBTCAgICAgICAgICAgPSA4O1xuICB2YXIgQ09NTUVOVCAgICAgICAgICAgPSA5O1xuICB2YXIgREVMSU1DSEFOR0UgICAgICAgPSAxMDtcbiAgdmFyIEFUVFJJQlVURSAgICAgICAgID0gMTM7XG4gIHZhciBDTE9TSU5HX1RBRyAgICAgICA9IDE0O1xuICB2YXIgQ09NUE9ORU5UICAgICAgICAgPSAxNTtcbiAgdmFyIFlJRUxERVIgICAgICAgICAgID0gMTY7XG4gIHZhciBJTkxJTkVfUEFSVElBTCAgICA9IDE3O1xuICB2YXIgRE9DVFlQRSAgICAgICAgICAgPSAxODtcbiAgdmFyIEFMSUFTICAgICAgICAgICAgID0gMTk7XG5cbiAgdmFyIE5VTUJFUl9MSVRFUkFMICAgID0gMjA7XG4gIHZhciBTVFJJTkdfTElURVJBTCAgICA9IDIxO1xuICB2YXIgQVJSQVlfTElURVJBTCAgICAgPSAyMjtcbiAgdmFyIE9CSkVDVF9MSVRFUkFMICAgID0gMjM7XG4gIHZhciBCT09MRUFOX0xJVEVSQUwgICA9IDI0O1xuICB2YXIgUkVHRVhQX0xJVEVSQUwgICAgPSAyNTtcblxuICB2YXIgR0xPQkFMICAgICAgICAgICAgPSAyNjtcbiAgdmFyIEtFWV9WQUxVRV9QQUlSICAgID0gMjc7XG5cblxuICB2YXIgUkVGRVJFTkNFICAgICAgICAgPSAzMDtcbiAgdmFyIFJFRklORU1FTlQgICAgICAgID0gMzE7XG4gIHZhciBNRU1CRVIgICAgICAgICAgICA9IDMyO1xuICB2YXIgUFJFRklYX09QRVJBVE9SICAgPSAzMztcbiAgdmFyIEJSQUNLRVRFRCAgICAgICAgID0gMzQ7XG4gIHZhciBDT05ESVRJT05BTCAgICAgICA9IDM1O1xuICB2YXIgSU5GSVhfT1BFUkFUT1IgICAgPSAzNjtcblxuICB2YXIgSU5WT0NBVElPTiAgICAgICAgPSA0MDtcblxuICB2YXIgU0VDVElPTl9JRiAgICAgICAgPSA1MDtcbiAgdmFyIFNFQ1RJT05fVU5MRVNTICAgID0gNTE7XG4gIHZhciBTRUNUSU9OX0VBQ0ggICAgICA9IDUyO1xuICB2YXIgU0VDVElPTl9XSVRIICAgICAgPSA1MztcbiAgdmFyIFNFQ1RJT05fSUZfV0lUSCAgID0gNTQ7XG5cbiAgdmFyIEVMU0UgICAgICAgICAgICAgID0gNjA7XG4gIHZhciBFTFNFSUYgICAgICAgICAgICA9IDYxO1xuXG4gIHZhciBFVkVOVCAgICAgICAgICAgICA9IDcwO1xuICB2YXIgREVDT1JBVE9SICAgICAgICAgPSA3MTtcbiAgdmFyIFRSQU5TSVRJT04gICAgICAgID0gNzI7XG4gIHZhciBCSU5ESU5HX0ZMQUcgICAgICA9IDczO1xuXG4gIHZhciBkZWxpbWl0ZXJDaGFuZ2VQYXR0ZXJuID0gL15bXlxccz1dKy87XG4gIHZhciB3aGl0ZXNwYWNlUGF0dGVybiA9IC9eXFxzKy87XG4gIGZ1bmN0aW9uIHJlYWREZWxpbWl0ZXJDaGFuZ2UgKCBwYXJzZXIgKSB7XG4gIFx0dmFyIHN0YXJ0LCBvcGVuaW5nLCBjbG9zaW5nO1xuXG4gIFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPScgKSApIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIG5ldyBvcGVuaW5nIGRlbGltaXRlclxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdG9wZW5pbmcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBkZWxpbWl0ZXJDaGFuZ2VQYXR0ZXJuICk7XG4gIFx0aWYgKCAhb3BlbmluZyApIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgKGluIGZhY3QsIGl0J3MgbmVjZXNzYXJ5Li4uKVxuICBcdGlmICggIXBhcnNlci5tYXRjaFBhdHRlcm4oIHdoaXRlc3BhY2VQYXR0ZXJuICkgKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRjbG9zaW5nID0gcGFyc2VyLm1hdGNoUGF0dGVybiggZGVsaW1pdGVyQ2hhbmdlUGF0dGVybiApO1xuICBcdGlmICggIWNsb3NpbmcgKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSBjbG9zaW5nICc9J1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJz0nICkgKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gWyBvcGVuaW5nLCBjbG9zaW5nIF07XG4gIH1cblxuICB2YXIgcmVnZXhwUGF0dGVybiA9IC9eKFxcLyg/OlteXFxuXFxyXFx1MjAyOFxcdTIwMjkvXFxcXFtdfFxcXFwufFxcWyg/OlteXFxuXFxyXFx1MjAyOFxcdTIwMjlcXF1cXFxcXXxcXFxcLikqXSkrXFwvKD86KFtnaW11eV0pKD8hW2Etel0qXFwyKSkqKD8hW2EtekEtWl8kMC05XSkpLztcblxuICBmdW5jdGlvbiByZWFkTnVtYmVyTGl0ZXJhbCAoIHBhcnNlciApIHtcbiAgXHR2YXIgcmVzdWx0O1xuXG4gIFx0aWYgKCByZXN1bHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCByZWdleHBQYXR0ZXJuICkgKSB7XG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBSRUdFWFBfTElURVJBTCxcbiAgXHRcdFx0djogcmVzdWx0XG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHBhdHRlcm4kMSA9IC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nO1xuXG4gIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cCAoIHN0ciApIHtcbiAgXHRyZXR1cm4gc3RyLnJlcGxhY2UoIHBhdHRlcm4kMSwgJ1xcXFwkJicgKTtcbiAgfVxuXG4gIHZhciByZWdFeHBDYWNoZSA9IHt9O1xuXG4gIGZ1bmN0aW9uIGdldExvd2VzdEluZGV4ICggaGF5c3RhY2ssIG5lZWRsZXMgKSB7XG4gIFx0cmV0dXJuIGhheXN0YWNrLnNlYXJjaCggcmVnRXhwQ2FjaGVbbmVlZGxlcy5qb2luKCldIHx8ICggcmVnRXhwQ2FjaGVbbmVlZGxlcy5qb2luKCldID0gbmV3IFJlZ0V4cCggbmVlZGxlcy5tYXAoIGVzY2FwZVJlZ0V4cCApLmpvaW4oICd8JyApICkgKSApO1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2thbmdheC9odG1sLW1pbmlmaWVyL2lzc3Vlcy82MyNpc3N1ZWNvbW1lbnQtMzc3NjMzMTZcbiAgdmFyIGJvb2xlYW5BdHRyaWJ1dGVzID0gL14oYWxsb3dGdWxsc2NyZWVufGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjaGVja2VkfGNvbXBhY3R8Y29udHJvbHN8ZGVjbGFyZXxkZWZhdWx0fGRlZmF1bHRDaGVja2VkfGRlZmF1bHRNdXRlZHxkZWZhdWx0U2VsZWN0ZWR8ZGVmZXJ8ZGlzYWJsZWR8ZW5hYmxlZHxmb3JtTm9WYWxpZGF0ZXxoaWRkZW58aW5kZXRlcm1pbmF0ZXxpbmVydHxpc01hcHxpdGVtU2NvcGV8bG9vcHxtdWx0aXBsZXxtdXRlZHxub0hyZWZ8bm9SZXNpemV8bm9TaGFkZXxub1ZhbGlkYXRlfG5vV3JhcHxvcGVufHBhdXNlT25FeGl0fHJlYWRPbmx5fHJlcXVpcmVkfHJldmVyc2VkfHNjb3BlZHxzZWFtbGVzc3xzZWxlY3RlZHxzb3J0YWJsZXx0cmFuc2xhdGV8dHJ1ZVNwZWVkfHR5cGVNdXN0TWF0Y2h8dmlzaWJsZSkkL2k7XG4gIHZhciB2b2lkRWxlbWVudE5hbWVzID0gL14oPzphcmVhfGJhc2V8YnJ8Y29sfGNvbW1hbmR8ZG9jdHlwZXxlbWJlZHxocnxpbWd8aW5wdXR8a2V5Z2VufGxpbmt8bWV0YXxwYXJhbXxzb3VyY2V8dHJhY2t8d2JyKSQvaTtcblxuICB2YXIgaHRtbEVudGl0aWVzID0geyBxdW90OiAzNCwgYW1wOiAzOCwgYXBvczogMzksIGx0OiA2MCwgZ3Q6IDYyLCBuYnNwOiAxNjAsIGlleGNsOiAxNjEsIGNlbnQ6IDE2MiwgcG91bmQ6IDE2MywgY3VycmVuOiAxNjQsIHllbjogMTY1LCBicnZiYXI6IDE2Niwgc2VjdDogMTY3LCB1bWw6IDE2OCwgY29weTogMTY5LCBvcmRmOiAxNzAsIGxhcXVvOiAxNzEsIG5vdDogMTcyLCBzaHk6IDE3MywgcmVnOiAxNzQsIG1hY3I6IDE3NSwgZGVnOiAxNzYsIHBsdXNtbjogMTc3LCBzdXAyOiAxNzgsIHN1cDM6IDE3OSwgYWN1dGU6IDE4MCwgbWljcm86IDE4MSwgcGFyYTogMTgyLCBtaWRkb3Q6IDE4MywgY2VkaWw6IDE4NCwgc3VwMTogMTg1LCBvcmRtOiAxODYsIHJhcXVvOiAxODcsIGZyYWMxNDogMTg4LCBmcmFjMTI6IDE4OSwgZnJhYzM0OiAxOTAsIGlxdWVzdDogMTkxLCBBZ3JhdmU6IDE5MiwgQWFjdXRlOiAxOTMsIEFjaXJjOiAxOTQsIEF0aWxkZTogMTk1LCBBdW1sOiAxOTYsIEFyaW5nOiAxOTcsIEFFbGlnOiAxOTgsIENjZWRpbDogMTk5LCBFZ3JhdmU6IDIwMCwgRWFjdXRlOiAyMDEsIEVjaXJjOiAyMDIsIEV1bWw6IDIwMywgSWdyYXZlOiAyMDQsIElhY3V0ZTogMjA1LCBJY2lyYzogMjA2LCBJdW1sOiAyMDcsIEVUSDogMjA4LCBOdGlsZGU6IDIwOSwgT2dyYXZlOiAyMTAsIE9hY3V0ZTogMjExLCBPY2lyYzogMjEyLCBPdGlsZGU6IDIxMywgT3VtbDogMjE0LCB0aW1lczogMjE1LCBPc2xhc2g6IDIxNiwgVWdyYXZlOiAyMTcsIFVhY3V0ZTogMjE4LCBVY2lyYzogMjE5LCBVdW1sOiAyMjAsIFlhY3V0ZTogMjIxLCBUSE9STjogMjIyLCBzemxpZzogMjIzLCBhZ3JhdmU6IDIyNCwgYWFjdXRlOiAyMjUsIGFjaXJjOiAyMjYsIGF0aWxkZTogMjI3LCBhdW1sOiAyMjgsIGFyaW5nOiAyMjksIGFlbGlnOiAyMzAsIGNjZWRpbDogMjMxLCBlZ3JhdmU6IDIzMiwgZWFjdXRlOiAyMzMsIGVjaXJjOiAyMzQsIGV1bWw6IDIzNSwgaWdyYXZlOiAyMzYsIGlhY3V0ZTogMjM3LCBpY2lyYzogMjM4LCBpdW1sOiAyMzksIGV0aDogMjQwLCBudGlsZGU6IDI0MSwgb2dyYXZlOiAyNDIsIG9hY3V0ZTogMjQzLCBvY2lyYzogMjQ0LCBvdGlsZGU6IDI0NSwgb3VtbDogMjQ2LCBkaXZpZGU6IDI0Nywgb3NsYXNoOiAyNDgsIHVncmF2ZTogMjQ5LCB1YWN1dGU6IDI1MCwgdWNpcmM6IDI1MSwgdXVtbDogMjUyLCB5YWN1dGU6IDI1MywgdGhvcm46IDI1NCwgeXVtbDogMjU1LCBPRWxpZzogMzM4LCBvZWxpZzogMzM5LCBTY2Fyb246IDM1Miwgc2Nhcm9uOiAzNTMsIFl1bWw6IDM3NiwgZm5vZjogNDAyLCBjaXJjOiA3MTAsIHRpbGRlOiA3MzIsIEFscGhhOiA5MTMsIEJldGE6IDkxNCwgR2FtbWE6IDkxNSwgRGVsdGE6IDkxNiwgRXBzaWxvbjogOTE3LCBaZXRhOiA5MTgsIEV0YTogOTE5LCBUaGV0YTogOTIwLCBJb3RhOiA5MjEsIEthcHBhOiA5MjIsIExhbWJkYTogOTIzLCBNdTogOTI0LCBOdTogOTI1LCBYaTogOTI2LCBPbWljcm9uOiA5MjcsIFBpOiA5MjgsIFJobzogOTI5LCBTaWdtYTogOTMxLCBUYXU6IDkzMiwgVXBzaWxvbjogOTMzLCBQaGk6IDkzNCwgQ2hpOiA5MzUsIFBzaTogOTM2LCBPbWVnYTogOTM3LCBhbHBoYTogOTQ1LCBiZXRhOiA5NDYsIGdhbW1hOiA5NDcsIGRlbHRhOiA5NDgsIGVwc2lsb246IDk0OSwgemV0YTogOTUwLCBldGE6IDk1MSwgdGhldGE6IDk1MiwgaW90YTogOTUzLCBrYXBwYTogOTU0LCBsYW1iZGE6IDk1NSwgbXU6IDk1NiwgbnU6IDk1NywgeGk6IDk1OCwgb21pY3JvbjogOTU5LCBwaTogOTYwLCByaG86IDk2MSwgc2lnbWFmOiA5NjIsIHNpZ21hOiA5NjMsIHRhdTogOTY0LCB1cHNpbG9uOiA5NjUsIHBoaTogOTY2LCBjaGk6IDk2NywgcHNpOiA5NjgsIG9tZWdhOiA5NjksIHRoZXRhc3ltOiA5NzcsIHVwc2loOiA5NzgsIHBpdjogOTgyLCBlbnNwOiA4MTk0LCBlbXNwOiA4MTk1LCB0aGluc3A6IDgyMDEsIHp3bmo6IDgyMDQsIHp3ajogODIwNSwgbHJtOiA4MjA2LCBybG06IDgyMDcsIG5kYXNoOiA4MjExLCBtZGFzaDogODIxMiwgbHNxdW86IDgyMTYsIHJzcXVvOiA4MjE3LCBzYnF1bzogODIxOCwgbGRxdW86IDgyMjAsIHJkcXVvOiA4MjIxLCBiZHF1bzogODIyMiwgZGFnZ2VyOiA4MjI0LCBEYWdnZXI6IDgyMjUsIGJ1bGw6IDgyMjYsIGhlbGxpcDogODIzMCwgcGVybWlsOiA4MjQwLCBwcmltZTogODI0MiwgUHJpbWU6IDgyNDMsIGxzYXF1bzogODI0OSwgcnNhcXVvOiA4MjUwLCBvbGluZTogODI1NCwgZnJhc2w6IDgyNjAsIGV1cm86IDgzNjQsIGltYWdlOiA4NDY1LCB3ZWllcnA6IDg0NzIsIHJlYWw6IDg0NzYsIHRyYWRlOiA4NDgyLCBhbGVmc3ltOiA4NTAxLCBsYXJyOiA4NTkyLCB1YXJyOiA4NTkzLCByYXJyOiA4NTk0LCBkYXJyOiA4NTk1LCBoYXJyOiA4NTk2LCBjcmFycjogODYyOSwgbEFycjogODY1NiwgdUFycjogODY1NywgckFycjogODY1OCwgZEFycjogODY1OSwgaEFycjogODY2MCwgZm9yYWxsOiA4NzA0LCBwYXJ0OiA4NzA2LCBleGlzdDogODcwNywgZW1wdHk6IDg3MDksIG5hYmxhOiA4NzExLCBpc2luOiA4NzEyLCBub3RpbjogODcxMywgbmk6IDg3MTUsIHByb2Q6IDg3MTksIHN1bTogODcyMSwgbWludXM6IDg3MjIsIGxvd2FzdDogODcyNywgcmFkaWM6IDg3MzAsIHByb3A6IDg3MzMsIGluZmluOiA4NzM0LCBhbmc6IDg3MzYsIGFuZDogODc0Mywgb3I6IDg3NDQsIGNhcDogODc0NSwgY3VwOiA4NzQ2LCAnaW50JzogODc0NywgdGhlcmU0OiA4NzU2LCBzaW06IDg3NjQsIGNvbmc6IDg3NzMsIGFzeW1wOiA4Nzc2LCBuZTogODgwMCwgZXF1aXY6IDg4MDEsIGxlOiA4ODA0LCBnZTogODgwNSwgc3ViOiA4ODM0LCBzdXA6IDg4MzUsIG5zdWI6IDg4MzYsIHN1YmU6IDg4MzgsIHN1cGU6IDg4MzksIG9wbHVzOiA4ODUzLCBvdGltZXM6IDg4NTUsIHBlcnA6IDg4NjksIHNkb3Q6IDg5MDEsIGxjZWlsOiA4OTY4LCByY2VpbDogODk2OSwgbGZsb29yOiA4OTcwLCByZmxvb3I6IDg5NzEsIGxhbmc6IDkwMDEsIHJhbmc6IDkwMDIsIGxvejogOTY3NCwgc3BhZGVzOiA5ODI0LCBjbHViczogOTgyNywgaGVhcnRzOiA5ODI5LCBkaWFtczogOTgzMFx0fTtcbiAgdmFyIGNvbnRyb2xDaGFyYWN0ZXJzID0gWyA4MzY0LCAxMjksIDgyMTgsIDQwMiwgODIyMiwgODIzMCwgODIyNCwgODIyNSwgNzEwLCA4MjQwLCAzNTIsIDgyNDksIDMzOCwgMTQxLCAzODEsIDE0MywgMTQ0LCA4MjE2LCA4MjE3LCA4MjIwLCA4MjIxLCA4MjI2LCA4MjExLCA4MjEyLCA3MzIsIDg0ODIsIDM1MywgODI1MCwgMzM5LCAxNTcsIDM4MiwgMzc2IF07XG4gIHZhciBlbnRpdHlQYXR0ZXJuID0gbmV3IFJlZ0V4cCggJyYoIz8oPzp4W1xcXFx3XFxcXGRdK3xcXFxcZCt8JyArIE9iamVjdC5rZXlzKCBodG1sRW50aXRpZXMgKS5qb2luKCAnfCcgKSArICcpKTs/JywgJ2cnICk7XG4gIHZhciBjb2RlUG9pbnRTdXBwb3J0ID0gdHlwZW9mIFN0cmluZy5mcm9tQ29kZVBvaW50ID09PSAnZnVuY3Rpb24nO1xuICB2YXIgY29kZVRvQ2hhciA9IGNvZGVQb2ludFN1cHBvcnQgPyBTdHJpbmcuZnJvbUNvZGVQb2ludCA6IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgZnVuY3Rpb24gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyAoIGh0bWwgKSB7XG4gIFx0cmV0dXJuIGh0bWwucmVwbGFjZSggZW50aXR5UGF0dGVybiwgZnVuY3Rpb24gKCBtYXRjaCwgZW50aXR5ICkge1xuICBcdFx0dmFyIGNvZGU7XG5cbiAgXHRcdC8vIEhhbmRsZSBuYW1lZCBlbnRpdGllc1xuICBcdFx0aWYgKCBlbnRpdHlbMF0gIT09ICcjJyApIHtcbiAgXHRcdFx0Y29kZSA9IGh0bWxFbnRpdGllc1sgZW50aXR5IF07XG4gIFx0XHR9IGVsc2UgaWYgKCBlbnRpdHlbMV0gPT09ICd4JyApIHtcbiAgXHRcdFx0Y29kZSA9IHBhcnNlSW50KCBlbnRpdHkuc3Vic3RyaW5nKCAyICksIDE2ICk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjb2RlID0gcGFyc2VJbnQoIGVudGl0eS5zdWJzdHJpbmcoIDEgKSwgMTAgKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCAhY29kZSApIHtcbiAgXHRcdFx0cmV0dXJuIG1hdGNoO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gY29kZVRvQ2hhciggdmFsaWRhdGVDb2RlKCBjb2RlICkgKTtcbiAgXHR9KTtcbiAgfVxuXG4gIHZhciBsZXNzVGhhbiA9IC88L2c7XG4gIHZhciBncmVhdGVyVGhhbiA9IC8+L2c7XG4gIHZhciBhbXAgPSAvJi9nO1xuICB2YXIgaW52YWxpZCA9IDY1NTMzO1xuXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWwgKCBzdHIgKSB7XG4gIFx0cmV0dXJuIHN0clxuICBcdFx0LnJlcGxhY2UoIGFtcCwgJyZhbXA7JyApXG4gIFx0XHQucmVwbGFjZSggbGVzc1RoYW4sICcmbHQ7JyApXG4gIFx0XHQucmVwbGFjZSggZ3JlYXRlclRoYW4sICcmZ3Q7JyApO1xuICB9XG5cbiAgLy8gc29tZSBjb2RlIHBvaW50cyBhcmUgdmVyYm90ZW4uIElmIHdlIHdlcmUgaW5zZXJ0aW5nIEhUTUwsIHRoZSBicm93c2VyIHdvdWxkIHJlcGxhY2UgdGhlIGlsbGVnYWxcbiAgLy8gY29kZSBwb2ludHMgd2l0aCBhbHRlcm5hdGl2ZXMgaW4gc29tZSBjYXNlcyAtIHNpbmNlIHdlJ3JlIGJ5cGFzc2luZyB0aGF0IG1lY2hhbmlzbSwgd2UgbmVlZFxuICAvLyB0byByZXBsYWNlIHRoZW0gb3Vyc2VsdmVzXG4gIC8vXG4gIC8vIFNvdXJjZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DaGFyYWN0ZXJfZW5jb2RpbmdzX2luX0hUTUwjSWxsZWdhbF9jaGFyYWN0ZXJzXG4gIGZ1bmN0aW9uIHZhbGlkYXRlQ29kZSAoIGNvZGUgKSB7XG4gIFx0aWYgKCAhY29kZSApIHtcbiAgXHRcdHJldHVybiBpbnZhbGlkO1xuICBcdH1cblxuICBcdC8vIGxpbmUgZmVlZCBiZWNvbWVzIGdlbmVyaWMgd2hpdGVzcGFjZVxuICBcdGlmICggY29kZSA9PT0gMTAgKSB7XG4gIFx0XHRyZXR1cm4gMzI7XG4gIFx0fVxuXG4gIFx0Ly8gQVNDSUkgcmFuZ2UuIChXaHkgc29tZW9uZSB3b3VsZCB1c2UgSFRNTCBlbnRpdGllcyBmb3IgQVNDSUkgY2hhcmFjdGVycyBJIGRvbid0IGtub3csIGJ1dC4uLilcbiAgXHRpZiAoIGNvZGUgPCAxMjggKSB7XG4gIFx0XHRyZXR1cm4gY29kZTtcbiAgXHR9XG5cbiAgXHQvLyBjb2RlIHBvaW50cyAxMjgtMTU5IGFyZSBkZWFsdCB3aXRoIGxlbmllbnRseSBieSBicm93c2VycywgYnV0IHRoZXkncmUgaW5jb3JyZWN0LiBXZSBuZWVkXG4gIFx0Ly8gdG8gY29ycmVjdCB0aGUgbWlzdGFrZSBvciB3ZSdsbCBlbmQgdXAgd2l0aCBtaXNzaW5nIOKCrCBzaWducyBhbmQgc28gb25cbiAgXHRpZiAoIGNvZGUgPD0gMTU5ICkge1xuICBcdFx0cmV0dXJuIGNvbnRyb2xDaGFyYWN0ZXJzWyBjb2RlIC0gMTI4IF07XG4gIFx0fVxuXG4gIFx0Ly8gYmFzaWMgbXVsdGlsaW5ndWFsIHBsYW5lXG4gIFx0aWYgKCBjb2RlIDwgNTUyOTYgKSB7XG4gIFx0XHRyZXR1cm4gY29kZTtcbiAgXHR9XG5cbiAgXHQvLyBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuICBcdGlmICggY29kZSA8PSA1NzM0MyApIHtcbiAgXHRcdHJldHVybiBpbnZhbGlkO1xuICBcdH1cblxuICBcdC8vIHJlc3Qgb2YgdGhlIGJhc2ljIG11bHRpbGluZ3VhbCBwbGFuZVxuICBcdGlmICggY29kZSA8PSA2NTUzNSApIHtcbiAgXHRcdHJldHVybiBjb2RlO1xuICBcdH0gZWxzZSBpZiAoICFjb2RlUG9pbnRTdXBwb3J0ICkge1xuICBcdFx0cmV0dXJuIGludmFsaWQ7XG4gIFx0fVxuXG4gIFx0Ly8gc3VwcGxlbWVudGFyeSBtdWx0aWxpbmd1YWwgcGxhbmUgMHgxMDAwMCAtIDB4MWZmZmZcbiAgXHRpZiAoIGNvZGUgPj0gNjU1MzYgJiYgY29kZSA8PSAxMzEwNzEgKSB7XG4gIFx0XHRyZXR1cm4gY29kZTtcbiAgXHR9XG5cbiAgXHQvLyBzdXBwbGVtZW50YXJ5IGlkZW9ncmFwaGljIHBsYW5lIDB4MjAwMDAgLSAweDJmZmZmXG4gIFx0aWYgKCBjb2RlID49IDEzMTA3MiAmJiBjb2RlIDw9IDE5NjYwNyApIHtcbiAgXHRcdHJldHVybiBjb2RlO1xuICBcdH1cblxuICBcdHJldHVybiBpbnZhbGlkO1xuICB9XG5cbiAgdmFyIGV4cGVjdGVkRXhwcmVzc2lvbiA9ICdFeHBlY3RlZCBhIEphdmFTY3JpcHQgZXhwcmVzc2lvbic7XG4gIHZhciBleHBlY3RlZFBhcmVuID0gJ0V4cGVjdGVkIGNsb3NpbmcgcGFyZW4nO1xuXG4gIC8vIGJ1bGxldHByb29mIG51bWJlciByZWdleCBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1JpY2gtSGFycmlzLzc1NDQzMzBcbiAgdmFyIG51bWJlclBhdHRlcm4gPSAvXig/OlsrLV0/KTAqKD86KD86KD86WzEtOV1cXGQqKT9cXC5cXGQrKXwoPzooPzowfFsxLTldXFxkKilcXC4pfCg/OjB8WzEtOV1cXGQqKSkoPzpbZUVdWystXT9cXGQrKT8vO1xuXG4gIGZ1bmN0aW9uIHJlYWROdW1iZXJMaXRlcmFsJDEgKCBwYXJzZXIgKSB7XG4gIFx0dmFyIHJlc3VsdDtcblxuICBcdGlmICggcmVzdWx0ID0gcGFyc2VyLm1hdGNoUGF0dGVybiggbnVtYmVyUGF0dGVybiApICkge1xuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogTlVNQkVSX0xJVEVSQUwsXG4gIFx0XHRcdHY6IHJlc3VsdFxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCb29sZWFuTGl0ZXJhbCAoIHBhcnNlciApIHtcbiAgXHR2YXIgcmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXG4gIFx0aWYgKCByZW1haW5pbmcuc3Vic3RyKCAwLCA0ICkgPT09ICd0cnVlJyApIHtcbiAgXHRcdHBhcnNlci5wb3MgKz0gNDtcbiAgXHRcdHJldHVybiB7XG4gIFx0XHRcdHQ6IEJPT0xFQU5fTElURVJBTCxcbiAgXHRcdFx0djogJ3RydWUnXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdGlmICggcmVtYWluaW5nLnN1YnN0ciggMCwgNSApID09PSAnZmFsc2UnICkge1xuICBcdFx0cGFyc2VyLnBvcyArPSA1O1xuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogQk9PTEVBTl9MSVRFUkFMLFxuICBcdFx0XHR2OiAnZmFsc2UnXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHN0cmluZ01pZGRsZVBhdHRlcm47XG4gIHZhciBlc2NhcGVTZXF1ZW5jZVBhdHRlcm47XG4gIHZhciBsaW5lQ29udGludWF0aW9uUGF0dGVybjtcbiAgLy8gTWF0Y2ggb25lIG9yIG1vcmUgY2hhcmFjdGVycyB1bnRpbDogXCIsICcsIFxcLCBvciBFT0wvRU9GLlxuICAvLyBFT0wvRU9GIGlzIHdyaXR0ZW4gYXMgKD8hLikgKG1lYW5pbmcgdGhlcmUncyBubyBub24tbmV3bGluZSBjaGFyIG5leHQpLlxuICBzdHJpbmdNaWRkbGVQYXR0ZXJuID0gL14oPz0uKVteXCInXFxcXF0rPyg/Oig/IS4pfCg/PVtcIidcXFxcXSkpLztcblxuICAvLyBNYXRjaCBvbmUgZXNjYXBlIHNlcXVlbmNlLCBpbmNsdWRpbmcgdGhlIGJhY2tzbGFzaC5cbiAgZXNjYXBlU2VxdWVuY2VQYXR0ZXJuID0gL15cXFxcKD86WydcIlxcXFxiZm5ydF18MCg/IVswLTldKXx4WzAtOWEtZkEtRl17Mn18dVswLTlhLWZBLUZdezR9fCg/PS4pW151eDAtOV0pLztcblxuICAvLyBNYXRjaCBvbmUgRVM1IGxpbmUgY29udGludWF0aW9uIChiYWNrc2xhc2ggKyBsaW5lIHRlcm1pbmF0b3IpLlxuICBsaW5lQ29udGludWF0aW9uUGF0dGVybiA9IC9eXFxcXCg/OlxcclxcbnxbXFx1MDAwQVxcdTAwMERcXHUyMDI4XFx1MjAyOV0pLztcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIGdldERvdWJsZVF1b3RlZFN0cmluZyBhbmQgZ2V0U2luZ2xlUXVvdGVkU3RyaW5nLlxuICBmdW5jdGlvbiBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciAoIG9rUXVvdGUgKSB7XG4gIFx0cmV0dXJuIGZ1bmN0aW9uICggcGFyc2VyICkge1xuICBcdFx0dmFyIGxpdGVyYWwgPSAnXCInO1xuICBcdFx0dmFyIGRvbmUgPSBmYWxzZTtcbiAgXHRcdHZhciBuZXh0O1xuXG4gIFx0XHR3aGlsZSAoICFkb25lICkge1xuICBcdFx0XHRuZXh0ID0gKCBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBzdHJpbmdNaWRkbGVQYXR0ZXJuICkgfHwgcGFyc2VyLm1hdGNoUGF0dGVybiggZXNjYXBlU2VxdWVuY2VQYXR0ZXJuICkgfHxcbiAgXHRcdFx0XHRwYXJzZXIubWF0Y2hTdHJpbmcoIG9rUXVvdGUgKSApO1xuICBcdFx0XHRpZiAoIG5leHQgKSB7XG4gIFx0XHRcdFx0aWYgKCBuZXh0ID09PSAoXCJcXFwiXCIpICkge1xuICBcdFx0XHRcdFx0bGl0ZXJhbCArPSBcIlxcXFxcXFwiXCI7XG4gIFx0XHRcdFx0fSBlbHNlIGlmICggbmV4dCA9PT0gKFwiXFxcXCdcIikgKSB7XG4gIFx0XHRcdFx0XHRsaXRlcmFsICs9IFwiJ1wiO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRsaXRlcmFsICs9IG5leHQ7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdG5leHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBsaW5lQ29udGludWF0aW9uUGF0dGVybiApO1xuICBcdFx0XHRcdGlmICggbmV4dCApIHtcbiAgXHRcdFx0XHRcdC8vIGNvbnZlcnQgXFwobmV3bGluZS1saWtlKSBpbnRvIGEgXFx1IGVzY2FwZSwgd2hpY2ggaXMgYWxsb3dlZCBpbiBKU09OXG4gIFx0XHRcdFx0XHRsaXRlcmFsICs9ICdcXFxcdScgKyAoICcwMDAnICsgbmV4dC5jaGFyQ29kZUF0KDEpLnRvU3RyaW5nKDE2KSApLnNsaWNlKCAtNCApO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0bGl0ZXJhbCArPSAnXCInO1xuXG4gIFx0XHQvLyB1c2UgSlNPTi5wYXJzZSB0byBpbnRlcnByZXQgZXNjYXBlc1xuICBcdFx0cmV0dXJuIEpTT04ucGFyc2UoIGxpdGVyYWwgKTtcbiAgXHR9O1xuICB9XG5cbiAgdmFyIGdldFNpbmdsZVF1b3RlZFN0cmluZyA9IG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyKCAoXCJcXFwiXCIpICk7XG4gIHZhciBnZXREb3VibGVRdW90ZWRTdHJpbmcgPSBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciggKFwiJ1wiKSApO1xuXG4gIGZ1bmN0aW9uIHJlYWRTdHJpbmdMaXRlcmFsICggcGFyc2VyICkge1xuICBcdHZhciBzdGFydCwgc3RyaW5nO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICdcIicgKSApIHtcbiAgXHRcdHN0cmluZyA9IGdldERvdWJsZVF1b3RlZFN0cmluZyggcGFyc2VyICk7XG5cbiAgXHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ1wiJyApICkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBTVFJJTkdfTElURVJBTCxcbiAgXHRcdFx0djogc3RyaW5nXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAoXCInXCIpICkgKSB7XG4gIFx0XHRzdHJpbmcgPSBnZXRTaW5nbGVRdW90ZWRTdHJpbmcoIHBhcnNlciApO1xuXG4gIFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIChcIidcIikgKSApIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogU1RSSU5HX0xJVEVSQUwsXG4gIFx0XHRcdHY6IHN0cmluZ1xuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBuYW1lUGF0dGVybiA9IC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qLztcblxuICB2YXIgaWRlbnRpZmllciA9IC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qJC87XG5cbiAgLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1wcm9wZXJ0aWVzXG4gIC8vIGNhbiBiZSBhbnkgbmFtZSwgc3RyaW5nIGxpdGVyYWwsIG9yIG51bWJlciBsaXRlcmFsXG4gIGZ1bmN0aW9uIHJlYWRLZXkgKCBwYXJzZXIgKSB7XG4gIFx0dmFyIHRva2VuO1xuXG4gIFx0aWYgKCB0b2tlbiA9IHJlYWRTdHJpbmdMaXRlcmFsKCBwYXJzZXIgKSApIHtcbiAgXHRcdHJldHVybiBpZGVudGlmaWVyLnRlc3QoIHRva2VuLnYgKSA/IHRva2VuLnYgOiAnXCInICsgdG9rZW4udi5yZXBsYWNlKCAvXCIvZywgJ1xcXFxcIicgKSArICdcIic7XG4gIFx0fVxuXG4gIFx0aWYgKCB0b2tlbiA9IHJlYWROdW1iZXJMaXRlcmFsJDEoIHBhcnNlciApICkge1xuICBcdFx0cmV0dXJuIHRva2VuLnY7XG4gIFx0fVxuXG4gIFx0aWYgKCB0b2tlbiA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIG5hbWVQYXR0ZXJuICkgKSB7XG4gIFx0XHRyZXR1cm4gdG9rZW47XG4gIFx0fVxuXG4gIFx0cmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkS2V5VmFsdWVQYWlyICggcGFyc2VyICkge1xuICBcdHZhciBzdGFydCwga2V5LCB2YWx1ZTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiAneycgYW5kIGtleVxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdHZhciByZWZLZXkgPSBwYXJzZXIubmV4dENoYXIoKSAhPT0gJ1xcJycgJiYgcGFyc2VyLm5leHRDaGFyKCkgIT09ICdcIic7XG5cbiAgXHRrZXkgPSByZWFkS2V5KCBwYXJzZXIgKTtcbiAgXHRpZiAoIGtleSA9PT0gbnVsbCApIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBrZXkgYW5kICc6J1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIGVzMjAxNSBzaG9ydGhhbmQgcHJvcGVydHlcbiAgXHRpZiAoIHJlZktleSAmJiAoIHBhcnNlci5uZXh0Q2hhcigpID09PSAnLCcgfHwgcGFyc2VyLm5leHRDaGFyKCkgPT09ICd9JyApICkge1xuICBcdFx0aWYgKCAhbmFtZVBhdHRlcm4udGVzdCgga2V5ICkgKSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvciggKFwiRXhwZWN0ZWQgYSB2YWxpZCByZWZlcmVuY2UsIGJ1dCBmb3VuZCAnXCIgKyBrZXkgKyBcIicgaW5zdGVhZC5cIikgKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogS0VZX1ZBTFVFX1BBSVIsXG4gIFx0XHRcdGs6IGtleSxcbiAgXHRcdFx0djoge1xuICBcdFx0XHRcdHQ6IFJFRkVSRU5DRSxcbiAgXHRcdFx0XHRuOiBrZXlcbiAgXHRcdFx0fVxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHQvLyBuZXh0IGNoYXJhY3RlciBtdXN0IGJlICc6J1xuICBcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzonICkgKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gJzonIGFuZCB2YWx1ZVxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIG5leHQgZXhwcmVzc2lvbiBtdXN0IGJlIGEsIHdlbGwuLi4gZXhwcmVzc2lvblxuICBcdHZhbHVlID0gcmVhZEV4cHJlc3Npb24oIHBhcnNlciApO1xuICBcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogS0VZX1ZBTFVFX1BBSVIsXG4gIFx0XHRrOiBrZXksXG4gIFx0XHR2OiB2YWx1ZVxuICBcdH07XG4gIH1cblxuICBmdW5jdGlvbiByZWFkS2V5VmFsdWVQYWlycyAoIHBhcnNlciApIHtcbiAgXHR2YXIgc3RhcnQsIHBhaXJzLCBwYWlyLCBrZXlWYWx1ZVBhaXJzO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0cGFpciA9IHJlYWRLZXlWYWx1ZVBhaXIoIHBhcnNlciApO1xuICBcdGlmICggcGFpciA9PT0gbnVsbCApIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhaXJzID0gWyBwYWlyIF07XG5cbiAgXHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJywnICkgKSB7XG4gIFx0XHRrZXlWYWx1ZVBhaXJzID0gcmVhZEtleVZhbHVlUGFpcnMoIHBhcnNlciApO1xuXG4gIFx0XHRpZiAoICFrZXlWYWx1ZVBhaXJzICkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gcGFpcnMuY29uY2F0KCBrZXlWYWx1ZVBhaXJzICk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHBhaXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZE9iamVjdExpdGVyYWwgKCBwYXJzZXIgKSB7XG4gIFx0dmFyIHN0YXJ0LCBrZXlWYWx1ZVBhaXJzO1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZVxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ3snICkgKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRrZXlWYWx1ZVBhaXJzID0gcmVhZEtleVZhbHVlUGFpcnMoIHBhcnNlciApO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuIGZpbmFsIHZhbHVlIGFuZCAnfSdcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICd9JyApICkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IE9CSkVDVF9MSVRFUkFMLFxuICBcdFx0bToga2V5VmFsdWVQYWlyc1xuICBcdH07XG4gIH1cblxuICBmdW5jdGlvbiByZWFkRXhwcmVzc2lvbkxpc3QgKCBwYXJzZXIgKSB7XG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0dmFyIGV4cHIgPSByZWFkRXhwcmVzc2lvbiggcGFyc2VyICk7XG5cbiAgXHRpZiAoIGV4cHIgPT09IG51bGwgKSByZXR1cm4gbnVsbDtcblxuICBcdHZhciBleHByZXNzaW9ucyA9IFsgZXhwciBdO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuIGV4cHJlc3Npb24gYW5kICcsJ1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnLCcgKSApIHtcbiAgXHRcdHZhciBuZXh0ID0gcmVhZEV4cHJlc3Npb25MaXN0KCBwYXJzZXIgKTtcbiAgXHRcdGlmICggbmV4dCA9PT0gbnVsbCApIHBhcnNlci5lcnJvciggZXhwZWN0ZWRFeHByZXNzaW9uICk7XG5cbiAgXHRcdGV4cHJlc3Npb25zLnB1c2guYXBwbHkoIGV4cHJlc3Npb25zLCBuZXh0ICk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGV4cHJlc3Npb25zO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEFycmF5TGl0ZXJhbCAoIHBhcnNlciApIHtcbiAgXHR2YXIgc3RhcnQsIGV4cHJlc3Npb25MaXN0O1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgJ1snXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnWycgKSApIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGV4cHJlc3Npb25MaXN0ID0gcmVhZEV4cHJlc3Npb25MaXN0KCBwYXJzZXIgKTtcblxuICBcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ10nICkgKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogQVJSQVlfTElURVJBTCxcbiAgXHRcdG06IGV4cHJlc3Npb25MaXN0XG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRMaXRlcmFsICggcGFyc2VyICkge1xuICBcdHJldHVybiByZWFkTnVtYmVyTGl0ZXJhbCQxKCBwYXJzZXIgKSAgfHxcbiAgXHQgICAgICAgcmVhZEJvb2xlYW5MaXRlcmFsKCBwYXJzZXIgKSB8fFxuICBcdCAgICAgICByZWFkU3RyaW5nTGl0ZXJhbCggcGFyc2VyICkgIHx8XG4gIFx0ICAgICAgIHJlYWRPYmplY3RMaXRlcmFsKCBwYXJzZXIgKSAgfHxcbiAgXHQgICAgICAgcmVhZEFycmF5TGl0ZXJhbCggcGFyc2VyICkgICB8fFxuICBcdCAgICAgICByZWFkTnVtYmVyTGl0ZXJhbCggcGFyc2VyICk7XG4gIH1cblxuICB2YXIgcHJlZml4UGF0dGVybiA9IC9eKD86flxcL3woPzpcXC5cXC5cXC8pK3xcXC5cXC8oPzpcXC5cXC5cXC8pKnxcXC4pLztcbiAgdmFyIGdsb2JhbHM7XG4gIHZhciBrZXl3b3JkcztcbiAgLy8gaWYgYSByZWZlcmVuY2UgaXMgYSBicm93c2VyIGdsb2JhbCwgd2UgZG9uJ3QgZGVmZXJlbmNlIGl0IGxhdGVyLCBzbyBpdCBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudFxuICBnbG9iYWxzID0gL14oPzpBcnJheXxjb25zb2xlfERhdGV8UmVnRXhwfGRlY29kZVVSSUNvbXBvbmVudHxkZWNvZGVVUkl8ZW5jb2RlVVJJQ29tcG9uZW50fGVuY29kZVVSSXxpc0Zpbml0ZXxpc05hTnxwYXJzZUZsb2F0fHBhcnNlSW50fEpTT058TWF0aHxOYU58dW5kZWZpbmVkfG51bGx8T2JqZWN0fE51bWJlcnxTdHJpbmd8Qm9vbGVhbilcXGIvO1xuXG4gIC8vIGtleXdvcmRzIGFyZSBub3QgdmFsaWQgcmVmZXJlbmNlcywgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGB0aGlzYFxuICBrZXl3b3JkcyA9IC9eKD86YnJlYWt8Y2FzZXxjYXRjaHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGZpbmFsbHl8Zm9yfGZ1bmN0aW9ufGlmfGlufGluc3RhbmNlb2Z8bmV3fHJldHVybnxzd2l0Y2h8dGhyb3d8dHJ5fHR5cGVvZnx2YXJ8dm9pZHx3aGlsZXx3aXRoKSQvO1xuXG4gIHZhciBsZWdhbFJlZmVyZW5jZSA9IC9eKD86W2EtekEtWiRfMC05XXxcXFxcXFwuKSsoPzooPzpcXC4oPzpbYS16QS1aJF8wLTldfFxcXFxcXC4pKyl8KD86XFxbWzAtOV0rXFxdKSkqLztcbiAgdmFyIHJlbGF4ZWROYW1lID0gL15bYS16QS1aXyRdWy1cXC9hLXpBLVpfJDAtOV0qLztcbiAgdmFyIHNwZWNpYWxzID0gL15AKD86a2V5cGF0aHxyb290cGF0aHxpbmRleHxrZXl8dGhpc3xnbG9iYWwpLztcbiAgdmFyIHNwZWNpYWxDYWxsID0gL15cXHMqXFwoLztcbiAgdmFyIHNwcmVhZFBhdHRlcm4gPSAvXlxccypcXC57M30vO1xuXG4gIGZ1bmN0aW9uIHJlYWRSZWZlcmVuY2UgKCBwYXJzZXIgKSB7XG4gIFx0dmFyIHN0YXJ0UG9zLCBwcmVmaXgsIG5hbWUsIGdsb2JhbCwgcmVmZXJlbmNlLCBmdWxsTGVuZ3RoLCBsYXN0RG90SW5kZXgsIHNwcmVhZDtcblxuICBcdHN0YXJ0UG9zID0gcGFyc2VyLnBvcztcblxuICBcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBzcGVjaWFscyApO1xuXG4gIFx0aWYgKCBuYW1lID09PSAnQGtleXBhdGgnIHx8IG5hbWUgPT09ICdAcm9vdHBhdGgnICkge1xuICBcdFx0aWYgKCBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBzcGVjaWFsQ2FsbCApICkge1xuICBcdFx0XHR2YXIgcmVmID0gcmVhZFJlZmVyZW5jZSggcGFyc2VyICk7XG4gIFx0XHRcdGlmICggIXJlZiApIHBhcnNlci5lcnJvciggKFwiRXhwZWN0ZWQgYSB2YWxpZCByZWZlcmVuY2UgZm9yIGEga2V5cGF0aCBleHByZXNzaW9uXCIpICk7XG5cbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJyknICkgKSBwYXJzZXIuZXJyb3IoIChcIlVuY2xvc2VkIGtleXBhdGggZXhwcmVzc2lvblwiKSApO1xuICBcdFx0XHRuYW1lICs9IFwiKFwiICsgKHJlZi5uKSArIFwiKVwiO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHNwcmVhZCA9ICFuYW1lICYmIHBhcnNlci5zcHJlYWRBcmdzICYmIHBhcnNlci5tYXRjaFBhdHRlcm4oIHNwcmVhZFBhdHRlcm4gKTtcblxuICBcdGlmICggIW5hbWUgKSB7XG4gIFx0XHRwcmVmaXggPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBwcmVmaXhQYXR0ZXJuICkgfHwgJyc7XG4gIFx0XHRuYW1lID0gKCAhcHJlZml4ICYmIHBhcnNlci5yZWxheGVkTmFtZXMgJiYgcGFyc2VyLm1hdGNoUGF0dGVybiggcmVsYXhlZE5hbWUgKSApIHx8XG4gIFx0XHQgICAgICAgcGFyc2VyLm1hdGNoUGF0dGVybiggbGVnYWxSZWZlcmVuY2UgKTtcblxuICBcdFx0aWYgKCAhbmFtZSAmJiBwcmVmaXggPT09ICcuJyApIHtcbiAgXHRcdFx0cHJlZml4ID0gJyc7XG4gIFx0XHRcdG5hbWUgPSAnLic7XG4gIFx0XHR9IGVsc2UgaWYgKCAhbmFtZSAmJiBwcmVmaXggKSB7XG4gIFx0XHRcdG5hbWUgPSBwcmVmaXg7XG4gIFx0XHRcdHByZWZpeCA9ICcnO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICggIW5hbWUgKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyBidWcgb3V0IGlmIGl0J3MgYSBrZXl3b3JkIChleGNlcHRpb24gZm9yIGFuY2VzdG9yL3Jlc3RyaWN0ZWQgcmVmcyAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzLzE0OTcpXG4gIFx0aWYgKCAhcHJlZml4ICYmICFwYXJzZXIucmVsYXhlZE5hbWVzICYmIGtleXdvcmRzLnRlc3QoIG5hbWUgKSApIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydFBvcztcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGlmIHRoaXMgaXMgYSBicm93c2VyIGdsb2JhbCwgc3RvcCBoZXJlXG4gIFx0aWYgKCAhcHJlZml4ICYmIGdsb2JhbHMudGVzdCggbmFtZSApICkge1xuICBcdFx0Z2xvYmFsID0gZ2xvYmFscy5leGVjKCBuYW1lIClbMF07XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnRQb3MgKyBnbG9iYWwubGVuZ3RoO1xuXG4gIFx0XHRyZXR1cm4ge1xuICBcdFx0XHR0OiBHTE9CQUwsXG4gIFx0XHRcdHY6ICggc3ByZWFkID8gJy4uLicgOiAnJyApICsgZ2xvYmFsXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdGZ1bGxMZW5ndGggPSAoIHNwcmVhZCA/IDMgOiAwICkgKyAoIHByZWZpeCB8fCAnJyApLmxlbmd0aCArIG5hbWUubGVuZ3RoO1xuICBcdHJlZmVyZW5jZSA9ICggcHJlZml4IHx8ICcnICkgKyBub3JtYWxpc2UoIG5hbWUgKTtcblxuICBcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnKCcgKSApIHtcbiAgXHRcdC8vIGlmIHRoaXMgaXMgYSBtZXRob2QgaW52b2NhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIGZ1bmN0aW9uKSB3ZSBuZWVkXG4gIFx0XHQvLyB0byBzdHJpcCB0aGUgbWV0aG9kIG5hbWUgZnJvbSB0aGUgcmVmZXJlbmNlIGNvbWJvLCBlbHNlIHRoZSBjb250ZXh0XG4gIFx0XHQvLyB3aWxsIGJlIHdyb25nXG4gIFx0XHQvLyBidXQgb25seSBpZiB0aGUgcmVmZXJlbmNlIHdhcyBhY3R1YWxseSBhIG1lbWJlciBhbmQgbm90IGEgcmVmaW5lbWVudFxuICBcdFx0bGFzdERvdEluZGV4ID0gcmVmZXJlbmNlLmxhc3RJbmRleE9mKCAnLicgKTtcbiAgXHRcdGlmICggbGFzdERvdEluZGV4ICE9PSAtMSAmJiBuYW1lWyBuYW1lLmxlbmd0aCAtIDEgXSAhPT0gJ10nICkge1xuICBcdFx0XHR2YXIgcmVmTGVuZ3RoID0gcmVmZXJlbmNlLmxlbmd0aDtcbiAgXHRcdFx0cmVmZXJlbmNlID0gcmVmZXJlbmNlLnN1YnN0ciggMCwgbGFzdERvdEluZGV4ICk7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydFBvcyArIChmdWxsTGVuZ3RoIC0gKCByZWZMZW5ndGggLSBsYXN0RG90SW5kZXggKSApO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyAtPSAxO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBSRUZFUkVOQ0UsXG4gIFx0XHRuOiAoIHNwcmVhZCA/ICcuLi4nIDogJycgKSArIHJlZmVyZW5jZS5yZXBsYWNlKCAvXnRoaXNcXC4vLCAnLi8nICkucmVwbGFjZSggL150aGlzJC8sICcuJyApXG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCcmFja2V0ZWRFeHByZXNzaW9uICggcGFyc2VyICkge1xuICBcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJygnICkgKSByZXR1cm4gbnVsbDtcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdHZhciBleHByID0gcmVhZEV4cHJlc3Npb24oIHBhcnNlciApO1xuXG4gIFx0aWYgKCAhZXhwciApIHBhcnNlci5lcnJvciggZXhwZWN0ZWRFeHByZXNzaW9uICk7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICcpJyApICkgcGFyc2VyLmVycm9yKCBleHBlY3RlZFBhcmVuICk7XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogQlJBQ0tFVEVELFxuICBcdFx0eDogZXhwclxuICBcdH07XG4gIH1cblxuICBmdW5jdGlvbiByZWFkUHJpbWFyeSAoIHBhcnNlciApIHtcbiAgXHRyZXR1cm4gcmVhZExpdGVyYWwoIHBhcnNlciApXG4gIFx0XHR8fCByZWFkUmVmZXJlbmNlKCBwYXJzZXIgKVxuICBcdFx0fHwgcmVhZEJyYWNrZXRlZEV4cHJlc3Npb24oIHBhcnNlciApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFJlZmluZW1lbnQgKCBwYXJzZXIgKSB7XG4gIFx0Ly8gc29tZSB0aGluZ3MgY2FsbCBmb3Igc3RyaWN0IHJlZmluZW1lbnQgKHBhcnRpYWwgbmFtZXMpLCBtZWFuaW5nIG5vIHNwYWNlIGJldHdlZW4gcmVmZXJlbmNlIGFuZCByZWZpbmVtZW50XG4gIFx0aWYgKCAhcGFyc2VyLnN0cmljdFJlZmluZW1lbnQgKSB7XG4gIFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0fVxuXG4gIFx0Ly8gXCIuXCIgbmFtZVxuICBcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnLicgKSApIHtcbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0dmFyIG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBuYW1lUGF0dGVybiApO1xuICBcdFx0aWYgKCBuYW1lICkge1xuICBcdFx0XHRyZXR1cm4ge1xuICBcdFx0XHRcdHQ6IFJFRklORU1FTlQsXG4gIFx0XHRcdFx0bjogbmFtZVxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBhIHByb3BlcnR5IG5hbWUnICk7XG4gIFx0fVxuXG4gIFx0Ly8gXCJbXCIgZXhwcmVzc2lvbiBcIl1cIlxuICBcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnWycgKSApIHtcbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0dmFyIGV4cHIgPSByZWFkRXhwcmVzc2lvbiggcGFyc2VyICk7XG4gIFx0XHRpZiAoICFleHByICkgcGFyc2VyLmVycm9yKCBleHBlY3RlZEV4cHJlc3Npb24gKTtcblxuICBcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICddJyApICkgcGFyc2VyLmVycm9yKCAoXCJFeHBlY3RlZCAnXSdcIikgKTtcblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogUkVGSU5FTUVOVCxcbiAgXHRcdFx0eDogZXhwclxuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRNZW1iZXJPckludm9jYXRpb24gKCBwYXJzZXIgKSB7XG4gIFx0dmFyIGV4cHJlc3Npb24gPSByZWFkUHJpbWFyeSggcGFyc2VyICk7XG5cbiAgXHRpZiAoICFleHByZXNzaW9uICkgcmV0dXJuIG51bGw7XG5cbiAgXHR3aGlsZSAoIGV4cHJlc3Npb24gKSB7XG4gIFx0XHR2YXIgcmVmaW5lbWVudCA9IHJlYWRSZWZpbmVtZW50KCBwYXJzZXIgKTtcbiAgXHRcdGlmICggcmVmaW5lbWVudCApIHtcbiAgXHRcdFx0ZXhwcmVzc2lvbiA9IHtcbiAgXHRcdFx0XHR0OiBNRU1CRVIsXG4gIFx0XHRcdFx0eDogZXhwcmVzc2lvbixcbiAgXHRcdFx0XHRyOiByZWZpbmVtZW50XG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdGVsc2UgaWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcoJyApICkge1xuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0XHRcdHZhciBzdGFydCA9IHBhcnNlci5zcHJlYWRBcmdzO1xuICBcdFx0XHRwYXJzZXIuc3ByZWFkQXJncyA9IHRydWU7XG4gIFx0XHRcdHZhciBleHByZXNzaW9uTGlzdCA9IHJlYWRFeHByZXNzaW9uTGlzdCggcGFyc2VyICk7XG4gIFx0XHRcdHBhcnNlci5zcHJlYWRBcmdzID0gc3RhcnQ7XG5cbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJyknICkgKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKCBleHBlY3RlZFBhcmVuICk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRleHByZXNzaW9uID0ge1xuICBcdFx0XHRcdHQ6IElOVk9DQVRJT04sXG4gIFx0XHRcdFx0eDogZXhwcmVzc2lvblxuICBcdFx0XHR9O1xuXG4gIFx0XHRcdGlmICggZXhwcmVzc2lvbkxpc3QgKSBleHByZXNzaW9uLm8gPSBleHByZXNzaW9uTGlzdDtcbiAgXHRcdH1cblxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdGJyZWFrO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBleHByZXNzaW9uO1xuICB9XG5cbiAgdmFyIHJlYWRUeXBlT2Y7XG4gIHZhciBtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyO1xuICBtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyID0gZnVuY3Rpb24gKCBzeW1ib2wsIGZhbGx0aHJvdWdoICkge1xuICBcdHJldHVybiBmdW5jdGlvbiAoIHBhcnNlciApIHtcbiAgXHRcdHZhciBleHByZXNzaW9uO1xuXG4gIFx0XHRpZiAoIGV4cHJlc3Npb24gPSBmYWxsdGhyb3VnaCggcGFyc2VyICkgKSB7XG4gIFx0XHRcdHJldHVybiBleHByZXNzaW9uO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIHN5bWJvbCApICkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRleHByZXNzaW9uID0gcmVhZEV4cHJlc3Npb24oIHBhcnNlciApO1xuICBcdFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKCBleHBlY3RlZEV4cHJlc3Npb24gKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0czogc3ltYm9sLFxuICBcdFx0XHRvOiBleHByZXNzaW9uLFxuICBcdFx0XHR0OiBQUkVGSVhfT1BFUkFUT1JcbiAgXHRcdH07XG4gIFx0fTtcbiAgfTtcblxuICAvLyBjcmVhdGUgYWxsIHByZWZpeCBzZXF1ZW5jZSBtYXRjaGVycywgcmV0dXJuIHJlYWRUeXBlT2ZcbiAgKGZ1bmN0aW9uKCkge1xuICBcdHZhciBpLCBsZW4sIG1hdGNoZXIsIHByZWZpeE9wZXJhdG9ycywgZmFsbHRocm91Z2g7XG5cbiAgXHRwcmVmaXhPcGVyYXRvcnMgPSAnISB+ICsgLSB0eXBlb2YnLnNwbGl0KCAnICcgKTtcblxuICBcdGZhbGx0aHJvdWdoID0gcmVhZE1lbWJlck9ySW52b2NhdGlvbjtcbiAgXHRmb3IgKCBpID0gMCwgbGVuID0gcHJlZml4T3BlcmF0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxICkge1xuICBcdFx0bWF0Y2hlciA9IG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXIoIHByZWZpeE9wZXJhdG9yc1tpXSwgZmFsbHRocm91Z2ggKTtcbiAgXHRcdGZhbGx0aHJvdWdoID0gbWF0Y2hlcjtcbiAgXHR9XG5cbiAgXHQvLyB0eXBlb2Ygb3BlcmF0b3IgaXMgaGlnaGVyIHByZWNlZGVuY2UgdGhhbiBtdWx0aXBsaWNhdGlvbiwgc28gcHJvdmlkZXMgdGhlXG4gIFx0Ly8gZmFsbHRocm91Z2ggZm9yIHRoZSBtdWx0aXBsaWNhdGlvbiBzZXF1ZW5jZSBtYXRjaGVyIHdlJ3JlIGFib3V0IHRvIGNyZWF0ZVxuICBcdC8vICh3ZSdyZSBza2lwcGluZyB2b2lkIGFuZCBkZWxldGUpXG4gIFx0cmVhZFR5cGVPZiA9IGZhbGx0aHJvdWdoO1xuICB9KCkpO1xuXG4gIHZhciByZWFkVHlwZW9mID0gcmVhZFR5cGVPZjtcblxuICB2YXIgcmVhZExvZ2ljYWxPcjtcbiAgdmFyIG1ha2VJbmZpeFNlcXVlbmNlTWF0Y2hlcjtcbiAgbWFrZUluZml4U2VxdWVuY2VNYXRjaGVyID0gZnVuY3Rpb24gKCBzeW1ib2wsIGZhbGx0aHJvdWdoICkge1xuICBcdHJldHVybiBmdW5jdGlvbiAoIHBhcnNlciApIHtcbiAgXHRcdHZhciBzdGFydCwgbGVmdCwgcmlnaHQ7XG5cbiAgXHRcdGxlZnQgPSBmYWxsdGhyb3VnaCggcGFyc2VyICk7XG4gIFx0XHRpZiAoICFsZWZ0ICkge1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0Ly8gTG9vcCB0byBoYW5kbGUgbGVmdC1yZWN1cnNpb24gaW4gYSBjYXNlIGxpa2UgYGEgKiBiICogY2AgYW5kIHByb2R1Y2VcbiAgXHRcdC8vIGxlZnQgYXNzb2NpYXRpb24sIGkuZS4gYChhICogYikgKiBjYC4gIFRoZSBtYXRjaGVyIGNhbid0IGNhbGwgaXRzZWxmXG4gIFx0XHQvLyB0byBwYXJzZSBgbGVmdGAgYmVjYXVzZSB0aGF0IHdvdWxkIGJlIGluZmluaXRlIHJlZ3Jlc3MuXG4gIFx0XHR3aGlsZSAoIHRydWUgKSB7XG4gIFx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBzeW1ib2wgKSApIHtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBpbiBvcGVyYXRvciBtdXN0IG5vdCBiZSBmb2xsb3dlZCBieSBbYS16QS1aXyQwLTldXG4gIFx0XHRcdGlmICggc3ltYm9sID09PSAnaW4nICYmIC9bYS16QS1aXyQwLTldLy50ZXN0KCBwYXJzZXIucmVtYWluaW5nKCkuY2hhckF0KCAwICkgKSApIHtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRcdFx0Ly8gcmlnaHQgb3BlcmFuZCBtdXN0IGFsc28gY29uc2lzdCBvZiBvbmx5IGhpZ2hlci1wcmVjZWRlbmNlIG9wZXJhdG9yc1xuICBcdFx0XHRyaWdodCA9IGZhbGx0aHJvdWdoKCBwYXJzZXIgKTtcbiAgXHRcdFx0aWYgKCAhcmlnaHQgKSB7XG4gIFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRcdHJldHVybiBsZWZ0O1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0bGVmdCA9IHtcbiAgXHRcdFx0XHR0OiBJTkZJWF9PUEVSQVRPUixcbiAgXHRcdFx0XHRzOiBzeW1ib2wsXG4gIFx0XHRcdFx0bzogWyBsZWZ0LCByaWdodCBdXG4gIFx0XHRcdH07XG5cbiAgXHRcdFx0Ly8gTG9vcCBiYWNrIGFyb3VuZC4gIElmIHdlIGRvbid0IHNlZSBhbm90aGVyIG9jY3VycmVuY2Ugb2YgdGhlIHN5bWJvbCxcbiAgXHRcdFx0Ly8gd2UnbGwgcmV0dXJuIGxlZnQuXG4gIFx0XHR9XG4gIFx0fTtcbiAgfTtcblxuICAvLyBjcmVhdGUgYWxsIGluZml4IHNlcXVlbmNlIG1hdGNoZXJzLCBhbmQgcmV0dXJuIHJlYWRMb2dpY2FsT3JcbiAgKGZ1bmN0aW9uKCkge1xuICBcdHZhciBpLCBsZW4sIG1hdGNoZXIsIGluZml4T3BlcmF0b3JzLCBmYWxsdGhyb3VnaDtcblxuICBcdC8vIEFsbCB0aGUgaW5maXggb3BlcmF0b3JzIG9uIG9yZGVyIG9mIHByZWNlZGVuY2UgKHNvdXJjZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvT3BlcmF0b3JfUHJlY2VkZW5jZSlcbiAgXHQvLyBFYWNoIHNlcXVlbmNlIG1hdGNoZXIgd2lsbCBpbml0aWFsbHkgZmFsbCB0aHJvdWdoIHRvIGl0cyBoaWdoZXIgcHJlY2VkZW5jZVxuICBcdC8vIG5laWdoYm91ciwgYW5kIG9ubHkgYXR0ZW1wdCB0byBtYXRjaCBpZiBvbmUgb2YgdGhlIGhpZ2hlciBwcmVjZWRlbmNlIG9wZXJhdG9yc1xuICBcdC8vIChvciwgdWx0aW1hdGVseSwgYSBsaXRlcmFsLCByZWZlcmVuY2UsIG9yIGJyYWNrZXRlZCBleHByZXNzaW9uKSBhbHJlYWR5IG1hdGNoZWRcbiAgXHRpbmZpeE9wZXJhdG9ycyA9ICcqIC8gJSArIC0gPDwgPj4gPj4+IDwgPD0gPiA+PSBpbiBpbnN0YW5jZW9mID09ICE9ID09PSAhPT0gJiBeIHwgJiYgfHwnLnNwbGl0KCAnICcgKTtcblxuICBcdC8vIEEgdHlwZW9mIG9wZXJhdG9yIGlzIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gbXVsdGlwbGljYXRpb25cbiAgXHRmYWxsdGhyb3VnaCA9IHJlYWRUeXBlb2Y7XG4gIFx0Zm9yICggaSA9IDAsIGxlbiA9IGluZml4T3BlcmF0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxICkge1xuICBcdFx0bWF0Y2hlciA9IG1ha2VJbmZpeFNlcXVlbmNlTWF0Y2hlciggaW5maXhPcGVyYXRvcnNbaV0sIGZhbGx0aHJvdWdoICk7XG4gIFx0XHRmYWxsdGhyb3VnaCA9IG1hdGNoZXI7XG4gIFx0fVxuXG4gIFx0Ly8gTG9naWNhbCBPUiBpcyB0aGUgZmFsbHRocm91Z2ggZm9yIHRoZSBjb25kaXRpb25hbCBtYXRjaGVyXG4gIFx0cmVhZExvZ2ljYWxPciA9IGZhbGx0aHJvdWdoO1xuICB9KCkpO1xuXG4gIHZhciByZWFkTG9naWNhbE9yJDEgPSByZWFkTG9naWNhbE9yO1xuXG4gIC8vIFRoZSBjb25kaXRpb25hbCBvcGVyYXRvciBpcyB0aGUgbG93ZXN0IHByZWNlZGVuY2Ugb3BlcmF0b3IsIHNvIHdlIHN0YXJ0IGhlcmVcbiAgZnVuY3Rpb24gZ2V0Q29uZGl0aW9uYWwgKCBwYXJzZXIgKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uLCBpZlRydWUsIGlmRmFsc2U7XG5cbiAgXHRleHByZXNzaW9uID0gcmVhZExvZ2ljYWxPciQxKCBwYXJzZXIgKTtcbiAgXHRpZiAoICFleHByZXNzaW9uICkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPycgKSApIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBleHByZXNzaW9uO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmVHJ1ZSA9IHJlYWRFeHByZXNzaW9uKCBwYXJzZXIgKTtcbiAgXHRpZiAoICFpZlRydWUgKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoIGV4cGVjdGVkRXhwcmVzc2lvbiApO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzonICkgKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBcIjpcIicgKTtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZkZhbHNlID0gcmVhZEV4cHJlc3Npb24oIHBhcnNlciApO1xuICBcdGlmICggIWlmRmFsc2UgKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoIGV4cGVjdGVkRXhwcmVzc2lvbiApO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBDT05ESVRJT05BTCxcbiAgXHRcdG86IFsgZXhwcmVzc2lvbiwgaWZUcnVlLCBpZkZhbHNlIF1cbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEV4cHJlc3Npb24gKCBwYXJzZXIgKSB7XG4gIFx0Ly8gVGhlIGNvbmRpdGlvbmFsIG9wZXJhdG9yIGlzIHRoZSBsb3dlc3QgcHJlY2VkZW5jZSBvcGVyYXRvciAoZXhjZXB0IHlpZWxkLFxuICBcdC8vIGFzc2lnbm1lbnQgb3BlcmF0b3JzLCBhbmQgY29tbWFzLCBub25lIG9mIHdoaWNoIGFyZSBzdXBwb3J0ZWQpLCBzbyB3ZVxuICBcdC8vIHN0YXJ0IHRoZXJlLiBJZiBpdCBkb2Vzbid0IG1hdGNoLCBpdCAnZmFsbHMgdGhyb3VnaCcgdG8gcHJvZ3Jlc3NpdmVseVxuICBcdC8vIGhpZ2hlciBwcmVjZWRlbmNlIG9wZXJhdG9ycywgdW50aWwgaXQgZXZlbnR1YWxseSBtYXRjaGVzIChvciBmYWlscyB0b1xuICBcdC8vIG1hdGNoKSBhICdwcmltYXJ5JyAtIGEgbGl0ZXJhbCBvciBhIHJlZmVyZW5jZS4gVGhpcyB3YXksIHRoZSBhYnN0cmFjdCBzeW50YXhcbiAgXHQvLyB0cmVlIGhhcyBldmVyeXRoaW5nIGluIGl0cyBwcm9wZXIgcGxhY2UsIGkuZS4gMiArIDMgKiA0ID09PSAxNCwgbm90IDIwLlxuICBcdHJldHVybiBnZXRDb25kaXRpb25hbCggcGFyc2VyICk7XG4gIH1cblxuICBmdW5jdGlvbiBmbGF0dGVuRXhwcmVzc2lvbiAoIGV4cHJlc3Npb24gKSB7XG4gIFx0dmFyIHJlZnMsIGNvdW50ID0gMCwgc3RyaW5naWZpZWQ7XG5cbiAgXHRleHRyYWN0UmVmcyggZXhwcmVzc2lvbiwgcmVmcyA9IFtdICk7XG4gIFx0c3RyaW5naWZpZWQgPSBzdHJpbmdpZnkoIGV4cHJlc3Npb24gKTtcblxuICBcdHJlZnMgPSByZWZzLm1hcCggZnVuY3Rpb24gKCByICkgeyByZXR1cm4gci5pbmRleE9mKCAnLi4uJyApID09PSAwID8gci5zdWJzdHIoIDMgKSA6IHI7IH0gKTtcblxuICBcdHJldHVybiB7XG4gIFx0XHRyOiByZWZzLFxuICBcdFx0czogZ2V0VmFycyhzdHJpbmdpZmllZClcbiAgXHR9O1xuXG4gIFx0ZnVuY3Rpb24gZ2V0VmFycyhleHByKSB7XG4gIFx0XHR2YXIgdmFycyA9IFtdO1xuICBcdFx0Zm9yICggdmFyIGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgaS0tICkge1xuICBcdFx0XHR2YXJzLnB1c2goIChcInNwcmVhZCRcIiArIGkpICk7XG4gIFx0XHR9XG4gIFx0XHRyZXR1cm4gdmFycy5sZW5ndGggPyAoXCIoZnVuY3Rpb24oKXt2YXIgXCIgKyAodmFycy5qb2luKCcsJykpICsgXCI7cmV0dXJuKFwiICsgZXhwciArIFwiKTt9KSgpXCIpIDogZXhwcjtcbiAgXHR9XG5cbiAgXHRmdW5jdGlvbiBzdHJpbmdpZnkgKCBub2RlICkge1xuICBcdFx0c3dpdGNoICggbm9kZS50ICkge1xuICBcdFx0XHRjYXNlIEJPT0xFQU5fTElURVJBTDpcbiAgXHRcdFx0Y2FzZSBHTE9CQUw6XG4gIFx0XHRcdGNhc2UgTlVNQkVSX0xJVEVSQUw6XG4gIFx0XHRcdGNhc2UgUkVHRVhQX0xJVEVSQUw6XG4gIFx0XHRcdFx0cmV0dXJuIG5vZGUudjtcblxuICBcdFx0XHRjYXNlIFNUUklOR19MSVRFUkFMOlxuICBcdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSggU3RyaW5nKCBub2RlLnYgKSApO1xuXG4gIFx0XHRcdGNhc2UgQVJSQVlfTElURVJBTDpcbiAgXHRcdFx0XHRyZXR1cm4gJ1snICsgKCBub2RlLm0gPyBub2RlLm0ubWFwKCBzdHJpbmdpZnkgKS5qb2luKCAnLCcgKSA6ICcnICkgKyAnXSc7XG5cbiAgXHRcdFx0Y2FzZSBPQkpFQ1RfTElURVJBTDpcbiAgXHRcdFx0XHRyZXR1cm4gJ3snICsgKCBub2RlLm0gPyBub2RlLm0ubWFwKCBzdHJpbmdpZnkgKS5qb2luKCAnLCcgKSA6ICcnICkgKyAnfSc7XG5cbiAgXHRcdFx0Y2FzZSBLRVlfVkFMVUVfUEFJUjpcbiAgXHRcdFx0XHRyZXR1cm4gbm9kZS5rICsgJzonICsgc3RyaW5naWZ5KCBub2RlLnYgKTtcblxuICBcdFx0XHRjYXNlIFBSRUZJWF9PUEVSQVRPUjpcbiAgXHRcdFx0XHRyZXR1cm4gKCBub2RlLnMgPT09ICd0eXBlb2YnID8gJ3R5cGVvZiAnIDogbm9kZS5zICkgKyBzdHJpbmdpZnkoIG5vZGUubyApO1xuXG4gIFx0XHRcdGNhc2UgSU5GSVhfT1BFUkFUT1I6XG4gIFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggbm9kZS5vWzBdICkgKyAoIG5vZGUucy5zdWJzdHIoIDAsIDIgKSA9PT0gJ2luJyA/ICcgJyArIG5vZGUucyArICcgJyA6IG5vZGUucyApICsgc3RyaW5naWZ5KCBub2RlLm9bMV0gKTtcblxuICBcdFx0XHRjYXNlIElOVk9DQVRJT046XG4gIFx0XHRcdFx0aWYgKCBub2RlLnNwcmVhZCApIHtcbiAgXHRcdFx0XHRcdHZhciBpZCA9IGNvdW50Kys7XG4gIFx0XHRcdFx0XHRyZXR1cm4gKFwiKHNwcmVhZCRcIiArIGlkICsgXCIgPSBcIiArIChzdHJpbmdpZnkobm9kZS54KSkgKyBcIikuYXBwbHkoc3ByZWFkJFwiICsgaWQgKyBcIiwgW10uY29uY2F0KFwiICsgKG5vZGUubyA/IG5vZGUuby5tYXAoIGZ1bmN0aW9uICggYSApIHsgcmV0dXJuIGEubiAmJiBhLm4uaW5kZXhPZiggJy4uLicgKSA9PT0gMCA/IHN0cmluZ2lmeSggYSApIDogJ1snICsgc3RyaW5naWZ5KGEpICsgJ10nOyB9ICkuam9pbiggJywnICkgOiAnJykgKyBcIikgKVwiKTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggbm9kZS54ICkgKyAnKCcgKyAoIG5vZGUubyA/IG5vZGUuby5tYXAoIHN0cmluZ2lmeSApLmpvaW4oICcsJyApIDogJycgKSArICcpJztcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0Y2FzZSBCUkFDS0VURUQ6XG4gIFx0XHRcdFx0cmV0dXJuICcoJyArIHN0cmluZ2lmeSggbm9kZS54ICkgKyAnKSc7XG5cbiAgXHRcdFx0Y2FzZSBNRU1CRVI6XG4gIFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggbm9kZS54ICkgKyBzdHJpbmdpZnkoIG5vZGUuciApO1xuXG4gIFx0XHRcdGNhc2UgUkVGSU5FTUVOVDpcbiAgXHRcdFx0XHRyZXR1cm4gKCBub2RlLm4gPyAnLicgKyBub2RlLm4gOiAnWycgKyBzdHJpbmdpZnkoIG5vZGUueCApICsgJ10nICk7XG5cbiAgXHRcdFx0Y2FzZSBDT05ESVRJT05BTDpcbiAgXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KCBub2RlLm9bMF0gKSArICc/JyArIHN0cmluZ2lmeSggbm9kZS5vWzFdICkgKyAnOicgKyBzdHJpbmdpZnkoIG5vZGUub1syXSApO1xuXG4gIFx0XHRcdGNhc2UgUkVGRVJFTkNFOlxuICBcdFx0XHRcdHJldHVybiAnXycgKyByZWZzLmluZGV4T2YoIG5vZGUubiApO1xuXG4gIFx0XHRcdGRlZmF1bHQ6XG4gIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnRXhwZWN0ZWQgbGVnYWwgSmF2YVNjcmlwdCcgKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICAvLyBUT0RPIG1heWJlIHJlZmFjdG9yIHRoaXM/XG4gIGZ1bmN0aW9uIGV4dHJhY3RSZWZzICggbm9kZSwgcmVmcyApIHtcbiAgXHR2YXIgaSwgbGlzdDtcblxuICBcdGlmICggbm9kZS50ID09PSBSRUZFUkVOQ0UgKSB7XG4gIFx0XHRpZiAoIHJlZnMuaW5kZXhPZiggbm9kZS5uICkgPT09IC0xICkge1xuICBcdFx0XHRyZWZzLnVuc2hpZnQoIG5vZGUubiApO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGxpc3QgPSBub2RlLm8gfHwgbm9kZS5tO1xuICBcdGlmICggbGlzdCApIHtcbiAgXHRcdGlmICggaXNPYmplY3QoIGxpc3QgKSApIHtcbiAgXHRcdFx0ZXh0cmFjdFJlZnMoIGxpc3QsIHJlZnMgKTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRcdFx0aWYgKCBsaXN0W2ldLm4gJiYgbGlzdFtpXS5uLmluZGV4T2YoJy4uLicpID09PSAwICkge1xuICBcdFx0XHRcdFx0bm9kZS5zcHJlYWQgPSB0cnVlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0XHRleHRyYWN0UmVmcyggbGlzdFtpXSwgcmVmcyApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKCBub2RlLnggKSB7XG4gIFx0XHRleHRyYWN0UmVmcyggbm9kZS54LCByZWZzICk7XG4gIFx0fVxuXG4gIFx0aWYgKCBub2RlLnIgKSB7XG4gIFx0XHRleHRyYWN0UmVmcyggbm9kZS5yLCByZWZzICk7XG4gIFx0fVxuXG4gIFx0aWYgKCBub2RlLnYgKSB7XG4gIFx0XHRleHRyYWN0UmVmcyggbm9kZS52LCByZWZzICk7XG4gIFx0fVxuICB9XG5cbiAgLy8gc2ltcGxlIEpTT04gcGFyc2VyLCB3aXRob3V0IHRoZSByZXN0cmljdGlvbnMgb2YgSlNPTiBwYXJzZVxuICAvLyAoaS5lLiBoYXZpbmcgdG8gZG91YmxlLXF1b3RlIGtleXMpLlxuICAvL1xuICAvLyBJZiBwYXNzZWQgYSBoYXNoIG9mIHZhbHVlcyBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LCAke3BsYWNlaG9sZGVyc31cbiAgLy8gd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRob3NlIHZhbHVlc1xuXG4gIHZhciBzcGVjaWFscyQxID0ge1xuICBcdCd0cnVlJzogdHJ1ZSxcbiAgXHQnZmFsc2UnOiBmYWxzZSxcbiAgXHQnbnVsbCc6IG51bGwsXG4gIFx0dW5kZWZpbmVkOiB1bmRlZmluZWRcbiAgfTtcblxuICB2YXIgc3BlY2lhbHNQYXR0ZXJuID0gbmV3IFJlZ0V4cCggJ14oPzonICsgT2JqZWN0LmtleXMoIHNwZWNpYWxzJDEgKS5qb2luKCAnfCcgKSArICcpJyApO1xuICB2YXIgbnVtYmVyUGF0dGVybiQxID0gL14oPzpbKy1dPykoPzooPzooPzowfFsxLTldXFxkKik/XFwuXFxkKyl8KD86KD86MHxbMS05XVxcZCopXFwuKXwoPzowfFsxLTldXFxkKikpKD86W2VFXVsrLV0/XFxkKyk/LztcbiAgdmFyIHBsYWNlaG9sZGVyUGF0dGVybiA9IC9cXCRcXHsoW15cXH1dKylcXH0vZztcbiAgdmFyIHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4gPSAvXlxcJFxceyhbXlxcfV0rKVxcfS87XG4gIHZhciBvbmx5V2hpdGVzcGFjZSA9IC9eXFxzKiQvO1xuXG4gIHZhciBKc29uUGFyc2VyID0gUGFyc2VyJDEuZXh0ZW5kKHtcbiAgXHRpbml0OiBmdW5jdGlvbiAoIHN0ciwgb3B0aW9ucyApIHtcbiAgXHRcdHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gIFx0XHR0aGlzLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdH0sXG5cbiAgXHRwb3N0UHJvY2VzczogZnVuY3Rpb24gKCByZXN1bHQgKSB7XG4gIFx0XHRpZiAoIHJlc3VsdC5sZW5ndGggIT09IDEgfHwgIW9ubHlXaGl0ZXNwYWNlLnRlc3QoIHRoaXMubGVmdG92ZXIgKSApIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB7IHZhbHVlOiByZXN1bHRbMF0udiB9O1xuICBcdH0sXG5cbiAgXHRjb252ZXJ0ZXJzOiBbXG4gIFx0XHRmdW5jdGlvbiBnZXRQbGFjZWhvbGRlciAoIHBhcnNlciApIHtcbiAgXHRcdFx0aWYgKCAhcGFyc2VyLnZhbHVlcyApIHJldHVybiBudWxsO1xuXG4gIFx0XHRcdHZhciBwbGFjZWhvbGRlciA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4gKTtcblxuICBcdFx0XHRpZiAoIHBsYWNlaG9sZGVyICYmICggcGFyc2VyLnZhbHVlcy5oYXNPd25Qcm9wZXJ0eSggcGxhY2Vob2xkZXIgKSApICkge1xuICBcdFx0XHRcdHJldHVybiB7IHY6IHBhcnNlci52YWx1ZXNbIHBsYWNlaG9sZGVyIF0gfTtcbiAgXHRcdFx0fVxuICBcdFx0fSxcblxuICBcdFx0ZnVuY3Rpb24gZ2V0U3BlY2lhbCAoIHBhcnNlciApIHtcbiAgXHRcdFx0dmFyIHNwZWNpYWwgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBzcGVjaWFsc1BhdHRlcm4gKTtcbiAgXHRcdFx0aWYgKCBzcGVjaWFsICkgcmV0dXJuIHsgdjogc3BlY2lhbHMkMVsgc3BlY2lhbCBdIH07XG4gIFx0XHR9LFxuXG4gIFx0XHRmdW5jdGlvbiBnZXROdW1iZXIgKCBwYXJzZXIgKSB7XG4gIFx0XHRcdHZhciBudW1iZXIgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBudW1iZXJQYXR0ZXJuJDEgKTtcbiAgXHRcdFx0aWYgKCBudW1iZXIgKSByZXR1cm4geyB2OiArbnVtYmVyIH07XG4gIFx0XHR9LFxuXG4gIFx0XHRmdW5jdGlvbiBnZXRTdHJpbmcgKCBwYXJzZXIgKSB7XG4gIFx0XHRcdHZhciBzdHJpbmdMaXRlcmFsID0gcmVhZFN0cmluZ0xpdGVyYWwoIHBhcnNlciApO1xuICBcdFx0XHR2YXIgdmFsdWVzID0gcGFyc2VyLnZhbHVlcztcblxuICBcdFx0XHRpZiAoIHN0cmluZ0xpdGVyYWwgJiYgdmFsdWVzICkge1xuICBcdFx0XHRcdHJldHVybiB7XG4gIFx0XHRcdFx0XHR2OiBzdHJpbmdMaXRlcmFsLnYucmVwbGFjZSggcGxhY2Vob2xkZXJQYXR0ZXJuLCBmdW5jdGlvbiAoIG1hdGNoLCAkMSApIHsgcmV0dXJuICggJDEgaW4gdmFsdWVzID8gdmFsdWVzWyAkMSBdIDogJDEgKTsgfSApXG4gIFx0XHRcdFx0fTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBzdHJpbmdMaXRlcmFsO1xuICBcdFx0fSxcblxuICBcdFx0ZnVuY3Rpb24gZ2V0T2JqZWN0ICggcGFyc2VyICkge1xuICBcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICd7JyApICkgcmV0dXJuIG51bGw7XG5cbiAgXHRcdFx0dmFyIHJlc3VsdCA9IHt9O1xuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ30nICkgKSB7XG4gIFx0XHRcdFx0cmV0dXJuIHsgdjogcmVzdWx0IH07XG4gIFx0XHRcdH1cblxuICBcdFx0XHR2YXIgcGFpcjtcbiAgXHRcdFx0d2hpbGUgKCBwYWlyID0gZ2V0S2V5VmFsdWVQYWlyKCBwYXJzZXIgKSApIHtcbiAgXHRcdFx0XHRyZXN1bHRbIHBhaXIua2V5IF0gPSBwYWlyLnZhbHVlO1xuXG4gIFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICd9JyApICkge1xuICBcdFx0XHRcdFx0cmV0dXJuIHsgdjogcmVzdWx0IH07XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnLCcgKSApIHtcbiAgXHRcdFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fSxcblxuICBcdFx0ZnVuY3Rpb24gZ2V0QXJyYXkgKCBwYXJzZXIgKSB7XG4gIFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ1snICkgKSByZXR1cm4gbnVsbDtcblxuICBcdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cbiAgXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnXScgKSApIHtcbiAgXHRcdFx0XHRyZXR1cm4geyB2OiByZXN1bHQgfTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHZhciB2YWx1ZVRva2VuO1xuICBcdFx0XHR3aGlsZSAoIHZhbHVlVG9rZW4gPSBwYXJzZXIucmVhZCgpICkge1xuICBcdFx0XHRcdHJlc3VsdC5wdXNoKCB2YWx1ZVRva2VuLnYgKTtcblxuICBcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdFx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnXScgKSApIHtcbiAgXHRcdFx0XHRcdHJldHVybiB7IHY6IHJlc3VsdCB9O1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJywnICkgKSB7XG4gIFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cbiAgXHRdXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGdldEtleVZhbHVlUGFpciAoIHBhcnNlciApIHtcbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHR2YXIga2V5ID0gcmVhZEtleSggcGFyc2VyICk7XG5cbiAgXHRpZiAoICFrZXkgKSByZXR1cm4gbnVsbDtcblxuICBcdHZhciBwYWlyID0geyBrZXk6IGtleSB9O1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzonICkgKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0dmFyIHZhbHVlVG9rZW4gPSBwYXJzZXIucmVhZCgpO1xuXG4gIFx0aWYgKCAhdmFsdWVUb2tlbiApIHJldHVybiBudWxsO1xuXG4gIFx0cGFpci52YWx1ZSA9IHZhbHVlVG9rZW4udjtcbiAgXHRyZXR1cm4gcGFpcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSlNPTiAoIHN0ciwgdmFsdWVzICkge1xuICBcdHZhciBwYXJzZXIgPSBuZXcgSnNvblBhcnNlciggc3RyLCB7IHZhbHVlczogdmFsdWVzIH0pO1xuICBcdHJldHVybiBwYXJzZXIucmVzdWx0O1xuICB9XG5cbiAgdmFyIG1ldGhvZENhbGxQYXR0ZXJuID0gL14oW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKVxcKC4qXFwpXFxzKiQvO1xuICB2YXIgRXhwcmVzc2lvblBhcnNlcjtcbiAgRXhwcmVzc2lvblBhcnNlciA9IFBhcnNlciQxLmV4dGVuZCh7XG4gIFx0Y29udmVydGVyczogWyByZWFkRXhwcmVzc2lvbiBdLFxuICBcdHNwcmVhZEFyZ3M6IHRydWVcbiAgfSk7XG5cbiAgLy8gVE9ETyBjbGVhbiB0aGlzIHVwLCBpdCdzIHNob2NraW5nXG4gIGZ1bmN0aW9uIHByb2Nlc3NEaXJlY3RpdmUgKCB0b2tlbnMsIHBhcmVudFBhcnNlciwgdHlwZSApIHtcbiAgXHR2YXIgcmVzdWx0LFxuICBcdFx0bWF0Y2gsXG4gIFx0XHR0b2tlbixcbiAgXHRcdGNvbG9uSW5kZXgsXG4gIFx0XHRkaXJlY3RpdmVOYW1lLFxuICBcdFx0ZGlyZWN0aXZlQXJncyxcbiAgXHRcdHBhcnNlZDtcblxuICBcdGlmICggdHlwZW9mIHRva2VucyA9PT0gJ3N0cmluZycgKSB7XG4gIFx0XHR2YXIgcG9zID0gcGFyZW50UGFyc2VyLnBvcyAtIHRva2Vucy5sZW5ndGg7XG4gIFx0XHRpZiAoIHR5cGUgPT09IERFQ09SQVRPUiB8fCB0eXBlID09PSBUUkFOU0lUSU9OICkge1xuICBcdFx0XHR2YXIgcGFyc2VyID0gbmV3IEV4cHJlc3Npb25QYXJzZXIoIChcIltcIiArIHRva2VucyArIFwiXVwiKSApO1xuICBcdFx0XHRyZXR1cm4geyBhOiBmbGF0dGVuRXhwcmVzc2lvbiggcGFyc2VyLnJlc3VsdFswXSApIH07XG4gIFx0XHR9XG5cbiAgXHRcdGlmICggdHlwZSA9PT0gRVZFTlQgJiYgKCBtYXRjaCA9IG1ldGhvZENhbGxQYXR0ZXJuLmV4ZWMoIHRva2VucyApICkgKSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKCBwYXJlbnRQYXJzZXIuZ2V0Q29udGV4dE1lc3NhZ2UoIHBvcywgKFwiVW5xdWFsaWZpZWQgbWV0aG9kIGV2ZW50cyBhcmUgZGVwcmVjYXRlZC4gUHJlZml4IG1ldGhvZHMgd2l0aCAnQHRoaXMuJyB0byBjYWxsIG1ldGhvZHMgb24gdGhlIGN1cnJlbnQgUmFjdGl2ZSBpbnN0YW5jZS5cIikgKVsyXSApO1xuICBcdFx0XHR0b2tlbnMgPSBcIkB0aGlzLlwiICsgKG1hdGNoWzFdKSArIFwiXCIgKyAodG9rZW5zLnN1YnN0cihtYXRjaFsxXS5sZW5ndGgpKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCB0eXBlID09PSBFVkVOVCAmJiB+dG9rZW5zLmluZGV4T2YoICcoJyApICkge1xuICBcdFx0XHR2YXIgcGFyc2VyJDEgPSBuZXcgRXhwcmVzc2lvblBhcnNlciggJ1snICsgdG9rZW5zICsgJ10nICk7XG4gIFx0XHRcdGlmICggcGFyc2VyJDEucmVzdWx0ICYmIHBhcnNlciQxLnJlc3VsdFswXSApIHtcbiAgXHRcdFx0XHRpZiAoIHBhcnNlciQxLnJlbWFpbmluZygpLmxlbmd0aCApIHtcbiAgXHRcdFx0XHRcdHBhcmVudFBhcnNlci5wb3MgPSBwb3MgKyB0b2tlbnMubGVuZ3RoIC0gcGFyc2VyJDEucmVtYWluaW5nKCkubGVuZ3RoO1xuICBcdFx0XHRcdFx0cGFyZW50UGFyc2VyLmVycm9yKCAoXCJJbnZhbGlkIGlucHV0IGFmdGVyIGV2ZW50IGV4cHJlc3Npb24gJ1wiICsgKHBhcnNlciQxLnJlbWFpbmluZygpKSArIFwiJ1wiKSApO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0XHRyZXR1cm4geyB4OiBmbGF0dGVuRXhwcmVzc2lvbiggcGFyc2VyJDEucmVzdWx0WzBdICkgfTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICggdG9rZW5zLmluZGV4T2YoICc6JyApID4gdG9rZW5zLmluZGV4T2YoICcoJyApIHx8ICF+dG9rZW5zLmluZGV4T2YoICc6JyApICkge1xuICBcdFx0XHRcdHBhcmVudFBhcnNlci5wb3MgPSBwb3M7XG4gIFx0XHRcdFx0cGFyZW50UGFyc2VyLmVycm9yKCAoXCJJbnZhbGlkIGlucHV0IGluIGV2ZW50IGV4cHJlc3Npb24gJ1wiICsgdG9rZW5zICsgXCInXCIpICk7XG4gIFx0XHRcdH1cblxuICBcdFx0fVxuXG4gIFx0XHRpZiAoIHRva2Vucy5pbmRleE9mKCAnOicgKSA9PT0gLTEgKSB7XG4gIFx0XHRcdHJldHVybiB0b2tlbnMudHJpbSgpO1xuICBcdFx0fVxuXG4gIFx0XHR0b2tlbnMgPSBbIHRva2VucyBdO1xuICBcdH1cblxuICBcdHJlc3VsdCA9IHt9O1xuXG4gIFx0ZGlyZWN0aXZlTmFtZSA9IFtdO1xuICBcdGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblxuICBcdGlmICggdG9rZW5zICkge1xuICBcdFx0d2hpbGUgKCB0b2tlbnMubGVuZ3RoICkge1xuICBcdFx0XHR0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuXG4gIFx0XHRcdGlmICggdHlwZW9mIHRva2VuID09PSAnc3RyaW5nJyApIHtcbiAgXHRcdFx0XHRjb2xvbkluZGV4ID0gdG9rZW4uaW5kZXhPZiggJzonICk7XG5cbiAgXHRcdFx0XHRpZiAoIGNvbG9uSW5kZXggPT09IC0xICkge1xuICBcdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKCB0b2tlbiApO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHQvLyBpcyB0aGUgY29sb24gdGhlIGZpcnN0IGNoYXJhY3Rlcj9cbiAgXHRcdFx0XHRcdGlmICggY29sb25JbmRleCApIHtcbiAgXHRcdFx0XHRcdFx0Ly8gbm9cbiAgXHRcdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKCB0b2tlbi5zdWJzdHIoIDAsIGNvbG9uSW5kZXggKSApO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBhbnl0aGluZyBhZnRlciB0aGUgY29sb24gaW4gdGhpcyB0b2tlbiwgdHJlYXRcbiAgXHRcdFx0XHRcdC8vIGl0IGFzIHRoZSBmaXJzdCB0b2tlbiBvZiB0aGUgZGlyZWN0aXZlQXJncyBmcmFnbWVudFxuICBcdFx0XHRcdFx0aWYgKCB0b2tlbi5sZW5ndGggPiBjb2xvbkluZGV4ICsgMSApIHtcbiAgXHRcdFx0XHRcdFx0ZGlyZWN0aXZlQXJnc1swXSA9IHRva2VuLnN1YnN0cmluZyggY29sb25JbmRleCArIDEgKTtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0ZWxzZSB7XG4gIFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKCB0b2tlbiApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGRpcmVjdGl2ZUFyZ3MgPSBkaXJlY3RpdmVBcmdzLmNvbmNhdCggdG9rZW5zICk7XG4gIFx0fVxuXG4gIFx0aWYgKCAhZGlyZWN0aXZlTmFtZS5sZW5ndGggKSB7XG4gIFx0XHRyZXN1bHQgPSAnJztcbiAgXHR9IGVsc2UgaWYgKCBkaXJlY3RpdmVBcmdzLmxlbmd0aCB8fCB0eXBlb2YgZGlyZWN0aXZlTmFtZSAhPT0gJ3N0cmluZycgKSB7XG4gIFx0XHRyZXN1bHQgPSB7XG4gIFx0XHRcdC8vIFRPRE8gaXMgdGhpcyByZWFsbHkgbmVjZXNzYXJ5PyBqdXN0IHVzZSB0aGUgYXJyYXlcbiAgXHRcdFx0bjogKCBkaXJlY3RpdmVOYW1lLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGlyZWN0aXZlTmFtZVswXSA9PT0gJ3N0cmluZycgPyBkaXJlY3RpdmVOYW1lWzBdIDogZGlyZWN0aXZlTmFtZSApXG4gIFx0XHR9O1xuXG4gIFx0XHRpZiAoIGRpcmVjdGl2ZUFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBkaXJlY3RpdmVBcmdzWzBdID09PSAnc3RyaW5nJyApIHtcbiAgXHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKCAnWycgKyBkaXJlY3RpdmVBcmdzWzBdICsgJ10nICk7XG4gIFx0XHRcdHJlc3VsdC5hID0gcGFyc2VkID8gcGFyc2VkLnZhbHVlIDogWyBkaXJlY3RpdmVBcmdzWzBdLnRyaW0oKSBdO1xuICBcdFx0fVxuXG4gIFx0XHRlbHNlIHtcbiAgXHRcdFx0cmVzdWx0LmQgPSBkaXJlY3RpdmVBcmdzO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHRyZXN1bHQgPSBkaXJlY3RpdmVOYW1lO1xuICBcdH1cblxuICBcdGlmICggZGlyZWN0aXZlQXJncy5sZW5ndGggJiYgdHlwZSApIHtcbiAgXHRcdHdhcm5JZkRlYnVnKCBwYXJlbnRQYXJzZXIuZ2V0Q29udGV4dE1lc3NhZ2UoIHBhcmVudFBhcnNlci5wb3MsIChcIlByb3h5IGV2ZW50cyB3aXRoIGFyZ3VtZW50cyBhcmUgZGVwcmVjYXRlZC4gWW91IGNhbiBmaXJlIGV2ZW50cyB3aXRoIGFyZ3VtZW50cyB1c2luZyBcXFwiQHRoaXMuZmlyZSgnZXZlbnROYW1lJywgYXJnMSwgYXJnMiwgLi4uKVxcXCIuXCIpIClbMl0gKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGF0dHJpYnV0ZU5hbWVQYXR0ZXJuID0gL15bXlxcc1wiJz5cXC89XSsvO1xuICB2YXIgb25QYXR0ZXJuID0gL15vbi87XG4gIHZhciBwcm94eUV2ZW50UGF0dGVybiA9IC9eb24tKFthLXpBLVpcXFxcKlxcXFwuJF9dW2EtekEtWlxcXFwqXFxcXC4kXzAtOVxcLV0rKSQvO1xuICB2YXIgcmVzZXJ2ZWRFdmVudE5hbWVzID0gL14oPzpjaGFuZ2V8cmVzZXR8dGVhcmRvd258dXBkYXRlfGNvbnN0cnVjdHxjb25maWd8aW5pdHxyZW5kZXJ8dW5yZW5kZXJ8ZGV0YWNofGluc2VydCkkLztcbiAgdmFyIGRlY29yYXRvclBhdHRlcm4gPSAvXmFzLShbYS16LUEtWl1bLWEtekEtWl8wLTldKikkLztcbiAgdmFyIHRyYW5zaXRpb25QYXR0ZXJuID0gL14oW2EtekEtWl0oPzooPyEtaW4tb3V0KVstYS16QS1aXzAtOV0pKiktKGlufG91dHxpbi1vdXQpJC87XG4gIHZhciBkaXJlY3RpdmVzID0ge1xuICBcdFx0XHRcdCAgICdpbnRyby1vdXRybyc6IHsgdDogVFJBTlNJVElPTiwgdjogJ3QwJyB9LFxuICBcdFx0XHRcdCAgIGludHJvOiB7IHQ6IFRSQU5TSVRJT04sIHY6ICd0MScgfSxcbiAgXHRcdFx0XHQgICBvdXRybzogeyB0OiBUUkFOU0lUSU9OLCB2OiAndDInIH0sXG4gIFx0XHRcdFx0ICAgbGF6eTogeyB0OiBCSU5ESU5HX0ZMQUcsIHY6ICdsJyB9LFxuICBcdFx0XHRcdCAgIHR3b3dheTogeyB0OiBCSU5ESU5HX0ZMQUcsIHY6ICd0JyB9LFxuICBcdFx0XHRcdCAgIGRlY29yYXRvcjogeyB0OiBERUNPUkFUT1IgfVxuICBcdFx0XHRcdCB9O1xuICB2YXIgdW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRleHRQYXR0ZXJuID0gL15bXlxcc1wiJz08PmBdKy87XG4gIGZ1bmN0aW9uIHJlYWRBdHRyaWJ1dGUgKCBwYXJzZXIgKSB7XG4gIFx0dmFyIGF0dHIsIG5hbWUsIHZhbHVlLCBpLCBuZWFyZXN0LCBpZHg7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybiggYXR0cmlidXRlTmFtZVBhdHRlcm4gKTtcbiAgXHRpZiAoICFuYW1lICkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gY2hlY2sgZm9yIGFjY2lkZW50YWwgZGVsaW1pdGVyIGNvbnN1bXB0aW9uIGUuZy4gPHRhZyBib29se3s+YXR0cnN9fSAvPlxuICBcdG5lYXJlc3QgPSBuYW1lLmxlbmd0aDtcbiAgXHRmb3IgKCBpID0gMDsgaSA8IHBhcnNlci50YWdzLmxlbmd0aDsgaSsrICkge1xuICBcdFx0aWYgKCB+KCBpZHggPSBuYW1lLmluZGV4T2YoIHBhcnNlci50YWdzWyBpIF0ub3BlbiApICkgKSB7XG4gIFx0XHRcdGlmICggaWR4IDwgbmVhcmVzdCApIG5lYXJlc3QgPSBpZHg7XG4gIFx0XHR9XG4gIFx0fVxuICBcdGlmICggbmVhcmVzdCA8IG5hbWUubGVuZ3RoICkge1xuICBcdFx0cGFyc2VyLnBvcyAtPSBuYW1lLmxlbmd0aCAtIG5lYXJlc3Q7XG4gIFx0XHRuYW1lID0gbmFtZS5zdWJzdHIoIDAsIG5lYXJlc3QgKTtcbiAgXHRcdHJldHVybiB7IG46IG5hbWUgfTtcbiAgXHR9XG5cbiAgXHRhdHRyID0geyBuOiBuYW1lIH07XG5cbiAgXHR2YWx1ZSA9IHJlYWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyICk7XG4gIFx0aWYgKCB2YWx1ZSAhPSBudWxsICkgeyAvLyBub3QgbnVsbC91bmRlZmluZWRcbiAgXHRcdGF0dHIuZiA9IHZhbHVlO1xuICBcdH1cblxuICBcdHJldHVybiBhdHRyO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEF0dHJpYnV0ZVZhbHVlICggcGFyc2VyICkge1xuICBcdHZhciBzdGFydCwgdmFsdWVTdGFydCwgc3RhcnREZXB0aCwgdmFsdWU7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBuZXh0IGNoYXJhY3RlciBtdXN0IGJlIGA9YCwgYC9gLCBgPmAgb3Igd2hpdGVzcGFjZVxuICBcdGlmICggIS9bPVxcLz5cXHNdLy50ZXN0KCBwYXJzZXIubmV4dENoYXIoKSApICkge1xuICBcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgYD1gLCBgL2AsIGA+YCBvciB3aGl0ZXNwYWNlJyApO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJz0nICkgKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHR2YWx1ZVN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHRzdGFydERlcHRoID0gcGFyc2VyLnNlY3Rpb25EZXB0aDtcblxuICBcdHZhbHVlID0gcmVhZFF1b3RlZEF0dHJpYnV0ZVZhbHVlKCBwYXJzZXIsIChcIidcIikgKSB8fFxuICBcdFx0XHRyZWFkUXVvdGVkQXR0cmlidXRlVmFsdWUoIHBhcnNlciwgKFwiXFxcIlwiKSApIHx8XG4gIFx0XHRcdHJlYWRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKCBwYXJzZXIgKTtcblxuICBcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCB2YWxpZCBhdHRyaWJ1dGUgdmFsdWUnICk7XG4gIFx0fVxuXG4gIFx0aWYgKCBwYXJzZXIuc2VjdGlvbkRlcHRoICE9PSBzdGFydERlcHRoICkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHZhbHVlU3RhcnQ7XG4gIFx0XHRwYXJzZXIuZXJyb3IoICdBbiBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBjb250YWluIGFzIG1hbnkgb3BlbmluZyBzZWN0aW9uIHRhZ3MgYXMgY2xvc2luZyBzZWN0aW9uIHRhZ3MnICk7XG4gIFx0fVxuXG4gIFx0aWYgKCAhdmFsdWUubGVuZ3RoICkge1xuICBcdFx0cmV0dXJuICcnO1xuICBcdH1cblxuICBcdGlmICggdmFsdWUubGVuZ3RoID09PSAxICYmIHR5cGVvZiB2YWx1ZVswXSA9PT0gJ3N0cmluZycgKSB7XG4gIFx0XHRyZXR1cm4gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyggdmFsdWVbMF0gKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuICggcGFyc2VyICkge1xuICBcdHZhciBzdGFydCwgdGV4dCwgaGF5c3RhY2ssIG5lZWRsZXMsIGluZGV4O1xuXG4gIFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0dGV4dCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHVucXVvdGVkQXR0cmlidXRlVmFsdWVUZXh0UGF0dGVybiApO1xuXG4gIFx0aWYgKCAhdGV4dCApIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGhheXN0YWNrID0gdGV4dDtcbiAgXHRuZWVkbGVzID0gcGFyc2VyLnRhZ3MubWFwKCBmdW5jdGlvbiAoIHQgKSB7IHJldHVybiB0Lm9wZW47IH0gKTsgLy8gVE9ETyByZWZhY3Rvci4uLiB3ZSBkbyB0aGlzIGluIHJlYWRUZXh0LmpzIGFzIHdlbGxcblxuICBcdGlmICggKCBpbmRleCA9IGdldExvd2VzdEluZGV4KCBoYXlzdGFjaywgbmVlZGxlcyApICkgIT09IC0xICkge1xuICBcdFx0dGV4dCA9IHRleHQuc3Vic3RyKCAwLCBpbmRleCApO1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0ICsgdGV4dC5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZSAoIHBhcnNlciApIHtcbiAgXHR2YXIgdG9rZW5zLCB0b2tlbjtcblxuICBcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IHRydWU7XG5cbiAgXHR0b2tlbnMgPSBbXTtcblxuICBcdHRva2VuID0gcmVhZE11c3RhY2hlKCBwYXJzZXIgKSB8fCByZWFkVW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuKCBwYXJzZXIgKTtcbiAgXHR3aGlsZSAoIHRva2VuICkge1xuICBcdFx0dG9rZW5zLnB1c2goIHRva2VuICk7XG4gIFx0XHR0b2tlbiA9IHJlYWRNdXN0YWNoZSggcGFyc2VyICkgfHwgcmVhZFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbiggcGFyc2VyICk7XG4gIFx0fVxuXG4gIFx0aWYgKCAhdG9rZW5zLmxlbmd0aCApIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IGZhbHNlO1xuICBcdHJldHVybiB0b2tlbnM7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkUXVvdGVkQXR0cmlidXRlVmFsdWUgKCBwYXJzZXIsIHF1b3RlTWFyayApIHtcbiAgXHR2YXIgc3RhcnQsIHRva2VucywgdG9rZW47XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIHF1b3RlTWFyayApICkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmluQXR0cmlidXRlID0gcXVvdGVNYXJrO1xuXG4gIFx0dG9rZW5zID0gW107XG5cbiAgXHR0b2tlbiA9IHJlYWRNdXN0YWNoZSggcGFyc2VyICkgfHwgcmVhZFF1b3RlZFN0cmluZ1Rva2VuKCBwYXJzZXIsIHF1b3RlTWFyayApO1xuICBcdHdoaWxlICggdG9rZW4gIT09IG51bGwgKSB7XG4gIFx0XHR0b2tlbnMucHVzaCggdG9rZW4gKTtcbiAgXHRcdHRva2VuID0gcmVhZE11c3RhY2hlKCBwYXJzZXIgKSB8fCByZWFkUXVvdGVkU3RyaW5nVG9rZW4oIHBhcnNlciwgcXVvdGVNYXJrICk7XG4gIFx0fVxuXG4gIFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBxdW90ZU1hcmsgKSApIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IGZhbHNlO1xuXG4gIFx0cmV0dXJuIHRva2VucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRRdW90ZWRTdHJpbmdUb2tlbiAoIHBhcnNlciwgcXVvdGVNYXJrICkge1xuICBcdHZhciBoYXlzdGFjayA9IHBhcnNlci5yZW1haW5pbmcoKTtcblxuICBcdHZhciBuZWVkbGVzID0gcGFyc2VyLnRhZ3MubWFwKCBmdW5jdGlvbiAoIHQgKSB7IHJldHVybiB0Lm9wZW47IH0gKTsgLy8gVE9ETyByZWZhY3Rvci4uLiB3ZSBkbyB0aGlzIGluIHJlYWRUZXh0LmpzIGFzIHdlbGxcbiAgXHRuZWVkbGVzLnB1c2goIHF1b3RlTWFyayApO1xuXG4gIFx0dmFyIGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgoIGhheXN0YWNrLCBuZWVkbGVzICk7XG5cbiAgXHRpZiAoIGluZGV4ID09PSAtMSApIHtcbiAgXHRcdHBhcnNlci5lcnJvciggJ1F1b3RlZCBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBoYXZlIGEgY2xvc2luZyBxdW90ZScgKTtcbiAgXHR9XG5cbiAgXHRpZiAoICFpbmRleCApIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5wb3MgKz0gaW5kZXg7XG4gIFx0cmV0dXJuIGhheXN0YWNrLnN1YnN0ciggMCwgaW5kZXggKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBdHRyaWJ1dGVPckRpcmVjdGl2ZSAoIHBhcnNlciApIHtcbiAgXHRcdHZhciBtYXRjaCxcbiAgXHRcdFx0YXR0cmlidXRlLFxuICBcdFx0ICAgIGRpcmVjdGl2ZTtcblxuICBcdFx0YXR0cmlidXRlID0gcmVhZEF0dHJpYnV0ZSggcGFyc2VyICk7XG5cbiAgXHRcdGlmICggIWF0dHJpYnV0ZSApIHJldHVybiBudWxsO1xuXG4gIFx0XHQvLyBpbnRybywgb3V0cm8sIGRlY29yYXRvclxuICBcdFx0aWYgKCBkaXJlY3RpdmUgPSBkaXJlY3RpdmVzWyBhdHRyaWJ1dGUubiBdICkge1xuICBcdFx0XHRhdHRyaWJ1dGUudCA9IGRpcmVjdGl2ZS50O1xuICBcdFx0XHRpZiAoIGRpcmVjdGl2ZS52ICkgYXR0cmlidXRlLnYgPSBkaXJlY3RpdmUudjtcbiAgXHRcdFx0ZGVsZXRlIGF0dHJpYnV0ZS5uOyAvLyBubyBuYW1lIG5lY2Vzc2FyeVxuXG4gIFx0XHRcdGlmICggZGlyZWN0aXZlLnQgPT09IFRSQU5TSVRJT04gfHwgZGlyZWN0aXZlLnQgPT09IERFQ09SQVRPUiApIGF0dHJpYnV0ZS5mID0gcHJvY2Vzc0RpcmVjdGl2ZSggYXR0cmlidXRlLmYsIHBhcnNlciApO1xuXG4gIFx0XHRcdGlmICggZGlyZWN0aXZlLnQgPT09IFRSQU5TSVRJT04gKSB7XG4gIFx0XHRcdFx0d2Fybk9uY2VJZkRlYnVnKCAoXCJcIiArIChkaXJlY3RpdmUudiA9PT0gJ3QwJyA/ICdpbnRyby1vdXRybycgOiBkaXJlY3RpdmUudiA9PT0gJ3QxJyA/ICdpbnRybycgOiAnb3V0cm8nKSArIFwiIGlzIGRlcHJlY2F0ZWQuIFRvIHNwZWNpZnkgdHJhbmlzaXRpb25zLCB1c2UgdGhlIHRyYW5zaXRpb24gbmFtZSBzdWZmaXhlZCB3aXRoICctaW4nLCAnLW91dCcsIG9yICctaW4tb3V0JyBhcyBhbiBhdHRyaWJ1dGUuIEFyZ3VtZW50cyBjYW4gYmUgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGUgdmFsdWUgYXMgYSBzaW1wbGUgbGlzdCBvZiBleHByZXNzaW9ucyB3aXRob3V0IG11c3RhY2hlcy5cIikgKTtcbiAgXHRcdFx0fSBlbHNlIGlmICggZGlyZWN0aXZlLnQgPT09IERFQ09SQVRPUiApIHtcbiAgXHRcdFx0XHR3YXJuT25jZUlmRGVidWcoIChcImRlY29yYXRvciBpcyBkZXByZWNhdGVkLiBUbyBzcGVjaWZ5IGRlY29yYXRvcnMsIHVzZSB0aGUgZGVjb3JhdG9yIG5hbWUgcHJlZml4ZWQgd2l0aCAnYXMtJyBhcyBhbiBhdHRyaWJ1dGUuIEFyZ3VtZW50cyBjYW4gYmUgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGUgdmFsdWUgYXMgYSBzaW1wbGUgbGlzdCBvZiBleHByZXNzaW9ucyB3aXRob3V0IG11c3RhY2hlcy5cIikgKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBkZWNvcmF0b3JzXG4gIFx0XHRlbHNlIGlmICggbWF0Y2ggPSBkZWNvcmF0b3JQYXR0ZXJuLmV4ZWMoIGF0dHJpYnV0ZS5uICkgKSB7XG4gIFx0XHRcdGRlbGV0ZSBhdHRyaWJ1dGUubjtcbiAgXHRcdFx0YXR0cmlidXRlLnQgPSBERUNPUkFUT1I7XG4gIFx0XHRcdGF0dHJpYnV0ZS5mID0gcHJvY2Vzc0RpcmVjdGl2ZSggYXR0cmlidXRlLmYsIHBhcnNlciwgREVDT1JBVE9SICk7XG4gIFx0XHRcdGlmICggdHlwZW9mIGF0dHJpYnV0ZS5mID09PSAnb2JqZWN0JyApIGF0dHJpYnV0ZS5mLm4gPSBtYXRjaFsxXTtcbiAgXHRcdFx0ZWxzZSBhdHRyaWJ1dGUuZiA9IG1hdGNoWzFdO1xuICBcdFx0fVxuXG4gIFx0XHQvLyB0cmFuc2l0aW9uc1xuICBcdFx0ZWxzZSBpZiAoIG1hdGNoID0gdHJhbnNpdGlvblBhdHRlcm4uZXhlYyggYXR0cmlidXRlLm4gKSApIHtcbiAgXHRcdFx0ZGVsZXRlIGF0dHJpYnV0ZS5uO1xuICBcdFx0XHRhdHRyaWJ1dGUudCA9IFRSQU5TSVRJT047XG4gIFx0XHRcdGF0dHJpYnV0ZS5mID0gcHJvY2Vzc0RpcmVjdGl2ZSggYXR0cmlidXRlLmYsIHBhcnNlciwgVFJBTlNJVElPTiApO1xuICBcdFx0XHRpZiAoIHR5cGVvZiBhdHRyaWJ1dGUuZiA9PT0gJ29iamVjdCcgKSBhdHRyaWJ1dGUuZi5uID0gbWF0Y2hbMV07XG4gIFx0XHRcdGVsc2UgYXR0cmlidXRlLmYgPSBtYXRjaFsxXTtcbiAgXHRcdFx0YXR0cmlidXRlLnYgPSBtYXRjaFsyXSA9PT0gJ2luLW91dCcgPyAndDAnIDogbWF0Y2hbMl0gPT09ICdpbicgPyAndDEnIDogJ3QyJztcbiAgXHRcdH1cblxuICBcdFx0Ly8gb24tY2xpY2sgZXRjXG4gIFx0XHRlbHNlIGlmICggbWF0Y2ggPSBwcm94eUV2ZW50UGF0dGVybi5leGVjKCBhdHRyaWJ1dGUubiApICkge1xuICBcdFx0XHRhdHRyaWJ1dGUubiA9IG1hdGNoWzFdO1xuICBcdFx0XHRhdHRyaWJ1dGUudCA9IEVWRU5UO1xuICBcdFx0XHRhdHRyaWJ1dGUuZiA9IHByb2Nlc3NEaXJlY3RpdmUoIGF0dHJpYnV0ZS5mLCBwYXJzZXIsIEVWRU5UICk7XG5cbiAgXHRcdFx0aWYgKCByZXNlcnZlZEV2ZW50TmFtZXMudGVzdCggYXR0cmlidXRlLmYubiB8fCBhdHRyaWJ1dGUuZiApICkge1xuICBcdFx0XHRcdHBhcnNlci5wb3MgLT0gKCBhdHRyaWJ1dGUuZi5uIHx8IGF0dHJpYnV0ZS5mICkubGVuZ3RoO1xuICBcdFx0XHRcdHBhcnNlci5lcnJvciggJ0Nhbm5vdCB1c2UgcmVzZXJ2ZWQgZXZlbnQgbmFtZXMgKGNoYW5nZSwgcmVzZXQsIHRlYXJkb3duLCB1cGRhdGUsIGNvbnN0cnVjdCwgY29uZmlnLCBpbml0LCByZW5kZXIsIHVucmVuZGVyLCBkZXRhY2gsIGluc2VydCknICk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdGlmICggcGFyc2VyLnNhbml0aXplRXZlbnRBdHRyaWJ1dGVzICYmIG9uUGF0dGVybi50ZXN0KCBhdHRyaWJ1dGUubiApICkge1xuICBcdFx0XHRcdHJldHVybiB7IGV4Y2x1ZGU6IHRydWUgfTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRhdHRyaWJ1dGUuZiA9IGF0dHJpYnV0ZS5mIHx8ICggYXR0cmlidXRlLmYgPT09ICcnID8gJycgOiAwICk7XG4gIFx0XHRcdFx0YXR0cmlidXRlLnQgPSBBVFRSSUJVVEU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGF0dHJpYnV0ZTtcbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXJDaGFuZ2VUb2tlbiA9IHsgdDogREVMSU1DSEFOR0UsIGV4Y2x1ZGU6IHRydWUgfTtcblxuICBmdW5jdGlvbiByZWFkTXVzdGFjaGUgKCBwYXJzZXIgKSB7XG4gIFx0dmFyIG11c3RhY2hlLCBpO1xuXG4gIFx0Ly8gSWYgd2UncmUgaW5zaWRlIGEgPHNjcmlwdD4gb3IgPHN0eWxlPiB0YWcsIGFuZCB3ZSdyZSBub3RcbiAgXHQvLyBpbnRlcnBvbGF0aW5nLCBidWcgb3V0XG4gIFx0aWYgKCBwYXJzZXIuaW50ZXJwb2xhdGVbIHBhcnNlci5pbnNpZGUgXSA9PT0gZmFsc2UgKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRmb3IgKCBpID0gMDsgaSA8IHBhcnNlci50YWdzLmxlbmd0aDsgaSArPSAxICkge1xuICBcdFx0aWYgKCBtdXN0YWNoZSA9IHJlYWRNdXN0YWNoZU9mVHlwZSggcGFyc2VyLCBwYXJzZXIudGFnc1tpXSApICkge1xuICBcdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKCBwYXJzZXIuaW5UYWcgJiYgIXBhcnNlci5pbkF0dHJpYnV0ZSApIHtcbiAgXHRcdG11c3RhY2hlID0gcmVhZEF0dHJpYnV0ZU9yRGlyZWN0aXZlKCBwYXJzZXIgKTtcbiAgXHRcdGlmICggbXVzdGFjaGUgKSB7XG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRNdXN0YWNoZU9mVHlwZSAoIHBhcnNlciwgdGFnICkge1xuICBcdHZhciBzdGFydCwgbXVzdGFjaGUsIHJlYWRlciwgaTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnXFxcXCcgKyB0YWcub3BlbiApICkge1xuICBcdFx0aWYgKCBzdGFydCA9PT0gMCB8fCBwYXJzZXIuc3RyWyBzdGFydCAtIDEgXSAhPT0gJ1xcXFwnICkge1xuICBcdFx0XHRyZXR1cm4gdGFnLm9wZW47XG4gIFx0XHR9XG4gIFx0fSBlbHNlIGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggdGFnLm9wZW4gKSApIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdC8vIGRlbGltaXRlciBjaGFuZ2U/XG4gIFx0aWYgKCBtdXN0YWNoZSA9IHJlYWREZWxpbWl0ZXJDaGFuZ2UoIHBhcnNlciApICkge1xuICBcdFx0Ly8gZmluZCBjbG9zaW5nIGRlbGltaXRlciBvciBhYm9ydC4uLlxuICBcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCB0YWcuY2xvc2UgKSApIHtcbiAgXHRcdFx0cmV0dXJuIG51bGw7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIC4uLnRoZW4gbWFrZSB0aGUgc3dpdGNoXG4gIFx0XHR0YWcub3BlbiA9IG11c3RhY2hlWzBdO1xuICBcdFx0dGFnLmNsb3NlID0gbXVzdGFjaGVbMV07XG4gIFx0XHRwYXJzZXIuc29ydE11c3RhY2hlVGFncygpO1xuXG4gIFx0XHRyZXR1cm4gZGVsaW1pdGVyQ2hhbmdlVG9rZW47XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0Ly8gaWxsZWdhbCBzZWN0aW9uIGNsb3NlclxuICBcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnLycgKSApIHtcbiAgXHRcdHBhcnNlci5wb3MgLT0gMTtcbiAgXHRcdHZhciByZXdpbmQgPSBwYXJzZXIucG9zO1xuICBcdFx0aWYgKCAhcmVhZE51bWJlckxpdGVyYWwoIHBhcnNlciApICkge1xuICBcdFx0XHRwYXJzZXIucG9zID0gcmV3aW5kIC0gKCB0YWcuY2xvc2UubGVuZ3RoICk7XG4gIFx0XHRcdGlmICggcGFyc2VyLmluQXR0cmlidXRlICkge1xuICBcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdBdHRlbXB0ZWQgdG8gY2xvc2UgYSBzZWN0aW9uIHRoYXQgd2FzblxcJ3Qgb3BlbicgKTtcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHJld2luZDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRmb3IgKCBpID0gMDsgaSA8IHRhZy5yZWFkZXJzLmxlbmd0aDsgaSArPSAxICkge1xuICBcdFx0cmVhZGVyID0gdGFnLnJlYWRlcnNbaV07XG5cbiAgXHRcdGlmICggbXVzdGFjaGUgPSByZWFkZXIoIHBhcnNlciwgdGFnICkgKSB7XG4gIFx0XHRcdGlmICggdGFnLmlzU3RhdGljICkge1xuICBcdFx0XHRcdG11c3RhY2hlLnMgPSB0cnVlOyAvLyBUT0RPIG1ha2UgdGhpcyBgMWAgaW5zdGVhZCAtIG1vcmUgY29tcGFjdFxuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCBwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMgKSB7XG4gIFx0XHRcdFx0bXVzdGFjaGUucCA9IHBhcnNlci5nZXRMaW5lUG9zKCBzdGFydCApO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZmluZUV4cHJlc3Npb24gKCBleHByZXNzaW9uLCBtdXN0YWNoZSApIHtcbiAgXHR2YXIgcmVmZXJlbmNlRXhwcmVzc2lvbjtcblxuICBcdGlmICggZXhwcmVzc2lvbiApIHtcbiAgXHRcdHdoaWxlICggZXhwcmVzc2lvbi50ID09PSBCUkFDS0VURUQgJiYgZXhwcmVzc2lvbi54ICkge1xuICBcdFx0XHRleHByZXNzaW9uID0gZXhwcmVzc2lvbi54O1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIGV4cHJlc3Npb24udCA9PT0gUkVGRVJFTkNFICkge1xuICBcdFx0XHRtdXN0YWNoZS5yID0gZXhwcmVzc2lvbi5uO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0aWYgKCByZWZlcmVuY2VFeHByZXNzaW9uID0gZ2V0UmVmZXJlbmNlRXhwcmVzc2lvbiggZXhwcmVzc2lvbiApICkge1xuICBcdFx0XHRcdG11c3RhY2hlLnJ4ID0gcmVmZXJlbmNlRXhwcmVzc2lvbjtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRtdXN0YWNoZS54ID0gZmxhdHRlbkV4cHJlc3Npb24oIGV4cHJlc3Npb24gKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbXVzdGFjaGU7XG4gIFx0fVxuICB9XG5cbiAgLy8gVE9ETyByZWZhY3RvciB0aGlzISBpdCdzIGJld2lsZGVyaW5nXG4gIGZ1bmN0aW9uIGdldFJlZmVyZW5jZUV4cHJlc3Npb24gKCBleHByZXNzaW9uICkge1xuICBcdHZhciBtZW1iZXJzID0gW10sIHJlZmluZW1lbnQ7XG5cbiAgXHR3aGlsZSAoIGV4cHJlc3Npb24udCA9PT0gTUVNQkVSICYmIGV4cHJlc3Npb24uci50ID09PSBSRUZJTkVNRU5UICkge1xuICBcdFx0cmVmaW5lbWVudCA9IGV4cHJlc3Npb24ucjtcblxuICBcdFx0aWYgKCByZWZpbmVtZW50LnggKSB7XG4gIFx0XHRcdGlmICggcmVmaW5lbWVudC54LnQgPT09IFJFRkVSRU5DRSApIHtcbiAgXHRcdFx0XHRtZW1iZXJzLnVuc2hpZnQoIHJlZmluZW1lbnQueCApO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdG1lbWJlcnMudW5zaGlmdCggZmxhdHRlbkV4cHJlc3Npb24oIHJlZmluZW1lbnQueCApICk7XG4gIFx0XHRcdH1cbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdG1lbWJlcnMudW5zaGlmdCggcmVmaW5lbWVudC5uICk7XG4gIFx0XHR9XG5cbiAgXHRcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uLng7XG4gIFx0fVxuXG4gIFx0aWYgKCBleHByZXNzaW9uLnQgIT09IFJFRkVSRU5DRSApIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHRyOiBleHByZXNzaW9uLm4sXG4gIFx0XHRtOiBtZW1iZXJzXG4gIFx0fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUcmlwbGUgKCBwYXJzZXIsIHRhZyApIHtcbiAgXHR2YXIgZXhwcmVzc2lvbiA9IHJlYWRFeHByZXNzaW9uKCBwYXJzZXIgKSwgdHJpcGxlO1xuXG4gIFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggdGFnLmNsb3NlICkgKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoIChcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArICh0YWcuY2xvc2UpICsgXCInXCIpICk7XG4gIFx0fVxuXG4gIFx0dHJpcGxlID0geyB0OiBUUklQTEUgfTtcbiAgXHRyZWZpbmVFeHByZXNzaW9uKCBleHByZXNzaW9uLCB0cmlwbGUgKTsgLy8gVE9ETyBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseSAtIGl0J3MgbXlzdGVyaW91c1xuXG4gIFx0cmV0dXJuIHRyaXBsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRVbmVzY2FwZWQgKCBwYXJzZXIsIHRhZyApIHtcbiAgXHR2YXIgZXhwcmVzc2lvbiwgdHJpcGxlO1xuXG4gIFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnJicgKSApIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGV4cHJlc3Npb24gPSByZWFkRXhwcmVzc2lvbiggcGFyc2VyICk7XG5cbiAgXHRpZiAoICFleHByZXNzaW9uICkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCB0YWcuY2xvc2UgKSApIHtcbiAgXHRcdHBhcnNlci5lcnJvciggKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgKHRhZy5jbG9zZSkgKyBcIidcIikgKTtcbiAgXHR9XG5cbiAgXHR0cmlwbGUgPSB7IHQ6IFRSSVBMRSB9O1xuICBcdHJlZmluZUV4cHJlc3Npb24oIGV4cHJlc3Npb24sIHRyaXBsZSApOyAvLyBUT0RPIGhhbmRsZSB0aGlzIGRpZmZlcmVudGx5IC0gaXQncyBteXN0ZXJpb3VzXG5cbiAgXHRyZXR1cm4gdHJpcGxlO1xuICB9XG5cbiAgdmFyIGxlZ2FsQWxpYXMgPSAvXig/OlthLXpBLVokXzAtOV18XFxcXFxcLikrKD86KD86KD86W2EtekEtWiRfMC05XXxcXFxcXFwuKSspfCg/OlxcW1swLTldK1xcXSkpKi87XG4gIHZhciBhc1JFID0gL15hcy9pO1xuXG4gIGZ1bmN0aW9uIHJlYWRBbGlhc2VzKCBwYXJzZXIgKSB7XG4gIFx0dmFyIGFsaWFzZXMgPSBbXSwgYWxpYXMsIHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGFsaWFzID0gcmVhZEFsaWFzKCBwYXJzZXIgKTtcblxuICBcdGlmICggYWxpYXMgKSB7XG4gIFx0XHRhbGlhcy54ID0gcmVmaW5lRXhwcmVzc2lvbiggYWxpYXMueCwge30gKTtcbiAgXHRcdGFsaWFzZXMucHVzaCggYWxpYXMgKTtcblxuICBcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0XHR3aGlsZSAoIHBhcnNlci5tYXRjaFN0cmluZygnLCcpICkge1xuICBcdFx0XHRhbGlhcyA9IHJlYWRBbGlhcyggcGFyc2VyICk7XG5cbiAgXHRcdFx0aWYgKCAhYWxpYXMgKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgYW5vdGhlciBhbGlhcy4nICk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRhbGlhcy54ID0gcmVmaW5lRXhwcmVzc2lvbiggYWxpYXMueCwge30gKTtcbiAgXHRcdFx0YWxpYXNlcy5wdXNoKCBhbGlhcyApO1xuXG4gIFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGFsaWFzZXM7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEFsaWFzKCBwYXJzZXIgKSB7XG4gIFx0dmFyIGV4cHIsIGFsaWFzLCBzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRleHByID0gcmVhZEV4cHJlc3Npb24oIHBhcnNlciwgW10gKTtcblxuICBcdGlmICggIWV4cHIgKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoICFwYXJzZXIubWF0Y2hQYXR0ZXJuKCBhc1JFICkgKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRhbGlhcyA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGxlZ2FsQWxpYXMgKTtcblxuICBcdGlmICggIWFsaWFzICkge1xuICBcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgYSBsZWdhbCBhbGlhcyBuYW1lLicgKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4geyBuOiBhbGlhcywgeDogZXhwciB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFBhcnRpYWwgKCBwYXJzZXIsIHRhZyApIHtcbiAgXHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc+JyApICkgcmV0dXJuIG51bGw7XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHQvLyBQYXJ0aWFsIG5hbWVzIGNhbiBpbmNsdWRlIGh5cGhlbnMsIHNvIHdlIGNhbid0IHVzZSByZWFkRXhwcmVzc2lvblxuICBcdC8vIGJsaW5kbHkuIEluc3RlYWQsIHdlIHVzZSB0aGUgYHJlbGF4ZWROYW1lc2AgZmxhZyB0byBpbmRpY2F0ZSB0aGF0XG4gIFx0Ly8gYGZvby1iYXJgIHNob3VsZCBiZSByZWFkIGFzIGEgc2luZ2xlIG5hbWUsIHJhdGhlciB0aGFuICdzdWJ0cmFjdFxuICBcdC8vIGJhciBmcm9tIGZvbydcbiAgXHRwYXJzZXIucmVsYXhlZE5hbWVzID0gcGFyc2VyLnN0cmljdFJlZmluZW1lbnQgPSB0cnVlO1xuICBcdHZhciBleHByZXNzaW9uID0gcmVhZEV4cHJlc3Npb24oIHBhcnNlciApO1xuICBcdHBhcnNlci5yZWxheGVkTmFtZXMgPSBwYXJzZXIuc3RyaWN0UmVmaW5lbWVudCA9IGZhbHNlO1xuXG4gIFx0aWYgKCAhZXhwcmVzc2lvbiApIHJldHVybiBudWxsO1xuXG4gIFx0dmFyIHBhcnRpYWwgPSB7IHQ6IFBBUlRJQUwgfTtcbiAgXHRyZWZpbmVFeHByZXNzaW9uKCBleHByZXNzaW9uLCBwYXJ0aWFsICk7IC8vIFRPRE8uLi5cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIGNoZWNrIGZvciBhbGlhcyBjb250ZXh0IGUuZy4gYHt7PmZvbyBiYXIgYXMgYmF0LCBiaXAgYXMgYm9wfX1gIHRoZW5cbiAgXHQvLyB0dXJuIGl0IGludG8gYHt7I3dpdGggYmFyIGFzIGJhdCwgYmlwIGFzIGJvcH19e3s+Zm9vfX17ey93aXRofX1gXG4gIFx0dmFyIGFsaWFzZXMgPSByZWFkQWxpYXNlcyggcGFyc2VyICk7XG4gIFx0aWYgKCBhbGlhc2VzICkge1xuICBcdFx0cGFydGlhbCA9IHtcbiAgXHRcdFx0dDogQUxJQVMsXG4gIFx0XHRcdHo6IGFsaWFzZXMsXG4gIFx0XHRcdGY6IFsgcGFydGlhbCBdXG4gIFx0XHR9O1xuICBcdH1cblxuICBcdC8vIG90aGVyd2lzZSBjaGVjayBmb3IgbGl0ZXJhbCBjb250ZXh0IGUuZy4gYHt7PmZvbyBiYXJ9fWAgdGhlblxuICBcdC8vIHR1cm4gaXQgaW50byBge3sjd2l0aCBiYXJ9fXt7PmZvb319e3svd2l0aH19YFxuICBcdGVsc2Uge1xuICBcdFx0dmFyIGNvbnRleHQgPSByZWFkRXhwcmVzc2lvbiggcGFyc2VyICk7XG4gIFx0XHRpZiAoIGNvbnRleHQpIHtcbiAgXHRcdFx0cGFydGlhbCA9IHtcbiAgXHRcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRcdG46IFNFQ1RJT05fV0lUSCxcbiAgXHRcdFx0XHRmOiBbIHBhcnRpYWwgXVxuICBcdFx0XHR9O1xuXG4gIFx0XHRcdHJlZmluZUV4cHJlc3Npb24oIGNvbnRleHQsIHBhcnRpYWwgKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIHRhZy5jbG9zZSApICkge1xuICBcdFx0cGFyc2VyLmVycm9yKCAoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyAodGFnLmNsb3NlKSArIFwiJ1wiKSApO1xuICBcdH1cblxuICBcdHJldHVybiBwYXJ0aWFsO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZENvbW1lbnQgKCBwYXJzZXIsIHRhZyApIHtcbiAgXHR2YXIgaW5kZXg7XG5cbiAgXHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICchJyApICkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aW5kZXggPSBwYXJzZXIucmVtYWluaW5nKCkuaW5kZXhPZiggdGFnLmNsb3NlICk7XG5cbiAgXHRpZiAoIGluZGV4ICE9PSAtMSApIHtcbiAgXHRcdHBhcnNlci5wb3MgKz0gaW5kZXggKyB0YWcuY2xvc2UubGVuZ3RoO1xuICBcdFx0cmV0dXJuIHsgdDogQ09NTUVOVCB9O1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRFeHByZXNzaW9uT3JSZWZlcmVuY2UgKCBwYXJzZXIsIGV4cGVjdGVkRm9sbG93ZXJzICkge1xuICBcdHZhciBzdGFydCwgZXhwcmVzc2lvbiwgaTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHRleHByZXNzaW9uID0gcmVhZEV4cHJlc3Npb24oIHBhcnNlciApO1xuXG4gIFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcbiAgXHRcdC8vIHZhbGlkIHJlZmVyZW5jZSBidXQgaW52YWxpZCBleHByZXNzaW9uIGUuZy4gYHt7bmV3fX1gP1xuICBcdFx0dmFyIHJlZiA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIC9eKFxcdyspLyApO1xuICBcdFx0aWYgKCByZWYgKSB7XG4gIFx0XHRcdHJldHVybiB7XG4gIFx0XHRcdFx0dDogUkVGRVJFTkNFLFxuICBcdFx0XHRcdG46IHJlZlxuICBcdFx0XHR9O1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRmb3IgKCBpID0gMDsgaSA8IGV4cGVjdGVkRm9sbG93ZXJzLmxlbmd0aDsgaSArPSAxICkge1xuICBcdFx0aWYgKCBwYXJzZXIucmVtYWluaW5nKCkuc3Vic3RyKCAwLCBleHBlY3RlZEZvbGxvd2Vyc1tpXS5sZW5ndGggKSA9PT0gZXhwZWN0ZWRGb2xsb3dlcnNbaV0gKSB7XG4gIFx0XHRcdHJldHVybiBleHByZXNzaW9uO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRyZXR1cm4gcmVhZFJlZmVyZW5jZSggcGFyc2VyICk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkSW50ZXJwb2xhdG9yICggcGFyc2VyLCB0YWcgKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uLCBpbnRlcnBvbGF0b3IsIGVycjtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdC8vIFRPRE8gd291bGQgYmUgZ29vZCBmb3IgcGVyZiBpZiB3ZSBjb3VsZCBkbyBhd2F5IHdpdGggdGhlIHRyeS1jYXRjaFxuICBcdHRyeSB7XG4gIFx0XHRleHByZXNzaW9uID0gcmVhZEV4cHJlc3Npb25PclJlZmVyZW5jZSggcGFyc2VyLCBbIHRhZy5jbG9zZSBdKTtcbiAgXHR9IGNhdGNoICggZSApIHtcbiAgXHRcdGVyciA9IGU7XG4gIFx0fVxuXG4gIFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcbiAgXHRcdGlmICggcGFyc2VyLnN0ci5jaGFyQXQoIHN0YXJ0ICkgPT09ICchJyApIHtcbiAgXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gY29tbWVudFxuICBcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRcdHJldHVybiBudWxsO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIGVyciApIHtcbiAgXHRcdFx0dGhyb3cgZXJyO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggdGFnLmNsb3NlICkgKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoIChcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArICh0YWcuY2xvc2UpICsgXCInIGFmdGVyIHJlZmVyZW5jZVwiKSApO1xuXG4gIFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuICBcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBjb21tZW50XG4gIFx0XHRcdGlmICggcGFyc2VyLm5leHRDaGFyKCkgPT09ICchJyApIHtcbiAgXHRcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHBhcnNlci5lcnJvciggKFwiRXhwZWN0ZWQgZXhwcmVzc2lvbiBvciBsZWdhbCByZWZlcmVuY2VcIikgKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpbnRlcnBvbGF0b3IgPSB7IHQ6IElOVEVSUE9MQVRPUiB9O1xuICBcdHJlZmluZUV4cHJlc3Npb24oIGV4cHJlc3Npb24sIGludGVycG9sYXRvciApOyAvLyBUT0RPIGhhbmRsZSB0aGlzIGRpZmZlcmVudGx5IC0gaXQncyBteXN0ZXJpb3VzXG5cbiAgXHRyZXR1cm4gaW50ZXJwb2xhdG9yO1xuICB9XG5cbiAgdmFyIHlpZWxkUGF0dGVybiA9IC9eeWllbGRcXHMqLztcblxuICBmdW5jdGlvbiByZWFkWWllbGRlciAoIHBhcnNlciwgdGFnICkge1xuICBcdGlmICggIXBhcnNlci5tYXRjaFBhdHRlcm4oIHlpZWxkUGF0dGVybiApICkgcmV0dXJuIG51bGw7XG5cbiAgXHR2YXIgbmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOVxcLV0qLyApO1xuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCB0YWcuY2xvc2UgKSApIHtcbiAgXHRcdHBhcnNlci5lcnJvciggKFwiZXhwZWN0ZWQgbGVnYWwgcGFydGlhbCBuYW1lXCIpICk7XG4gIFx0fVxuXG4gIFx0dmFyIHlpZWxkZXIgPSB7IHQ6IFlJRUxERVIgfTtcbiAgXHRpZiAoIG5hbWUgKSB5aWVsZGVyLm4gPSBuYW1lO1xuXG4gIFx0cmV0dXJuIHlpZWxkZXI7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkQ2xvc2luZyAoIHBhcnNlciwgdGFnICkge1xuICBcdHZhciBzdGFydCwgcmVtYWluaW5nLCBpbmRleCwgY2xvc2luZztcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggdGFnLm9wZW4gKSApIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJy8nICkgKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cbiAgXHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG4gIFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZiggdGFnLmNsb3NlICk7XG5cbiAgXHRpZiAoIGluZGV4ICE9PSAtMSApIHtcbiAgXHRcdGNsb3NpbmcgPSB7XG4gIFx0XHRcdHQ6IENMT1NJTkcsXG4gIFx0XHRcdHI6IHJlbWFpbmluZy5zdWJzdHIoIDAsIGluZGV4ICkuc3BsaXQoICcgJyApWzBdXG4gIFx0XHR9O1xuXG4gIFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXG4gIFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIHRhZy5jbG9zZSApICkge1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoIChcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArICh0YWcuY2xvc2UpICsgXCInXCIpICk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBjbG9zaW5nO1xuICBcdH1cblxuICBcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRyZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBlbHNlUGF0dGVybiA9IC9eXFxzKmVsc2VcXHMqLztcblxuICBmdW5jdGlvbiByZWFkRWxzZSAoIHBhcnNlciwgdGFnICkge1xuICBcdHZhciBzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIHRhZy5vcGVuICkgKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoICFwYXJzZXIubWF0Y2hQYXR0ZXJuKCBlbHNlUGF0dGVybiApICkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCB0YWcuY2xvc2UgKSApIHtcbiAgXHRcdHBhcnNlci5lcnJvciggKFwiRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgJ1wiICsgKHRhZy5jbG9zZSkgKyBcIidcIikgKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4ge1xuICBcdFx0dDogRUxTRVxuICBcdH07XG4gIH1cblxuICB2YXIgZWxzZVBhdHRlcm4kMSA9IC9eXFxzKmVsc2VpZlxccysvO1xuXG4gIGZ1bmN0aW9uIHJlYWRFbHNlSWYgKCBwYXJzZXIsIHRhZyApIHtcbiAgXHR2YXIgc3RhcnQgPSBwYXJzZXIucG9zO1xuXG4gIFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCB0YWcub3BlbiApICkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCAhcGFyc2VyLm1hdGNoUGF0dGVybiggZWxzZVBhdHRlcm4kMSApICkge1xuICBcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0dmFyIGV4cHJlc3Npb24gPSByZWFkRXhwcmVzc2lvbiggcGFyc2VyICk7XG5cbiAgXHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIHRhZy5jbG9zZSApICkge1xuICBcdFx0cGFyc2VyLmVycm9yKCAoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyAodGFnLmNsb3NlKSArIFwiJ1wiKSApO1xuICBcdH1cblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBFTFNFSUYsXG4gIFx0XHR4OiBleHByZXNzaW9uXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBoYW5kbGViYXJzQmxvY2tDb2RlcyA9IHtcbiAgXHQnZWFjaCc6ICAgIFNFQ1RJT05fRUFDSCxcbiAgXHQnaWYnOiAgICAgIFNFQ1RJT05fSUYsXG4gIFx0J3dpdGgnOiAgICBTRUNUSU9OX0lGX1dJVEgsXG4gIFx0J3VubGVzcyc6ICBTRUNUSU9OX1VOTEVTU1xuICB9O1xuXG4gIHZhciBpbmRleFJlZlBhdHRlcm4gPSAvXlxccyo6XFxzKihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopLztcbiAgdmFyIGtleUluZGV4UmVmUGF0dGVybiA9IC9eXFxzKixcXHMqKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKikvO1xuICB2YXIgaGFuZGxlYmFyc0Jsb2NrUGF0dGVybiA9IG5ldyBSZWdFeHAoICdeKCcgKyBPYmplY3Qua2V5cyggaGFuZGxlYmFyc0Jsb2NrQ29kZXMgKS5qb2luKCAnfCcgKSArICcpXFxcXGInICk7XG4gIGZ1bmN0aW9uIHJlYWRTZWN0aW9uICggcGFyc2VyLCB0YWcgKSB7XG4gIFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uLCBzZWN0aW9uLCBjaGlsZCwgY2hpbGRyZW4sIGhhc0Vsc2UsIGJsb2NrLCB1bmxlc3NCbG9jaywgY29uZGl0aW9ucywgY2xvc2VkLCBpLCBleHBlY3RlZENsb3NlLCBhbGlhc09ubHkgPSBmYWxzZTtcblxuICBcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblxuICBcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnXicgKSApIHtcbiAgXHRcdHNlY3Rpb24gPSB7IHQ6IFNFQ1RJT04sIGY6IFtdLCBuOiBTRUNUSU9OX1VOTEVTUyB9O1xuICBcdH0gZWxzZSBpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJyMnICkgKSB7XG4gIFx0XHRzZWN0aW9uID0geyB0OiBTRUNUSU9OLCBmOiBbXSB9O1xuXG4gIFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ3BhcnRpYWwnICkgKSB7XG4gIFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydCAtIHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMF0ubGVuZ3RoO1xuICBcdFx0XHRwYXJzZXIuZXJyb3IoICdQYXJ0aWFsIGRlZmluaXRpb25zIGNhbiBvbmx5IGJlIGF0IHRoZSB0b3AgbGV2ZWwgb2YgdGhlIHRlbXBsYXRlLCBvciBpbW1lZGlhdGVseSBpbnNpZGUgY29tcG9uZW50cycgKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCBibG9jayA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGhhbmRsZWJhcnNCbG9ja1BhdHRlcm4gKSApIHtcbiAgXHRcdFx0ZXhwZWN0ZWRDbG9zZSA9IGJsb2NrO1xuICBcdFx0XHRzZWN0aW9uLm4gPSBoYW5kbGViYXJzQmxvY2tDb2Rlc1sgYmxvY2sgXTtcbiAgXHRcdH1cbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0aWYgKCBibG9jayA9PT0gJ3dpdGgnICkge1xuICBcdFx0dmFyIGFsaWFzZXMgPSByZWFkQWxpYXNlcyggcGFyc2VyICk7XG4gIFx0XHRpZiAoIGFsaWFzZXMgKSB7XG4gIFx0XHRcdGFsaWFzT25seSA9IHRydWU7XG4gIFx0XHRcdHNlY3Rpb24ueiA9IGFsaWFzZXM7XG4gIFx0XHRcdHNlY3Rpb24udCA9IEFMSUFTO1xuICBcdFx0fVxuICBcdH0gZWxzZSBpZiAoIGJsb2NrID09PSAnZWFjaCcgKSB7XG4gIFx0XHR2YXIgYWxpYXMgPSByZWFkQWxpYXMoIHBhcnNlciApO1xuICBcdFx0aWYgKCBhbGlhcyApIHtcbiAgXHRcdFx0c2VjdGlvbi56ID0gWyB7IG46IGFsaWFzLm4sIHg6IHsgcjogJy4nIH0gfSBdO1xuICBcdFx0XHRleHByZXNzaW9uID0gYWxpYXMueDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoICFhbGlhc09ubHkgKSB7XG4gIFx0XHRpZiAoICFleHByZXNzaW9uICkgZXhwcmVzc2lvbiA9IHJlYWRFeHByZXNzaW9uKCBwYXJzZXIgKTtcblxuICBcdFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgZXhwcmVzc2lvbicgKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gb3B0aW9uYWwgaW5kZXggYW5kIGtleSByZWZlcmVuY2VzXG4gIFx0XHRpZiAoIGkgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBpbmRleFJlZlBhdHRlcm4gKSApIHtcbiAgXHRcdFx0dmFyIGV4dHJhO1xuXG4gIFx0XHRcdGlmICggZXh0cmEgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBrZXlJbmRleFJlZlBhdHRlcm4gKSApIHtcbiAgXHRcdFx0XHRzZWN0aW9uLmkgPSBpICsgJywnICsgZXh0cmE7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0c2VjdGlvbi5pID0gaTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggdGFnLmNsb3NlICkgKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoIChcIkV4cGVjdGVkIGNsb3NpbmcgZGVsaW1pdGVyICdcIiArICh0YWcuY2xvc2UpICsgXCInXCIpICk7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnNlY3Rpb25EZXB0aCArPSAxO1xuICBcdGNoaWxkcmVuID0gc2VjdGlvbi5mO1xuXG4gIFx0Y29uZGl0aW9ucyA9IFtdO1xuXG4gIFx0dmFyIHBvcztcbiAgXHRkbyB7XG4gIFx0XHRwb3MgPSBwYXJzZXIucG9zO1xuICBcdFx0aWYgKCBjaGlsZCA9IHJlYWRDbG9zaW5nKCBwYXJzZXIsIHRhZyApICkge1xuICBcdFx0XHRpZiAoIGV4cGVjdGVkQ2xvc2UgJiYgY2hpbGQuciAhPT0gZXhwZWN0ZWRDbG9zZSApIHtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gcG9zO1xuICBcdFx0XHRcdHBhcnNlci5lcnJvciggKFwiRXhwZWN0ZWQgXCIgKyAodGFnLm9wZW4pICsgXCIvXCIgKyBleHBlY3RlZENsb3NlICsgXCJcIiArICh0YWcuY2xvc2UpKSApO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cGFyc2VyLnNlY3Rpb25EZXB0aCAtPSAxO1xuICBcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHRlbHNlIGlmICggIWFsaWFzT25seSAmJiAoIGNoaWxkID0gcmVhZEVsc2VJZiggcGFyc2VyLCB0YWcgKSApICkge1xuICBcdFx0XHRpZiAoIHNlY3Rpb24ubiA9PT0gU0VDVElPTl9VTkxFU1MgKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKCAne3tlbHNlfX0gbm90IGFsbG93ZWQgaW4ge3sjdW5sZXNzfX0nICk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIGhhc0Vsc2UgKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnaWxsZWdhbCB7e2Vsc2VpZi4uLn19IGFmdGVyIHt7ZWxzZX19JyApO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCAhdW5sZXNzQmxvY2sgKSB7XG4gIFx0XHRcdFx0dW5sZXNzQmxvY2sgPSBbXTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHZhciBtdXN0YWNoZSA9IHtcbiAgXHRcdFx0XHR0OiBTRUNUSU9OLFxuICBcdFx0XHRcdG46IFNFQ1RJT05fSUYsXG4gIFx0XHRcdFx0ZjogY2hpbGRyZW4gPSBbXVxuICBcdFx0XHR9O1xuICBcdFx0XHRyZWZpbmVFeHByZXNzaW9uKCBjaGlsZC54LCBtdXN0YWNoZSApO1xuXG4gIFx0XHRcdHVubGVzc0Jsb2NrLnB1c2goIG11c3RhY2hlICk7XG4gIFx0XHR9XG5cbiAgXHRcdGVsc2UgaWYgKCAhYWxpYXNPbmx5ICYmICggY2hpbGQgPSByZWFkRWxzZSggcGFyc2VyLCB0YWcgKSApICkge1xuICBcdFx0XHRpZiAoIHNlY3Rpb24ubiA9PT0gU0VDVElPTl9VTkxFU1MgKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKCAne3tlbHNlfX0gbm90IGFsbG93ZWQgaW4ge3sjdW5sZXNzfX0nICk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIGhhc0Vsc2UgKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKCAndGhlcmUgY2FuIG9ubHkgYmUgb25lIHt7ZWxzZX19IGJsb2NrLCBhdCB0aGUgZW5kIG9mIGEgc2VjdGlvbicgKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGhhc0Vsc2UgPSB0cnVlO1xuXG4gIFx0XHRcdC8vIHVzZSBhbiB1bmxlc3MgYmxvY2sgaWYgdGhlcmUncyBubyBlbHNlaWZcbiAgXHRcdFx0aWYgKCAhdW5sZXNzQmxvY2sgKSB7XG4gIFx0XHRcdFx0dW5sZXNzQmxvY2sgPSBbXTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHVubGVzc0Jsb2NrLnB1c2goe1xuICBcdFx0XHRcdHQ6IFNFQ1RJT04sXG4gIFx0XHRcdFx0bjogU0VDVElPTl9VTkxFU1MsXG4gIFx0XHRcdFx0ZjogY2hpbGRyZW4gPSBbXVxuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0ZWxzZSB7XG4gIFx0XHRcdGNoaWxkID0gcGFyc2VyLnJlYWQoIFJFQURFUlMgKTtcblxuICBcdFx0XHRpZiAoICFjaGlsZCApIHtcbiAgXHRcdFx0XHRicmVhaztcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNoaWxkcmVuLnB1c2goIGNoaWxkICk7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoICFjbG9zZWQgKTtcblxuICBcdGlmICggdW5sZXNzQmxvY2sgKSB7XG4gIFx0XHRzZWN0aW9uLmwgPSB1bmxlc3NCbG9jaztcbiAgXHR9XG5cbiAgXHRpZiAoICFhbGlhc09ubHkgKSB7XG4gIFx0XHRyZWZpbmVFeHByZXNzaW9uKCBleHByZXNzaW9uLCBzZWN0aW9uICk7XG4gIFx0fVxuXG4gIFx0Ly8gVE9ETyBpZiBhIHNlY3Rpb24gaXMgZW1wdHkgaXQgc2hvdWxkIGJlIGRpc2NhcmRlZC4gRG9uJ3QgZG9cbiAgXHQvLyB0aGF0IGhlcmUgdGhvdWdoIC0gd2UgbmVlZCB0byBjbGVhbiBldmVyeXRoaW5nIHVwIGZpcnN0LCBhc1xuICBcdC8vIGl0IG1heSBjb250YWluIHJlbW92ZWFibGUgd2hpdGVzcGFjZS4gQXMgYSB0ZW1wb3JhcnkgbWVhc3VyZSxcbiAgXHQvLyB0byBwYXNzIHRoZSBleGlzdGluZyB0ZXN0cywgcmVtb3ZlIGVtcHR5IGBmYCBhcnJheXNcbiAgXHRpZiAoICFzZWN0aW9uLmYubGVuZ3RoICkge1xuICBcdFx0ZGVsZXRlIHNlY3Rpb24uZjtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc2VjdGlvbjtcbiAgfVxuXG4gIHZhciBPUEVOX0NPTU1FTlQgPSAnPCEtLSc7XG4gIHZhciBDTE9TRV9DT01NRU5UID0gJy0tPic7XG4gIGZ1bmN0aW9uIHJlYWRIdG1sQ29tbWVudCAoIHBhcnNlciApIHtcbiAgXHR2YXIgc3RhcnQsIGNvbnRlbnQsIHJlbWFpbmluZywgZW5kSW5kZXgsIGNvbW1lbnQ7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIHBhcnNlci50ZXh0T25seU1vZGUgfHwgIXBhcnNlci5tYXRjaFN0cmluZyggT1BFTl9DT01NRU5UICkgKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG4gIFx0ZW5kSW5kZXggPSByZW1haW5pbmcuaW5kZXhPZiggQ0xPU0VfQ09NTUVOVCApO1xuXG4gIFx0aWYgKCBlbmRJbmRleCA9PT0gLTEgKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoICdJbGxlZ2FsIEhUTUwgLSBleHBlY3RlZCBjbG9zaW5nIGNvbW1lbnQgc2VxdWVuY2UgKFxcJy0tPlxcJyknICk7XG4gIFx0fVxuXG4gIFx0Y29udGVudCA9IHJlbWFpbmluZy5zdWJzdHIoIDAsIGVuZEluZGV4ICk7XG4gIFx0cGFyc2VyLnBvcyArPSBlbmRJbmRleCArIDM7XG5cbiAgXHRjb21tZW50ID0ge1xuICBcdFx0dDogQ09NTUVOVCxcbiAgXHRcdGM6IGNvbnRlbnRcbiAgXHR9O1xuXG4gIFx0aWYgKCBwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMgKSB7XG4gIFx0XHRjb21tZW50LnAgPSBwYXJzZXIuZ2V0TGluZVBvcyggc3RhcnQgKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gY29tbWVudDtcbiAgfVxuXG4gIHZhciBsZWFkaW5nTGluZWJyZWFrID0gL15bIFxcdFxcZlxcclxcbl0qXFxyP1xcbi87XG4gIHZhciB0cmFpbGluZ0xpbmVicmVhayA9IC9cXHI/XFxuWyBcXHRcXGZcXHJcXG5dKiQvO1xuICBmdW5jdGlvbiBzdHJpcFN0YW5kYWxvbmVzICggaXRlbXMgKSB7XG4gIFx0dmFyIGksIGN1cnJlbnQsIGJhY2tPbmUsIGJhY2tUd28sIGxhc3RTZWN0aW9uSXRlbTtcblxuICBcdGZvciAoIGk9MTsgaTxpdGVtcy5sZW5ndGg7IGkrPTEgKSB7XG4gIFx0XHRjdXJyZW50ID0gaXRlbXNbaV07XG4gIFx0XHRiYWNrT25lID0gaXRlbXNbaS0xXTtcbiAgXHRcdGJhY2tUd28gPSBpdGVtc1tpLTJdO1xuXG4gIFx0XHQvLyBpZiB3ZSdyZSBhdCB0aGUgZW5kIG9mIGEgW3RleHRdW2NvbW1lbnRdW3RleHRdIHNlcXVlbmNlLi4uXG4gIFx0XHRpZiAoIGlzU3RyaW5nKCBjdXJyZW50ICkgJiYgaXNDb21tZW50KCBiYWNrT25lICkgJiYgaXNTdHJpbmcoIGJhY2tUd28gKSApIHtcblxuICBcdFx0XHQvLyAuLi4gYW5kIHRoZSBjb21tZW50IGlzIGEgc3RhbmRhbG9uZSAoaS5lLiBsaW5lIGJyZWFrcyBlaXRoZXIgc2lkZSkuLi5cbiAgXHRcdFx0aWYgKCB0cmFpbGluZ0xpbmVicmVhay50ZXN0KCBiYWNrVHdvICkgJiYgbGVhZGluZ0xpbmVicmVhay50ZXN0KCBjdXJyZW50ICkgKSB7XG5cbiAgXHRcdFx0XHQvLyAuLi4gdGhlbiB3ZSB3YW50IHRvIHJlbW92ZSB0aGUgd2hpdGVzcGFjZSBhZnRlciB0aGUgZmlyc3QgbGluZSBicmVha1xuICBcdFx0XHRcdGl0ZW1zW2ktMl0gPSBiYWNrVHdvLnJlcGxhY2UoIHRyYWlsaW5nTGluZWJyZWFrLCAnXFxuJyApO1xuXG4gIFx0XHRcdFx0Ly8gYW5kIHRoZSBsZWFkaW5nIGxpbmUgYnJlYWsgb2YgdGhlIHNlY29uZCB0ZXh0IHRva2VuXG4gIFx0XHRcdFx0aXRlbXNbaV0gPSBjdXJyZW50LnJlcGxhY2UoIGxlYWRpbmdMaW5lYnJlYWssICcnICk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gaWYgdGhlIGN1cnJlbnQgaXRlbSBpcyBhIHNlY3Rpb24sIGFuZCBpdCBpcyBwcmVjZWRlZCBieSBhIGxpbmVicmVhaywgYW5kXG4gIFx0XHQvLyBpdHMgZmlyc3QgaXRlbSBpcyBhIGxpbmVicmVhay4uLlxuICBcdFx0aWYgKCBpc1NlY3Rpb24oIGN1cnJlbnQgKSAmJiBpc1N0cmluZyggYmFja09uZSApICkge1xuICBcdFx0XHRpZiAoIHRyYWlsaW5nTGluZWJyZWFrLnRlc3QoIGJhY2tPbmUgKSAmJiBpc1N0cmluZyggY3VycmVudC5mWzBdICkgJiYgbGVhZGluZ0xpbmVicmVhay50ZXN0KCBjdXJyZW50LmZbMF0gKSApIHtcbiAgXHRcdFx0XHRpdGVtc1tpLTFdID0gYmFja09uZS5yZXBsYWNlKCB0cmFpbGluZ0xpbmVicmVhaywgJ1xcbicgKTtcbiAgXHRcdFx0XHRjdXJyZW50LmZbMF0gPSBjdXJyZW50LmZbMF0ucmVwbGFjZSggbGVhZGluZ0xpbmVicmVhaywgJycgKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBpZiB0aGUgbGFzdCBpdGVtIHdhcyBhIHNlY3Rpb24sIGFuZCBpdCBpcyBmb2xsb3dlZCBieSBhIGxpbmVicmVhaywgYW5kXG4gIFx0XHQvLyBpdHMgbGFzdCBpdGVtIGlzIGEgbGluZWJyZWFrLi4uXG4gIFx0XHRpZiAoIGlzU3RyaW5nKCBjdXJyZW50ICkgJiYgaXNTZWN0aW9uKCBiYWNrT25lICkgKSB7XG4gIFx0XHRcdGxhc3RTZWN0aW9uSXRlbSA9IGxhc3RJdGVtKCBiYWNrT25lLmYgKTtcblxuICBcdFx0XHRpZiAoIGlzU3RyaW5nKCBsYXN0U2VjdGlvbkl0ZW0gKSAmJiB0cmFpbGluZ0xpbmVicmVhay50ZXN0KCBsYXN0U2VjdGlvbkl0ZW0gKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoIGN1cnJlbnQgKSApIHtcbiAgXHRcdFx0XHRiYWNrT25lLmZbIGJhY2tPbmUuZi5sZW5ndGggLSAxIF0gPSBsYXN0U2VjdGlvbkl0ZW0ucmVwbGFjZSggdHJhaWxpbmdMaW5lYnJlYWssICdcXG4nICk7XG4gIFx0XHRcdFx0aXRlbXNbaV0gPSBjdXJyZW50LnJlcGxhY2UoIGxlYWRpbmdMaW5lYnJlYWssICcnICk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gaXRlbXM7XG4gIH1cblxuICBmdW5jdGlvbiBpc1N0cmluZyAoIGl0ZW0gKSB7XG4gIFx0cmV0dXJuIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ29tbWVudCAoIGl0ZW0gKSB7XG4gIFx0cmV0dXJuIGl0ZW0udCA9PT0gQ09NTUVOVCB8fCBpdGVtLnQgPT09IERFTElNQ0hBTkdFO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTZWN0aW9uICggaXRlbSApIHtcbiAgXHRyZXR1cm4gKCBpdGVtLnQgPT09IFNFQ1RJT04gfHwgaXRlbS50ID09PSBJTlZFUlRFRCApICYmIGl0ZW0uZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaW1XaGl0ZXNwYWNlICggaXRlbXMsIGxlYWRpbmdQYXR0ZXJuLCB0cmFpbGluZ1BhdHRlcm4gKSB7XG4gIFx0dmFyIGl0ZW07XG5cbiAgXHRpZiAoIGxlYWRpbmdQYXR0ZXJuICkge1xuICBcdFx0aXRlbSA9IGl0ZW1zWzBdO1xuICBcdFx0aWYgKCB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgKSB7XG4gIFx0XHRcdGl0ZW0gPSBpdGVtLnJlcGxhY2UoIGxlYWRpbmdQYXR0ZXJuLCAnJyApO1xuXG4gIFx0XHRcdGlmICggIWl0ZW0gKSB7XG4gIFx0XHRcdFx0aXRlbXMuc2hpZnQoKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRpdGVtc1swXSA9IGl0ZW07XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoIHRyYWlsaW5nUGF0dGVybiApIHtcbiAgXHRcdGl0ZW0gPSBsYXN0SXRlbSggaXRlbXMgKTtcbiAgXHRcdGlmICggdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnICkge1xuICBcdFx0XHRpdGVtID0gaXRlbS5yZXBsYWNlKCB0cmFpbGluZ1BhdHRlcm4sICcnICk7XG5cbiAgXHRcdFx0aWYgKCAhaXRlbSApIHtcbiAgXHRcdFx0XHRpdGVtcy5wb3AoKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRpdGVtc1sgaXRlbXMubGVuZ3RoIC0gMSBdID0gaXRlbTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBjb250aWd1b3VzV2hpdGVzcGFjZSA9IC9bIFxcdFxcZlxcclxcbl0rL2c7XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50cyA9IC9eKD86cHJlfHNjcmlwdHxzdHlsZXx0ZXh0YXJlYSkkL2k7XG4gIHZhciBsZWFkaW5nV2hpdGVzcGFjZSQxID0gL15bIFxcdFxcZlxcclxcbl0rLztcbiAgdmFyIHRyYWlsaW5nV2hpdGVzcGFjZSA9IC9bIFxcdFxcZlxcclxcbl0rJC87XG4gIHZhciBsZWFkaW5nTmV3TGluZSA9IC9eKD86XFxyXFxufFxccnxcXG4pLztcbiAgdmFyIHRyYWlsaW5nTmV3TGluZSA9IC8oPzpcXHJcXG58XFxyfFxcbikkLztcblxuICBmdW5jdGlvbiBjbGVhbnVwICggaXRlbXMsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2UsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZSApIHtcbiAgXHRpZiAoIHR5cGVvZiBpdGVtcyA9PT0gJ3N0cmluZycgKSByZXR1cm47XG5cbiAgXHR2YXIgaSxcbiAgXHRcdGl0ZW0sXG4gIFx0XHRwcmV2aW91c0l0ZW0sXG4gIFx0XHRuZXh0SXRlbSxcbiAgXHRcdHByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LFxuICBcdFx0cmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCxcbiAgXHRcdHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LFxuICBcdFx0a2V5O1xuXG4gIFx0Ly8gRmlyc3QgcGFzcyAtIHJlbW92ZSBzdGFuZGFsb25lcyBhbmQgY29tbWVudHMgZXRjXG4gIFx0c3RyaXBTdGFuZGFsb25lcyggaXRlbXMgKTtcblxuICBcdGkgPSBpdGVtcy5sZW5ndGg7XG4gIFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRpdGVtID0gaXRlbXNbaV07XG5cbiAgXHRcdC8vIFJlbW92ZSBkZWxpbWl0ZXIgY2hhbmdlcywgdW5zYWZlIGVsZW1lbnRzIGV0Y1xuICBcdFx0aWYgKCBpdGVtLmV4Y2x1ZGUgKSB7XG4gIFx0XHRcdGl0ZW1zLnNwbGljZSggaSwgMSApO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBSZW1vdmUgY29tbWVudHMsIHVubGVzcyB3ZSB3YW50IHRvIGtlZXAgdGhlbVxuICBcdFx0ZWxzZSBpZiAoIHN0cmlwQ29tbWVudHMgJiYgaXRlbS50ID09PSBDT01NRU5UICkge1xuICBcdFx0XHRpdGVtcy5zcGxpY2UoIGksIDEgKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyBJZiBuZWNlc3NhcnksIHJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gIFx0dHJpbVdoaXRlc3BhY2UoIGl0ZW1zLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZSA/IGxlYWRpbmdXaGl0ZXNwYWNlJDEgOiBudWxsLCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2UgPyB0cmFpbGluZ1doaXRlc3BhY2UgOiBudWxsICk7XG5cbiAgXHRpID0gaXRlbXMubGVuZ3RoO1xuICBcdHdoaWxlICggaS0tICkge1xuICBcdFx0aXRlbSA9IGl0ZW1zW2ldO1xuXG4gIFx0XHQvLyBSZWN1cnNlXG4gIFx0XHRpZiAoIGl0ZW0uZiApIHtcbiAgXHRcdFx0dmFyIGlzUHJlc2VydmVXaGl0ZXNwYWNlRWxlbWVudCA9IGl0ZW0udCA9PT0gRUxFTUVOVCAmJiBwcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50cy50ZXN0KCBpdGVtLmUgKTtcbiAgXHRcdFx0cHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSBwcmVzZXJ2ZVdoaXRlc3BhY2UgfHwgaXNQcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50O1xuXG4gIFx0XHRcdGlmICggIXByZXNlcnZlV2hpdGVzcGFjZSAmJiBpc1ByZXNlcnZlV2hpdGVzcGFjZUVsZW1lbnQgKSB7XG4gIFx0XHRcdFx0dHJpbVdoaXRlc3BhY2UoIGl0ZW0uZiwgbGVhZGluZ05ld0xpbmUsIHRyYWlsaW5nTmV3TGluZSApO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCAhcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgKSB7XG4gIFx0XHRcdFx0cHJldmlvdXNJdGVtID0gaXRlbXNbIGkgLSAxIF07XG4gIFx0XHRcdFx0bmV4dEl0ZW0gPSBpdGVtc1sgaSArIDEgXTtcblxuICBcdFx0XHRcdC8vIGlmIHRoZSBwcmV2aW91cyBpdGVtIHdhcyBhIHRleHQgaXRlbSB3aXRoIHRyYWlsaW5nIHdoaXRlc3BhY2UsXG4gIFx0XHRcdFx0Ly8gcmVtb3ZlIGxlYWRpbmcgd2hpdGVzcGFjZSBpbnNpZGUgdGhlIGZyYWdtZW50XG4gIFx0XHRcdFx0aWYgKCAhcHJldmlvdXNJdGVtIHx8ICggdHlwZW9mIHByZXZpb3VzSXRlbSA9PT0gJ3N0cmluZycgJiYgdHJhaWxpbmdXaGl0ZXNwYWNlLnRlc3QoIHByZXZpb3VzSXRlbSApICkgKSB7XG4gIFx0XHRcdFx0XHRyZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyBhbmQgdmljZSB2ZXJzYVxuICBcdFx0XHRcdGlmICggIW5leHRJdGVtIHx8ICggdHlwZW9mIG5leHRJdGVtID09PSAnc3RyaW5nJyAmJiBsZWFkaW5nV2hpdGVzcGFjZSQxLnRlc3QoIG5leHRJdGVtICkgKSApIHtcbiAgXHRcdFx0XHRcdHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjbGVhbnVwKCBpdGVtLmYsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCApO1xuXG4gIFx0XHRcdC8vIGNsZWFuIHVwIG5hbWUgdGVtcGxhdGVzIChldmVudHMsIGRlY29yYXRvcnMsIGV0YylcbiAgXHRcdFx0aWYgKCBpc0FycmF5KCBpdGVtLmYubiApICkge1xuICBcdFx0XHRcdGNsZWFudXAoIGl0ZW0uZi5uLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZSApO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0Ly8gY2xlYW4gdXAgYXJnIHRlbXBsYXRlcyAoZXZlbnRzLCBkZWNvcmF0b3JzLCBldGMpXG4gIFx0XHRcdGlmICggaXNBcnJheSggaXRlbS5mLmQgKSApIHtcbiAgXHRcdFx0XHRjbGVhbnVwKCBpdGVtLmYuZCwgc3RyaXBDb21tZW50cywgcHJlc2VydmVXaGl0ZXNwYWNlLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2UgKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBTcGxpdCBpZi1lbHNlIGJsb2NrcyBpbnRvIHR3byAoYW4gaWYsIGFuZCBhbiB1bmxlc3MpXG4gIFx0XHRpZiAoIGl0ZW0ubCApIHtcbiAgXHRcdFx0Y2xlYW51cCggaXRlbS5sLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ICk7XG5cbiAgXHRcdFx0aXRlbS5sLmZvckVhY2goIGZ1bmN0aW9uICggcyApIHsgcmV0dXJuIHMubCA9IDE7IH0gKTtcbiAgXHRcdFx0aXRlbS5sLnVuc2hpZnQoIGkgKyAxLCAwICk7XG4gIFx0XHRcdGl0ZW1zLnNwbGljZS5hcHBseSggaXRlbXMsIGl0ZW0ubCApO1xuICBcdFx0XHRkZWxldGUgaXRlbS5sOyAvLyBUT0RPIHdvdWxkIGJlIG5pY2UgaWYgdGhlcmUgd2FzIGEgd2F5IGFyb3VuZCB0aGlzXG4gIFx0XHR9XG5cbiAgXHRcdC8vIENsZWFuIHVwIGVsZW1lbnQgYXR0cmlidXRlc1xuICBcdFx0aWYgKCBpdGVtLmEgKSB7XG4gIFx0XHRcdGZvciAoIGtleSBpbiBpdGVtLmEgKSB7XG4gIFx0XHRcdFx0aWYgKCBpdGVtLmEuaGFzT3duUHJvcGVydHkoIGtleSApICYmIHR5cGVvZiBpdGVtLmFbIGtleSBdICE9PSAnc3RyaW5nJyApIHtcbiAgXHRcdFx0XHRcdGNsZWFudXAoIGl0ZW0uYVsga2V5IF0sIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdC8vIENsZWFuIHVwIGNvbmRpdGlvbmFsIGF0dHJpYnV0ZXNcbiAgXHRcdGlmICggaXRlbS5tICkge1xuICBcdFx0XHRjbGVhbnVwKCBpdGVtLm0sIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgKTtcbiAgXHRcdFx0aWYgKCBpdGVtLm0ubGVuZ3RoIDwgMSApIGRlbGV0ZSBpdGVtLm07XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gZmluYWwgcGFzcyAtIGZ1c2UgdGV4dCBub2RlcyB0b2dldGhlclxuICBcdGkgPSBpdGVtcy5sZW5ndGg7XG4gIFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRpZiAoIHR5cGVvZiBpdGVtc1tpXSA9PT0gJ3N0cmluZycgKSB7XG4gIFx0XHRcdGlmICggdHlwZW9mIGl0ZW1zW2krMV0gPT09ICdzdHJpbmcnICkge1xuICBcdFx0XHRcdGl0ZW1zW2ldID0gaXRlbXNbaV0gKyBpdGVtc1tpKzFdO1xuICBcdFx0XHRcdGl0ZW1zLnNwbGljZSggaSArIDEsIDEgKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICggIXByZXNlcnZlV2hpdGVzcGFjZSApIHtcbiAgXHRcdFx0XHRpdGVtc1tpXSA9IGl0ZW1zW2ldLnJlcGxhY2UoIGNvbnRpZ3VvdXNXaGl0ZXNwYWNlLCAnICcgKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICggaXRlbXNbaV0gPT09ICcnICkge1xuICBcdFx0XHRcdGl0ZW1zLnNwbGljZSggaSwgMSApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIGNsb3NpbmdUYWdQYXR0ZXJuID0gL14oW2EtekEtWl17MSx9Oj9bYS16QS1aMC05XFwtXSopXFxzKlxcPi87XG5cbiAgZnVuY3Rpb24gcmVhZENsb3NpbmdUYWcgKCBwYXJzZXIgKSB7XG4gIFx0dmFyIHN0YXJ0LCB0YWc7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHQvLyBhcmUgd2UgbG9va2luZyBhdCBhIGNsb3NpbmcgdGFnP1xuICBcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzwvJyApICkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCB0YWcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBjbG9zaW5nVGFnUGF0dGVybiApICkge1xuICBcdFx0aWYgKCBwYXJzZXIuaW5zaWRlICYmIHRhZyAhPT0gcGFyc2VyLmluc2lkZSApIHtcbiAgXHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuICBcdFx0XHRyZXR1cm4gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHtcbiAgXHRcdFx0dDogQ0xPU0lOR19UQUcsXG4gIFx0XHRcdGU6IHRhZ1xuICBcdFx0fTtcbiAgXHR9XG5cbiAgXHQvLyBXZSBoYXZlIGFuIGlsbGVnYWwgY2xvc2luZyB0YWcsIHJlcG9ydCBpdFxuICBcdHBhcnNlci5wb3MgLT0gMjtcbiAgXHRwYXJzZXIuZXJyb3IoICdJbGxlZ2FsIGNsb3NpbmcgdGFnJyApO1xuICB9XG5cbiAgdmFyIHRhZ05hbWVQYXR0ZXJuID0gL15bYS16QS1aXXsxLH06P1thLXpBLVowLTlcXC1dKi87XG4gIHZhciB2YWxpZFRhZ05hbWVGb2xsb3dlciA9IC9eW1xcc1xcblxcLz5dLztcbiAgdmFyIGV4Y2x1ZGUgPSB7IGV4Y2x1ZGU6IHRydWUgfTtcbiAgdmFyIGRpc2FsbG93ZWRDb250ZW50cztcbiAgLy8gYmFzZWQgb24gaHR0cDovL2RldmVsb3BlcnMud2hhdHdnLm9yZy9zeW50YXguaHRtbCNzeW50YXgtdGFnLW9taXNzaW9uXG4gIGRpc2FsbG93ZWRDb250ZW50cyA9IHtcbiAgXHRsaTogWyAnbGknIF0sXG4gIFx0ZHQ6IFsgJ2R0JywgJ2RkJyBdLFxuICBcdGRkOiBbICdkdCcsICdkZCcgXSxcbiAgXHRwOiAnYWRkcmVzcyBhcnRpY2xlIGFzaWRlIGJsb2NrcXVvdGUgZGl2IGRsIGZpZWxkc2V0IGZvb3RlciBmb3JtIGgxIGgyIGgzIGg0IGg1IGg2IGhlYWRlciBoZ3JvdXAgaHIgbWFpbiBtZW51IG5hdiBvbCBwIHByZSBzZWN0aW9uIHRhYmxlIHVsJy5zcGxpdCggJyAnICksXG4gIFx0cnQ6IFsgJ3J0JywgJ3JwJyBdLFxuICBcdHJwOiBbICdydCcsICdycCcgXSxcbiAgXHRvcHRncm91cDogWyAnb3B0Z3JvdXAnIF0sXG4gIFx0b3B0aW9uOiBbICdvcHRpb24nLCAnb3B0Z3JvdXAnIF0sXG4gIFx0dGhlYWQ6IFsgJ3Rib2R5JywgJ3Rmb290JyBdLFxuICBcdHRib2R5OiBbICd0Ym9keScsICd0Zm9vdCcgXSxcbiAgXHR0Zm9vdDogWyAndGJvZHknIF0sXG4gIFx0dHI6IFsgJ3RyJywgJ3Rib2R5JyBdLFxuICBcdHRkOiBbICd0ZCcsICd0aCcsICd0cicgXSxcbiAgXHR0aDogWyAndGQnLCAndGgnLCAndHInIF1cbiAgfTtcblxuICBmdW5jdGlvbiByZWFkRWxlbWVudCAoIHBhcnNlciApIHtcbiAgXHR2YXIgc3RhcnQsXG4gIFx0XHRlbGVtZW50LFxuICBcdFx0YXR0cmlidXRlLFxuICBcdFx0c2VsZkNsb3NpbmcsXG4gIFx0XHRjaGlsZHJlbixcbiAgXHRcdHBhcnRpYWxzLFxuICBcdFx0aGFzUGFydGlhbHMsXG4gIFx0XHRjaGlsZCxcbiAgXHRcdGNsb3NlZCxcbiAgXHRcdHBvcyxcbiAgXHRcdHJlbWFpbmluZyxcbiAgXHRcdGNsb3NpbmdUYWc7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHRpZiAoIHBhcnNlci5pbnNpZGUgfHwgcGFyc2VyLmluQXR0cmlidXRlIHx8IHBhcnNlci50ZXh0T25seU1vZGUgKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc8JyApICkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gaWYgdGhpcyBpcyBhIGNsb3NpbmcgdGFnLCBhYm9ydCBzdHJhaWdodCBhd2F5XG4gIFx0aWYgKCBwYXJzZXIubmV4dENoYXIoKSA9PT0gJy8nICkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0ZWxlbWVudCA9IHt9O1xuICBcdGlmICggcGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zICkge1xuICBcdFx0ZWxlbWVudC5wID0gcGFyc2VyLmdldExpbmVQb3MoIHN0YXJ0ICk7XG4gIFx0fVxuXG4gIFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICchJyApICkge1xuICBcdFx0ZWxlbWVudC50ID0gRE9DVFlQRTtcbiAgXHRcdGlmICggIXBhcnNlci5tYXRjaFBhdHRlcm4oIC9eZG9jdHlwZS9pICkgKSB7XG4gIFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIERPQ1RZUEUgZGVjbGFyYXRpb24nICk7XG4gIFx0XHR9XG5cbiAgXHRcdGVsZW1lbnQuYSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIC9eKC4rPyk+LyApO1xuICBcdFx0cmV0dXJuIGVsZW1lbnQ7XG4gIFx0fVxuXG4gIFx0ZWxlbWVudC50ID0gRUxFTUVOVDtcblxuICBcdC8vIGVsZW1lbnQgbmFtZVxuICBcdGVsZW1lbnQuZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHRhZ05hbWVQYXR0ZXJuICk7XG4gIFx0aWYgKCAhZWxlbWVudC5lICkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gbmV4dCBjaGFyYWN0ZXIgbXVzdCBiZSB3aGl0ZXNwYWNlLCBjbG9zaW5nIHNvbGlkdXMgb3IgJz4nXG4gIFx0aWYgKCAhdmFsaWRUYWdOYW1lRm9sbG93ZXIudGVzdCggcGFyc2VyLm5leHRDaGFyKCkgKSApIHtcbiAgXHRcdHBhcnNlci5lcnJvciggJ0lsbGVnYWwgdGFnIG5hbWUnICk7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXG4gIFx0cGFyc2VyLmluVGFnID0gdHJ1ZTtcblxuICBcdC8vIGRpcmVjdGl2ZXMgYW5kIGF0dHJpYnV0ZXNcbiAgXHR3aGlsZSAoIGF0dHJpYnV0ZSA9IHJlYWRNdXN0YWNoZSggcGFyc2VyICkgKSB7XG4gIFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gZmFsc2UgKSB7XG4gIFx0XHRcdGlmICggIWVsZW1lbnQubSApIGVsZW1lbnQubSA9IFtdO1xuICBcdFx0XHRlbGVtZW50Lm0ucHVzaCggYXR0cmlidXRlICk7XG4gIFx0XHR9XG5cbiAgXHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgXHR9XG5cbiAgXHRwYXJzZXIuaW5UYWcgPSBmYWxzZTtcblxuICBcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIGNsb3Npbmcgc29saWR1c1xuICBcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblxuICBcdC8vIHNlbGYtY2xvc2luZyBzb2xpZHVzP1xuICBcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnLycgKSApIHtcbiAgXHRcdHNlbGZDbG9zaW5nID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHQvLyBjbG9zaW5nIGFuZ2xlIGJyYWNrZXRcbiAgXHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc+JyApICkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0dmFyIGxvd2VyQ2FzZU5hbWUgPSBlbGVtZW50LmUudG9Mb3dlckNhc2UoKTtcbiAgXHR2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gcGFyc2VyLnByZXNlcnZlV2hpdGVzcGFjZTtcblxuICBcdGlmICggIXNlbGZDbG9zaW5nICYmICF2b2lkRWxlbWVudE5hbWVzLnRlc3QoIGVsZW1lbnQuZSApICkge1xuICBcdFx0cGFyc2VyLmVsZW1lbnRTdGFjay5wdXNoKCBsb3dlckNhc2VOYW1lICk7XG5cbiAgXHRcdC8vIFNwZWNpYWwgY2FzZSAtIGlmIHdlIG9wZW4gYSBzY3JpcHQgZWxlbWVudCwgZnVydGhlciB0YWdzIHNob3VsZFxuICBcdFx0Ly8gYmUgaWdub3JlZCB1bmxlc3MgdGhleSdyZSBhIGNsb3Npbmcgc2NyaXB0IGVsZW1lbnRcbiAgXHRcdGlmICggbG93ZXJDYXNlTmFtZSA9PT0gJ3NjcmlwdCcgfHwgbG93ZXJDYXNlTmFtZSA9PT0gJ3N0eWxlJyB8fCBsb3dlckNhc2VOYW1lID09PSAndGV4dGFyZWEnICkge1xuICBcdFx0XHRwYXJzZXIuaW5zaWRlID0gbG93ZXJDYXNlTmFtZTtcbiAgXHRcdH1cblxuICBcdFx0Y2hpbGRyZW4gPSBbXTtcbiAgXHRcdHBhcnRpYWxzID0gY3JlYXRlKCBudWxsICk7XG5cbiAgXHRcdGRvIHtcbiAgXHRcdFx0cG9zID0gcGFyc2VyLnBvcztcbiAgXHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXG4gIFx0XHRcdGlmICggIXJlbWFpbmluZyApIHtcbiAgXHRcdFx0XHRwYXJzZXIuZXJyb3IoIChcIk1pc3NpbmcgZW5kIFwiICsgKHBhcnNlci5lbGVtZW50U3RhY2subGVuZ3RoID4gMSA/ICd0YWdzJyA6ICd0YWcnKSArIFwiIChcIiArIChwYXJzZXIuZWxlbWVudFN0YWNrLnJldmVyc2UoKS5tYXAoIGZ1bmN0aW9uICggeCApIHsgcmV0dXJuIChcIjwvXCIgKyB4ICsgXCI+XCIpOyB9ICkuam9pbiggJycgKSkgKyBcIilcIikgKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGlmIGZvciBleGFtcGxlIHdlJ3JlIGluIGFuIDxsaT4gZWxlbWVudCwgYW5kIHdlIHNlZSBhbm90aGVyXG4gIFx0XHRcdC8vIDxsaT4gdGFnLCBjbG9zZSB0aGUgZmlyc3Qgc28gdGhleSBiZWNvbWUgc2libGluZ3NcbiAgXHRcdFx0aWYgKCAhY2FuQ29udGFpbiggbG93ZXJDYXNlTmFtZSwgcmVtYWluaW5nICkgKSB7XG4gIFx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGNsb3NpbmcgdGFnXG4gIFx0XHRcdGVsc2UgaWYgKCBjbG9zaW5nVGFnID0gcmVhZENsb3NpbmdUYWcoIHBhcnNlciApICkge1xuICBcdFx0XHRcdGNsb3NlZCA9IHRydWU7XG5cbiAgXHRcdFx0XHR2YXIgY2xvc2luZ1RhZ05hbWUgPSBjbG9zaW5nVGFnLmUudG9Mb3dlckNhc2UoKTtcblxuICBcdFx0XHRcdC8vIGlmIHRoaXMgKmlzbid0KiB0aGUgY2xvc2luZyB0YWcgZm9yIHRoZSBjdXJyZW50IGVsZW1lbnQuLi5cbiAgXHRcdFx0XHRpZiAoIGNsb3NpbmdUYWdOYW1lICE9PSBsb3dlckNhc2VOYW1lICkge1xuICBcdFx0XHRcdFx0Ly8gcmV3aW5kIHBhcnNlclxuICBcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcblxuICBcdFx0XHRcdFx0Ly8gaWYgaXQgZG9lc24ndCBjbG9zZSBhIHBhcmVudCB0YWcsIGVycm9yXG4gIFx0XHRcdFx0XHRpZiAoICF+cGFyc2VyLmVsZW1lbnRTdGFjay5pbmRleE9mKCBjbG9zaW5nVGFnTmFtZSApICkge1xuICBcdFx0XHRcdFx0XHR2YXIgZXJyb3JNZXNzYWdlID0gJ1VuZXhwZWN0ZWQgY2xvc2luZyB0YWcnO1xuXG4gIFx0XHRcdFx0XHRcdC8vIGFkZCBhZGRpdGlvbmFsIGhlbHAgZm9yIHZvaWQgZWxlbWVudHMsIHNpbmNlIGNvbXBvbmVudCBuYW1lc1xuICBcdFx0XHRcdFx0XHQvLyBtaWdodCBjbGFzaCB3aXRoIHRoZW1cbiAgXHRcdFx0XHRcdFx0aWYgKCB2b2lkRWxlbWVudE5hbWVzLnRlc3QoIGNsb3NpbmdUYWdOYW1lICkgKSB7XG4gIFx0XHRcdFx0XHRcdFx0ZXJyb3JNZXNzYWdlICs9IFwiICg8XCIgKyBjbG9zaW5nVGFnTmFtZSArIFwiPiBpcyBhIHZvaWQgZWxlbWVudCAtIGl0IGNhbm5vdCBjb250YWluIGNoaWxkcmVuKVwiO1xuICBcdFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvck1lc3NhZ2UgKTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHQvLyBpbXBsaWNpdCBjbG9zZSBieSBjbG9zaW5nIHNlY3Rpb24gdGFnLiBUT0RPIGNsZWFuIHRoaXMgdXBcbiAgXHRcdFx0ZWxzZSBpZiAoIGNoaWxkID0gcmVhZENsb3NpbmcoIHBhcnNlciwgeyBvcGVuOiBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzBdLCBjbG9zZTogcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1sxXSB9ICkgKSB7XG4gIFx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHRwYXJzZXIucG9zID0gcG9zO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0ZWxzZSB7XG4gIFx0XHRcdFx0aWYgKCBjaGlsZCA9IHBhcnNlci5yZWFkKCBQQVJUSUFMX1JFQURFUlMgKSApIHtcbiAgXHRcdFx0XHRcdGlmICggcGFydGlhbHNbIGNoaWxkLm4gXSApIHtcbiAgXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcbiAgXHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRHVwbGljYXRlIHBhcnRpYWwgZGVmaW5pdGlvbicgKTtcbiAgXHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0Y2xlYW51cCggY2hpbGQuZiwgcGFyc2VyLnN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgIXByZXNlcnZlV2hpdGVzcGFjZSwgIXByZXNlcnZlV2hpdGVzcGFjZSApO1xuXG4gIFx0XHRcdFx0XHRwYXJ0aWFsc1sgY2hpbGQubiBdID0gY2hpbGQuZjtcbiAgXHRcdFx0XHRcdGhhc1BhcnRpYWxzID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRlbHNlIHtcbiAgXHRcdFx0XHRcdGlmICggY2hpbGQgPSBwYXJzZXIucmVhZCggUkVBREVSUyApICkge1xuICBcdFx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKCBjaGlsZCApO1xuICBcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0Y2xvc2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH0gd2hpbGUgKCAhY2xvc2VkICk7XG5cbiAgXHRcdGlmICggY2hpbGRyZW4ubGVuZ3RoICkge1xuICBcdFx0XHRlbGVtZW50LmYgPSBjaGlsZHJlbjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCBoYXNQYXJ0aWFscyApIHtcbiAgXHRcdFx0ZWxlbWVudC5wID0gcGFydGlhbHM7XG4gIFx0XHR9XG5cbiAgXHRcdHBhcnNlci5lbGVtZW50U3RhY2sucG9wKCk7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmluc2lkZSA9IG51bGw7XG5cbiAgXHRpZiAoIHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzICYmIHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzLmluZGV4T2YoIGxvd2VyQ2FzZU5hbWUgKSAhPT0gLTEgKSB7XG4gIFx0XHRyZXR1cm4gZXhjbHVkZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkNvbnRhaW4gKCBuYW1lLCByZW1haW5pbmcgKSB7XG4gIFx0dmFyIG1hdGNoLCBkaXNhbGxvd2VkO1xuXG4gIFx0bWF0Y2ggPSAvXjwoW2EtekEtWl1bYS16QS1aMC05XSopLy5leGVjKCByZW1haW5pbmcgKTtcbiAgXHRkaXNhbGxvd2VkID0gZGlzYWxsb3dlZENvbnRlbnRzWyBuYW1lIF07XG5cbiAgXHRpZiAoICFtYXRjaCB8fCAhZGlzYWxsb3dlZCApIHtcbiAgXHRcdHJldHVybiB0cnVlO1xuICBcdH1cblxuICBcdHJldHVybiAhfmRpc2FsbG93ZWQuaW5kZXhPZiggbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRleHQgKCBwYXJzZXIgKSB7XG4gIFx0dmFyIGluZGV4LCByZW1haW5pbmcsIGRpc2FsbG93ZWQsIGJhcnJpZXI7XG5cbiAgXHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cbiAgXHRpZiAoIHBhcnNlci50ZXh0T25seU1vZGUgKSB7XG4gIFx0XHRkaXNhbGxvd2VkID0gcGFyc2VyLnRhZ3MubWFwKCBmdW5jdGlvbiAoIHQgKSB7IHJldHVybiB0Lm9wZW47IH0gKTtcbiAgXHRcdGRpc2FsbG93ZWQgPSBkaXNhbGxvd2VkLmNvbmNhdCggcGFyc2VyLnRhZ3MubWFwKCBmdW5jdGlvbiAoIHQgKSB7IHJldHVybiAnXFxcXCcgKyB0Lm9wZW47IH0gKSApO1xuXG4gIFx0XHRpbmRleCA9IGdldExvd2VzdEluZGV4KCByZW1haW5pbmcsIGRpc2FsbG93ZWQgKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0YmFycmllciA9IHBhcnNlci5pbnNpZGUgPyAnPC8nICsgcGFyc2VyLmluc2lkZSA6ICc8JztcblxuICBcdFx0aWYgKCBwYXJzZXIuaW5zaWRlICYmICFwYXJzZXIuaW50ZXJwb2xhdGVbIHBhcnNlci5pbnNpZGUgXSApIHtcbiAgXHRcdFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZiggYmFycmllciApO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0ZGlzYWxsb3dlZCA9IHBhcnNlci50YWdzLm1hcCggZnVuY3Rpb24gKCB0ICkgeyByZXR1cm4gdC5vcGVuOyB9ICk7XG4gIFx0XHRcdGRpc2FsbG93ZWQgPSBkaXNhbGxvd2VkLmNvbmNhdCggcGFyc2VyLnRhZ3MubWFwKCBmdW5jdGlvbiAoIHQgKSB7IHJldHVybiAnXFxcXCcgKyB0Lm9wZW47IH0gKSApO1xuXG4gIFx0XHRcdC8vIGh0dHA6Ly9kZXZlbG9wZXJzLndoYXR3Zy5vcmcvc3ludGF4Lmh0bWwjc3ludGF4LWF0dHJpYnV0ZXNcbiAgXHRcdFx0aWYgKCBwYXJzZXIuaW5BdHRyaWJ1dGUgPT09IHRydWUgKSB7XG4gIFx0XHRcdFx0Ly8gd2UncmUgaW5zaWRlIGFuIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZVxuICBcdFx0XHRcdGRpc2FsbG93ZWQucHVzaCggKFwiXFxcIlwiKSwgKFwiJ1wiKSwgKFwiPVwiKSwgKFwiPFwiKSwgKFwiPlwiKSwgJ2AnICk7XG4gIFx0XHRcdH0gZWxzZSBpZiAoIHBhcnNlci5pbkF0dHJpYnV0ZSApIHtcbiAgXHRcdFx0XHQvLyBxdW90ZWQgYXR0cmlidXRlIHZhbHVlXG4gIFx0XHRcdFx0ZGlzYWxsb3dlZC5wdXNoKCBwYXJzZXIuaW5BdHRyaWJ1dGUgKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRkaXNhbGxvd2VkLnB1c2goIGJhcnJpZXIgKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgoIHJlbWFpbmluZywgZGlzYWxsb3dlZCApO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICggIWluZGV4ICkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG4gIFx0XHRpbmRleCA9IHJlbWFpbmluZy5sZW5ndGg7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblxuICBcdGlmICggKCBwYXJzZXIuaW5zaWRlICYmIHBhcnNlci5pbnNpZGUgIT09ICd0ZXh0YXJlYScgKSB8fCBwYXJzZXIudGV4dE9ubHlNb2RlICkge1xuICBcdFx0cmV0dXJuIHJlbWFpbmluZy5zdWJzdHIoIDAsIGluZGV4ICk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHJldHVybiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKCByZW1haW5pbmcuc3Vic3RyKCAwLCBpbmRleCApICk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIHN0YXJ0UGF0dGVybiA9IC9ePCEtLVxccyovO1xuICB2YXIgbmFtZVBhdHRlcm4kMSA9IC9zKj5cXHMqKFthLXpBLVpfJF1bLWEtekEtWl8kMC05XSopXFxzKi87XG4gIHZhciBmaW5pc2hQYXR0ZXJuID0gL1xccyotLT4vO1xuXG4gIGZ1bmN0aW9uIHJlYWRQYXJ0aWFsRGVmaW5pdGlvbkNvbW1lbnQgKCBwYXJzZXIgKSB7XG4gIFx0dmFyIHN0YXJ0ID0gcGFyc2VyLnBvcztcbiAgXHR2YXIgb3BlbiA9IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMF07XG4gIFx0dmFyIGNsb3NlID0gcGFyc2VyLnN0YW5kYXJkRGVsaW1pdGVyc1sxXTtcblxuICBcdGlmICggIXBhcnNlci5tYXRjaFBhdHRlcm4oIHN0YXJ0UGF0dGVybiApIHx8ICFwYXJzZXIubWF0Y2hTdHJpbmcoIG9wZW4gKSApIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdHZhciBuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybiggbmFtZVBhdHRlcm4kMSApO1xuXG4gIFx0d2Fybk9uY2VJZkRlYnVnKCAoXCJJbmxpbmUgcGFydGlhbCBjb21tZW50cyBhcmUgZGVwcmVjYXRlZC5cXG5Vc2UgdGhpcy4uLlxcbiAge3sjcGFydGlhbCBcIiArIG5hbWUgKyBcIn19IC4uLiB7ey9wYXJ0aWFsfX1cXG5cXG4uLi5pbnN0ZWFkIG9mIHRoaXM6XFxuICA8IS0tIHt7PlwiICsgbmFtZSArIFwifX0gLS0+IC4uLiA8IS0tIHt7L1wiICsgbmFtZSArIFwifX0gLS0+J1wiKSApO1xuXG4gIFx0Ly8gbWFrZSBzdXJlIHRoZSByZXN0IG9mIHRoZSBjb21tZW50IGlzIGluIHRoZSBjb3JyZWN0IHBsYWNlXG4gIFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBjbG9zZSApIHx8ICFwYXJzZXIubWF0Y2hQYXR0ZXJuKCBmaW5pc2hQYXR0ZXJuICkgKSB7XG4gIFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHR2YXIgY29udGVudCA9IFtdO1xuICBcdHZhciBjbG9zZWQ7XG5cbiAgXHR2YXIgZW5kUGF0dGVybiA9IG5ldyBSZWdFeHAoJ148IS0tXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCggb3BlbiApICsgJ1xcXFxzKlxcXFwvXFxcXHMqJyArIG5hbWUgKyAnXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCggY2xvc2UgKSArICdcXFxccyotLT4nKTtcblxuICBcdGRvIHtcbiAgXHRcdGlmICggcGFyc2VyLm1hdGNoUGF0dGVybiggZW5kUGF0dGVybiApICkge1xuICBcdFx0XHRjbG9zZWQgPSB0cnVlO1xuICBcdFx0fVxuXG4gIFx0XHRlbHNlIHtcbiAgXHRcdFx0dmFyIGNoaWxkID0gcGFyc2VyLnJlYWQoIFJFQURFUlMgKTtcbiAgXHRcdFx0aWYgKCAhY2hpbGQgKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKCAoXCJleHBlY3RlZCBjbG9zaW5nIGNvbW1lbnQgKCc8IS0tIFwiICsgb3BlbiArIFwiL1wiICsgbmFtZSArIFwiXCIgKyBjbG9zZSArIFwiIC0tPicpXCIpICk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjb250ZW50LnB1c2goIGNoaWxkICk7XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoICFjbG9zZWQgKTtcblxuICBcdHJldHVybiB7XG4gIFx0XHR0OiBJTkxJTkVfUEFSVElBTCxcbiAgXHRcdGY6IGNvbnRlbnQsXG4gIFx0XHRuOiBuYW1lXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBwYXJ0aWFsRGVmaW5pdGlvblNlY3Rpb25QYXR0ZXJuID0gL15cXHMqI1xccypwYXJ0aWFsXFxzKy87XG5cbiAgZnVuY3Rpb24gcmVhZFBhcnRpYWxEZWZpbml0aW9uU2VjdGlvbiAoIHBhcnNlciApIHtcbiAgXHR2YXIgc3RhcnQsIG5hbWUsIGNvbnRlbnQsIGNoaWxkLCBjbG9zZWQ7XG5cbiAgXHRzdGFydCA9IHBhcnNlci5wb3M7XG5cbiAgXHR2YXIgZGVsaW1pdGVycyA9IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnM7XG5cbiAgXHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIGRlbGltaXRlcnNbMF0gKSApIHtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdGlmICggIXBhcnNlci5tYXRjaFBhdHRlcm4oIHBhcnRpYWxEZWZpbml0aW9uU2VjdGlvblBhdHRlcm4gKSApIHtcbiAgXHRcdHBhcnNlci5wb3MgPSBzdGFydDtcbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH1cblxuICBcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCAvXlthLXpBLVpfJF1bYS16QS1aXyQwLTlcXC1cXC9dKi8gKTtcblxuICBcdGlmICggIW5hbWUgKSB7XG4gIFx0XHRwYXJzZXIuZXJyb3IoICdleHBlY3RlZCBsZWdhbCBwYXJ0aWFsIG5hbWUnICk7XG4gIFx0fVxuXG4gIFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICBcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggZGVsaW1pdGVyc1sxXSApICkge1xuICBcdFx0cGFyc2VyLmVycm9yKCAoXCJFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciAnXCIgKyAoZGVsaW1pdGVyc1sxXSkgKyBcIidcIikgKTtcbiAgXHR9XG5cbiAgXHRjb250ZW50ID0gW107XG5cbiAgXHRkbyB7XG4gIFx0XHQvLyBUT0RPIGNsZWFuIHRoaXMgdXBcbiAgXHRcdGlmICggY2hpbGQgPSByZWFkQ2xvc2luZyggcGFyc2VyLCB7IG9wZW46IHBhcnNlci5zdGFuZGFyZERlbGltaXRlcnNbMF0sIGNsb3NlOiBwYXJzZXIuc3RhbmRhcmREZWxpbWl0ZXJzWzFdIH0pICkge1xuICBcdFx0XHRpZiAoICFjaGlsZC5yID09PSAncGFydGlhbCcgKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKCAoXCJFeHBlY3RlZCBcIiArIChkZWxpbWl0ZXJzWzBdKSArIFwiL3BhcnRpYWxcIiArIChkZWxpbWl0ZXJzWzFdKSkgKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNsb3NlZCA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdGVsc2Uge1xuICBcdFx0XHRjaGlsZCA9IHBhcnNlci5yZWFkKCBSRUFERVJTICk7XG5cbiAgXHRcdFx0aWYgKCAhY2hpbGQgKSB7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKCAoXCJFeHBlY3RlZCBcIiArIChkZWxpbWl0ZXJzWzBdKSArIFwiL3BhcnRpYWxcIiArIChkZWxpbWl0ZXJzWzFdKSkgKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGNvbnRlbnQucHVzaCggY2hpbGQgKTtcbiAgXHRcdH1cbiAgXHR9IHdoaWxlICggIWNsb3NlZCApO1xuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdHQ6IElOTElORV9QQVJUSUFMLFxuICBcdFx0bjogbmFtZSxcbiAgXHRcdGY6IGNvbnRlbnRcbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRlbXBsYXRlICggcGFyc2VyICkge1xuICBcdHZhciBmcmFnbWVudCA9IFtdO1xuICBcdHZhciBwYXJ0aWFscyA9IGNyZWF0ZSggbnVsbCApO1xuICBcdHZhciBoYXNQYXJ0aWFscyA9IGZhbHNlO1xuXG4gIFx0dmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IHBhcnNlci5wcmVzZXJ2ZVdoaXRlc3BhY2U7XG5cbiAgXHR3aGlsZSAoIHBhcnNlci5wb3MgPCBwYXJzZXIuc3RyLmxlbmd0aCApIHtcbiAgXHRcdHZhciBwb3MgPSBwYXJzZXIucG9zLCBpdGVtLCBwYXJ0aWFsO1xuXG4gIFx0XHRpZiAoIHBhcnRpYWwgPSBwYXJzZXIucmVhZCggUEFSVElBTF9SRUFERVJTICkgKSB7XG4gIFx0XHRcdGlmICggcGFydGlhbHNbIHBhcnRpYWwubiBdICkge1xuICBcdFx0XHRcdHBhcnNlci5wb3MgPSBwb3M7XG4gIFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRHVwbGljYXRlZCBwYXJ0aWFsIGRlZmluaXRpb24nICk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRjbGVhbnVwKCBwYXJ0aWFsLmYsIHBhcnNlci5zdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsICFwcmVzZXJ2ZVdoaXRlc3BhY2UsICFwcmVzZXJ2ZVdoaXRlc3BhY2UgKTtcblxuICBcdFx0XHRwYXJ0aWFsc1sgcGFydGlhbC5uIF0gPSBwYXJ0aWFsLmY7XG4gIFx0XHRcdGhhc1BhcnRpYWxzID0gdHJ1ZTtcbiAgXHRcdH0gZWxzZSBpZiAoIGl0ZW0gPSBwYXJzZXIucmVhZCggUkVBREVSUyApICkge1xuICBcdFx0XHRmcmFnbWVudC5wdXNoKCBpdGVtICk7XG4gIFx0XHR9IGVsc2UgIHtcbiAgXHRcdFx0cGFyc2VyLmVycm9yKCAnVW5leHBlY3RlZCB0ZW1wbGF0ZSBjb250ZW50JyApO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHZhciByZXN1bHQgPSB7XG4gIFx0XHR2OiBURU1QTEFURV9WRVJTSU9OLFxuICBcdFx0dDogZnJhZ21lbnRcbiAgXHR9O1xuXG4gIFx0aWYgKCBoYXNQYXJ0aWFscyApIHtcbiAgXHRcdHJlc3VsdC5wID0gcGFydGlhbHM7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydEV4cHJlc3Npb25zICggb2JqLCBleHByICkge1xuXG4gIFx0T2JqZWN0LmtleXMoIG9iaiApLmZvckVhY2goIGZ1bmN0aW9uICgga2V5ICkge1xuICBcdFx0aWYgICggaXNFeHByZXNzaW9uKCBrZXksIG9iaiApICkgcmV0dXJuIGFkZFRvKCBvYmosIGV4cHIgKTtcblxuICBcdFx0dmFyIHJlZiA9IG9ialsga2V5IF07XG4gIFx0XHRpZiAoIGhhc0NoaWxkcmVuKCByZWYgKSApIGluc2VydEV4cHJlc3Npb25zKCByZWYsIGV4cHIgKTtcbiAgIFx0fSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0V4cHJlc3Npb24oIGtleSwgb2JqICkge1xuICBcdHJldHVybiBrZXkgPT09ICdzJyAmJiBpc0FycmF5KCBvYmouciApO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkVG8oIG9iaiwgZXhwciApIHtcbiAgXHR2YXIgcyA9IG9iai5zLCByID0gb2JqLnI7XG4gIFx0aWYgKCAhZXhwclsgcyBdICkgZXhwclsgcyBdID0gZnJvbUV4cHJlc3Npb24oIHMsIHIubGVuZ3RoICk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNDaGlsZHJlbiggcmVmICkge1xuICBcdHJldHVybiBpc0FycmF5KCByZWYgKSB8fCBpc09iamVjdCggcmVmICk7XG4gIH1cblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy90ZW1wbGF0ZS1zcGVjIGZvciBpbmZvcm1hdGlvblxuICAvLyBhYm91dCB0aGUgUmFjdGl2ZSB0ZW1wbGF0ZSBzcGVjaWZpY2F0aW9uXG5cbiAgdmFyIFNUQU5EQVJEX1JFQURFUlMgPSBbIHJlYWRQYXJ0aWFsLCByZWFkVW5lc2NhcGVkLCByZWFkU2VjdGlvbiwgcmVhZFlpZWxkZXIsIHJlYWRJbnRlcnBvbGF0b3IsIHJlYWRDb21tZW50IF07XG4gIHZhciBUUklQTEVfUkVBREVSUyA9IFsgcmVhZFRyaXBsZSBdO1xuICB2YXIgU1RBVElDX1JFQURFUlMgPSBbIHJlYWRVbmVzY2FwZWQsIHJlYWRTZWN0aW9uLCByZWFkSW50ZXJwb2xhdG9yIF07IC8vIFRPRE8gZG9lcyBpdCBtYWtlIHNlbnNlIHRvIGhhdmUgYSBzdGF0aWMgc2VjdGlvbj9cblxuICB2YXIgU3RhbmRhcmRQYXJzZXI7XG5cbiAgZnVuY3Rpb24gcGFyc2UgKCB0ZW1wbGF0ZSwgb3B0aW9ucyApIHtcbiAgXHRyZXR1cm4gbmV3IFN0YW5kYXJkUGFyc2VyKCB0ZW1wbGF0ZSwgb3B0aW9ucyB8fCB7fSApLnJlc3VsdDtcbiAgfVxuXG4gIHBhcnNlLmNvbXB1dGVkU3RyaW5ncyA9IGZ1bmN0aW9uKCBjb21wdXRlZCApIHtcbiAgXHRpZiAoICFjb21wdXRlZCApIHJldHVybiBbXTtcblxuICBcdE9iamVjdC5rZXlzKCBjb21wdXRlZCApLmZvckVhY2goIGZ1bmN0aW9uICgga2V5ICkge1xuICBcdFx0dmFyIHZhbHVlID0gY29tcHV0ZWRbIGtleSBdO1xuICBcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICkge1xuICBcdFx0XHRjb21wdXRlZFsga2V5IF0gPSBmcm9tQ29tcHV0YXRpb25TdHJpbmcoIHZhbHVlICk7XG4gIFx0XHR9XG4gIFx0fSk7XG4gIH07XG5cblxuICB2YXIgUkVBREVSUyA9IFsgcmVhZE11c3RhY2hlLCByZWFkSHRtbENvbW1lbnQsIHJlYWRFbGVtZW50LCByZWFkVGV4dCBdO1xuICB2YXIgUEFSVElBTF9SRUFERVJTID0gWyByZWFkUGFydGlhbERlZmluaXRpb25Db21tZW50LCByZWFkUGFydGlhbERlZmluaXRpb25TZWN0aW9uIF07XG5cbiAgU3RhbmRhcmRQYXJzZXIgPSBQYXJzZXIkMS5leHRlbmQoe1xuICBcdGluaXQ6IGZ1bmN0aW9uICggc3RyLCBvcHRpb25zICkge1xuICBcdFx0dmFyIHRyaXBsZURlbGltaXRlcnMgPSBvcHRpb25zLnRyaXBsZURlbGltaXRlcnMgfHwgWyAne3t7JywgJ319fScgXSxcbiAgXHRcdFx0c3RhdGljRGVsaW1pdGVycyA9IG9wdGlvbnMuc3RhdGljRGVsaW1pdGVycyB8fCBbICdbWycsICddXScgXSxcbiAgXHRcdFx0c3RhdGljVHJpcGxlRGVsaW1pdGVycyA9IG9wdGlvbnMuc3RhdGljVHJpcGxlRGVsaW1pdGVycyB8fCBbICdbW1snLCAnXV1dJyBdO1xuXG4gIFx0XHR0aGlzLnN0YW5kYXJkRGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycyB8fCBbICd7eycsICd9fScgXTtcblxuICBcdFx0dGhpcy50YWdzID0gW1xuICBcdFx0XHR7IGlzU3RhdGljOiBmYWxzZSwgaXNUcmlwbGU6IGZhbHNlLCBvcGVuOiB0aGlzLnN0YW5kYXJkRGVsaW1pdGVyc1swXSwgY2xvc2U6IHRoaXMuc3RhbmRhcmREZWxpbWl0ZXJzWzFdLCByZWFkZXJzOiBTVEFOREFSRF9SRUFERVJTIH0sXG4gIFx0XHRcdHsgaXNTdGF0aWM6IGZhbHNlLCBpc1RyaXBsZTogdHJ1ZSwgIG9wZW46IHRyaXBsZURlbGltaXRlcnNbMF0sICAgICAgICBjbG9zZTogdHJpcGxlRGVsaW1pdGVyc1sxXSwgICAgICAgIHJlYWRlcnM6IFRSSVBMRV9SRUFERVJTIH0sXG4gIFx0XHRcdHsgaXNTdGF0aWM6IHRydWUsICBpc1RyaXBsZTogZmFsc2UsIG9wZW46IHN0YXRpY0RlbGltaXRlcnNbMF0sICAgICAgICBjbG9zZTogc3RhdGljRGVsaW1pdGVyc1sxXSwgICAgICAgIHJlYWRlcnM6IFNUQVRJQ19SRUFERVJTIH0sXG4gIFx0XHRcdHsgaXNTdGF0aWM6IHRydWUsICBpc1RyaXBsZTogdHJ1ZSwgIG9wZW46IHN0YXRpY1RyaXBsZURlbGltaXRlcnNbMF0sICBjbG9zZTogc3RhdGljVHJpcGxlRGVsaW1pdGVyc1sxXSwgIHJlYWRlcnM6IFRSSVBMRV9SRUFERVJTIH1cbiAgXHRcdF07XG5cbiAgXHRcdHRoaXMuY29udGV4dExpbmVzID0gb3B0aW9ucy5jb250ZXh0TGluZXMgfHwgMDtcblxuICBcdFx0dGhpcy5zb3J0TXVzdGFjaGVUYWdzKCk7XG5cbiAgXHRcdHRoaXMuc2VjdGlvbkRlcHRoID0gMDtcbiAgXHRcdHRoaXMuZWxlbWVudFN0YWNrID0gW107XG5cbiAgXHRcdHRoaXMuaW50ZXJwb2xhdGUgPSB7XG4gIFx0XHRcdHNjcmlwdDogIW9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgb3B0aW9ucy5pbnRlcnBvbGF0ZS5zY3JpcHQgIT09IGZhbHNlLFxuICBcdFx0XHRzdHlsZTogIW9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgb3B0aW9ucy5pbnRlcnBvbGF0ZS5zdHlsZSAhPT0gZmFsc2UsXG4gIFx0XHRcdHRleHRhcmVhOiB0cnVlXG4gIFx0XHR9O1xuXG4gIFx0XHRpZiAoIG9wdGlvbnMuc2FuaXRpemUgPT09IHRydWUgKSB7XG4gIFx0XHRcdG9wdGlvbnMuc2FuaXRpemUgPSB7XG4gIFx0XHRcdFx0Ly8gYmxhY2tsaXN0IGZyb20gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtY2FqYS9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2NhamEvbGFuZy9odG1sL2h0bWw0LWVsZW1lbnRzLXdoaXRlbGlzdC5qc29uXG4gIFx0XHRcdFx0ZWxlbWVudHM6ICdhcHBsZXQgYmFzZSBiYXNlZm9udCBib2R5IGZyYW1lIGZyYW1lc2V0IGhlYWQgaHRtbCBpc2luZGV4IGxpbmsgbWV0YSBub2ZyYW1lcyBub3NjcmlwdCBvYmplY3QgcGFyYW0gc2NyaXB0IHN0eWxlIHRpdGxlJy5zcGxpdCggJyAnICksXG4gIFx0XHRcdFx0ZXZlbnRBdHRyaWJ1dGVzOiB0cnVlXG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuc3RyaXBDb21tZW50cyA9IG9wdGlvbnMuc3RyaXBDb21tZW50cyAhPT0gZmFsc2U7XG4gIFx0XHR0aGlzLnByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlO1xuICBcdFx0dGhpcy5zYW5pdGl6ZUVsZW1lbnRzID0gb3B0aW9ucy5zYW5pdGl6ZSAmJiBvcHRpb25zLnNhbml0aXplLmVsZW1lbnRzO1xuICBcdFx0dGhpcy5zYW5pdGl6ZUV2ZW50QXR0cmlidXRlcyA9IG9wdGlvbnMuc2FuaXRpemUgJiYgb3B0aW9ucy5zYW5pdGl6ZS5ldmVudEF0dHJpYnV0ZXM7XG4gIFx0XHR0aGlzLmluY2x1ZGVMaW5lUG9zaXRpb25zID0gb3B0aW9ucy5pbmNsdWRlTGluZVBvc2l0aW9ucztcbiAgXHRcdHRoaXMudGV4dE9ubHlNb2RlID0gb3B0aW9ucy50ZXh0T25seU1vZGU7XG4gIFx0XHR0aGlzLmNzcCA9IG9wdGlvbnMuY3NwO1xuICBcdH0sXG5cbiAgXHRwb3N0UHJvY2VzczogZnVuY3Rpb24gKCByZXN1bHQgKSB7XG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBlbXB0eSBzdHJpbmdcbiAgXHRcdGlmICggIXJlc3VsdC5sZW5ndGggKSB7XG4gIFx0XHRcdHJldHVybiB7IHQ6IFtdLCB2OiBURU1QTEFURV9WRVJTSU9OIH07XG4gIFx0XHR9XG5cbiAgXHRcdGlmICggdGhpcy5zZWN0aW9uRGVwdGggPiAwICkge1xuICBcdFx0XHR0aGlzLmVycm9yKCAnQSBzZWN0aW9uIHdhcyBsZWZ0IG9wZW4nICk7XG4gIFx0XHR9XG5cbiAgXHRcdGNsZWFudXAoIHJlc3VsdFswXS50LCB0aGlzLnN0cmlwQ29tbWVudHMsIHRoaXMucHJlc2VydmVXaGl0ZXNwYWNlLCAhdGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2UsICF0aGlzLnByZXNlcnZlV2hpdGVzcGFjZSApO1xuXG4gIFx0XHRpZiAoIHRoaXMuY3NwICE9PSBmYWxzZSApIHtcbiAgXHRcdFx0dmFyIGV4cHIgPSB7fTtcbiAgXHRcdFx0aW5zZXJ0RXhwcmVzc2lvbnMoIHJlc3VsdFswXS50LCBleHByICk7XG4gIFx0XHRcdGlmICggT2JqZWN0LmtleXMoIGV4cHIgKS5sZW5ndGggKSByZXN1bHRbMF0uZSA9IGV4cHI7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiByZXN1bHRbMF07XG4gIFx0fSxcblxuICBcdGNvbnZlcnRlcnM6IFtcbiAgXHRcdHJlYWRUZW1wbGF0ZVxuICBcdF0sXG5cbiAgXHRzb3J0TXVzdGFjaGVUYWdzOiBmdW5jdGlvbiAoKSB7XG4gIFx0XHQvLyBTb3J0IGluIG9yZGVyIG9mIGRlc2NlbmRpbmcgb3BlbmluZyBkZWxpbWl0ZXIgbGVuZ3RoIChsb25nZXIgZmlyc3QpLFxuICBcdFx0Ly8gdG8gcHJvdGVjdCBhZ2FpbnN0IG9wZW5pbmcgZGVsaW1pdGVycyBiZWluZyBzdWJzdHJpbmdzIG9mIGVhY2ggb3RoZXJcbiAgXHRcdHRoaXMudGFncy5zb3J0KCBmdW5jdGlvbiAoIGEsIGIgKSB7XG4gIFx0XHRcdHJldHVybiBiLm9wZW4ubGVuZ3RoIC0gYS5vcGVuLmxlbmd0aDtcbiAgXHRcdH0pO1xuICBcdH1cbiAgfSk7XG5cbiAgdmFyIHBhcnNlT3B0aW9ucyA9IFtcbiAgXHQnZGVsaW1pdGVycycsXG4gIFx0J3RyaXBsZURlbGltaXRlcnMnLFxuICBcdCdzdGF0aWNEZWxpbWl0ZXJzJyxcbiAgXHQnc3RhdGljVHJpcGxlRGVsaW1pdGVycycsXG4gIFx0J2NzcCcsXG4gIFx0J2ludGVycG9sYXRlJyxcbiAgXHQncHJlc2VydmVXaGl0ZXNwYWNlJyxcbiAgXHQnc2FuaXRpemUnLFxuICBcdCdzdHJpcENvbW1lbnRzJyxcbiAgXHQnY29udGV4dExpbmVzJ1xuICBdO1xuXG4gIHZhciBURU1QTEFURV9JTlNUUlVDVElPTlMgPSBcIkVpdGhlciBwcmVwYXJzZSBvciB1c2UgYSByYWN0aXZlIHJ1bnRpbWUgc291cmNlIHRoYXQgaW5jbHVkZXMgdGhlIHBhcnNlci4gXCI7XG5cbiAgdmFyIENPTVBVVEFUSU9OX0lOU1RSVUNUSU9OUyA9IFwiRWl0aGVyIHVzZTpcXG5cXG5cXHRSYWN0aXZlLnBhcnNlLmNvbXB1dGVkU3RyaW5ncyggY29tcG9uZW50LmNvbXB1dGVkIClcXG5cXG5hdCBidWlsZCB0aW1lIHRvIHByZS1jb252ZXJ0IHRoZSBzdHJpbmdzIHRvIGZ1bmN0aW9ucywgb3IgdXNlIGZ1bmN0aW9ucyBpbnN0ZWFkIG9mIHN0cmluZ3MgaW4gY29tcHV0ZWQgcHJvcGVydGllcy5cIjtcblxuXG4gIGZ1bmN0aW9uIHRocm93Tm9QYXJzZSAoIG1ldGhvZCwgZXJyb3IsIGluc3RydWN0aW9ucyApIHtcbiAgXHRpZiAoICFtZXRob2QgKSB7XG4gIFx0XHRmYXRhbCggKFwiTWlzc2luZyBSYWN0aXZlLnBhcnNlIC0gY2Fubm90IHBhcnNlIFwiICsgZXJyb3IgKyBcIi4gXCIgKyBpbnN0cnVjdGlvbnMpICk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKCBib2R5LCBsZW5ndGggKSB7XG4gIFx0dGhyb3dOb1BhcnNlKCBmcm9tRXhwcmVzc2lvbiwgJ25ldyBleHByZXNzaW9uIGZ1bmN0aW9uJywgVEVNUExBVEVfSU5TVFJVQ1RJT05TICk7XG4gIFx0cmV0dXJuIGZyb21FeHByZXNzaW9uKCBib2R5LCBsZW5ndGggKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uRnJvbVN0cmluZyAoIHN0ciwgYmluZFRvICkge1xuICBcdHRocm93Tm9QYXJzZSggZnJvbUNvbXB1dGF0aW9uU3RyaW5nLCAnY29tcHV0aW9uIHN0cmluZyBcIiR7c3RyfVwiJywgQ09NUFVUQVRJT05fSU5TVFJVQ1RJT05TICk7XG4gIFx0cmV0dXJuIGZyb21Db21wdXRhdGlvblN0cmluZyggc3RyLCBiaW5kVG8gKTtcbiAgfVxuXG4gIHZhciBwYXJzZXIgPSB7XG5cbiAgXHRmcm9tSWQ6IGZ1bmN0aW9uICggaWQsIG9wdGlvbnMgKSB7XG4gIFx0XHRpZiAoICFkb2MgKSB7XG4gIFx0XHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLm5vVGhyb3cgKSB7IHJldHVybjsgfVxuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIChcIkNhbm5vdCByZXRyaWV2ZSB0ZW1wbGF0ZSAjXCIgKyBpZCArIFwiIGFzIFJhY3RpdmUgaXMgbm90IHJ1bm5pbmcgaW4gYSBicm93c2VyLlwiKSApO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIGlkICkgaWQgPSBpZC5yZXBsYWNlKCAvXiMvLCAnJyApO1xuXG4gIFx0XHR2YXIgdGVtcGxhdGU7XG5cbiAgXHRcdGlmICggISggdGVtcGxhdGUgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoIGlkICkgKSkge1xuICBcdFx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93ICkgeyByZXR1cm47IH1cbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAoXCJDb3VsZCBub3QgZmluZCB0ZW1wbGF0ZSBlbGVtZW50IHdpdGggaWQgI1wiICsgaWQpICk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICggdGVtcGxhdGUudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnU0NSSVBUJyApIHtcbiAgXHRcdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMubm9UaHJvdyApIHsgcmV0dXJuOyB9XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvciggKFwiVGVtcGxhdGUgZWxlbWVudCB3aXRoIGlkICNcIiArIGlkICsgXCIsIG11c3QgYmUgYSA8c2NyaXB0PiBlbGVtZW50XCIpICk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiAoICd0ZXh0Q29udGVudCcgaW4gdGVtcGxhdGUgPyB0ZW1wbGF0ZS50ZXh0Q29udGVudCA6IHRlbXBsYXRlLmlubmVySFRNTCApO1xuXG4gIFx0fSxcblxuICBcdGlzUGFyc2VkOiBmdW5jdGlvbiAoIHRlbXBsYXRlKSB7XG4gIFx0XHRyZXR1cm4gISggdHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyApO1xuICBcdH0sXG5cbiAgXHRnZXRQYXJzZU9wdGlvbnM6IGZ1bmN0aW9uICggcmFjdGl2ZSApIHtcbiAgXHRcdC8vIENvdWxkIGJlIFJhY3RpdmUgb3IgYSBDb21wb25lbnRcbiAgXHRcdGlmICggcmFjdGl2ZS5kZWZhdWx0cyApIHsgcmFjdGl2ZSA9IHJhY3RpdmUuZGVmYXVsdHM7IH1cblxuICBcdFx0cmV0dXJuIHBhcnNlT3B0aW9ucy5yZWR1Y2UoIGZ1bmN0aW9uICggdmFsLCBrZXkgKSB7XG4gIFx0XHRcdHZhbFsga2V5IF0gPSByYWN0aXZlWyBrZXkgXTtcbiAgXHRcdFx0cmV0dXJuIHZhbDtcbiAgXHRcdH0sIHt9KTtcbiAgXHR9LFxuXG4gIFx0cGFyc2U6IGZ1bmN0aW9uICggdGVtcGxhdGUsIG9wdGlvbnMgKSB7XG4gIFx0XHR0aHJvd05vUGFyc2UoIHBhcnNlLCAndGVtcGxhdGUnLCBURU1QTEFURV9JTlNUUlVDVElPTlMgKTtcbiAgXHRcdHZhciBwYXJzZWQgPSBwYXJzZSggdGVtcGxhdGUsIG9wdGlvbnMgKTtcbiAgXHRcdGFkZEZ1bmN0aW9ucyggcGFyc2VkICk7XG4gIFx0XHRyZXR1cm4gcGFyc2VkO1xuICBcdH0sXG5cbiAgXHRwYXJzZUZvcjogZnVuY3Rpb24oIHRlbXBsYXRlLCByYWN0aXZlICkge1xuICBcdFx0cmV0dXJuIHRoaXMucGFyc2UoIHRlbXBsYXRlLCB0aGlzLmdldFBhcnNlT3B0aW9ucyggcmFjdGl2ZSApICk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciB0ZW1wbGF0ZUNvbmZpZ3VyYXRvciA9IHtcbiAgXHRuYW1lOiAndGVtcGxhdGUnLFxuXG4gIFx0ZXh0ZW5kOiBmdW5jdGlvbiAoIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKSB7XG4gIFx0XHQvLyBvbmx5IGFzc2lnbiBpZiBleGlzdHNcbiAgXHRcdGlmICggJ3RlbXBsYXRlJyBpbiBvcHRpb25zICkge1xuICBcdFx0XHR2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXG4gIFx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnZnVuY3Rpb24nICkge1xuICBcdFx0XHRcdHByb3RvLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0cHJvdG8udGVtcGxhdGUgPSBwYXJzZVRlbXBsYXRlKCB0ZW1wbGF0ZSwgcHJvdG8gKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRpbml0OiBmdW5jdGlvbiAoIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApIHtcbiAgXHRcdC8vIFRPRE8gYmVjYXVzZSBvZiBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB3ZSBtaWdodCBqdXN0IGJlIGFibGUgdG8gdXNlXG4gIFx0XHQvLyByYWN0aXZlLnRlbXBsYXRlLCBhbmQgbm90IGJvdGhlciBwYXNzaW5nIHRocm91Z2ggdGhlIFBhcmVudCBvYmplY3QuXG4gIFx0XHQvLyBBdCBwcmVzZW50IHRoYXQgYnJlYWtzIHRoZSB0ZXN0IG1vY2tzJyBleHBlY3RhdGlvbnNcbiAgXHRcdHZhciB0ZW1wbGF0ZSA9ICd0ZW1wbGF0ZScgaW4gb3B0aW9ucyA/IG9wdGlvbnMudGVtcGxhdGUgOiBQYXJlbnQucHJvdG90eXBlLnRlbXBsYXRlO1xuICBcdFx0dGVtcGxhdGUgPSB0ZW1wbGF0ZSB8fCB7IHY6IFRFTVBMQVRFX1ZFUlNJT04sIHQ6IFtdIH07XG5cbiAgXHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnZnVuY3Rpb24nICkge1xuICBcdFx0XHR2YXIgZm4gPSB0ZW1wbGF0ZTtcbiAgXHRcdFx0dGVtcGxhdGUgPSBnZXREeW5hbWljVGVtcGxhdGUoIHJhY3RpdmUsIGZuICk7XG5cbiAgXHRcdFx0cmFjdGl2ZS5fY29uZmlnLnRlbXBsYXRlID0ge1xuICBcdFx0XHRcdGZuOiBmbixcbiAgXHRcdFx0XHRyZXN1bHQ6IHRlbXBsYXRlXG4gIFx0XHRcdH07XG4gIFx0XHR9XG5cbiAgXHRcdHRlbXBsYXRlID0gcGFyc2VUZW1wbGF0ZSggdGVtcGxhdGUsIHJhY3RpdmUgKTtcblxuICBcdFx0Ly8gVE9ETyB0aGUgbmFtaW5nIG9mIHRoaXMgaXMgY29uZnVzaW5nIC0gcmFjdGl2ZS50ZW1wbGF0ZSByZWZlcnMgdG8gWy4uLl0sXG4gIFx0XHQvLyBidXQgQ29tcG9uZW50LnByb3RvdHlwZS50ZW1wbGF0ZSByZWZlcnMgdG8ge3Y6MSx0OltdLHA6W119Li4uXG4gIFx0XHQvLyBpdCdzIHVubmVjZXNzYXJ5LCBiZWNhdXNlIHRoZSBkZXZlbG9wZXIgbmV2ZXIgbmVlZHMgdG8gYWNjZXNzXG4gIFx0XHQvLyByYWN0aXZlLnRlbXBsYXRlXG4gIFx0XHRyYWN0aXZlLnRlbXBsYXRlID0gdGVtcGxhdGUudDtcblxuICBcdFx0aWYgKCB0ZW1wbGF0ZS5wICkge1xuICBcdFx0XHRleHRlbmRQYXJ0aWFscyggcmFjdGl2ZS5wYXJ0aWFscywgdGVtcGxhdGUucCApO1xuICBcdFx0fVxuICBcdH0sXG5cbiAgXHRyZXNldDogZnVuY3Rpb24gKCByYWN0aXZlICkge1xuICBcdFx0dmFyIHJlc3VsdCA9IHJlc2V0VmFsdWUoIHJhY3RpdmUgKTtcblxuICBcdFx0aWYgKCByZXN1bHQgKSB7XG4gIFx0XHRcdHZhciBwYXJzZWQgPSBwYXJzZVRlbXBsYXRlKCByZXN1bHQsIHJhY3RpdmUgKTtcblxuICBcdFx0XHRyYWN0aXZlLnRlbXBsYXRlID0gcGFyc2VkLnQ7XG4gIFx0XHRcdGV4dGVuZFBhcnRpYWxzKCByYWN0aXZlLnBhcnRpYWxzLCBwYXJzZWQucCwgdHJ1ZSApO1xuXG4gIFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICBmdW5jdGlvbiByZXNldFZhbHVlICggcmFjdGl2ZSApIHtcbiAgXHR2YXIgaW5pdGlhbCA9IHJhY3RpdmUuX2NvbmZpZy50ZW1wbGF0ZTtcblxuICBcdC8vIElmIHRoaXMgaXNuJ3QgYSBkeW5hbWljIHRlbXBsYXRlLCB0aGVyZSdzIG5vdGhpbmcgdG8gZG9cbiAgXHRpZiAoICFpbml0aWFsIHx8ICFpbml0aWFsLmZuICkge1xuICBcdFx0cmV0dXJuO1xuICBcdH1cblxuICBcdHZhciByZXN1bHQgPSBnZXREeW5hbWljVGVtcGxhdGUoIHJhY3RpdmUsIGluaXRpYWwuZm4gKTtcblxuICBcdC8vIFRPRE8gZGVlcCBlcXVhbGl0eSBjaGVjayB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlLXJlbmRlcmluZ1xuICBcdC8vIGluIHRoZSBjYXNlIG9mIGFscmVhZHktcGFyc2VkIHRlbXBsYXRlc1xuICBcdGlmICggcmVzdWx0ICE9PSBpbml0aWFsLnJlc3VsdCApIHtcbiAgXHRcdGluaXRpYWwucmVzdWx0ID0gcmVzdWx0O1xuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXREeW5hbWljVGVtcGxhdGUgKCByYWN0aXZlLCBmbiApIHtcbiAgXHRyZXR1cm4gZm4uY2FsbCggcmFjdGl2ZSwge1xuICBcdFx0ZnJvbUlkOiBwYXJzZXIuZnJvbUlkLFxuICBcdFx0aXNQYXJzZWQ6IHBhcnNlci5pc1BhcnNlZCxcbiAgXHRcdHBhcnNlOiBmdW5jdGlvbiAoIHRlbXBsYXRlLCBvcHRpb25zICkge1xuICBcdFx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSBwYXJzZXIuZ2V0UGFyc2VPcHRpb25zKCByYWN0aXZlICk7XG5cbiAgXHRcdFx0cmV0dXJuIHBhcnNlci5wYXJzZSggdGVtcGxhdGUsIG9wdGlvbnMgKTtcbiAgXHRcdH1cbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVGVtcGxhdGUgKCB0ZW1wbGF0ZSwgcmFjdGl2ZSApIHtcbiAgXHRpZiAoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKSB7XG4gIFx0XHQvLyBwYXJzZSB3aWxsIHZhbGlkYXRlIGFuZCBhZGQgZXhwcmVzc2lvbiBmdW5jdGlvbnNcbiAgXHRcdHRlbXBsYXRlID0gcGFyc2VBc1N0cmluZyggdGVtcGxhdGUsIHJhY3RpdmUgKTtcbiAgXHR9XG4gIFx0ZWxzZSB7XG4gIFx0XHQvLyBuZWVkIHRvIHZhbGlkYXRlIGFuZCBhZGQgZXhwIGZvciBhbHJlYWR5IHBhcnNlZCB0ZW1wbGF0ZVxuICBcdFx0dmFsaWRhdGUkMSggdGVtcGxhdGUgKTtcbiAgXHRcdGFkZEZ1bmN0aW9ucyggdGVtcGxhdGUgKTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGVtcGxhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUFzU3RyaW5nICggdGVtcGxhdGUsIHJhY3RpdmUgKSB7XG4gIFx0Ly8gSUQgb2YgYW4gZWxlbWVudCBjb250YWluaW5nIHRoZSB0ZW1wbGF0ZT9cbiAgXHRpZiAoIHRlbXBsYXRlWzBdID09PSAnIycgKSB7XG4gIFx0XHR0ZW1wbGF0ZSA9IHBhcnNlci5mcm9tSWQoIHRlbXBsYXRlICk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHBhcnNlci5wYXJzZUZvciggdGVtcGxhdGUsIHJhY3RpdmUgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlJDEoIHRlbXBsYXRlICkge1xuXG4gIFx0Ly8gQ2hlY2sgdGhhdCB0aGUgdGVtcGxhdGUgZXZlbiBleGlzdHNcbiAgXHRpZiAoIHRlbXBsYXRlID09IHVuZGVmaW5lZCApIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvciggKFwiVGhlIHRlbXBsYXRlIGNhbm5vdCBiZSBcIiArIHRlbXBsYXRlICsgXCIuXCIpICk7XG4gIFx0fVxuXG4gIFx0Ly8gQ2hlY2sgdGhlIHBhcnNlZCB0ZW1wbGF0ZSBoYXMgYSB2ZXJzaW9uIGF0IGFsbFxuICBcdGVsc2UgaWYgKCB0eXBlb2YgdGVtcGxhdGUudiAhPT0gJ251bWJlcicgKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUaGUgdGVtcGxhdGUgcGFyc2VyIHdhcyBwYXNzZWQgYSBub24tc3RyaW5nIHRlbXBsYXRlLCBidXQgdGhlIHRlbXBsYXRlIGRvZXNuXFwndCBoYXZlIGEgdmVyc2lvbi4gIE1ha2Ugc3VyZSB5b3VcXCdyZSBwYXNzaW5nIGluIHRoZSB0ZW1wbGF0ZSB5b3UgdGhpbmsgeW91IGFyZS4nICk7XG4gIFx0fVxuXG4gIFx0Ly8gQ2hlY2sgd2UncmUgdXNpbmcgdGhlIGNvcnJlY3QgdmVyc2lvblxuICBcdGVsc2UgaWYgKCB0ZW1wbGF0ZS52ICE9PSBURU1QTEFURV9WRVJTSU9OICkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKCAoXCJNaXNtYXRjaGVkIHRlbXBsYXRlIHZlcnNpb24gKGV4cGVjdGVkIFwiICsgVEVNUExBVEVfVkVSU0lPTiArIFwiLCBnb3QgXCIgKyAodGVtcGxhdGUudikgKyBcIikgUGxlYXNlIGVuc3VyZSB5b3UgYXJlIHVzaW5nIHRoZSBsYXRlc3QgdmVyc2lvbiBvZiBSYWN0aXZlLmpzIGluIHlvdXIgYnVpbGQgcHJvY2VzcyBhcyB3ZWxsIGFzIGluIHlvdXIgYXBwXCIpICk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kUGFydGlhbHMgKCBleGlzdGluZ1BhcnRpYWxzLCBuZXdQYXJ0aWFscywgb3ZlcndyaXRlICkge1xuICBcdGlmICggIW5ld1BhcnRpYWxzICkgcmV0dXJuO1xuXG4gIFx0Ly8gVE9ETyB0aGVyZSdzIGFuIGFtYmlndWl0eSBoZXJlIC0gd2UgbmVlZCB0byBvdmVyd3JpdGUgaW4gdGhlIGByZXNldCgpYFxuICBcdC8vIGNhc2UsIGJ1dCBub3QgaW5pdGlhbGx5Li4uXG5cbiAgXHRmb3IgKCB2YXIga2V5IGluIG5ld1BhcnRpYWxzICkge1xuICBcdFx0aWYgKCBvdmVyd3JpdGUgfHwgIWV4aXN0aW5nUGFydGlhbHMuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuICBcdFx0XHRleGlzdGluZ1BhcnRpYWxzWyBrZXkgXSA9IG5ld1BhcnRpYWxzWyBrZXkgXTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgcmVnaXN0cnlOYW1lcyA9IFtcbiAgXHQnYWRhcHRvcnMnLFxuICBcdCdjb21wb25lbnRzJyxcbiAgXHQnY29tcHV0ZWQnLFxuICBcdCdkZWNvcmF0b3JzJyxcbiAgXHQnZWFzaW5nJyxcbiAgXHQnZXZlbnRzJyxcbiAgXHQnaW50ZXJwb2xhdG9ycycsXG4gIFx0J3BhcnRpYWxzJyxcbiAgXHQndHJhbnNpdGlvbnMnXG4gIF07XG5cbiAgdmFyIFJlZ2lzdHJ5ID0gZnVuY3Rpb24gUmVnaXN0cnkgKCBuYW1lLCB1c2VEZWZhdWx0cyApIHtcbiAgXHR0aGlzLm5hbWUgPSBuYW1lO1xuICBcdHRoaXMudXNlRGVmYXVsdHMgPSB1c2VEZWZhdWx0cztcbiAgfTtcblxuICBSZWdpc3RyeS5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kICggUGFyZW50LCBwcm90bywgb3B0aW9ucyApIHtcbiAgXHR0aGlzLmNvbmZpZ3VyZShcbiAgXHRcdHRoaXMudXNlRGVmYXVsdHMgPyBQYXJlbnQuZGVmYXVsdHMgOiBQYXJlbnQsXG4gIFx0XHR0aGlzLnVzZURlZmF1bHRzID8gcHJvdG8gOiBwcm90by5jb25zdHJ1Y3RvcixcbiAgXHRcdG9wdGlvbnMgKTtcbiAgfTtcblxuICBSZWdpc3RyeS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKCkge1xuICBcdC8vIG5vb3BcbiAgfTtcblxuICBSZWdpc3RyeS5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gY29uZmlndXJlICggUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMgKSB7XG4gIFx0dmFyIG5hbWUgPSB0aGlzLm5hbWU7XG4gIFx0dmFyIG9wdGlvbiA9IG9wdGlvbnNbIG5hbWUgXTtcblxuICBcdHZhciByZWdpc3RyeSA9IGNyZWF0ZSggUGFyZW50W25hbWVdICk7XG5cbiAgXHRmb3IgKCB2YXIga2V5IGluIG9wdGlvbiApIHtcbiAgXHRcdHJlZ2lzdHJ5WyBrZXkgXSA9IG9wdGlvblsga2V5IF07XG4gIFx0fVxuXG4gIFx0dGFyZ2V0WyBuYW1lIF0gPSByZWdpc3RyeTtcbiAgfTtcblxuICBSZWdpc3RyeS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCAoIHJhY3RpdmUgKSB7XG4gIFx0dmFyIHJlZ2lzdHJ5ID0gcmFjdGl2ZVsgdGhpcy5uYW1lIF07XG4gIFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuICBcdE9iamVjdC5rZXlzKCByZWdpc3RyeSApLmZvckVhY2goIGZ1bmN0aW9uICgga2V5ICkge1xuICBcdFx0dmFyIGl0ZW0gPSByZWdpc3RyeVsga2V5IF07XG4gIFx0XHRcdFxuICBcdFx0aWYgKCBpdGVtLl9mbiApIHtcbiAgXHRcdFx0aWYgKCBpdGVtLl9mbi5pc093bmVyICkge1xuICBcdFx0XHRcdHJlZ2lzdHJ5W2tleV0gPSBpdGVtLl9mbjtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRkZWxldGUgcmVnaXN0cnlba2V5XTtcbiAgXHRcdFx0fVxuICBcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdHJldHVybiBjaGFuZ2VkO1xuICB9O1xuXG4gIHZhciByZWdpc3RyaWVzID0gcmVnaXN0cnlOYW1lcy5tYXAoIGZ1bmN0aW9uICggbmFtZSApIHsgcmV0dXJuIG5ldyBSZWdpc3RyeSggbmFtZSwgbmFtZSA9PT0gJ2NvbXB1dGVkJyApOyB9ICk7XG5cbiAgZnVuY3Rpb24gd3JhcCAoIHBhcmVudCwgbmFtZSwgbWV0aG9kICkge1xuICBcdGlmICggIS9fc3VwZXIvLnRlc3QoIG1ldGhvZCApICkgcmV0dXJuIG1ldGhvZDtcblxuICBcdGZ1bmN0aW9uIHdyYXBwZXIgKCkge1xuICBcdFx0dmFyIHN1cGVyTWV0aG9kID0gZ2V0U3VwZXJNZXRob2QoIHdyYXBwZXIuX3BhcmVudCwgbmFtZSApO1xuICBcdFx0dmFyIGhhc1N1cGVyID0gJ19zdXBlcicgaW4gdGhpcztcbiAgXHRcdHZhciBvbGRTdXBlciA9IHRoaXMuX3N1cGVyO1xuXG4gIFx0XHR0aGlzLl9zdXBlciA9IHN1cGVyTWV0aG9kO1xuXG4gIFx0XHR2YXIgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuICBcdFx0aWYgKCBoYXNTdXBlciApIHtcbiAgXHRcdFx0dGhpcy5fc3VwZXIgPSBvbGRTdXBlcjtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLl9zdXBlcjtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9XG5cbiAgXHR3cmFwcGVyLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIFx0d3JhcHBlci5fbWV0aG9kID0gbWV0aG9kO1xuXG4gIFx0cmV0dXJuIHdyYXBwZXI7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdXBlck1ldGhvZCAoIHBhcmVudCwgbmFtZSApIHtcbiAgXHRpZiAoIG5hbWUgaW4gcGFyZW50ICkge1xuICBcdFx0dmFyIHZhbHVlID0gcGFyZW50WyBuYW1lIF07XG5cbiAgXHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgP1xuICBcdFx0XHR2YWx1ZSA6XG4gIFx0XHRcdGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9O1xuICBcdH1cblxuICBcdHJldHVybiBub29wO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZSggZGVwcmVjYXRlZCwgY29ycmVjdCwgaXNFcnJvciApIHtcbiAgXHRyZXR1cm4gXCJvcHRpb25zLlwiICsgZGVwcmVjYXRlZCArIFwiIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIG9wdGlvbnMuXCIgKyBjb3JyZWN0ICsgXCIuXCJcbiAgXHRcdCsgKCBpc0Vycm9yID8gKFwiIFlvdSBjYW5ub3Qgc3BlY2lmeSBib3RoIG9wdGlvbnMsIHBsZWFzZSB1c2Ugb3B0aW9ucy5cIiArIGNvcnJlY3QgKyBcIi5cIikgOiAnJyApO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVwcmVjYXRlT3B0aW9uICggb3B0aW9ucywgZGVwcmVjYXRlZE9wdGlvbiwgY29ycmVjdCApIHtcbiAgXHRpZiAoIGRlcHJlY2F0ZWRPcHRpb24gaW4gb3B0aW9ucyApIHtcbiAgXHRcdGlmKCAhKCBjb3JyZWN0IGluIG9wdGlvbnMgKSApIHtcbiAgXHRcdFx0d2FybklmRGVidWcoIGdldE1lc3NhZ2UoIGRlcHJlY2F0ZWRPcHRpb24sIGNvcnJlY3QgKSApO1xuICBcdFx0XHRvcHRpb25zWyBjb3JyZWN0IF0gPSBvcHRpb25zWyBkZXByZWNhdGVkT3B0aW9uIF07XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGdldE1lc3NhZ2UoIGRlcHJlY2F0ZWRPcHRpb24sIGNvcnJlY3QsIHRydWUgKSApO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZSAoIG9wdGlvbnMgKSB7XG4gIFx0ZGVwcmVjYXRlT3B0aW9uKCBvcHRpb25zLCAnYmVmb3JlSW5pdCcsICdvbmNvbnN0cnVjdCcgKTtcbiAgXHRkZXByZWNhdGVPcHRpb24oIG9wdGlvbnMsICdpbml0JywgJ29ucmVuZGVyJyApO1xuICBcdGRlcHJlY2F0ZU9wdGlvbiggb3B0aW9ucywgJ2NvbXBsZXRlJywgJ29uY29tcGxldGUnICk7XG4gIFx0ZGVwcmVjYXRlT3B0aW9uKCBvcHRpb25zLCAnZXZlbnREZWZpbml0aW9ucycsICdldmVudHMnICk7XG5cbiAgXHQvLyBVc2luZyBleHRlbmQgd2l0aCBDb21wb25lbnQgaW5zdGVhZCBvZiBvcHRpb25zLFxuICBcdC8vIGxpa2UgSHVtYW4uZXh0ZW5kKCBTcGlkZXIgKSBtZWFucyBhZGFwdG9ycyBhcyBhIHJlZ2lzdHJ5XG4gIFx0Ly8gZ2V0cyBjb3BpZWQgdG8gb3B0aW9ucy4gU28gd2UgaGF2ZSB0byBjaGVjayBpZiBhY3R1YWxseSBhbiBhcnJheVxuICBcdGlmICggaXNBcnJheSggb3B0aW9ucy5hZGFwdG9ycyApICkge1xuICBcdFx0ZGVwcmVjYXRlT3B0aW9uKCBvcHRpb25zLCAnYWRhcHRvcnMnLCAnYWRhcHQnICk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGN1c3RvbSA9IHtcbiAgXHRhZGFwdDogYWRhcHRDb25maWd1cmF0b3IsXG4gIFx0Y3NzOiBjc3NDb25maWd1cmF0b3IsXG4gIFx0ZGF0YTogZGF0YUNvbmZpZ3VyYXRvcixcbiAgXHR0ZW1wbGF0ZTogdGVtcGxhdGVDb25maWd1cmF0b3JcbiAgfTtcblxuICB2YXIgZGVmYXVsdEtleXMgPSBPYmplY3Qua2V5cyggZGVmYXVsdHMgKTtcblxuICB2YXIgaXNTdGFuZGFyZEtleSA9IG1ha2VPYmooIGRlZmF1bHRLZXlzLmZpbHRlciggZnVuY3Rpb24gKCBrZXkgKSB7IHJldHVybiAhY3VzdG9tWyBrZXkgXTsgfSApICk7XG5cbiAgLy8gYmxhY2tsaXN0ZWQga2V5cyB0aGF0IHdlIGRvbid0IGRvdWJsZSBleHRlbmRcbiAgdmFyIGlzQmxhY2tsaXN0ZWQgPSBtYWtlT2JqKCBkZWZhdWx0S2V5cy5jb25jYXQoIHJlZ2lzdHJpZXMubWFwKCBmdW5jdGlvbiAoIHIgKSB7IHJldHVybiByLm5hbWU7IH0gKSApICk7XG5cbiAgdmFyIG9yZGVyID0gW10uY29uY2F0KFxuICBcdGRlZmF1bHRLZXlzLmZpbHRlciggZnVuY3Rpb24gKCBrZXkgKSB7IHJldHVybiAhcmVnaXN0cmllc1sga2V5IF0gJiYgIWN1c3RvbVsga2V5IF07IH0gKSxcbiAgXHRyZWdpc3RyaWVzLFxuICBcdC8vY3VzdG9tLmRhdGEsXG4gIFx0Y3VzdG9tLnRlbXBsYXRlLFxuICBcdGN1c3RvbS5jc3NcbiAgKTtcblxuICB2YXIgY29uZmlnID0ge1xuICBcdGV4dGVuZDogZnVuY3Rpb24gKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICkgeyByZXR1cm4gY29uZmlndXJlKCAnZXh0ZW5kJywgUGFyZW50LCBwcm90bywgb3B0aW9ucyApOyB9LFxuXG4gIFx0aW5pdDogZnVuY3Rpb24gKCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKSB7IHJldHVybiBjb25maWd1cmUoICdpbml0JywgUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICk7IH0sXG5cbiAgXHRyZXNldDogZnVuY3Rpb24gKCByYWN0aXZlICkge1xuICBcdFx0cmV0dXJuIG9yZGVyLmZpbHRlciggZnVuY3Rpb24gKCBjICkge1xuICBcdFx0XHRyZXR1cm4gYy5yZXNldCAmJiBjLnJlc2V0KCByYWN0aXZlICk7XG4gIFx0XHR9KS5tYXAoIGZ1bmN0aW9uICggYyApIHsgcmV0dXJuIGMubmFtZTsgfSApO1xuICBcdH0sXG5cbiAgXHQvLyB0aGlzIGRlZmluZXMgdGhlIG9yZGVyLiBUT0RPIHRoaXMgaXNuJ3QgdXNlZCBhbnl3aGVyZSBpbiB0aGUgY29kZWJhc2UsXG4gIFx0Ly8gb25seSBpbiB0aGUgdGVzdCBzdWl0ZSAtIHNob3VsZCBnZXQgcmlkIG9mIGl0XG4gIFx0b3JkZXI6IG9yZGVyXG4gIH07XG5cbiAgZnVuY3Rpb24gY29uZmlndXJlICggbWV0aG9kLCBQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyApIHtcbiAgXHRkZXByZWNhdGUoIG9wdGlvbnMgKTtcblxuICBcdGZvciAoIHZhciBrZXkgaW4gb3B0aW9ucyApIHtcbiAgXHRcdGlmICggaXNTdGFuZGFyZEtleS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG4gIFx0XHRcdHZhciB2YWx1ZSA9IG9wdGlvbnNbIGtleSBdO1xuXG4gIFx0XHRcdC8vIHdhcm4gdGhlIGRldmVsb3BlciBpZiB0aGV5IHBhc3NlZCBhIGZ1bmN0aW9uIGFuZCBpZ25vcmUgaXRzIHZhbHVlXG5cbiAgXHRcdFx0Ly8gTk9URTogd2UgYWxsb3cgc29tZSBmdW5jdGlvbnMgb24gXCJlbFwiIGJlY2F1c2Ugd2UgZHVjayB0eXBlIGVsZW1lbnQgbGlzdHNcbiAgXHRcdFx0Ly8gYW5kIHNvbWUgbGlicmFyaWVzIG9yIGVmJ2VkLXVwIHZpcnR1YWwgYnJvd3NlcnMgKHBoYW50b21KUykgcmV0dXJuIGFcbiAgXHRcdFx0Ly8gZnVuY3Rpb24gb2JqZWN0IGFzIHRoZSByZXN1bHQgb2YgcXVlcnlTZWxlY3RvciBtZXRob2RzXG4gIFx0XHRcdGlmICgga2V5ICE9PSAnZWwnICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgXHRcdFx0XHR3YXJuSWZEZWJ1ZyggKFwiXCIgKyBrZXkgKyBcIiBpcyBhIFJhY3RpdmUgb3B0aW9uIHRoYXQgZG9lcyBub3QgZXhwZWN0IGEgZnVuY3Rpb24gYW5kIHdpbGwgYmUgaWdub3JlZFwiKSxcbiAgXHRcdFx0XHRcdG1ldGhvZCA9PT0gJ2luaXQnID8gdGFyZ2V0IDogbnVsbCApO1xuICBcdFx0XHR9XG4gIFx0XHRcdGVsc2Uge1xuICBcdFx0XHRcdHRhcmdldFsga2V5IF0gPSB2YWx1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIGRpc2FsbG93IGNvbWJpbmF0aW9uIG9mIGBhcHBlbmRgIGFuZCBgZW5oYW5jZWBcbiAgXHRpZiAoIG9wdGlvbnMuYXBwZW5kICYmIG9wdGlvbnMuZW5oYW5jZSApIHtcbiAgXHRcdHRocm93IG5ldyBFcnJvciggJ0Nhbm5vdCB1c2UgYXBwZW5kIGFuZCBlbmhhbmNlIGF0IHRoZSBzYW1lIHRpbWUnICk7XG4gIFx0fVxuXG4gIFx0cmVnaXN0cmllcy5mb3JFYWNoKCBmdW5jdGlvbiAoIHJlZ2lzdHJ5ICkge1xuICBcdFx0cmVnaXN0cnlbIG1ldGhvZCBdKCBQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyApO1xuICBcdH0pO1xuXG4gIFx0YWRhcHRDb25maWd1cmF0b3JbIG1ldGhvZCBdKCBQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyApO1xuICBcdHRlbXBsYXRlQ29uZmlndXJhdG9yWyBtZXRob2QgXSggUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMgKTtcbiAgXHRjc3NDb25maWd1cmF0b3JbIG1ldGhvZCBdKCBQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyApO1xuXG4gIFx0ZXh0ZW5kT3RoZXJNZXRob2RzKCBQYXJlbnQucHJvdG90eXBlLCB0YXJnZXQsIG9wdGlvbnMgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZE90aGVyTWV0aG9kcyAoIHBhcmVudCwgdGFyZ2V0LCBvcHRpb25zICkge1xuICBcdGZvciAoIHZhciBrZXkgaW4gb3B0aW9ucyApIHtcbiAgXHRcdGlmICggIWlzQmxhY2tsaXN0ZWRbIGtleSBdICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuICBcdFx0XHR2YXIgbWVtYmVyID0gb3B0aW9uc1sga2V5IF07XG5cbiAgXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIG1ldGhvZCB0aGF0IG92ZXJ3cml0ZXMgYSBtZXRob2QsIHdyYXAgaXQ6XG4gIFx0XHRcdGlmICggdHlwZW9mIG1lbWJlciA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgXHRcdFx0XHRtZW1iZXIgPSB3cmFwKCBwYXJlbnQsIGtleSwgbWVtYmVyICk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0YXJnZXRbIGtleSBdID0gbWVtYmVyO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VPYmogKCBhcnJheSApIHtcbiAgXHR2YXIgb2JqID0ge307XG4gIFx0YXJyYXkuZm9yRWFjaCggZnVuY3Rpb24gKCB4ICkgeyByZXR1cm4gb2JqW3hdID0gdHJ1ZTsgfSApO1xuICBcdHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgc2hvdWxkUmVyZW5kZXIgPSBbICd0ZW1wbGF0ZScsICdwYXJ0aWFscycsICdjb21wb25lbnRzJywgJ2RlY29yYXRvcnMnLCAnZXZlbnRzJyBdO1xuXG4gIHZhciBjb21wbGV0ZUhvb2skMSA9IG5ldyBIb29rKCAnY29tcGxldGUnICk7XG4gIHZhciByZXNldEhvb2sgPSBuZXcgSG9vayggJ3Jlc2V0JyApO1xuICB2YXIgcmVuZGVySG9vayQxID0gbmV3IEhvb2soICdyZW5kZXInICk7XG4gIHZhciB1bnJlbmRlckhvb2sgPSBuZXcgSG9vayggJ3VucmVuZGVyJyApO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkcmVzZXQgKCBkYXRhICkge1xuICBcdGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIFx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUaGUgcmVzZXQgbWV0aG9kIHRha2VzIGVpdGhlciBubyBhcmd1bWVudHMsIG9yIGFuIG9iamVjdCBjb250YWluaW5nIG5ldyBkYXRhJyApO1xuICBcdH1cblxuICBcdC8vIFRFTVAgbmVlZCB0byB0aWR5IHRoaXMgdXBcbiAgXHRkYXRhID0gZGF0YUNvbmZpZ3VyYXRvci5pbml0KCB0aGlzLmNvbnN0cnVjdG9yLCB0aGlzLCB7IGRhdGE6IGRhdGEgfSk7XG5cbiAgXHR2YXIgcHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblxuICBcdC8vIElmIHRoZSByb290IG9iamVjdCBpcyB3cmFwcGVkLCB0cnkgYW5kIHVzZSB0aGUgd3JhcHBlcidzIHJlc2V0IHZhbHVlXG4gIFx0dmFyIHdyYXBwZXIgPSB0aGlzLnZpZXdtb2RlbC53cmFwcGVyO1xuICBcdGlmICggd3JhcHBlciAmJiB3cmFwcGVyLnJlc2V0ICkge1xuICBcdFx0aWYgKCB3cmFwcGVyLnJlc2V0KCBkYXRhICkgPT09IGZhbHNlICkge1xuICBcdFx0XHQvLyByZXNldCB3YXMgcmVqZWN0ZWQsIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgb2JqZWN0XG4gIFx0XHRcdHRoaXMudmlld21vZGVsLnNldCggZGF0YSApO1xuICBcdFx0fVxuICBcdH0gZWxzZSB7XG4gIFx0XHR0aGlzLnZpZXdtb2RlbC5zZXQoIGRhdGEgKTtcbiAgXHR9XG5cbiAgXHQvLyByZXNldCBjb25maWcgaXRlbXMgYW5kIHRyYWNrIGlmIG5lZWQgdG8gcmVyZW5kZXJcbiAgXHR2YXIgY2hhbmdlcyA9IGNvbmZpZy5yZXNldCggdGhpcyApO1xuICBcdHZhciByZXJlbmRlcjtcblxuICBcdHZhciBpID0gY2hhbmdlcy5sZW5ndGg7XG4gIFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRpZiAoIHNob3VsZFJlcmVuZGVyLmluZGV4T2YoIGNoYW5nZXNbaV0gKSA+IC0xICkge1xuICBcdFx0XHRyZXJlbmRlciA9IHRydWU7XG4gIFx0XHRcdGJyZWFrO1xuICBcdFx0fVxuICBcdH1cblxuICBcdGlmICggcmVyZW5kZXIgKSB7XG4gIFx0XHR1bnJlbmRlckhvb2suZmlyZSggdGhpcyApO1xuICBcdFx0dGhpcy5mcmFnbWVudC5yZXNldFRlbXBsYXRlKCB0aGlzLnRlbXBsYXRlICk7XG4gIFx0XHRyZW5kZXJIb29rJDEuZmlyZSggdGhpcyApO1xuICBcdFx0Y29tcGxldGVIb29rJDEuZmlyZSggdGhpcyApO1xuICBcdH1cblxuICBcdHJ1bmxvb3AuZW5kKCk7XG5cbiAgXHRyZXNldEhvb2suZmlyZSggdGhpcywgZGF0YSApO1xuXG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjb2xsZWN0KCBzb3VyY2UsIG5hbWUsIGF0dHIsIGRlc3QgKSB7XG4gIFx0c291cmNlLmZvckVhY2goIGZ1bmN0aW9uICggaXRlbSApIHtcbiAgXHRcdC8vIHF1ZXVlIHRvIHJlcmVuZGVyIGlmIHRoZSBpdGVtIGlzIGEgcGFydGlhbCBhbmQgdGhlIGN1cnJlbnQgbmFtZSBtYXRjaGVzXG4gIFx0XHRpZiAoIGl0ZW0udHlwZSA9PT0gUEFSVElBTCAmJiAoIGl0ZW0ucmVmTmFtZSA9PT0gIG5hbWUgfHwgaXRlbS5uYW1lID09PSBuYW1lICkgKSB7XG4gIFx0XHRcdGl0ZW0uaW5BdHRyaWJ1dGUgPSBhdHRyO1xuICBcdFx0XHRkZXN0LnB1c2goIGl0ZW0gKTtcbiAgXHRcdFx0cmV0dXJuOyAvLyBnbyBubyBmdXJ0aGVyXG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlmIGl0IGhhcyBhIGZyYWdtZW50LCBwcm9jZXNzIGl0cyBpdGVtc1xuICBcdFx0aWYgKCBpdGVtLmZyYWdtZW50ICkge1xuICBcdFx0XHRjb2xsZWN0KCBpdGVtLmZyYWdtZW50Lml0ZXJhdGlvbnMgfHwgaXRlbS5mcmFnbWVudC5pdGVtcywgbmFtZSwgYXR0ciwgZGVzdCApO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBvciBpZiBpdCBpcyBpdHNlbGYgYSBmcmFnbWVudCwgcHJvY2VzcyBpdHMgaXRlbXNcbiAgXHRcdGVsc2UgaWYgKCBpc0FycmF5KCBpdGVtLml0ZW1zICkgKSB7XG4gIFx0XHRcdGNvbGxlY3QoIGl0ZW0uaXRlbXMsIG5hbWUsIGF0dHIsIGRlc3QgKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gb3IgaWYgaXQgaXMgYSBjb21wb25lbnQsIHN0ZXAgaW4gYW5kIHByb2Nlc3MgaXRzIGl0ZW1zXG4gIFx0XHRlbHNlIGlmICggaXRlbS50eXBlID09PSBDT01QT05FTlQgJiYgaXRlbS5pbnN0YW5jZSApIHtcbiAgXHRcdFx0Ly8gLi4udW5sZXNzIHRoZSBwYXJ0aWFsIGlzIHNoYWRvd2VkXG4gIFx0XHRcdGlmICggaXRlbS5pbnN0YW5jZS5wYXJ0aWFsc1sgbmFtZSBdICkgcmV0dXJuO1xuICBcdFx0XHRjb2xsZWN0KCBpdGVtLmluc3RhbmNlLmZyYWdtZW50Lml0ZW1zLCBuYW1lLCBhdHRyLCBkZXN0ICk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlmIHRoZSBpdGVtIGlzIGFuIGVsZW1lbnQsIHByb2Nlc3MgaXRzIGF0dHJpYnV0ZXMgdG9vXG4gIFx0XHRpZiAoIGl0ZW0udHlwZSA9PT0gRUxFTUVOVCApIHtcbiAgXHRcdFx0aWYgKCBpc0FycmF5KCBpdGVtLmF0dHJpYnV0ZXMgKSApIHtcbiAgXHRcdFx0XHRjb2xsZWN0KCBpdGVtLmF0dHJpYnV0ZXMsIG5hbWUsIHRydWUsIGRlc3QgKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9yY2VSZXNldFRlbXBsYXRlICggcGFydGlhbCApIHtcbiAgXHRwYXJ0aWFsLmZvcmNlUmVzZXRUZW1wbGF0ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRQYXJ0aWFsICggbmFtZSwgcGFydGlhbCApIHtcbiAgXHR2YXIgY29sbGVjdGlvbiA9IFtdO1xuICBcdGNvbGxlY3QoIHRoaXMuZnJhZ21lbnQuaXRlbXMsIG5hbWUsIGZhbHNlLCBjb2xsZWN0aW9uICk7XG5cbiAgXHR2YXIgcHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblxuICBcdHRoaXMucGFydGlhbHNbIG5hbWUgXSA9IHBhcnRpYWw7XG4gIFx0Y29sbGVjdGlvbi5mb3JFYWNoKCBmb3JjZVJlc2V0VGVtcGxhdGUgKTtcblxuICBcdHJ1bmxvb3AuZW5kKCk7XG5cbiAgXHRyZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciBJdGVtID0gZnVuY3Rpb24gSXRlbSAoIG9wdGlvbnMgKSB7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5yYWN0aXZlID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudC5yYWN0aXZlO1xuXG4gIFx0dGhpcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gIFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG4gIFx0dGhpcy50eXBlID0gb3B0aW9ucy50ZW1wbGF0ZS50O1xuXG4gIFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9O1xuXG4gIEl0ZW0ucHJvdG90eXBlLmJ1YmJsZSA9IGZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gIFx0aWYgKCAhdGhpcy5kaXJ0eSApIHtcbiAgXHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuICBcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcbiAgXHR9XG4gIH07XG5cbiAgSXRlbS5wcm90b3R5cGUuZGVzdHJveWVkID0gZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgXHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB0aGlzLmZyYWdtZW50LmRlc3Ryb3llZCgpO1xuICB9O1xuXG4gIEl0ZW0ucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiBmaW5kICgpIHtcbiAgXHRyZXR1cm4gbnVsbDtcbiAgfTtcblxuICBJdGVtLnByb3RvdHlwZS5maW5kQWxsID0gZnVuY3Rpb24gZmluZEFsbCAoKSB7XG4gIFx0Ly8gbm9vcFxuICB9O1xuXG4gIEl0ZW0ucHJvdG90eXBlLmZpbmRDb21wb25lbnQgPSBmdW5jdGlvbiBmaW5kQ29tcG9uZW50ICgpIHtcbiAgXHRyZXR1cm4gbnVsbDtcbiAgfTtcblxuICBJdGVtLnByb3RvdHlwZS5maW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGZpbmRBbGxDb21wb25lbnRzICgpIHtcbiAgXHQvLyBub29wO1xuICB9O1xuXG4gIEl0ZW0ucHJvdG90eXBlLmZpbmROZXh0Tm9kZSA9IGZ1bmN0aW9uIGZpbmROZXh0Tm9kZSAoKSB7XG4gIFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICk7XG4gIH07XG5cbiAgSXRlbS5wcm90b3R5cGUuc2h1ZmZsZWQgPSBmdW5jdGlvbiBzaHVmZmxlZCAoKSB7XG4gIFx0aWYgKCB0aGlzLmZyYWdtZW50ICkgdGhpcy5mcmFnbWVudC5zaHVmZmxlZCgpO1xuICB9O1xuXG4gIEl0ZW0ucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiB2YWx1ZU9mICgpIHtcbiAgXHRyZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIHZhciBDb21wdXRhdGlvbkNoaWxkID0gKGZ1bmN0aW9uIChNb2RlbCkge1xuICBcdGZ1bmN0aW9uIENvbXB1dGF0aW9uQ2hpbGQgKCkge1xuICBcdFx0TW9kZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXHR9XG5cbiAgXHRDb21wdXRhdGlvbkNoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1vZGVsICYmIE1vZGVsLnByb3RvdHlwZSApO1xuICBcdENvbXB1dGF0aW9uQ2hpbGQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29tcHV0YXRpb25DaGlsZDtcblxuICBcdENvbXB1dGF0aW9uQ2hpbGQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoIHNob3VsZENhcHR1cmUgKSB7XG4gIFx0XHRpZiAoIHNob3VsZENhcHR1cmUgKSBjYXB0dXJlKCB0aGlzICk7XG5cbiAgXHRcdHZhciBwYXJlbnRWYWx1ZSA9IHRoaXMucGFyZW50LmdldCgpO1xuICBcdFx0cmV0dXJuIHBhcmVudFZhbHVlID8gcGFyZW50VmFsdWVbIHRoaXMua2V5IF0gOiB1bmRlZmluZWQ7XG4gIFx0fTtcblxuICBcdENvbXB1dGF0aW9uQ2hpbGQucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSQxICgpIHtcbiAgXHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gIFx0XHR0aGlzLmxpbmtzLmZvckVhY2goIG1hcmtlZCApO1xuICBcdFx0dGhpcy5kZXBzLmZvckVhY2goIGhhbmRsZUNoYW5nZSApO1xuICBcdFx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKCBoYW5kbGVDaGFuZ2UgKTtcbiAgXHRcdHRoaXMuY2xlYXJVbnJlc29sdmVkcygpOyAvLyBUT0RPIGlzIHRoaXMgbmVjZXNzYXJ5P1xuICBcdH07XG5cbiAgXHRDb21wdXRhdGlvbkNoaWxkLnByb3RvdHlwZS5qb2luS2V5ID0gZnVuY3Rpb24gam9pbktleSAoIGtleSApIHtcbiAgXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwga2V5ID09PSAnJyApIHJldHVybiB0aGlzO1xuXG4gIFx0XHRpZiAoICF0aGlzLmNoaWxkQnlLZXkuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuICBcdFx0XHR2YXIgY2hpbGQgPSBuZXcgQ29tcHV0YXRpb25DaGlsZCggdGhpcywga2V5ICk7XG4gIFx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggY2hpbGQgKTtcbiAgXHRcdFx0dGhpcy5jaGlsZEJ5S2V5WyBrZXkgXSA9IGNoaWxkO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gdGhpcy5jaGlsZEJ5S2V5WyBrZXkgXTtcbiAgXHR9O1xuXG4gIFx0cmV0dXJuIENvbXB1dGF0aW9uQ2hpbGQ7XG4gIH0oTW9kZWwpKTtcblxuICBmdW5jdGlvbiBjcmVhdGVSZXNvbHZlciAoIHByb3h5LCByZWYsIGluZGV4ICkge1xuICBcdHZhciByZXNvbHZlciA9IHByb3h5LmZyYWdtZW50LnJlc29sdmUoIHJlZiwgZnVuY3Rpb24gKCBtb2RlbCApIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSggcHJveHkucmVzb2x2ZXJzLCByZXNvbHZlciApO1xuICBcdFx0cHJveHkubW9kZWxzWyBpbmRleCBdID0gbW9kZWw7XG4gIFx0XHRwcm94eS5idWJibGUoKTtcbiAgXHR9KTtcblxuICBcdHByb3h5LnJlc29sdmVycy5wdXNoKCByZXNvbHZlciApO1xuICB9XG5cbiAgdmFyIEV4cHJlc3Npb25Qcm94eSA9IChmdW5jdGlvbiAoTW9kZWwpIHtcbiAgXHRmdW5jdGlvbiBFeHByZXNzaW9uUHJveHkgKCBmcmFnbWVudCwgdGVtcGxhdGUgKSB7XG4gIFx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0TW9kZWwuY2FsbCggdGhpcywgZnJhZ21lbnQucmFjdGl2ZS52aWV3bW9kZWwsIG51bGwgKTtcblxuICBcdFx0dGhpcy5mcmFnbWVudCA9IGZyYWdtZW50O1xuICBcdFx0dGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuXG4gIFx0XHR0aGlzLmlzUmVhZG9ubHkgPSB0cnVlO1xuICBcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgXHRcdHRoaXMuZm4gPSBnZXRGdW5jdGlvbiggdGVtcGxhdGUucywgdGVtcGxhdGUuci5sZW5ndGggKTtcblxuICBcdFx0dGhpcy5yZXNvbHZlcnMgPSBbXTtcbiAgXHRcdHRoaXMubW9kZWxzID0gdGhpcy50ZW1wbGF0ZS5yLm1hcCggZnVuY3Rpb24gKCByZWYsIGluZGV4ICkge1xuICBcdFx0XHR2YXIgbW9kZWwgPSByZXNvbHZlUmVmZXJlbmNlKCB0aGlzJDEuZnJhZ21lbnQsIHJlZiApO1xuXG4gIFx0XHRcdGlmICggIW1vZGVsICkge1xuICBcdFx0XHRcdGNyZWF0ZVJlc29sdmVyKCB0aGlzJDEsIHJlZiwgaW5kZXggKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHJldHVybiBtb2RlbDtcbiAgXHRcdH0pO1xuICBcdFx0dGhpcy5kZXBlbmRlbmNpZXMgPSBbXTtcblxuICBcdFx0dGhpcy5zaHVmZmxlID0gdW5kZWZpbmVkO1xuXG4gIFx0XHR0aGlzLmJ1YmJsZSgpO1xuICBcdH1cblxuICBcdEV4cHJlc3Npb25Qcm94eS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNb2RlbCAmJiBNb2RlbC5wcm90b3R5cGUgKTtcbiAgXHRFeHByZXNzaW9uUHJveHkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXhwcmVzc2lvblByb3h5O1xuXG4gIFx0RXhwcmVzc2lvblByb3h5LnByb3RvdHlwZS5idWJibGUgPSBmdW5jdGlvbiBidWJibGUgKCBhY3R1YWxseUNoYW5nZWQgKSB7XG4gIFx0XHQvLyByZWZyZXNoIHRoZSBrZXlwYXRoXG4gIFx0XHRpZiAoIGFjdHVhbGx5Q2hhbmdlZCA9PT0gdm9pZCAwICkgYWN0dWFsbHlDaGFuZ2VkID0gdHJ1ZTtcblxuICBcdFx0aWYgKCB0aGlzLnJlZ2lzdGVyZWQgKSBkZWxldGUgdGhpcy5yb290LmV4cHJlc3Npb25zWyB0aGlzLmtleXBhdGggXTtcbiAgXHRcdHRoaXMua2V5cGF0aCA9IHVuZGVmaW5lZDtcblxuICBcdFx0aWYgKCBhY3R1YWxseUNoYW5nZWQgKSB7XG4gIFx0XHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuICBcdFx0XHR0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRFeHByZXNzaW9uUHJveHkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoIHNob3VsZENhcHR1cmUgKSB7XG4gIFx0XHRpZiAoIHNob3VsZENhcHR1cmUgKSBjYXB0dXJlKCB0aGlzICk7XG5cbiAgXHRcdGlmICggdGhpcy5kaXJ0eSApIHtcbiAgXHRcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuICBcdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICBcdFx0XHRpZiAoIHRoaXMud3JhcHBlciApIHRoaXMubmV3V3JhcHBlclZhbHVlID0gdGhpcy52YWx1ZTtcbiAgXHRcdFx0dGhpcy5hZGFwdCgpO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gc2hvdWxkQ2FwdHVyZSAmJiB0aGlzLndyYXBwZXIgPyB0aGlzLndyYXBwZXJWYWx1ZSA6IHRoaXMudmFsdWU7XG4gIFx0fTtcblxuICBcdEV4cHJlc3Npb25Qcm94eS5wcm90b3R5cGUuZ2V0S2V5cGF0aCA9IGZ1bmN0aW9uIGdldEtleXBhdGggKCkge1xuICBcdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdGlmICggIXRoaXMudGVtcGxhdGUgKSByZXR1cm4gJ0B1bmRlZmluZWQnO1xuICBcdFx0aWYgKCAhdGhpcy5rZXlwYXRoICkge1xuICBcdFx0XHR0aGlzLmtleXBhdGggPSAnQCcgKyB0aGlzLnRlbXBsYXRlLnMucmVwbGFjZSggL18oXFxkKykvZywgZnVuY3Rpb24gKCBtYXRjaCwgaSApIHtcbiAgXHRcdFx0XHRpZiAoIGkgPj0gdGhpcyQxLm1vZGVscy5sZW5ndGggKSByZXR1cm4gbWF0Y2g7XG5cbiAgXHRcdFx0XHR2YXIgbW9kZWwgPSB0aGlzJDEubW9kZWxzW2ldO1xuICBcdFx0XHRcdHJldHVybiBtb2RlbCA/IG1vZGVsLmdldEtleXBhdGgoKSA6ICdAdW5kZWZpbmVkJztcbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0dGhpcy5yb290LmV4cHJlc3Npb25zWyB0aGlzLmtleXBhdGggXSA9IHRoaXM7XG4gIFx0XHRcdHRoaXMucmVnaXN0ZXJlZCA9IHRydWU7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLmtleXBhdGg7XG4gIFx0fTtcblxuICBcdEV4cHJlc3Npb25Qcm94eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSAoKSB7XG4gIFx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0c3RhcnRDYXB0dXJpbmcoKTtcbiAgXHRcdHZhciByZXN1bHQ7XG5cbiAgXHRcdHRyeSB7XG4gIFx0XHRcdHZhciBwYXJhbXMgPSB0aGlzLm1vZGVscy5tYXAoIGZ1bmN0aW9uICggbSApIHsgcmV0dXJuIG0gPyBtLmdldCggdHJ1ZSApIDogdW5kZWZpbmVkOyB9ICk7XG4gIFx0XHRcdHJlc3VsdCA9IHRoaXMuZm4uYXBwbHkoIHRoaXMuZnJhZ21lbnQucmFjdGl2ZSwgcGFyYW1zICk7XG4gIFx0XHR9IGNhdGNoICggZXJyICkge1xuICBcdFx0XHR3YXJuSWZEZWJ1ZyggKFwiRmFpbGVkIHRvIGNvbXB1dGUgXCIgKyAodGhpcy5nZXRLZXlwYXRoKCkpICsgXCI6IFwiICsgKGVyci5tZXNzYWdlIHx8IGVycikpICk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBkZXBlbmRlbmNpZXMgPSBzdG9wQ2FwdHVyaW5nKCk7XG4gIFx0XHQvLyByZW1vdmUgbWlzc2luZyBkZXBzXG4gIFx0XHR0aGlzLmRlcGVuZGVuY2llcy5maWx0ZXIoIGZ1bmN0aW9uICggZCApIHsgcmV0dXJuICF+ZGVwZW5kZW5jaWVzLmluZGV4T2YoIGQgKTsgfSApLmZvckVhY2goIGZ1bmN0aW9uICggZCApIHtcbiAgXHRcdFx0ZC51bnJlZ2lzdGVyKCB0aGlzJDEgKTtcbiAgXHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzJDEuZGVwZW5kZW5jaWVzLCBkICk7XG4gIFx0XHR9KTtcbiAgXHRcdC8vIHJlZ2lzdGVyIG5ldyBkZXBzXG4gIFx0XHRkZXBlbmRlbmNpZXMuZmlsdGVyKCBmdW5jdGlvbiAoIGQgKSB7IHJldHVybiAhfnRoaXMkMS5kZXBlbmRlbmNpZXMuaW5kZXhPZiggZCApOyB9ICkuZm9yRWFjaCggZnVuY3Rpb24gKCBkICkge1xuICBcdFx0XHRkLnJlZ2lzdGVyKCB0aGlzJDEgKTtcbiAgXHRcdFx0dGhpcyQxLmRlcGVuZGVuY2llcy5wdXNoKCBkICk7XG4gIFx0XHR9KTtcblxuICBcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHR9O1xuXG4gIFx0RXhwcmVzc2lvblByb3h5LnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UkMSAoKSB7XG4gIFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5saW5rcy5mb3JFYWNoKCBtYXJrZWQgKTtcbiAgXHRcdHRoaXMuZGVwcy5mb3JFYWNoKCBoYW5kbGVDaGFuZ2UgKTtcbiAgXHRcdHRoaXMuY2hpbGRyZW4uZm9yRWFjaCggaGFuZGxlQ2hhbmdlICk7XG5cbiAgXHRcdHRoaXMuY2xlYXJVbnJlc29sdmVkcygpO1xuICBcdH07XG5cbiAgXHRFeHByZXNzaW9uUHJveHkucHJvdG90eXBlLmpvaW5LZXkgPSBmdW5jdGlvbiBqb2luS2V5ICgga2V5ICkge1xuICBcdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBrZXkgPT09ICcnICkgcmV0dXJuIHRoaXM7XG5cbiAgXHRcdGlmICggIXRoaXMuY2hpbGRCeUtleS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG4gIFx0XHRcdHZhciBjaGlsZCA9IG5ldyBDb21wdXRhdGlvbkNoaWxkKCB0aGlzLCBrZXkgKTtcbiAgXHRcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKCBjaGlsZCApO1xuICBcdFx0XHR0aGlzLmNoaWxkQnlLZXlbIGtleSBdID0gY2hpbGQ7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLmNoaWxkQnlLZXlbIGtleSBdO1xuICBcdH07XG5cbiAgXHRFeHByZXNzaW9uUHJveHkucHJvdG90eXBlLm1hcmsgPSBmdW5jdGlvbiBtYXJrICgpIHtcbiAgXHRcdHRoaXMuaGFuZGxlQ2hhbmdlKCk7XG4gIFx0fTtcblxuICBcdEV4cHJlc3Npb25Qcm94eS5wcm90b3R5cGUucmViaW5kaW5nID0gZnVuY3Rpb24gcmViaW5kaW5nICggbmV4dCwgcHJldmlvdXMsIHNhZmUgKSB7XG4gIFx0XHR2YXIgaWR4ID0gdGhpcy5tb2RlbHMuaW5kZXhPZiggcHJldmlvdXMgKTtcblxuICBcdFx0aWYgKCB+aWR4ICkge1xuICBcdFx0XHRuZXh0ID0gcmViaW5kTWF0Y2goIHRoaXMudGVtcGxhdGUucltpZHhdLCBuZXh0LCBwcmV2aW91cyApO1xuICBcdFx0XHRpZiAoIG5leHQgIT09IHByZXZpb3VzICkge1xuICBcdFx0XHRcdHByZXZpb3VzLnVucmVnaXN0ZXIoIHRoaXMgKTtcbiAgXHRcdFx0XHR0aGlzLm1vZGVscy5zcGxpY2UoIGlkeCwgMSwgbmV4dCApO1xuICBcdFx0XHRcdC8vIFRPRE86IHNldCB1cCBhIHJlc29sdmVyIGlmIHRoZXJlIGlzIG5vIG5leHQ/XG4gIFx0XHRcdFx0aWYgKCBuZXh0ICkgbmV4dC5hZGRTaHVmZmxlUmVnaXN0ZXIoIHRoaXMsICdtYXJrJyApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0XHR0aGlzLmJ1YmJsZSggIXNhZmUgKTtcbiAgXHR9O1xuXG4gIFx0RXhwcmVzc2lvblByb3h5LnByb3RvdHlwZS5yZXRyaWV2ZSA9IGZ1bmN0aW9uIHJldHJpZXZlICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmdldCgpO1xuICBcdH07XG5cbiAgXHRFeHByZXNzaW9uUHJveHkucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICBcdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHRoaXMudW5iaW5kKCk7XG4gIFx0XHR0aGlzLmZyYWdtZW50ID0gdW5kZWZpbmVkO1xuICBcdFx0aWYgKCB0aGlzLmRlcGVuZGVuY2llcyApIHRoaXMuZGVwZW5kZW5jaWVzLmZvckVhY2goIGZ1bmN0aW9uICggZCApIHsgcmV0dXJuIGQudW5yZWdpc3RlciggdGhpcyQxICk7IH0gKTtcbiAgXHRcdE1vZGVsLnByb3RvdHlwZS50ZWFyZG93bi5jYWxsKHRoaXMpO1xuICBcdH07XG5cbiAgXHRFeHByZXNzaW9uUHJveHkucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyKCBkZXAgKSB7XG4gIFx0XHRNb2RlbC5wcm90b3R5cGUudW5yZWdpc3Rlci5jYWxsKCB0aGlzLCBkZXAgKTtcbiAgXHRcdGlmICggIXRoaXMuZGVwcy5sZW5ndGggKSB0aGlzLnRlYXJkb3duKCk7XG4gIFx0fTtcblxuICBcdEV4cHJlc3Npb25Qcm94eS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gdW5iaW5kJDEgKCkge1xuICBcdFx0dGhpcy5yZXNvbHZlcnMuZm9yRWFjaCggdW5iaW5kICk7XG4gIFx0fTtcblxuICBcdHJldHVybiBFeHByZXNzaW9uUHJveHk7XG4gIH0oTW9kZWwpKTtcblxuICB2YXIgUmVmZXJlbmNlRXhwcmVzc2lvbkNoaWxkID0gKGZ1bmN0aW9uIChNb2RlbCkge1xuICBcdGZ1bmN0aW9uIFJlZmVyZW5jZUV4cHJlc3Npb25DaGlsZCAoIHBhcmVudCwga2V5ICkge1xuICBcdFx0TW9kZWwuY2FsbCAoIHRoaXMsIHBhcmVudCwga2V5ICk7XG4gIFx0fVxuXG4gIFx0UmVmZXJlbmNlRXhwcmVzc2lvbkNoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1vZGVsICYmIE1vZGVsLnByb3RvdHlwZSApO1xuICBcdFJlZmVyZW5jZUV4cHJlc3Npb25DaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWZlcmVuY2VFeHByZXNzaW9uQ2hpbGQ7XG5cbiAgXHRSZWZlcmVuY2VFeHByZXNzaW9uQ2hpbGQucHJvdG90eXBlLmFwcGx5VmFsdWUgPSBmdW5jdGlvbiBhcHBseVZhbHVlICggdmFsdWUgKSB7XG4gIFx0XHRpZiAoIGlzRXF1YWwoIHZhbHVlLCB0aGlzLnZhbHVlICkgKSByZXR1cm47XG5cbiAgXHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCwga2V5cyA9IFsgdGhpcy5rZXkgXTtcbiAgXHRcdHdoaWxlICggcGFyZW50ICkge1xuICBcdFx0XHRpZiAoIHBhcmVudC5iYXNlICkge1xuICBcdFx0XHRcdHZhciB0YXJnZXQgPSBwYXJlbnQubW9kZWwuam9pbkFsbCgga2V5cyApO1xuICBcdFx0XHRcdHRhcmdldC5hcHBseVZhbHVlKCB2YWx1ZSApO1xuICBcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0a2V5cy51bnNoaWZ0KCBwYXJlbnQua2V5ICk7XG5cbiAgXHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0UmVmZXJlbmNlRXhwcmVzc2lvbkNoaWxkLnByb3RvdHlwZS5qb2luS2V5ID0gZnVuY3Rpb24gam9pbktleSAoIGtleSApIHtcbiAgXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwga2V5ID09PSAnJyApIHJldHVybiB0aGlzO1xuXG4gIFx0XHRpZiAoICF0aGlzLmNoaWxkQnlLZXkuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuICBcdFx0XHR2YXIgY2hpbGQgPSBuZXcgUmVmZXJlbmNlRXhwcmVzc2lvbkNoaWxkKCB0aGlzLCBrZXkgKTtcbiAgXHRcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKCBjaGlsZCApO1xuICBcdFx0XHR0aGlzLmNoaWxkQnlLZXlbIGtleSBdID0gY2hpbGQ7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzLmNoaWxkQnlLZXlbIGtleSBdO1xuICBcdH07XG5cbiAgXHRSZWZlcmVuY2VFeHByZXNzaW9uQ2hpbGQucHJvdG90eXBlLnJldHJpZXZlID0gZnVuY3Rpb24gcmV0cmlldmUgKCkge1xuICBcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50LmdldCgpO1xuICBcdFx0cmV0dXJuIHBhcmVudCAmJiB0aGlzLmtleSBpbiBwYXJlbnQgPyBwYXJlbnRbIHRoaXMua2V5IF0gOiB1bmRlZmluZWQ7XG4gIFx0fTtcblxuICBcdHJldHVybiBSZWZlcmVuY2VFeHByZXNzaW9uQ2hpbGQ7XG4gIH0oTW9kZWwpKTtcblxuICB2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblByb3h5ID0gKGZ1bmN0aW9uIChNb2RlbCkge1xuICBcdGZ1bmN0aW9uIFJlZmVyZW5jZUV4cHJlc3Npb25Qcm94eSAoIGZyYWdtZW50LCB0ZW1wbGF0ZSApIHtcbiAgXHRcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHRNb2RlbC5jYWxsKCB0aGlzLCBudWxsLCBudWxsICk7XG4gIFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgXHRcdHRoaXMucm9vdCA9IGZyYWdtZW50LnJhY3RpdmUudmlld21vZGVsO1xuICBcdFx0dGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuXG4gIFx0XHR0aGlzLnJlc29sdmVycyA9IFtdO1xuXG4gIFx0XHR0aGlzLmJhc2UgPSByZXNvbHZlJDIoIGZyYWdtZW50LCB0ZW1wbGF0ZSApO1xuICBcdFx0dmFyIGJhc2VSZXNvbHZlcjtcblxuICBcdFx0aWYgKCAhdGhpcy5iYXNlICkge1xuICBcdFx0XHRiYXNlUmVzb2x2ZXIgPSBmcmFnbWVudC5yZXNvbHZlKCB0ZW1wbGF0ZS5yLCBmdW5jdGlvbiAoIG1vZGVsICkge1xuICBcdFx0XHRcdHRoaXMkMS5iYXNlID0gbW9kZWw7XG4gIFx0XHRcdFx0dGhpcyQxLmJ1YmJsZSgpO1xuXG4gIFx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzJDEucmVzb2x2ZXJzLCBiYXNlUmVzb2x2ZXIgKTtcbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0dGhpcy5yZXNvbHZlcnMucHVzaCggYmFzZVJlc29sdmVyICk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBpbnRlcm1lZGlhcnkgPSB0aGlzLmludGVybWVkaWFyeSA9IHtcbiAgXHRcdFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuaGFuZGxlQ2hhbmdlKCk7IH0sXG4gIFx0XHRcdHJlYmluZGluZzogZnVuY3Rpb24gKCBuZXh0LCBwcmV2aW91cyApIHtcbiAgXHRcdFx0XHRpZiAoIHByZXZpb3VzID09PSB0aGlzJDEuYmFzZSApIHtcbiAgXHRcdFx0XHRcdG5leHQgPSByZWJpbmRNYXRjaCggdGVtcGxhdGUsIG5leHQsIHByZXZpb3VzICk7XG4gIFx0XHRcdFx0XHRpZiAoIG5leHQgIT09IHRoaXMkMS5iYXNlICkge1xuICBcdFx0XHRcdFx0XHR0aGlzJDEuYmFzZS51bnJlZ2lzdGVyKCBpbnRlcm1lZGlhcnkgKTtcbiAgXHRcdFx0XHRcdFx0dGhpcyQxLmJhc2UgPSBuZXh0O1xuICBcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZiB0aGVyZSBpcyBubyBuZXh0LCBzZXQgdXAgYSByZXNvbHZlcj9cbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0dmFyIGlkeCA9IHRoaXMkMS5tZW1iZXJzLmluZGV4T2YoIHByZXZpb3VzICk7XG4gIFx0XHRcdFx0XHRpZiAoIH5pZHggKSB7XG4gIFx0XHRcdFx0XHRcdC8vIG9ubHkgZGlyZWN0IHJlZmVyZW5jZXMgd2lsbCByZWJpbmQuLi4gZXhwcmVzc2lvbnMgaGFuZGxlIHRoZW1zZWx2ZXNcbiAgXHRcdFx0XHRcdFx0bmV4dCA9IHJlYmluZE1hdGNoKCB0ZW1wbGF0ZS5tW2lkeF0ubiwgbmV4dCwgcHJldmlvdXMgKTtcbiAgXHRcdFx0XHRcdFx0aWYgKCBuZXh0ICE9PSB0aGlzJDEubWVtYmVyc1tpZHhdICkge1xuICBcdFx0XHRcdFx0XHRcdHRoaXMkMS5tZW1iZXJzLnNwbGljZSggaWR4LCAxLCBuZXh0ICk7XG4gIFx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWYgdGhlcmUgaXMgbm8gbmV4dCwgc2V0IHVwIGEgcmVzb2x2ZXI/XG4gIFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoIG5leHQgIT09IHByZXZpb3VzICkgcHJldmlvdXMudW5yZWdpc3RlciggaW50ZXJtZWRpYXJ5ICk7XG4gIFx0XHRcdFx0aWYgKCBuZXh0ICkgbmV4dC5hZGRTaHVmZmxlVGFzayggZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV4dC5yZWdpc3RlciggaW50ZXJtZWRpYXJ5ICk7IH0gKTtcblxuICBcdFx0XHRcdHRoaXMkMS5idWJibGUoKTtcbiAgXHRcdFx0fVxuICBcdFx0fTtcblxuICBcdFx0dGhpcy5tZW1iZXJzID0gdGVtcGxhdGUubS5tYXAoIGZ1bmN0aW9uICggdGVtcGxhdGUsIGkgKSB7XG4gIFx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyApIHtcbiAgXHRcdFx0XHRyZXR1cm4geyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRlbXBsYXRlOyB9IH07XG4gIFx0XHRcdH1cblxuICBcdFx0XHR2YXIgbW9kZWw7XG4gIFx0XHRcdHZhciByZXNvbHZlcjtcblxuICBcdFx0XHRpZiAoIHRlbXBsYXRlLnQgPT09IFJFRkVSRU5DRSApIHtcbiAgXHRcdFx0XHRtb2RlbCA9IHJlc29sdmVSZWZlcmVuY2UoIGZyYWdtZW50LCB0ZW1wbGF0ZS5uICk7XG5cbiAgXHRcdFx0XHRpZiAoIG1vZGVsICkge1xuICBcdFx0XHRcdFx0bW9kZWwucmVnaXN0ZXIoIGludGVybWVkaWFyeSApO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRyZXNvbHZlciA9IGZyYWdtZW50LnJlc29sdmUoIHRlbXBsYXRlLm4sIGZ1bmN0aW9uICggbW9kZWwgKSB7XG4gIFx0XHRcdFx0XHRcdHRoaXMkMS5tZW1iZXJzW2ldID0gbW9kZWw7XG5cbiAgXHRcdFx0XHRcdFx0bW9kZWwucmVnaXN0ZXIoIGludGVybWVkaWFyeSApO1xuICBcdFx0XHRcdFx0XHR0aGlzJDEuaGFuZGxlQ2hhbmdlKCk7XG5cbiAgXHRcdFx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzJDEucmVzb2x2ZXJzLCByZXNvbHZlciApO1xuICBcdFx0XHRcdFx0fSk7XG5cbiAgXHRcdFx0XHRcdHRoaXMkMS5yZXNvbHZlcnMucHVzaCggcmVzb2x2ZXIgKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRyZXR1cm4gbW9kZWw7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRtb2RlbCA9IG5ldyBFeHByZXNzaW9uUHJveHkoIGZyYWdtZW50LCB0ZW1wbGF0ZSApO1xuICBcdFx0XHRtb2RlbC5yZWdpc3RlciggaW50ZXJtZWRpYXJ5ICk7XG4gIFx0XHRcdHJldHVybiBtb2RlbDtcbiAgXHRcdH0pO1xuXG4gIFx0XHR0aGlzLmlzVW5yZXNvbHZlZCA9IHRydWU7XG4gIFx0XHR0aGlzLmJ1YmJsZSgpO1xuICBcdH1cblxuICBcdFJlZmVyZW5jZUV4cHJlc3Npb25Qcm94eS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNb2RlbCAmJiBNb2RlbC5wcm90b3R5cGUgKTtcbiAgXHRSZWZlcmVuY2VFeHByZXNzaW9uUHJveHkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVmZXJlbmNlRXhwcmVzc2lvblByb3h5O1xuXG4gIFx0UmVmZXJlbmNlRXhwcmVzc2lvblByb3h5LnByb3RvdHlwZS5idWJibGUgPSBmdW5jdGlvbiBidWJibGUgKCkge1xuICBcdFx0aWYgKCAhdGhpcy5iYXNlICkgcmV0dXJuO1xuICBcdFx0aWYgKCAhdGhpcy5kaXJ0eSApIHRoaXMuaGFuZGxlQ2hhbmdlKCk7XG4gIFx0fTtcblxuICBcdFJlZmVyZW5jZUV4cHJlc3Npb25Qcm94eS5wcm90b3R5cGUuZm9yY2VSZXNvbHV0aW9uID0gZnVuY3Rpb24gZm9yY2VSZXNvbHV0aW9uICgpIHtcbiAgXHRcdHRoaXMucmVzb2x2ZXJzLmZvckVhY2goIGZ1bmN0aW9uICggcmVzb2x2ZXIgKSB7IHJldHVybiByZXNvbHZlci5mb3JjZVJlc29sdXRpb24oKTsgfSApO1xuICBcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG4gIFx0XHR0aGlzLmJ1YmJsZSgpO1xuICBcdH07XG5cbiAgXHRSZWZlcmVuY2VFeHByZXNzaW9uUHJveHkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoIHNob3VsZENhcHR1cmUgKSB7XG4gIFx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0aWYgKCB0aGlzLmRpcnR5ICkge1xuICBcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXG4gIFx0XHRcdHZhciBpID0gdGhpcy5tZW1iZXJzLmxlbmd0aCwgcmVzb2x2ZWQgPSB0cnVlO1xuICBcdFx0XHR3aGlsZSAoIHJlc29sdmVkICYmIGktLSApIHtcbiAgXHRcdFx0XHRpZiAoICF0aGlzJDEubWVtYmVyc1tpXSApIHJlc29sdmVkID0gZmFsc2U7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIHRoaXMuYmFzZSAmJiByZXNvbHZlZCApIHtcbiAgXHRcdFx0XHR2YXIga2V5cyA9IHRoaXMubWVtYmVycy5tYXAoIGZ1bmN0aW9uICggbSApIHsgcmV0dXJuIGVzY2FwZUtleSggU3RyaW5nKCBtLmdldCgpICkgKTsgfSApO1xuICBcdFx0XHRcdHZhciBtb2RlbCA9IHRoaXMuYmFzZS5qb2luQWxsKCBrZXlzICk7XG5cbiAgXHRcdFx0XHRpZiAoIG1vZGVsICE9PSB0aGlzLm1vZGVsICkge1xuICBcdFx0XHRcdFx0aWYgKCB0aGlzLm1vZGVsICkge1xuICBcdFx0XHRcdFx0XHR0aGlzLm1vZGVsLnVucmVnaXN0ZXIoIHRoaXMgKTtcbiAgXHRcdFx0XHRcdFx0dGhpcy5tb2RlbC51bnJlZ2lzdGVyVHdvd2F5QmluZGluZyggdGhpcyApO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHR0aGlzLm1vZGVsID0gbW9kZWw7XG4gIFx0XHRcdFx0XHR0aGlzLnBhcmVudCA9IG1vZGVsLnBhcmVudDtcbiAgXHRcdFx0XHRcdHRoaXMubW9kZWwucmVnaXN0ZXIoIHRoaXMgKTtcbiAgXHRcdFx0XHRcdHRoaXMubW9kZWwucmVnaXN0ZXJUd293YXlCaW5kaW5nKCB0aGlzICk7XG5cbiAgXHRcdFx0XHRcdGlmICggdGhpcy5rZXlwYXRoTW9kZWwgKSB0aGlzLmtleXBhdGhNb2RlbC5oYW5kbGVDaGFuZ2UoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5tb2RlbCA/IHRoaXMubW9kZWwuZ2V0KCBzaG91bGRDYXB0dXJlICkgOiB1bmRlZmluZWQ7XG4gIFx0XHRcdHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgXHRcdFx0dGhpcy5tYXJrKCk7XG4gIFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMubW9kZWwgPyB0aGlzLm1vZGVsLmdldCggc2hvdWxkQ2FwdHVyZSApIDogdW5kZWZpbmVkO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHQvLyBpbmRpcmVjdCB0d28td2F5IGJpbmRpbmdzXG4gIFx0UmVmZXJlbmNlRXhwcmVzc2lvblByb3h5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlICgpIHtcbiAgXHRcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHR0aGlzLnZhbHVlID0gdGhpcy5tb2RlbCA/IHRoaXMubW9kZWwuZ2V0KCkgOiB1bmRlZmluZWQ7XG5cbiAgXHRcdHZhciBpID0gdGhpcy5iaW5kaW5ncy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdFx0dmFyIHZhbHVlID0gdGhpcyQxLmJpbmRpbmdzW2ldLmdldFZhbHVlKCk7XG4gIFx0XHRcdGlmICggdmFsdWUgIT09IHRoaXMkMS52YWx1ZSApIHJldHVybiB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gY2hlY2sgb25lLXdheSBiaW5kaW5nc1xuICBcdFx0dmFyIG9uZXdheSA9IGZpbmRCb3VuZFZhbHVlKCB0aGlzLmRlcHMgKTtcbiAgXHRcdGlmICggb25ld2F5ICkgcmV0dXJuIG9uZXdheS52YWx1ZTtcblxuICBcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIFx0fTtcblxuICBcdFJlZmVyZW5jZUV4cHJlc3Npb25Qcm94eS5wcm90b3R5cGUuZ2V0S2V5cGF0aCA9IGZ1bmN0aW9uIGdldEtleXBhdGggKCkge1xuICBcdFx0cmV0dXJuIHRoaXMubW9kZWwgPyB0aGlzLm1vZGVsLmdldEtleXBhdGgoKSA6ICdAdW5kZWZpbmVkJztcbiAgXHR9O1xuXG4gIFx0UmVmZXJlbmNlRXhwcmVzc2lvblByb3h5LnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UkMSAoKSB7XG4gIFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgXHRcdHRoaXMubWFyaygpO1xuICBcdH07XG5cbiAgXHRSZWZlcmVuY2VFeHByZXNzaW9uUHJveHkucHJvdG90eXBlLmpvaW5LZXkgPSBmdW5jdGlvbiBqb2luS2V5ICgga2V5ICkge1xuICBcdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBrZXkgPT09ICcnICkgcmV0dXJuIHRoaXM7XG5cbiAgXHRcdGlmICggIXRoaXMuY2hpbGRCeUtleS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG4gIFx0XHRcdHZhciBjaGlsZCA9IG5ldyBSZWZlcmVuY2VFeHByZXNzaW9uQ2hpbGQoIHRoaXMsIGtleSApO1xuICBcdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goIGNoaWxkICk7XG4gIFx0XHRcdHRoaXMuY2hpbGRCeUtleVsga2V5IF0gPSBjaGlsZDtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMuY2hpbGRCeUtleVsga2V5IF07XG4gIFx0fTtcblxuICBcdFJlZmVyZW5jZUV4cHJlc3Npb25Qcm94eS5wcm90b3R5cGUubWFyayA9IGZ1bmN0aW9uIG1hcmskMSAoKSB7XG4gIFx0XHRpZiAoIHRoaXMuZGlydHkgKSB7XG4gIFx0XHRcdHRoaXMuZGVwcy5mb3JFYWNoKCBoYW5kbGVDaGFuZ2UgKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5saW5rcy5mb3JFYWNoKCBtYXJrZWQgKTtcbiAgXHRcdHRoaXMuY2hpbGRyZW4uZm9yRWFjaCggbWFyayApO1xuICBcdFx0dGhpcy5jbGVhclVucmVzb2x2ZWRzKCk7XG4gIFx0fTtcblxuICBcdFJlZmVyZW5jZUV4cHJlc3Npb25Qcm94eS5wcm90b3R5cGUucmV0cmlldmUgPSBmdW5jdGlvbiByZXRyaWV2ZSAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHR9O1xuXG4gIFx0UmVmZXJlbmNlRXhwcmVzc2lvblByb3h5LnByb3RvdHlwZS5yZWJpbmRpbmcgPSBmdW5jdGlvbiByZWJpbmRpbmcgKCkgeyB9OyAvLyBOT09QXG5cbiAgXHRSZWZlcmVuY2VFeHByZXNzaW9uUHJveHkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoIHZhbHVlICkge1xuICBcdFx0aWYgKCAhdGhpcy5tb2RlbCApIHRocm93IG5ldyBFcnJvciggJ1VucmVzb2x2ZWQgcmVmZXJlbmNlIGV4cHJlc3Npb24uIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4hJyApO1xuICBcdFx0dGhpcy5tb2RlbC5zZXQoIHZhbHVlICk7XG4gIFx0fTtcblxuICBcdFJlZmVyZW5jZUV4cHJlc3Npb25Qcm94eS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gdW5iaW5kJDEgKCkge1xuICBcdFx0dGhpcy5yZXNvbHZlcnMuZm9yRWFjaCggdW5iaW5kICk7XG4gIFx0XHRpZiAoIHRoaXMubW9kZWwgKSB7XG4gIFx0XHRcdHRoaXMubW9kZWwudW5yZWdpc3RlciggdGhpcyApO1xuICBcdFx0XHR0aGlzLm1vZGVsLnVucmVnaXN0ZXJUd293YXlCaW5kaW5nKCB0aGlzICk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdHJldHVybiBSZWZlcmVuY2VFeHByZXNzaW9uUHJveHk7XG4gIH0oTW9kZWwpKTtcblxuICBmdW5jdGlvbiByZXNvbHZlJDIgKCBmcmFnbWVudCwgdGVtcGxhdGUgKSB7XG4gIFx0aWYgKCB0ZW1wbGF0ZS5yICkge1xuICBcdFx0cmV0dXJuIHJlc29sdmVSZWZlcmVuY2UoIGZyYWdtZW50LCB0ZW1wbGF0ZS5yICk7XG4gIFx0fVxuXG4gIFx0ZWxzZSBpZiAoIHRlbXBsYXRlLnggKSB7XG4gIFx0XHRyZXR1cm4gbmV3IEV4cHJlc3Npb25Qcm94eSggZnJhZ21lbnQsIHRlbXBsYXRlLnggKTtcbiAgXHR9XG5cbiAgXHRlbHNlIGlmICggdGVtcGxhdGUucnggKSB7XG4gIFx0XHRyZXR1cm4gbmV3IFJlZmVyZW5jZUV4cHJlc3Npb25Qcm94eSggZnJhZ21lbnQsIHRlbXBsYXRlLnJ4ICk7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUFsaWFzZXMoIHNlY3Rpb24gKSB7XG4gIFx0aWYgKCBzZWN0aW9uLnRlbXBsYXRlLnogKSB7XG4gIFx0XHRzZWN0aW9uLmFsaWFzZXMgPSB7fTtcblxuICBcdFx0dmFyIHJlZnMgPSBzZWN0aW9uLnRlbXBsYXRlLno7XG4gIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCByZWZzLmxlbmd0aDsgaSsrICkge1xuICBcdFx0XHRzZWN0aW9uLmFsaWFzZXNbIHJlZnNbaV0ubiBdID0gcmVzb2x2ZSQyKCBzZWN0aW9uLnBhcmVudEZyYWdtZW50LCByZWZzW2ldLnggKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgQWxpYXMgPSAoZnVuY3Rpb24gKEl0ZW0pIHtcbiAgXHRmdW5jdGlvbiBBbGlhcyAoIG9wdGlvbnMgKSB7XG4gIFx0XHRJdGVtLmNhbGwoIHRoaXMsIG9wdGlvbnMgKTtcblxuICBcdFx0dGhpcy5mcmFnbWVudCA9IG51bGw7XG4gIFx0fVxuXG4gIFx0QWxpYXMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSXRlbSAmJiBJdGVtLnByb3RvdHlwZSApO1xuICBcdEFsaWFzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFsaWFzO1xuXG4gIFx0QWxpYXMucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiBiaW5kICgpIHtcbiAgXHRcdHJlc29sdmVBbGlhc2VzKCB0aGlzICk7XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoe1xuICBcdFx0XHRvd25lcjogdGhpcyxcbiAgXHRcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUuZlxuICBcdFx0fSkuYmluZCgpO1xuICBcdH07XG5cbiAgXHRBbGlhcy5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gZGV0YWNoICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50ID8gdGhpcy5mcmFnbWVudC5kZXRhY2goKSA6IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgXHR9O1xuXG4gIFx0QWxpYXMucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiBmaW5kICggc2VsZWN0b3IgKSB7XG4gIFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdEFsaWFzLnByb3RvdHlwZS5maW5kQWxsID0gZnVuY3Rpb24gZmluZEFsbCAoIHNlbGVjdG9yLCBxdWVyeSApIHtcbiAgXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0QWxpYXMucHJvdG90eXBlLmZpbmRDb21wb25lbnQgPSBmdW5jdGlvbiBmaW5kQ29tcG9uZW50ICggbmFtZSApIHtcbiAgXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudCggbmFtZSApO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRBbGlhcy5wcm90b3R5cGUuZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiBmaW5kQWxsQ29tcG9uZW50cyAoIG5hbWUsIHF1ZXJ5ICkge1xuICBcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBuYW1lLCBxdWVyeSApO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRBbGlhcy5wcm90b3R5cGUuZmlyc3ROb2RlID0gZnVuY3Rpb24gZmlyc3ROb2RlICggc2tpcFBhcmVudCApIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50ICYmIHRoaXMuZnJhZ21lbnQuZmlyc3ROb2RlKCBza2lwUGFyZW50ICk7XG4gIFx0fTtcblxuICBcdEFsaWFzLnByb3RvdHlwZS5yZWJpbmRpbmcgPSBmdW5jdGlvbiByZWJpbmRpbmcgKCkge1xuICBcdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdGlmICggdGhpcy5sb2NrZWQgKSByZXR1cm47XG4gIFx0XHR0aGlzLmxvY2tlZCA9IHRydWU7XG4gIFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24gKCkge1xuICBcdFx0XHR0aGlzJDEubG9ja2VkID0gZmFsc2U7XG4gIFx0XHRcdHJlc29sdmVBbGlhc2VzKCB0aGlzJDEgKTtcbiAgXHRcdH0pO1xuICBcdH07XG5cbiAgXHRBbGlhcy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICggdGFyZ2V0ICkge1xuICBcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB0aGlzLmZyYWdtZW50LnJlbmRlciggdGFyZ2V0ICk7XG4gIFx0fTtcblxuICBcdEFsaWFzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICggZXNjYXBlICkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQgPyB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCBlc2NhcGUgKSA6ICcnO1xuICBcdH07XG5cbiAgXHRBbGlhcy5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gdW5iaW5kICgpIHtcbiAgXHRcdHRoaXMuYWxpYXNlcyA9IHt9O1xuICBcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkgdGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9O1xuXG4gIFx0QWxpYXMucHJvdG90eXBlLnVucmVuZGVyID0gZnVuY3Rpb24gdW5yZW5kZXIgKCBzaG91bGREZXN0cm95ICkge1xuICBcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICYmIHRoaXMuZnJhZ21lbnQgKSB0aGlzLmZyYWdtZW50LnVucmVuZGVyKCBzaG91bGREZXN0cm95ICk7XG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gIFx0fTtcblxuICBcdEFsaWFzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICBcdFx0aWYgKCB0aGlzLmRpcnR5ICkge1xuICBcdFx0XHR0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudXBkYXRlKCk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdHJldHVybiBBbGlhcztcbiAgfShJdGVtKSk7XG5cbiAgZnVuY3Rpb24gZmluZEVsZW1lbnQoIHN0YXJ0LCBvckNvbXBvbmVudCwgbmFtZSApIHtcbiAgXHRpZiAoIG9yQ29tcG9uZW50ID09PSB2b2lkIDAgKSBvckNvbXBvbmVudCA9IHRydWU7XG5cbiAgXHR3aGlsZSAoIHN0YXJ0ICYmICggc3RhcnQudHlwZSAhPT0gRUxFTUVOVCB8fCAoIG5hbWUgJiYgc3RhcnQubmFtZSAhPT0gbmFtZSApICkgJiYgKCAhb3JDb21wb25lbnQgfHwgc3RhcnQudHlwZSAhPT0gQ09NUE9ORU5UICkgKSB7XG4gIFx0XHQvLyBzdGFydCBpcyBhIGZyYWdtZW50IC0gbG9vayBhdCB0aGUgb3duZXJcbiAgXHRcdGlmICggc3RhcnQub3duZXIgKSBzdGFydCA9IHN0YXJ0Lm93bmVyO1xuICBcdFx0Ly8gc3RhcnQgaXMgYSBjb21wb25lbnQgb3IgeWllbGRlciAtIGxvb2sgYXQgdGhlIGNvbnRhaW5lclxuICBcdFx0ZWxzZSBpZiAoIHN0YXJ0LmNvbXBvbmVudCApIHN0YXJ0ID0gc3RhcnQuY29udGFpbmVyRnJhZ21lbnQgfHwgc3RhcnQuY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuICBcdFx0Ly8gc3RhcnQgaXMgYW4gaXRlbSAtIGxvb2sgYXQgdGhlIHBhcmVudFxuICBcdFx0ZWxzZSBpZiAoIHN0YXJ0LnBhcmVudCApIHN0YXJ0ID0gc3RhcnQucGFyZW50O1xuICBcdFx0Ly8gc3RhcnQgaXMgYW4gaXRlbSB3aXRob3V0IGEgcGFyZW50IC0gbG9vayBhdCB0aGUgcGFyZW50IGZyYWdtZW50XG4gIFx0XHRlbHNlIGlmICggc3RhcnQucGFyZW50RnJhZ21lbnQgKSBzdGFydCA9IHN0YXJ0LnBhcmVudEZyYWdtZW50O1xuXG4gIFx0XHRlbHNlIHN0YXJ0ID0gdW5kZWZpbmVkO1xuICBcdH1cblxuICBcdHJldHVybiBzdGFydDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbWVsQ2FzZSAoIGh5cGhlbmF0ZWRTdHIgKSB7XG4gIFx0cmV0dXJuIGh5cGhlbmF0ZWRTdHIucmVwbGFjZSggLy0oW2EtekEtWl0pL2csIGZ1bmN0aW9uICggbWF0Y2gsICQxICkge1xuICBcdFx0cmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7XG4gIFx0fSk7XG4gIH1cblxuICB2YXIgc3BhY2UgPSAvXFxzKy87XG4gIHZhciBzcGVjaWFscyQyID0geyAnZmxvYXQnOiAnY3NzRmxvYXQnIH07XG4gIHZhciByZW1vdmUgPSAvXFwvXFwqKD86W1xcc1xcU10qPylcXCpcXC8vZztcbiAgdmFyIGVzY2FwZSA9IC91cmxcXChcXHMqKFsnXCJdKSg/OlxcXFxbXFxzXFxTXXwoPyFcXDEpLikqXFwxXFxzKlxcKXx1cmxcXCgoPzpcXFxcW1xcc1xcU118W14pXSkqXFwpfChbJ1wiXSkoPzpcXFxcW1xcc1xcU118KD8hXFwxKS4pKlxcMi9naTtcbiAgdmFyIHZhbHVlID0gL1xcMChcXGQrKS9nO1xuXG4gIGZ1bmN0aW9uIHJlYWRTdHlsZSAoIGNzcyApIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgICAgaWYgKCB0eXBlb2YgY3NzICE9PSAnc3RyaW5nJyApIHJldHVybiB7fTtcblxuICAgICAgcmV0dXJuIGNzcy5yZXBsYWNlKCBlc2NhcGUsIGZ1bmN0aW9uICggbWF0Y2ggKSB7IHJldHVybiAoXCJcXHUwMDAwXCIgKyAodmFsdWVzLnB1c2goIG1hdGNoICkgLSAxKSk7IH0pXG4gICAgICAgICAgLnJlcGxhY2UoIHJlbW92ZSwgJycgKVxuICAgICAgICAgIC5zcGxpdCggJzsnIClcbiAgICAgICAgICAuZmlsdGVyKCBmdW5jdGlvbiAoIHJ1bGUgKSB7IHJldHVybiAhIXJ1bGUudHJpbSgpOyB9IClcbiAgICAgICAgICAubWFwKCBmdW5jdGlvbiAoIHJ1bGUgKSB7IHJldHVybiBydWxlLnJlcGxhY2UoIHZhbHVlLCBmdW5jdGlvbiAoIG1hdGNoLCBuICkgeyByZXR1cm4gdmFsdWVzWyBuIF07IH0gKTsgfSApXG4gICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoIHJ1bGVzLCBydWxlICkge1xuICAgICAgICAgICAgICB2YXIgaSA9IHJ1bGUuaW5kZXhPZignOicpO1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IGNhbWVsQ2FzZSggcnVsZS5zdWJzdHIoIDAsIGkgKS50cmltKCkgKTtcbiAgICAgICAgICAgICAgcnVsZXNbIHNwZWNpYWxzJDJbIG5hbWUgXSB8fCBuYW1lIF0gPSBydWxlLnN1YnN0ciggaSArIDEgKS50cmltKCk7XG4gICAgICAgICAgICAgIHJldHVybiBydWxlcztcbiAgICAgICAgICB9LCB7fSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkQ2xhc3MgKCBzdHIgKSB7XG4gICAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoIHNwYWNlICk7XG5cbiAgICAvLyByZW1vdmUgYW55IGVtcHR5IGVudHJpZXNcbiAgICB2YXIgaSA9IGxpc3QubGVuZ3RoO1xuICAgIHdoaWxlICggaS0tICkge1xuICAgICAgaWYgKCAhbGlzdFtpXSApIGxpc3Quc3BsaWNlKCBpLCAxICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICB2YXIgdGV4dFR5cGVzID0gWyB1bmRlZmluZWQsICd0ZXh0JywgJ3NlYXJjaCcsICd1cmwnLCAnZW1haWwnLCAnaGlkZGVuJywgJ3Bhc3N3b3JkJywgJ3NlYXJjaCcsICdyZXNldCcsICdzdWJtaXQnIF07XG5cbiAgZnVuY3Rpb24gZ2V0VXBkYXRlRGVsZWdhdGUgKCBhdHRyaWJ1dGUgKSB7XG4gIFx0dmFyIGVsZW1lbnQgPSBhdHRyaWJ1dGUuZWxlbWVudCwgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xuXG4gIFx0aWYgKCBuYW1lID09PSAnaWQnICkgcmV0dXJuIHVwZGF0ZUlkO1xuXG4gIFx0aWYgKCBuYW1lID09PSAndmFsdWUnICkge1xuICBcdFx0aWYgKCBhdHRyaWJ1dGUuaW50ZXJwb2xhdG9yICkgYXR0cmlidXRlLmludGVycG9sYXRvci5ib3VuZCA9IHRydWU7XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIHNlbGVjdHNcbiAgXHRcdGlmICggZWxlbWVudC5uYW1lID09PSAnc2VsZWN0JyAmJiBuYW1lID09PSAndmFsdWUnICkge1xuICBcdFx0XHRyZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdtdWx0aXBsZScgKSA/IHVwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUgOiB1cGRhdGVTZWxlY3RWYWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCBlbGVtZW50Lm5hbWUgPT09ICd0ZXh0YXJlYScgKSByZXR1cm4gdXBkYXRlU3RyaW5nVmFsdWU7XG5cbiAgXHRcdC8vIHNwZWNpYWwgY2FzZSAtIGNvbnRlbnRlZGl0YWJsZVxuICBcdFx0aWYgKCBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NvbnRlbnRlZGl0YWJsZScgKSAhPSBudWxsICkgcmV0dXJuIHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlO1xuXG4gIFx0XHQvLyBzcGVjaWFsIGNhc2UgLSA8aW5wdXQ+XG4gIFx0XHRpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ2lucHV0JyApIHtcbiAgXHRcdFx0dmFyIHR5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3R5cGUnICk7XG5cbiAgXHRcdFx0Ly8gdHlwZT0nZmlsZScgdmFsdWU9J3t7ZmlsZUxpc3R9fSc+XG4gIFx0XHRcdGlmICggdHlwZSA9PT0gJ2ZpbGUnICkgcmV0dXJuIG5vb3A7IC8vIHJlYWQtb25seVxuXG4gIFx0XHRcdC8vIHR5cGU9J3JhZGlvJyBuYW1lPSd7e3R3b3dheX19J1xuICBcdFx0XHRpZiAoIHR5cGUgPT09ICdyYWRpbycgJiYgZWxlbWVudC5iaW5kaW5nICYmIGVsZW1lbnQuYmluZGluZy5hdHRyaWJ1dGUubmFtZSA9PT0gJ25hbWUnICkgcmV0dXJuIHVwZGF0ZVJhZGlvVmFsdWU7XG5cbiAgXHRcdFx0aWYgKCB+dGV4dFR5cGVzLmluZGV4T2YoIHR5cGUgKSApIHJldHVybiB1cGRhdGVTdHJpbmdWYWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHVwZGF0ZVZhbHVlO1xuICBcdH1cblxuICBcdHZhciBub2RlID0gZWxlbWVudC5ub2RlO1xuXG4gIFx0Ly8gc3BlY2lhbCBjYXNlIC0gPGlucHV0IHR5cGU9J3JhZGlvJyBuYW1lPSd7e3R3b3dheX19JyB2YWx1ZT0nZm9vJz5cbiAgXHRpZiAoIGF0dHJpYnV0ZS5pc1R3b3dheSAmJiBuYW1lID09PSAnbmFtZScgKSB7XG4gIFx0XHRpZiAoIG5vZGUudHlwZSA9PT0gJ3JhZGlvJyApIHJldHVybiB1cGRhdGVSYWRpb05hbWU7XG4gIFx0XHRpZiAoIG5vZGUudHlwZSA9PT0gJ2NoZWNrYm94JyApIHJldHVybiB1cGRhdGVDaGVja2JveE5hbWU7XG4gIFx0fVxuXG4gIFx0aWYgKCBuYW1lID09PSAnc3R5bGUnICkgcmV0dXJuIHVwZGF0ZVN0eWxlQXR0cmlidXRlO1xuXG4gIFx0aWYgKCBuYW1lLmluZGV4T2YoICdzdHlsZS0nICkgPT09IDAgKSByZXR1cm4gdXBkYXRlSW5saW5lU3R5bGU7XG5cbiAgXHQvLyBzcGVjaWFsIGNhc2UgLSBjbGFzcyBuYW1lcy4gSUUgZnVja3MgdGhpbmdzIHVwLCBhZ2FpblxuICBcdGlmICggbmFtZSA9PT0gJ2NsYXNzJyAmJiAoICFub2RlLm5hbWVzcGFjZVVSSSB8fCBub2RlLm5hbWVzcGFjZVVSSSA9PT0gaHRtbCApICkgcmV0dXJuIHVwZGF0ZUNsYXNzTmFtZTtcblxuICBcdGlmICggbmFtZS5pbmRleE9mKCAnY2xhc3MtJyApID09PSAwICkgcmV0dXJuIHVwZGF0ZUlubGluZUNsYXNzO1xuXG4gIFx0aWYgKCBhdHRyaWJ1dGUuaXNCb29sZWFuICkge1xuICBcdFx0dmFyIHR5cGUkMSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndHlwZScgKTtcbiAgXHRcdGlmICggYXR0cmlidXRlLmludGVycG9sYXRvciAmJiBuYW1lID09PSAnY2hlY2tlZCcgJiYgKCB0eXBlJDEgPT09ICdjaGVja2JveCcgfHwgdHlwZSQxID09PSAncmFkaW8nICkgKSBhdHRyaWJ1dGUuaW50ZXJwb2xhdG9yLmJvdW5kID0gdHJ1ZTtcbiAgXHRcdHJldHVybiB1cGRhdGVCb29sZWFuO1xuICBcdH1cblxuICBcdGlmICggYXR0cmlidXRlLm5hbWVzcGFjZSAmJiBhdHRyaWJ1dGUubmFtZXNwYWNlICE9PSBhdHRyaWJ1dGUubm9kZS5uYW1lc3BhY2VVUkkgKSByZXR1cm4gdXBkYXRlTmFtZXNwYWNlZEF0dHJpYnV0ZTtcblxuICBcdHJldHVybiB1cGRhdGVBdHRyaWJ1dGU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVJZCAoIHJlc2V0ICkge1xuICBcdHZhciByZWYgPSB0aGlzLCBub2RlID0gcmVmLm5vZGU7XG4gIFx0dmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG4gIFx0Ly8gcmVtb3ZlIHRoZSBtYXBwaW5nIHRvIHRoaXMgbm9kZSBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIHJlcGxhY2VkXG4gIFx0aWYgKCB0aGlzLnJhY3RpdmUubm9kZXNbIG5vZGUuaWQgXSA9PT0gbm9kZSApIGRlbGV0ZSB0aGlzLnJhY3RpdmUubm9kZXNbIG5vZGUuaWQgXTtcbiAgXHRpZiAoIHJlc2V0ICkgcmV0dXJuIG5vZGUucmVtb3ZlQXR0cmlidXRlKCAnaWQnICk7XG5cbiAgXHR0aGlzLnJhY3RpdmUubm9kZXNbIHZhbHVlIF0gPSBub2RlO1xuXG4gIFx0bm9kZS5pZCA9IHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSAoIHJlc2V0ICkge1xuICBcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICBcdGlmICggIWlzQXJyYXkoIHZhbHVlICkgKSB2YWx1ZSA9IFsgdmFsdWUgXTtcblxuICBcdHZhciBvcHRpb25zID0gdGhpcy5ub2RlLm9wdGlvbnM7XG4gIFx0dmFyIGkgPSBvcHRpb25zLmxlbmd0aDtcblxuICBcdGlmICggcmVzZXQgKSB7XG4gIFx0XHR3aGlsZSAoIGktLSApIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRcdHZhciBvcHRpb24gPSBvcHRpb25zW2ldO1xuICBcdFx0XHR2YXIgb3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgP1xuICBcdFx0XHRcdG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6XG4gIFx0XHRcdFx0b3B0aW9uLnZhbHVlOyAvLyBvcHRpb25zIGluc2VydGVkIHZpYSBhIHRyaXBsZSBkb24ndCBoYXZlIF9yYWN0aXZlXG5cbiAgXHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gYXJyYXlDb250YWlucyggdmFsdWUsIG9wdGlvblZhbHVlICk7XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2VsZWN0VmFsdWUgKCByZXNldCApIHtcbiAgXHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgXHRpZiAoICF0aGlzLmxvY2tlZCApIHsgLy8gVE9ETyBpcyBsb2NrZWQgc3RpbGwgYSB0aGluZz9cbiAgXHRcdHRoaXMubm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHZhbHVlO1xuXG4gIFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMubm9kZS5vcHRpb25zO1xuICBcdFx0dmFyIGkgPSBvcHRpb25zLmxlbmd0aDtcbiAgXHRcdHZhciB3YXNTZWxlY3RlZCA9IGZhbHNlO1xuXG4gIFx0XHRpZiAoIHJlc2V0ICkge1xuICBcdFx0XHR3aGlsZSAoIGktLSApIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHdoaWxlICggaS0tICkge1xuICBcdFx0XHRcdHZhciBvcHRpb24gPSBvcHRpb25zW2ldO1xuICBcdFx0XHRcdHZhciBvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/XG4gIFx0XHRcdFx0XHRvcHRpb24uX3JhY3RpdmUudmFsdWUgOlxuICBcdFx0XHRcdFx0b3B0aW9uLnZhbHVlOyAvLyBvcHRpb25zIGluc2VydGVkIHZpYSBhIHRyaXBsZSBkb24ndCBoYXZlIF9yYWN0aXZlXG4gIFx0XHRcdFx0aWYgKCBvcHRpb24uZGlzYWJsZWQgJiYgb3B0aW9uLnNlbGVjdGVkICkgd2FzU2VsZWN0ZWQgPSB0cnVlO1xuXG4gIFx0XHRcdFx0aWYgKCBvcHRpb25WYWx1ZSA9PSB2YWx1ZSApIHsgLy8gZG91YmxlIGVxdWFscyBhcyB3ZSBtYXkgYmUgY29tcGFyaW5nIG51bWJlcnMgd2l0aCBzdHJpbmdzXG4gIFx0XHRcdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICBcdFx0XHRcdFx0cmV0dXJuO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRpZiAoICF3YXNTZWxlY3RlZCApIHRoaXMubm9kZS5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIFx0fVxuICB9XG5cblxuICBmdW5jdGlvbiB1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZSAoIHJlc2V0ICkge1xuICBcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICBcdGlmICggIXRoaXMubG9ja2VkICkge1xuICBcdFx0aWYgKCByZXNldCApIHRoaXMubm9kZS5pbm5lckhUTUwgPSAnJztcbiAgXHRcdGVsc2UgdGhpcy5ub2RlLmlubmVySFRNTCA9IHZhbHVlID09PSB1bmRlZmluZWQgPyAnJyA6IHZhbHVlO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVJhZGlvVmFsdWUgKCByZXNldCApIHtcbiAgXHR2YXIgbm9kZSA9IHRoaXMubm9kZTtcbiAgXHR2YXIgd2FzQ2hlY2tlZCA9IG5vZGUuY2hlY2tlZDtcblxuICBcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICBcdGlmICggcmVzZXQgKSByZXR1cm4gbm9kZS5jaGVja2VkID0gZmFsc2U7XG5cbiAgXHQvL25vZGUudmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG4gIFx0bm9kZS52YWx1ZSA9IHRoaXMubm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHZhbHVlO1xuICBcdG5vZGUuY2hlY2tlZCA9IHZhbHVlID09PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbmFtZScgKTtcblxuICBcdC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgLSBpZiB0aGUgaW5wdXQgd2FzIGNoZWNrZWQsIGFuZCB0aGUgdmFsdWVcbiAgXHQvLyBjaGFuZ2VkIHNvIHRoYXQgaXQncyBubyBsb25nZXIgY2hlY2tlZCwgdGhlIHR3b3dheSBiaW5kaW5nIGlzXG4gIFx0Ly8gbW9zdCBsaWtlbHkgb3V0IG9mIGRhdGUuIFRvIGZpeCBpdCB3ZSBoYXZlIHRvIGp1bXAgdGhyb3VnaCBzb21lXG4gIFx0Ly8gaG9vcHMuLi4gdGhpcyBpcyBhIGxpdHRsZSBrbHVkZ3kgYnV0IGl0IHdvcmtzXG4gIFx0aWYgKCB3YXNDaGVja2VkICYmICFub2RlLmNoZWNrZWQgJiYgdGhpcy5lbGVtZW50LmJpbmRpbmcgJiYgdGhpcy5lbGVtZW50LmJpbmRpbmcucmVuZGVyZWQgKSB7XG4gIFx0XHR0aGlzLmVsZW1lbnQuYmluZGluZy5ncm91cC5tb2RlbC5zZXQoIHRoaXMuZWxlbWVudC5iaW5kaW5nLmdyb3VwLmdldFZhbHVlKCkgKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVWYWx1ZSAoIHJlc2V0ICkge1xuICBcdGlmICggIXRoaXMubG9ja2VkICkge1xuICBcdFx0aWYgKCByZXNldCApIHtcbiAgXHRcdFx0dGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuICBcdFx0XHR0aGlzLm5vZGUudmFsdWUgPSB0aGlzLm5vZGUuX3JhY3RpdmUudmFsdWUgPSBudWxsO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICBcdFx0dGhpcy5ub2RlLnZhbHVlID0gdGhpcy5ub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG4gIFx0XHR0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCAndmFsdWUnLCB2YWx1ZSApO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0cmluZ1ZhbHVlICggcmVzZXQgKSB7XG4gIFx0aWYgKCAhdGhpcy5sb2NrZWQgKSB7XG4gIFx0XHRpZiAoIHJlc2V0ICkge1xuICBcdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUudmFsdWUgPSAnJztcbiAgXHRcdFx0dGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICBcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG5cbiAgXHRcdHRoaXMubm9kZS52YWx1ZSA9IHNhZmVUb1N0cmluZ1ZhbHVlKCB2YWx1ZSApO1xuICBcdFx0dGhpcy5ub2RlLnNldEF0dHJpYnV0ZSggJ3ZhbHVlJywgc2FmZVRvU3RyaW5nVmFsdWUoIHZhbHVlICkgKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVSYWRpb05hbWUgKCByZXNldCApIHtcbiAgXHRpZiAoIHJlc2V0ICkgdGhpcy5ub2RlLmNoZWNrZWQgPSBmYWxzZTtcbiAgXHRlbHNlIHRoaXMubm9kZS5jaGVja2VkID0gKCB0aGlzLmdldFZhbHVlKCkgPT0gdGhpcy5ub2RlLl9yYWN0aXZlLnZhbHVlICk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGVja2JveE5hbWUgKCByZXNldCApIHtcbiAgXHR2YXIgcmVmID0gdGhpcywgZWxlbWVudCA9IHJlZi5lbGVtZW50LCBub2RlID0gcmVmLm5vZGU7XG4gIFx0dmFyIGJpbmRpbmcgPSBlbGVtZW50LmJpbmRpbmc7XG5cbiAgXHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gIFx0dmFyIHZhbHVlQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblxuICBcdGlmICggcmVzZXQgKSB7XG4gIFx0XHQvLyBUT0RPOiBXQVQ/XG4gIFx0fVxuXG4gIFx0aWYgKCAhaXNBcnJheSggdmFsdWUgKSApIHtcbiAgXHRcdGJpbmRpbmcuaXNDaGVja2VkID0gbm9kZS5jaGVja2VkID0gKCB2YWx1ZSA9PSB2YWx1ZUF0dHJpYnV0ZSApO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR2YXIgaSA9IHZhbHVlLmxlbmd0aDtcbiAgXHRcdHdoaWxlICggaS0tICkge1xuICBcdFx0XHRpZiAoIHZhbHVlQXR0cmlidXRlID09IHZhbHVlW2ldICkge1xuICBcdFx0XHRcdGJpbmRpbmcuaXNDaGVja2VkID0gbm9kZS5jaGVja2VkID0gdHJ1ZTtcbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHRcdGJpbmRpbmcuaXNDaGVja2VkID0gbm9kZS5jaGVja2VkID0gZmFsc2U7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU3R5bGVBdHRyaWJ1dGUgKCByZXNldCApIHtcbiAgXHR2YXIgcHJvcHMgPSByZXNldCA/IHt9IDogcmVhZFN0eWxlKCB0aGlzLmdldFZhbHVlKCkgfHwgJycgKTtcbiAgXHR2YXIgc3R5bGUgPSB0aGlzLm5vZGUuc3R5bGU7XG4gIFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyggcHJvcHMgKTtcbiAgXHR2YXIgcHJldiA9IHRoaXMucHJldmlvdXMgfHwgW107XG5cbiAgXHR2YXIgaSA9IDA7XG4gIFx0d2hpbGUgKCBpIDwga2V5cy5sZW5ndGggKSB7XG4gIFx0XHRpZiAoIGtleXNbaV0gaW4gc3R5bGUgKSBzdHlsZVsga2V5c1tpXSBdID0gcHJvcHNbIGtleXNbaV0gXTtcbiAgXHRcdGkrKztcbiAgXHR9XG5cbiAgXHQvLyByZW1vdmUgbm93LW1pc3NpbmcgYXR0cnNcbiAgXHRpID0gcHJldi5sZW5ndGg7XG4gIFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRpZiAoICF+a2V5cy5pbmRleE9mKCBwcmV2W2ldICkgJiYgcHJldltpXSBpbiBzdHlsZSApIHN0eWxlWyBwcmV2W2ldIF0gPSAnJztcbiAgXHR9XG5cbiAgXHR0aGlzLnByZXZpb3VzID0ga2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUlubGluZVN0eWxlICggcmVzZXQgKSB7XG4gIFx0aWYgKCAhdGhpcy5zdHlsZU5hbWUgKSB7XG4gIFx0XHR0aGlzLnN0eWxlTmFtZSA9IGNhbWVsaXplKCB0aGlzLm5hbWUuc3Vic3RyKCA2ICkgKTtcbiAgXHR9XG5cbiAgXHR0aGlzLm5vZGUuc3R5bGVbIHRoaXMuc3R5bGVOYW1lIF0gPSByZXNldCA/ICcnIDogdGhpcy5nZXRWYWx1ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NOYW1lICggcmVzZXQgKSB7XG4gIFx0dmFyIHZhbHVlID0gcmVzZXQgPyBbXSA6IHJlYWRDbGFzcyggc2FmZVRvU3RyaW5nVmFsdWUoIHRoaXMuZ2V0VmFsdWUoKSApICk7XG4gIFx0dmFyIGF0dHIgPSByZWFkQ2xhc3MoIHRoaXMubm9kZS5jbGFzc05hbWUgKTtcbiAgXHR2YXIgcHJldiA9IHRoaXMucHJldmlvdXMgfHwgYXR0ci5zbGljZSggMCApO1xuXG4gIFx0dmFyIGkgPSAwO1xuICBcdHdoaWxlICggaSA8IHZhbHVlLmxlbmd0aCApIHtcbiAgXHRcdGlmICggIX5hdHRyLmluZGV4T2YoIHZhbHVlW2ldICkgKSBhdHRyLnB1c2goIHZhbHVlW2ldICk7XG4gIFx0XHRpKys7XG4gIFx0fVxuXG4gIFx0Ly8gcmVtb3ZlIG5vdy1taXNzaW5nIGNsYXNzZXNcbiAgXHRpID0gcHJldi5sZW5ndGg7XG4gIFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRpZiAoICF+dmFsdWUuaW5kZXhPZiggcHJldltpXSApICkge1xuICBcdFx0XHR2YXIgaWR4ID0gYXR0ci5pbmRleE9mKCBwcmV2W2ldICk7XG4gIFx0XHRcdGlmICggfmlkeCApIGF0dHIuc3BsaWNlKCBpZHgsIDEgKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR2YXIgY2xhc3NOYW1lID0gYXR0ci5qb2luKCAnICcgKTtcblxuICBcdGlmICggY2xhc3NOYW1lICE9PSB0aGlzLm5vZGUuY2xhc3NOYW1lICkge1xuICBcdFx0dGhpcy5ub2RlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgXHR9XG5cbiAgXHR0aGlzLnByZXZpb3VzID0gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVJbmxpbmVDbGFzcyAoIHJlc2V0ICkge1xuICBcdHZhciBuYW1lID0gdGhpcy5uYW1lLnN1YnN0ciggNiApO1xuICBcdHZhciBhdHRyID0gcmVhZENsYXNzKCB0aGlzLm5vZGUuY2xhc3NOYW1lICk7XG4gIFx0dmFyIHZhbHVlID0gcmVzZXQgPyBmYWxzZSA6IHRoaXMuZ2V0VmFsdWUoKTtcblxuICBcdGlmICggIXRoaXMuaW5saW5lQ2xhc3MgKSB0aGlzLmlubGluZUNsYXNzID0gbmFtZTtcblxuICBcdGlmICggdmFsdWUgJiYgIX5hdHRyLmluZGV4T2YoIG5hbWUgKSApIGF0dHIucHVzaCggbmFtZSApO1xuICBcdGVsc2UgaWYgKCAhdmFsdWUgJiYgfmF0dHIuaW5kZXhPZiggbmFtZSApICkgYXR0ci5zcGxpY2UoIGF0dHIuaW5kZXhPZiggbmFtZSApLCAxICk7XG5cbiAgXHR0aGlzLm5vZGUuY2xhc3NOYW1lID0gYXR0ci5qb2luKCAnICcgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUJvb2xlYW4gKCByZXNldCApIHtcbiAgXHQvLyB3aXRoIHR3by13YXkgYmluZGluZywgb25seSB1cGRhdGUgaWYgdGhlIGNoYW5nZSB3YXNuJ3QgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyXG4gIFx0Ly8gb3RoZXJ3aXNlIHRoZSBjdXJzb3Igd2lsbCBvZnRlbiBiZSBzZW50IHRvIHRoZSB3cm9uZyBwbGFjZVxuICBcdGlmICggIXRoaXMubG9ja2VkICkge1xuICBcdFx0aWYgKCByZXNldCApIHtcbiAgXHRcdFx0aWYgKCB0aGlzLnVzZVByb3BlcnR5ICkgdGhpcy5ub2RlWyB0aGlzLnByb3BlcnR5TmFtZSBdID0gZmFsc2U7XG4gIFx0XHRcdHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoIHRoaXMucHJvcGVydHlOYW1lICk7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCB0aGlzLnVzZVByb3BlcnR5ICkge1xuICBcdFx0XHR0aGlzLm5vZGVbIHRoaXMucHJvcGVydHlOYW1lIF0gPSB0aGlzLmdldFZhbHVlKCk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpZiAoIHRoaXMuZ2V0VmFsdWUoKSApIHtcbiAgXHRcdFx0XHR0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCB0aGlzLnByb3BlcnR5TmFtZSwgJycgKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR0aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKCB0aGlzLnByb3BlcnR5TmFtZSApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQXR0cmlidXRlICggcmVzZXQgKSB7XG4gIFx0aWYgKCByZXNldCApIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoIHRoaXMubmFtZSApO1xuICBcdGVsc2UgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSggdGhpcy5uYW1lLCBzYWZlVG9TdHJpbmdWYWx1ZSggdGhpcy5nZXRTdHJpbmcoKSApICk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVOYW1lc3BhY2VkQXR0cmlidXRlICggcmVzZXQgKSB7XG4gIFx0aWYgKCByZXNldCApIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGVOUyggdGhpcy5uYW1lc3BhY2UsIHRoaXMubmFtZS5zbGljZSggdGhpcy5uYW1lLmluZGV4T2YoICc6JyApICsgMSApICk7XG4gIFx0ZWxzZSB0aGlzLm5vZGUuc2V0QXR0cmlidXRlTlMoIHRoaXMubmFtZXNwYWNlLCB0aGlzLm5hbWUuc2xpY2UoIHRoaXMubmFtZS5pbmRleE9mKCAnOicgKSArIDEgKSwgc2FmZVRvU3RyaW5nVmFsdWUoIHRoaXMuZ2V0U3RyaW5nKCkgKSApO1xuICB9XG5cbiAgdmFyIHByb3BlcnR5TmFtZXMgPSB7XG4gIFx0J2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuICBcdGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIFx0Ymdjb2xvcjogJ2JnQ29sb3InLFxuICBcdCdjbGFzcyc6ICdjbGFzc05hbWUnLFxuICBcdGNvZGViYXNlOiAnY29kZUJhc2UnLFxuICBcdGNvbHNwYW46ICdjb2xTcGFuJyxcbiAgXHRjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuICBcdGRhdGV0aW1lOiAnZGF0ZVRpbWUnLFxuICBcdGRpcm5hbWU6ICdkaXJOYW1lJyxcbiAgXHQnZm9yJzogJ2h0bWxGb3InLFxuICBcdCdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIFx0aXNtYXA6ICdpc01hcCcsXG4gIFx0bWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgXHRub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG4gIFx0cHViZGF0ZTogJ3B1YkRhdGUnLFxuICBcdHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICBcdHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgXHR0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgXHR1c2VtYXA6ICd1c2VNYXAnXG4gIH07XG5cbiAgZnVuY3Rpb24gbG9va3VwTmFtZXNwYWNlICggbm9kZSwgcHJlZml4ICkge1xuICBcdHZhciBxdWFsaWZpZWQgPSBcInhtbG5zOlwiICsgcHJlZml4O1xuXG4gIFx0d2hpbGUgKCBub2RlICkge1xuICBcdFx0aWYgKCBub2RlLmhhc0F0dHJpYnV0ZSAmJiBub2RlLmhhc0F0dHJpYnV0ZSggcXVhbGlmaWVkICkgKSByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoIHF1YWxpZmllZCApO1xuICBcdFx0bm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbmFtZXNwYWNlc1sgcHJlZml4IF07XG4gIH1cblxuICB2YXIgQXR0cmlidXRlID0gKGZ1bmN0aW9uIChJdGVtKSB7XG4gIFx0ZnVuY3Rpb24gQXR0cmlidXRlICggb3B0aW9ucyApIHtcbiAgXHRcdEl0ZW0uY2FsbCggdGhpcywgb3B0aW9ucyApO1xuXG4gIFx0XHR0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLm47XG4gIFx0XHR0aGlzLm5hbWVzcGFjZSA9IG51bGw7XG5cbiAgXHRcdHRoaXMub3duZXIgPSBvcHRpb25zLm93bmVyIHx8IG9wdGlvbnMucGFyZW50RnJhZ21lbnQub3duZXIgfHwgb3B0aW9ucy5lbGVtZW50IHx8IGZpbmRFbGVtZW50KCBvcHRpb25zLnBhcmVudEZyYWdtZW50ICk7XG4gIFx0XHR0aGlzLmVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQgfHwgKHRoaXMub3duZXIuYXR0cmlidXRlQnlOYW1lID8gdGhpcy5vd25lciA6IGZpbmRFbGVtZW50KCBvcHRpb25zLnBhcmVudEZyYWdtZW50ICkgKTtcbiAgXHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50OyAvLyBzaGFyZWRcbiAgXHRcdHRoaXMucmFjdGl2ZSA9IHRoaXMucGFyZW50RnJhZ21lbnQucmFjdGl2ZTtcblxuICBcdFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICBcdFx0dGhpcy51cGRhdGVEZWxlZ2F0ZSA9IG51bGw7XG4gIFx0XHR0aGlzLmZyYWdtZW50ID0gbnVsbDtcblxuICBcdFx0dGhpcy5lbGVtZW50LmF0dHJpYnV0ZUJ5TmFtZVsgdGhpcy5uYW1lIF0gPSB0aGlzO1xuXG4gIFx0XHRpZiAoICFpc0FycmF5KCBvcHRpb25zLnRlbXBsYXRlLmYgKSApIHtcbiAgXHRcdFx0dGhpcy52YWx1ZSA9IG9wdGlvbnMudGVtcGxhdGUuZjtcbiAgXHRcdFx0aWYgKCB0aGlzLnZhbHVlID09PSAwICkge1xuICBcdFx0XHRcdHRoaXMudmFsdWUgPSAnJztcbiAgXHRcdFx0fVxuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCh7XG4gIFx0XHRcdFx0b3duZXI6IHRoaXMsXG4gIFx0XHRcdFx0dGVtcGxhdGU6IG9wdGlvbnMudGVtcGxhdGUuZlxuICBcdFx0XHR9KTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5pbnRlcnBvbGF0b3IgPSB0aGlzLmZyYWdtZW50ICYmXG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQuaXRlbXMubGVuZ3RoID09PSAxICYmXG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQuaXRlbXNbMF0udHlwZSA9PT0gSU5URVJQT0xBVE9SICYmXG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQuaXRlbXNbMF07XG5cbiAgXHRcdGlmICggdGhpcy5pbnRlcnBvbGF0b3IgKSB0aGlzLmludGVycG9sYXRvci5vd25lciA9IHRoaXM7XG4gIFx0fVxuXG4gIFx0QXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEl0ZW0gJiYgSXRlbS5wcm90b3R5cGUgKTtcbiAgXHRBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXR0cmlidXRlO1xuXG4gIFx0QXR0cmlidXRlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gYmluZCAoKSB7XG4gIFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQuYmluZCgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRBdHRyaWJ1dGUucHJvdG90eXBlLmJ1YmJsZSA9IGZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gIFx0XHRpZiAoICF0aGlzLmRpcnR5ICkge1xuICBcdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuICBcdFx0XHR0aGlzLmVsZW1lbnQuYnViYmxlKCk7XG4gIFx0XHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRBdHRyaWJ1dGUucHJvdG90eXBlLmRlc3Ryb3llZCA9IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gIFx0XHR0aGlzLnVwZGF0ZURlbGVnYXRlKCB0cnVlICk7XG4gIFx0fTtcblxuICBcdEF0dHJpYnV0ZS5wcm90b3R5cGUuZ2V0U3RyaW5nID0gZnVuY3Rpb24gZ2V0U3RyaW5nICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50ID9cbiAgXHRcdFx0dGhpcy5mcmFnbWVudC50b1N0cmluZygpIDpcbiAgXHRcdFx0dGhpcy52YWx1ZSAhPSBudWxsID8gJycgKyB0aGlzLnZhbHVlIDogJyc7XG4gIFx0fTtcblxuICBcdC8vIFRPRE8gY291bGQgZ2V0VmFsdWUgZXZlciBiZSBjYWxsZWQgZm9yIGEgc3RhdGljIGF0dHJpYnV0ZSxcbiAgXHQvLyBvciBjYW4gd2UgYXNzdW1lIHRoYXQgdGhpcy5mcmFnbWVudCBleGlzdHM/XG4gIFx0QXR0cmlidXRlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50ID8gdGhpcy5mcmFnbWVudC52YWx1ZU9mKCkgOiBib29sZWFuQXR0cmlidXRlcy50ZXN0KCB0aGlzLm5hbWUgKSA/IHRydWUgOiB0aGlzLnZhbHVlO1xuICBcdH07XG5cbiAgXHRBdHRyaWJ1dGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuICBcdFx0dGhpcy5ub2RlID0gbm9kZTtcblxuICBcdFx0Ly8gc2hvdWxkIHdlIHVzZSBkaXJlY3QgcHJvcGVydHkgYWNjZXNzLCBvciBzZXRBdHRyaWJ1dGU/XG4gIFx0XHRpZiAoICFub2RlLm5hbWVzcGFjZVVSSSB8fCBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5odG1sICkge1xuICBcdFx0XHR0aGlzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZXNbIHRoaXMubmFtZSBdIHx8IHRoaXMubmFtZTtcblxuICBcdFx0XHRpZiAoIG5vZGVbIHRoaXMucHJvcGVydHlOYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcbiAgXHRcdFx0XHR0aGlzLnVzZVByb3BlcnR5ID0gdHJ1ZTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIGlzIGF0dHJpYnV0ZSBhIGJvb2xlYW4gYXR0cmlidXRlIG9yICd2YWx1ZSc/IElmIHNvIHdlJ3JlIGJldHRlciBvZmYgZG9pbmcgZS5nLlxuICBcdFx0XHQvLyBub2RlLnNlbGVjdGVkID0gdHJ1ZSByYXRoZXIgdGhhbiBub2RlLnNldEF0dHJpYnV0ZSggJ3NlbGVjdGVkJywgJycgKVxuICBcdFx0XHRpZiAoIGJvb2xlYW5BdHRyaWJ1dGVzLnRlc3QoIHRoaXMubmFtZSApIHx8IHRoaXMuaXNUd293YXkgKSB7XG4gIFx0XHRcdFx0dGhpcy5pc0Jvb2xlYW4gPSB0cnVlO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCB0aGlzLnByb3BlcnR5TmFtZSA9PT0gJ3ZhbHVlJyApIHtcbiAgXHRcdFx0XHRub2RlLl9yYWN0aXZlLnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRpZiAoIG5vZGUubmFtZXNwYWNlVVJJICkge1xuICBcdFx0XHR2YXIgaW5kZXggPSB0aGlzLm5hbWUuaW5kZXhPZiggJzonICk7XG4gIFx0XHRcdGlmICggaW5kZXggIT09IC0xICkge1xuICBcdFx0XHRcdHRoaXMubmFtZXNwYWNlID0gbG9va3VwTmFtZXNwYWNlKCBub2RlLCB0aGlzLm5hbWUuc2xpY2UoIDAsIGluZGV4ICkgKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR0aGlzLm5hbWVzcGFjZSA9IG5vZGUubmFtZXNwYWNlVVJJO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICBcdFx0dGhpcy51cGRhdGVEZWxlZ2F0ZSA9IGdldFVwZGF0ZURlbGVnYXRlKCB0aGlzICk7XG4gIFx0XHR0aGlzLnVwZGF0ZURlbGVnYXRlKCk7XG4gIFx0fTtcblxuICBcdEF0dHJpYnV0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgXHRcdC8vIFNwZWNpYWwgY2FzZSAtIHNlbGVjdCBhbmQgdGV4dGFyZWEgdmFsdWVzIChzaG91bGQgbm90IGJlIHN0cmluZ2lmaWVkKVxuICBcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICd2YWx1ZScgJiYgKCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnY29udGVudGVkaXRhYmxlJyApICE9PSB1bmRlZmluZWQgfHwgKCB0aGlzLmVsZW1lbnQubmFtZSA9PT0gJ3NlbGVjdCcgfHwgdGhpcy5lbGVtZW50Lm5hbWUgPT09ICd0ZXh0YXJlYScgKSApICkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFNwZWNpYWwgY2FzZSDigJMgYm91bmQgcmFkaW8gYG5hbWVgIGF0dHJpYnV0ZXNcbiAgXHRcdGlmICggdGhpcy5uYW1lID09PSAnbmFtZScgJiYgdGhpcy5lbGVtZW50Lm5hbWUgPT09ICdpbnB1dCcgJiYgdGhpcy5pbnRlcnBvbGF0b3IgJiYgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3R5cGUnICkgPT09ICdyYWRpbycgKSB7XG4gIFx0XHRcdHJldHVybiAoXCJuYW1lPVxcXCJ7e1wiICsgKHRoaXMuaW50ZXJwb2xhdG9yLm1vZGVsLmdldEtleXBhdGgoKSkgKyBcIn19XFxcIlwiKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gc3R5bGUgYW5kIGNsYXNzIGF0dHJpYnV0ZXMgYW5kIGRpcmVjdGl2ZXNcbiAgXHRcdGlmICggdGhpcy5vd25lciA9PT0gdGhpcy5lbGVtZW50ICYmICggdGhpcy5uYW1lID09PSAnc3R5bGUnIHx8IHRoaXMubmFtZSA9PT0gJ2NsYXNzJyB8fCB0aGlzLnN0eWxlTmFtZSB8fCB0aGlzLmlubGluZUNsYXNzICkgKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCAhdGhpcy5yZW5kZXJlZCAmJiB0aGlzLm93bmVyID09PSB0aGlzLmVsZW1lbnQgJiYgKCAhdGhpcy5uYW1lLmluZGV4T2YoICdzdHlsZS0nICkgfHwgIXRoaXMubmFtZS5pbmRleE9mKCAnY2xhc3MtJyApICkgKSB7XG4gIFx0XHRcdGlmICggIXRoaXMubmFtZS5pbmRleE9mKCAnc3R5bGUtJyApICkge1xuICBcdFx0XHRcdHRoaXMuc3R5bGVOYW1lID0gY2FtZWxpemUoIHRoaXMubmFtZS5zdWJzdHIoIDYgKSApO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHRoaXMuaW5saW5lQ2xhc3MgPSB0aGlzLm5hbWUuc3Vic3RyKCA2ICk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdGlmICggYm9vbGVhbkF0dHJpYnV0ZXMudGVzdCggdGhpcy5uYW1lICkgKSByZXR1cm4gdmFsdWUgPyB0aGlzLm5hbWUgOiAnJztcbiAgXHRcdGlmICggdmFsdWUgPT0gbnVsbCApIHJldHVybiAnJztcblxuICBcdFx0dmFyIHN0ciA9IHNhZmVBdHRyaWJ1dGVTdHJpbmcoIHRoaXMuZ2V0U3RyaW5nKCkgKTtcbiAgXHRcdHJldHVybiBzdHIgP1xuICBcdFx0XHQoXCJcIiArICh0aGlzLm5hbWUpICsgXCI9XFxcIlwiICsgc3RyICsgXCJcXFwiXCIpIDpcbiAgXHRcdFx0dGhpcy5uYW1lO1xuICBcdH07XG5cbiAgXHRBdHRyaWJ1dGUucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uIHVuYmluZCAoKSB7XG4gIFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdH07XG5cbiAgXHRBdHRyaWJ1dGUucHJvdG90eXBlLnVucmVuZGVyID0gZnVuY3Rpb24gdW5yZW5kZXIgKCkge1xuICBcdFx0dGhpcy51cGRhdGVEZWxlZ2F0ZSggdHJ1ZSApO1xuXG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gIFx0fTtcblxuICBcdEF0dHJpYnV0ZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgXHRcdGlmICggdGhpcy5kaXJ0eSApIHtcbiAgXHRcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuICBcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB0aGlzLmZyYWdtZW50LnVwZGF0ZSgpO1xuICBcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB0aGlzLnVwZGF0ZURlbGVnYXRlKCk7XG4gIFx0XHRcdGlmICggdGhpcy5pc1R3b3dheSAmJiAhdGhpcy5sb2NrZWQgKSB7XG4gIFx0XHRcdFx0dGhpcy5pbnRlcnBvbGF0b3IudHdvd2F5QmluZGluZy5sYXN0VmFsKCB0cnVlLCB0aGlzLmludGVycG9sYXRvci5tb2RlbC5nZXQoKSApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdHJldHVybiBBdHRyaWJ1dGU7XG4gIH0oSXRlbSkpO1xuXG4gIHZhciBCaW5kaW5nRmxhZyA9IChmdW5jdGlvbiAoSXRlbSkge1xuICBcdGZ1bmN0aW9uIEJpbmRpbmdGbGFnICggb3B0aW9ucyApIHtcbiAgXHRcdEl0ZW0uY2FsbCggdGhpcywgb3B0aW9ucyApO1xuXG4gIFx0XHR0aGlzLm93bmVyID0gb3B0aW9ucy5vd25lciB8fCBvcHRpb25zLnBhcmVudEZyYWdtZW50Lm93bmVyIHx8IGZpbmRFbGVtZW50KCBvcHRpb25zLnBhcmVudEZyYWdtZW50ICk7XG4gIFx0XHR0aGlzLmVsZW1lbnQgPSB0aGlzLm93bmVyLmF0dHJpYnV0ZUJ5TmFtZSA/IHRoaXMub3duZXIgOiBmaW5kRWxlbWVudCggb3B0aW9ucy5wYXJlbnRGcmFnbWVudCApO1xuICBcdFx0dGhpcy5mbGFnID0gb3B0aW9ucy50ZW1wbGF0ZS52ID09PSAnbCcgPyAnbGF6eScgOiAndHdvd2F5JztcblxuICBcdFx0aWYgKCB0aGlzLmVsZW1lbnQudHlwZSA9PT0gRUxFTUVOVCApIHtcbiAgXHRcdFx0aWYgKCBpc0FycmF5KCBvcHRpb25zLnRlbXBsYXRlLmYgKSApIHtcbiAgXHRcdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KHtcbiAgXHRcdFx0XHRcdG93bmVyOiB0aGlzLFxuICBcdFx0XHRcdFx0dGVtcGxhdGU6IG9wdGlvbnMudGVtcGxhdGUuZlxuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5pbnRlcnBvbGF0b3IgPSB0aGlzLmZyYWdtZW50ICYmXG4gIFx0XHRcdFx0XHRcdFx0XHR0aGlzLmZyYWdtZW50Lml0ZW1zLmxlbmd0aCA9PT0gMSAmJlxuICBcdFx0XHRcdFx0XHRcdFx0dGhpcy5mcmFnbWVudC5pdGVtc1swXS50eXBlID09PSBJTlRFUlBPTEFUT1IgJiZcbiAgXHRcdFx0XHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQuaXRlbXNbMF07XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0QmluZGluZ0ZsYWcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSXRlbSAmJiBJdGVtLnByb3RvdHlwZSApO1xuICBcdEJpbmRpbmdGbGFnLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJpbmRpbmdGbGFnO1xuXG4gIFx0QmluZGluZ0ZsYWcucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiBiaW5kICgpIHtcbiAgXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHRoaXMuZnJhZ21lbnQuYmluZCgpO1xuICBcdFx0c2V0JDIoIHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSwgdHJ1ZSApO1xuICBcdH07XG5cbiAgXHRCaW5kaW5nRmxhZy5wcm90b3R5cGUuYnViYmxlID0gZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgXHRcdGlmICggIXRoaXMuZGlydHkgKSB7XG4gIFx0XHRcdHRoaXMuZWxlbWVudC5idWJibGUoKTtcbiAgXHRcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdEJpbmRpbmdGbGFnLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlICgpIHtcbiAgXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHJldHVybiB0aGlzLmZyYWdtZW50LnZhbHVlT2YoKTtcbiAgXHRcdGVsc2UgaWYgKCAndmFsdWUnIGluIHRoaXMgKSByZXR1cm4gdGhpcy52YWx1ZTtcbiAgXHRcdGVsc2UgaWYgKCAnZicgaW4gdGhpcy50ZW1wbGF0ZSApIHJldHVybiB0aGlzLnRlbXBsYXRlLmY7XG4gIFx0XHRlbHNlIHJldHVybiB0cnVlO1xuICBcdH07XG5cbiAgXHRCaW5kaW5nRmxhZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgXHRcdHNldCQyKCB0aGlzLCB0aGlzLmdldFZhbHVlKCksIHRydWUgKTtcbiAgXHR9O1xuXG4gIFx0QmluZGluZ0ZsYWcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkgeyByZXR1cm4gJyc7IH07XG5cbiAgXHRCaW5kaW5nRmxhZy5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gdW5iaW5kICgpIHtcbiAgXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cbiAgXHRcdGRlbGV0ZSB0aGlzLmVsZW1lbnRbIHRoaXMuZmxhZyBdO1xuICBcdH07XG5cbiAgXHRCaW5kaW5nRmxhZy5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiB1bnJlbmRlciAoKSB7XG4gIFx0XHRpZiAoIHRoaXMuZWxlbWVudC5yZW5kZXJlZCApIHRoaXMuZWxlbWVudC5yZWNyZWF0ZVR3b3dheUJpbmRpbmcoKTtcbiAgXHR9O1xuXG4gIFx0QmluZGluZ0ZsYWcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIFx0XHRpZiAoIHRoaXMuZGlydHkgKSB7XG4gIFx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHRoaXMuZnJhZ21lbnQudXBkYXRlKCk7XG4gIFx0XHRcdHNldCQyKCB0aGlzLCB0aGlzLmdldFZhbHVlKCksIHRydWUgKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0cmV0dXJuIEJpbmRpbmdGbGFnO1xuICB9KEl0ZW0pKTtcblxuICBmdW5jdGlvbiBzZXQkMiAoIGZsYWcsIHZhbHVlLCB1cGRhdGUgKSB7XG4gIFx0aWYgKCB2YWx1ZSA9PT0gMCApIHtcbiAgXHRcdGZsYWcudmFsdWUgPSB0cnVlO1xuICBcdH0gZWxzZSBpZiAoIHZhbHVlID09PSAndHJ1ZScgKSB7XG4gIFx0XHRmbGFnLnZhbHVlID0gdHJ1ZTtcbiAgXHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJzAnICkge1xuICBcdFx0ZmxhZy52YWx1ZSA9IGZhbHNlO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRmbGFnLnZhbHVlID0gdmFsdWU7XG4gIFx0fVxuXG4gIFx0dmFyIGN1cnJlbnQgPSBmbGFnLmVsZW1lbnRbIGZsYWcuZmxhZyBdO1xuICBcdGZsYWcuZWxlbWVudFsgZmxhZy5mbGFnIF0gPSBmbGFnLnZhbHVlO1xuICBcdGlmICggdXBkYXRlICYmICFmbGFnLmVsZW1lbnQuYXR0cmlidXRlcy5iaW5kaW5nICYmIGN1cnJlbnQgIT09IGZsYWcudmFsdWUgKSB7XG4gIFx0XHRmbGFnLmVsZW1lbnQucmVjcmVhdGVUd293YXlCaW5kaW5nKCk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGZsYWcudmFsdWU7XG4gIH1cblxuICB2YXIgZGl2JDEgPSBkb2MgPyBjcmVhdGVFbGVtZW50KCAnZGl2JyApIDogbnVsbDtcblxuICB2YXIgYXR0cmlidXRlcyA9IGZhbHNlO1xuICBmdW5jdGlvbiBpbkF0dHJpYnV0ZXMoKSB7IHJldHVybiBhdHRyaWJ1dGVzOyB9XG4gIGZ1bmN0aW9uIGRvSW5BdHRyaWJ1dGVzKCBmbiApIHtcbiAgXHRhdHRyaWJ1dGVzID0gdHJ1ZTtcbiAgXHRmbigpO1xuICBcdGF0dHJpYnV0ZXMgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBDb25kaXRpb25hbEF0dHJpYnV0ZSA9IChmdW5jdGlvbiAoSXRlbSkge1xuICBcdGZ1bmN0aW9uIENvbmRpdGlvbmFsQXR0cmlidXRlICggb3B0aW9ucyApIHtcbiAgXHRcdEl0ZW0uY2FsbCggdGhpcywgb3B0aW9ucyApO1xuXG4gIFx0XHR0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcblxuICBcdFx0dGhpcy5vd25lciA9IG9wdGlvbnMub3duZXI7XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoe1xuICBcdFx0XHRyYWN0aXZlOiB0aGlzLnJhY3RpdmUsXG4gIFx0XHRcdG93bmVyOiB0aGlzLFxuICBcdFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZVxuICBcdFx0fSk7XG4gIFx0XHQvLyB0aGlzIGZyYWdtZW50IGNhbid0IHBhcnRpY2lwYXRlIGluIG5vZGUteSB0aGluZ3NcbiAgXHRcdHRoaXMuZnJhZ21lbnQuZmluZE5leHROb2RlID0gbm9vcDtcblxuICBcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuICBcdH1cblxuICBcdENvbmRpdGlvbmFsQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEl0ZW0gJiYgSXRlbS5wcm90b3R5cGUgKTtcbiAgXHRDb25kaXRpb25hbEF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25kaXRpb25hbEF0dHJpYnV0ZTtcblxuICBcdENvbmRpdGlvbmFsQXR0cmlidXRlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gYmluZCAoKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LmJpbmQoKTtcbiAgXHR9O1xuXG4gIFx0Q29uZGl0aW9uYWxBdHRyaWJ1dGUucHJvdG90eXBlLmJ1YmJsZSA9IGZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gIFx0XHRpZiAoICF0aGlzLmRpcnR5ICkge1xuICBcdFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgXHRcdFx0dGhpcy5vd25lci5idWJibGUoKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0Q29uZGl0aW9uYWxBdHRyaWJ1dGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gIFx0XHR0aGlzLm5vZGUgPSB0aGlzLm93bmVyLm5vZGU7XG4gIFx0XHRpZiAoIHRoaXMubm9kZSApIHtcbiAgXHRcdFx0dGhpcy5pc1N2ZyA9IHRoaXMubm9kZS5uYW1lc3BhY2VVUkkgPT09IHN2ZyQxO1xuICBcdFx0fVxuXG4gIFx0XHRhdHRyaWJ1dGVzID0gdHJ1ZTtcbiAgXHRcdGlmICggIXRoaXMucmVuZGVyZWQgKSB0aGlzLmZyYWdtZW50LnJlbmRlcigpO1xuICBcdFx0YXR0cmlidXRlcyA9IGZhbHNlO1xuXG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHRcdHRoaXMuZGlydHkgPSB0cnVlOyAvLyBUT0RPIHRoaXMgc2VlbXMgaGFja3ksIGJ1dCBuZWNlc3NhcnkgZm9yIHRlc3RzIHRvIHBhc3MgaW4gYnJvd3NlciBBTkQgbm9kZS5qc1xuICBcdFx0dGhpcy51cGRhdGUoKTtcbiAgXHR9O1xuXG4gIFx0Q29uZGl0aW9uYWxBdHRyaWJ1dGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoKTtcbiAgXHR9O1xuXG4gIFx0Q29uZGl0aW9uYWxBdHRyaWJ1dGUucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uIHVuYmluZCAoKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdH07XG5cbiAgXHRDb25kaXRpb25hbEF0dHJpYnV0ZS5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiB1bnJlbmRlciAoKSB7XG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKCk7XG4gIFx0fTtcblxuICBcdENvbmRpdGlvbmFsQXR0cmlidXRlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICBcdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHZhciBzdHI7XG4gIFx0XHR2YXIgYXR0cnM7XG5cbiAgXHRcdGlmICggdGhpcy5kaXJ0eSApIHtcbiAgXHRcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuXG4gIFx0XHRcdGF0dHJpYnV0ZXMgPSB0cnVlO1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnVwZGF0ZSgpO1xuICBcdFx0XHRhdHRyaWJ1dGVzID0gZmFsc2U7XG5cbiAgXHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICYmIHRoaXMubm9kZSApIHtcbiAgXHRcdFx0XHRzdHIgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIFx0XHRcdFx0YXR0cnMgPSBwYXJzZUF0dHJpYnV0ZXMoIHN0ciwgdGhpcy5pc1N2ZyApO1xuXG4gIFx0XHRcdFx0Ly8gYW55IGF0dHJpYnV0ZXMgdGhhdCBwcmV2aW91c2x5IGV4aXN0ZWQgYnV0IG5vIGxvbmdlciBkb1xuICBcdFx0XHRcdC8vIG11c3QgYmUgcmVtb3ZlZFxuICBcdFx0XHRcdHRoaXMuYXR0cmlidXRlcy5maWx0ZXIoIGZ1bmN0aW9uICggYSApIHsgcmV0dXJuIG5vdEluKCBhdHRycywgYSApOyB9ICkuZm9yRWFjaCggZnVuY3Rpb24gKCBhICkge1xuICBcdFx0XHRcdFx0dGhpcyQxLm5vZGUucmVtb3ZlQXR0cmlidXRlKCBhLm5hbWUgKTtcbiAgXHRcdFx0XHR9KTtcblxuICBcdFx0XHRcdGF0dHJzLmZvckVhY2goIGZ1bmN0aW9uICggYSApIHtcbiAgXHRcdFx0XHRcdHRoaXMkMS5ub2RlLnNldEF0dHJpYnV0ZSggYS5uYW1lLCBhLnZhbHVlICk7XG4gIFx0XHRcdFx0fSk7XG5cbiAgXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH07XG5cbiAgXHRyZXR1cm4gQ29uZGl0aW9uYWxBdHRyaWJ1dGU7XG4gIH0oSXRlbSkpO1xuXG4gIGZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyAoIHN0ciwgaXNTdmcgKSB7XG4gIFx0dmFyIHRhZ05hbWUgPSBpc1N2ZyA/ICdzdmcnIDogJ2Rpdic7XG4gIFx0cmV0dXJuIHN0clxuICBcdFx0PyAoZGl2JDEuaW5uZXJIVE1MID0gXCI8XCIgKyB0YWdOYW1lICsgXCIgXCIgKyBzdHIgKyBcIj48L1wiICsgdGFnTmFtZSArIFwiPlwiKSAmJlxuICBcdFx0XHR0b0FycmF5KGRpdiQxLmNoaWxkTm9kZXNbMF0uYXR0cmlidXRlcylcbiAgXHRcdDogW107XG4gIH1cblxuICBmdW5jdGlvbiBub3RJbiAoIGhheXN0YWNrLCBuZWVkbGUgKSB7XG4gIFx0dmFyIGkgPSBoYXlzdGFjay5sZW5ndGg7XG5cbiAgXHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdGlmICggaGF5c3RhY2tbaV0ubmFtZSA9PT0gbmVlZGxlLm5hbWUgKSB7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NXcmFwcGVyICggd3JhcHBlciwgYXJyYXksIG1ldGhvZE5hbWUsIG5ld0luZGljZXMgKSB7XG4gIFx0dmFyIF9fbW9kZWwgPSB3cmFwcGVyLl9fbW9kZWw7XG5cbiAgXHRpZiAoIG5ld0luZGljZXMgKSB7XG4gIFx0XHRfX21vZGVsLnNodWZmbGUoIG5ld0luZGljZXMgKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0Ly8gSWYgdGhpcyBpcyBhIHNvcnQgb3IgcmV2ZXJzZSwgd2UganVzdCBkbyByb290LnNldCgpLi4uXG4gIFx0XHQvLyBUT0RPIHVzZSBtZXJnZSBsb2dpYz9cbiAgXHRcdC8vcm9vdC52aWV3bW9kZWwubWFyaygga2V5cGF0aCApO1xuICBcdH1cbiAgfVxuXG4gIHZhciBtdXRhdG9yTWV0aG9kcyA9IFsgJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCcgXTtcbiAgdmFyIHBhdGNoZWRBcnJheVByb3RvID0gW107XG5cbiAgbXV0YXRvck1ldGhvZHMuZm9yRWFjaCggZnVuY3Rpb24gKCBtZXRob2ROYW1lICkge1xuICBcdHZhciBtZXRob2QgPSBmdW5jdGlvbiAoKSB7XG4gIFx0XHR2YXIgdGhpcyQxID0gdGhpcztcbiAgXHRcdHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gIFx0XHR2YXIgbmV3SW5kaWNlcyA9IGdldE5ld0luZGljZXMoIHRoaXMubGVuZ3RoLCBtZXRob2ROYW1lLCBhcmdzICk7XG5cbiAgXHRcdC8vIGxvY2sgYW55IG1hZ2ljIGFycmF5IHdyYXBwZXJzLCBzbyB0aGF0IHRoaW5ncyBkb24ndCBnZXQgZnVkZ2VkXG4gIFx0XHR0aGlzLl9yYWN0aXZlLndyYXBwZXJzLmZvckVhY2goIGZ1bmN0aW9uICggciApIHsgaWYgKCByLm1hZ2ljICkgci5tYWdpYy5sb2NrZWQgPSB0cnVlOyB9ICk7XG5cbiAgXHRcdC8vIGFwcGx5IHRoZSB1bmRlcmx5aW5nIG1ldGhvZFxuICBcdFx0dmFyIHJlc3VsdCA9IEFycmF5LnByb3RvdHlwZVsgbWV0aG9kTmFtZSBdLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuICBcdFx0Ly8gdHJpZ2dlciBjaGFuZ2VzXG4gIFx0XHRydW5sb29wLnN0YXJ0KCk7XG5cbiAgXHRcdHRoaXMuX3JhY3RpdmUuc2V0dGluZyA9IHRydWU7XG4gIFx0XHR2YXIgaSA9IHRoaXMuX3JhY3RpdmUud3JhcHBlcnMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRcdHByb2Nlc3NXcmFwcGVyKCB0aGlzJDEuX3JhY3RpdmUud3JhcHBlcnNbaV0sIHRoaXMkMSwgbWV0aG9kTmFtZSwgbmV3SW5kaWNlcyApO1xuICBcdFx0fVxuXG4gIFx0XHRydW5sb29wLmVuZCgpO1xuXG4gIFx0XHR0aGlzLl9yYWN0aXZlLnNldHRpbmcgPSBmYWxzZTtcblxuICBcdFx0Ly8gdW5sb2NrIHRoZSBtYWdpYyBhcnJheXMuLi4gbWFnaWMuLi4gYmFoXG4gIFx0XHR0aGlzLl9yYWN0aXZlLndyYXBwZXJzLmZvckVhY2goIGZ1bmN0aW9uICggciApIHsgaWYgKCByLm1hZ2ljICkgci5tYWdpYy5sb2NrZWQgPSBmYWxzZTsgfSApO1xuXG4gIFx0XHRyZXR1cm4gcmVzdWx0O1xuICBcdH07XG5cbiAgXHRkZWZpbmVQcm9wZXJ0eSggcGF0Y2hlZEFycmF5UHJvdG8sIG1ldGhvZE5hbWUsIHtcbiAgXHRcdHZhbHVlOiBtZXRob2QsXG4gIFx0XHRjb25maWd1cmFibGU6IHRydWVcbiAgXHR9KTtcbiAgfSk7XG5cbiAgdmFyIHBhdGNoQXJyYXlNZXRob2RzO1xuICB2YXIgdW5wYXRjaEFycmF5TWV0aG9kcztcblxuICAvLyBjYW4gd2UgdXNlIHByb3RvdHlwZSBjaGFpbiBpbmplY3Rpb24/XG4gIC8vIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2hvdy1lY21hc2NyaXB0LTUtc3RpbGwtZG9lcy1ub3QtYWxsb3ctdG8tc3ViY2xhc3MtYW4tYXJyYXkvI3dyYXBwZXJzX3Byb3RvdHlwZV9jaGFpbl9pbmplY3Rpb25cbiAgaWYgKCAoe30pLl9fcHJvdG9fXyApIHtcbiAgXHQvLyB5ZXMsIHdlIGNhblxuICBcdHBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24gKCBhcnJheSApIHsgcmV0dXJuIGFycmF5Ll9fcHJvdG9fXyA9IHBhdGNoZWRBcnJheVByb3RvOyB9O1xuICBcdHVucGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiAoIGFycmF5ICkgeyByZXR1cm4gYXJyYXkuX19wcm90b19fID0gQXJyYXkucHJvdG90eXBlOyB9O1xuICB9XG5cbiAgZWxzZSB7XG4gIFx0Ly8gbm8sIHdlIGNhbid0XG4gIFx0cGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiAoIGFycmF5ICkge1xuICBcdFx0dmFyIGkgPSBtdXRhdG9yTWV0aG9kcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdFx0dmFyIG1ldGhvZE5hbWUgPSBtdXRhdG9yTWV0aG9kc1tpXTtcbiAgXHRcdFx0ZGVmaW5lUHJvcGVydHkoIGFycmF5LCBtZXRob2ROYW1lLCB7XG4gIFx0XHRcdFx0dmFsdWU6IHBhdGNoZWRBcnJheVByb3RvWyBtZXRob2ROYW1lIF0sXG4gIFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHR1bnBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24gKCBhcnJheSApIHtcbiAgXHRcdHZhciBpID0gbXV0YXRvck1ldGhvZHMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRcdGRlbGV0ZSBhcnJheVsgbXV0YXRvck1ldGhvZHNbaV0gXTtcbiAgXHRcdH1cbiAgXHR9O1xuICB9XG5cbiAgcGF0Y2hBcnJheU1ldGhvZHMudW5wYXRjaCA9IHVucGF0Y2hBcnJheU1ldGhvZHM7IC8vIFRPRE8gZXhwb3J0IHNlcGFyYXRlbHk/XG4gIHZhciBwYXRjaCA9IHBhdGNoQXJyYXlNZXRob2RzO1xuXG4gIHZhciBlcnJvck1lc3NhZ2UkMSA9ICdTb21ldGhpbmcgd2VudCB3cm9uZyBpbiBhIHJhdGhlciBpbnRlcmVzdGluZyB3YXknO1xuXG4gIHZhciBhcnJheUFkYXB0b3IgPSB7XG4gIFx0ZmlsdGVyOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcbiAgXHRcdC8vIHdyYXAgdGhlIGFycmF5IGlmIGEpIGIpIGl0J3MgYW4gYXJyYXksIGFuZCBiKSBlaXRoZXIgaXQgaGFzbid0IGJlZW4gd3JhcHBlZCBhbHJlYWR5LFxuICBcdFx0Ly8gb3IgdGhlIGFycmF5IGRpZG4ndCB0cmlnZ2VyIHRoZSBnZXQoKSBpdHNlbGZcbiAgXHRcdHJldHVybiBpc0FycmF5KCBvYmplY3QgKSAmJiAoICFvYmplY3QuX3JhY3RpdmUgfHwgIW9iamVjdC5fcmFjdGl2ZS5zZXR0aW5nICk7XG4gIFx0fSxcbiAgXHR3cmFwOiBmdW5jdGlvbiAoIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICkge1xuICBcdFx0cmV0dXJuIG5ldyBBcnJheVdyYXBwZXIoIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICk7XG4gIFx0fVxuICB9O1xuXG4gIHZhciBBcnJheVdyYXBwZXIgPSBmdW5jdGlvbiBBcnJheVdyYXBwZXIgKCByYWN0aXZlLCBhcnJheSApIHtcbiAgXHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuICBcdHRoaXMudmFsdWUgPSBhcnJheTtcbiAgXHR0aGlzLl9fbW9kZWwgPSBudWxsOyAvLyBmaWxsZWQgaW4gbGF0ZXJcblxuICBcdC8vIGlmIHRoaXMgYXJyYXkgaGFzbid0IGFscmVhZHkgYmVlbiByYWN0aWZpZWQsIHJhY3RpZnkgaXRcbiAgXHRpZiAoICFhcnJheS5fcmFjdGl2ZSApIHtcbiAgXHRcdC8vIGRlZmluZSBhIG5vbi1lbnVtZXJhYmxlIF9yYWN0aXZlIHByb3BlcnR5IHRvIHN0b3JlIHRoZSB3cmFwcGVyc1xuICBcdFx0ZGVmaW5lUHJvcGVydHkoIGFycmF5LCAnX3JhY3RpdmUnLCB7XG4gIFx0XHRcdHZhbHVlOiB7XG4gIFx0XHRcdFx0d3JhcHBlcnM6IFtdLFxuICBcdFx0XHRcdGluc3RhbmNlczogW10sXG4gIFx0XHRcdFx0c2V0dGluZzogZmFsc2VcbiAgXHRcdFx0fSxcbiAgXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG4gIFx0XHR9KTtcblxuICBcdFx0cGF0Y2goIGFycmF5ICk7XG4gIFx0fVxuXG4gIFx0Ly8gc3RvcmUgdGhlIHJhY3RpdmUgaW5zdGFuY2UsIHNvIHdlIGNhbiBoYW5kbGUgdHJhbnNpdGlvbnMgbGF0ZXJcbiAgXHRpZiAoICFhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXNbIHJhY3RpdmUuX2d1aWQgXSApIHtcbiAgXHRcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlc1sgcmFjdGl2ZS5fZ3VpZCBdID0gMDtcbiAgXHRcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlcy5wdXNoKCByYWN0aXZlICk7XG4gIFx0fVxuXG4gIFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzWyByYWN0aXZlLl9ndWlkIF0gKz0gMTtcbiAgXHRhcnJheS5fcmFjdGl2ZS53cmFwcGVycy5wdXNoKCB0aGlzICk7XG4gIH07XG5cbiAgQXJyYXlXcmFwcGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBcdHJldHVybiB0aGlzLnZhbHVlO1xuICB9O1xuXG4gIEFycmF5V3JhcHBlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCAoIHZhbHVlICkge1xuICBcdHJldHVybiB0aGlzLnZhbHVlID09PSB2YWx1ZTtcbiAgfTtcblxuICBBcnJheVdyYXBwZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICBcdHZhciBhcnJheSwgc3RvcmFnZSwgd3JhcHBlcnMsIGluc3RhbmNlcywgaW5kZXg7XG5cbiAgXHRhcnJheSA9IHRoaXMudmFsdWU7XG4gIFx0c3RvcmFnZSA9IGFycmF5Ll9yYWN0aXZlO1xuICBcdHdyYXBwZXJzID0gc3RvcmFnZS53cmFwcGVycztcbiAgXHRpbnN0YW5jZXMgPSBzdG9yYWdlLmluc3RhbmNlcztcblxuICBcdC8vIGlmIHRlYXJkb3duKCkgd2FzIGludm9rZWQgYmVjYXVzZSB3ZSdyZSBjbGVhcmluZyB0aGUgY2FjaGUgYXMgYSByZXN1bHQgb2ZcbiAgXHQvLyBhIGNoYW5nZSB0aGF0IHRoZSBhcnJheSBpdHNlbGYgdHJpZ2dlcmVkLCB3ZSBjYW4gc2F2ZSBvdXJzZWx2ZXMgdGhlIHRlYXJkb3duXG4gIFx0Ly8gYW5kIGltbWVkaWF0ZSBzZXR1cFxuICBcdGlmICggc3RvcmFnZS5zZXR0aW5nICkge1xuICBcdFx0cmV0dXJuIGZhbHNlOyAvLyBzbyB0aGF0IHdlIGRvbid0IHJlbW92ZSBpdCBmcm9tIGNhY2hlZCB3cmFwcGVyc1xuICBcdH1cblxuICBcdGluZGV4ID0gd3JhcHBlcnMuaW5kZXhPZiggdGhpcyApO1xuICBcdGlmICggaW5kZXggPT09IC0xICkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKCBlcnJvck1lc3NhZ2UkMSApO1xuICBcdH1cblxuICBcdHdyYXBwZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblxuICBcdC8vIGlmIG5vdGhpbmcgZWxzZSBkZXBlbmRzIG9uIHRoaXMgYXJyYXksIHdlIGNhbiByZXZlcnQgaXQgdG8gaXRzXG4gIFx0Ly8gbmF0dXJhbCBzdGF0ZVxuICBcdGlmICggIXdyYXBwZXJzLmxlbmd0aCApIHtcbiAgXHRcdGRlbGV0ZSBhcnJheS5fcmFjdGl2ZTtcbiAgXHRcdHBhdGNoLnVucGF0Y2goIHRoaXMudmFsdWUgKTtcbiAgXHR9XG5cbiAgXHRlbHNlIHtcbiAgXHRcdC8vIHJlbW92ZSByYWN0aXZlIGluc3RhbmNlIGlmIHBvc3NpYmxlXG4gIFx0XHRpbnN0YW5jZXNbIHRoaXMucm9vdC5fZ3VpZCBdIC09IDE7XG4gIFx0XHRpZiAoICFpbnN0YW5jZXNbIHRoaXMucm9vdC5fZ3VpZCBdICkge1xuICBcdFx0XHRpbmRleCA9IGluc3RhbmNlcy5pbmRleE9mKCB0aGlzLnJvb3QgKTtcblxuICBcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcbiAgXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGVycm9yTWVzc2FnZSQxICk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpbnN0YW5jZXMuc3BsaWNlKCBpbmRleCwgMSApO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICB2YXIgbWFnaWNBZGFwdG9yO1xuXG4gIHRyeSB7XG4gIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAndGVzdCcsIHsgZ2V0OiBmdW5jdGlvbigpIHt9LCBzZXQ6IGZ1bmN0aW9uKCkge30gfSk7XG5cbiAgXHRtYWdpY0FkYXB0b3IgPSB7XG4gIFx0XHRmaWx0ZXI6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gIFx0XHRcdHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xuICBcdFx0fSxcbiAgXHRcdHdyYXA6IGZ1bmN0aW9uICggcmFjdGl2ZSwgdmFsdWUsIGtleXBhdGggKSB7XG4gIFx0XHRcdHJldHVybiBuZXcgTWFnaWNXcmFwcGVyKCByYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCApO1xuICBcdFx0fVxuICBcdH07XG4gIH0gY2F0Y2ggKCBlcnIgKSB7XG4gIFx0bWFnaWNBZGFwdG9yID0gZmFsc2U7XG4gIH1cblxuICB2YXIgbWFnaWNBZGFwdG9yJDEgPSBtYWdpY0FkYXB0b3I7XG5cbiAgZnVuY3Rpb24gY3JlYXRlT3JXcmFwRGVzY3JpcHRvciAoIG9yaWdpbmFsRGVzY3JpcHRvciwgcmFjdGl2ZSwga2V5cGF0aCwgd3JhcHBlciApIHtcbiAgXHRpZiAoIG9yaWdpbmFsRGVzY3JpcHRvci5zZXQgJiYgb3JpZ2luYWxEZXNjcmlwdG9yLnNldC5fX21hZ2ljICkge1xuICBcdFx0b3JpZ2luYWxEZXNjcmlwdG9yLnNldC5fX21hZ2ljLmRlcGVuZGFudHMucHVzaCh7IHJhY3RpdmU6IHJhY3RpdmUsIGtleXBhdGg6IGtleXBhdGggfSk7XG4gIFx0XHRyZXR1cm4gb3JpZ2luYWxEZXNjcmlwdG9yO1xuICBcdH1cblxuICBcdHZhciBzZXR0aW5nO1xuXG4gIFx0dmFyIGRlcGVuZGFudHMgPSBbeyByYWN0aXZlOiByYWN0aXZlLCBrZXlwYXRoOiBrZXlwYXRoIH1dO1xuXG4gIFx0dmFyIGRlc2NyaXB0b3IgPSB7XG4gIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0cmV0dXJuICd2YWx1ZScgaW4gb3JpZ2luYWxEZXNjcmlwdG9yID8gb3JpZ2luYWxEZXNjcmlwdG9yLnZhbHVlIDogb3JpZ2luYWxEZXNjcmlwdG9yLmdldC5jYWxsKCB0aGlzICk7XG4gIFx0XHR9LFxuICBcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgXHRcdFx0aWYgKCBzZXR0aW5nICkgcmV0dXJuO1xuXG4gIFx0XHRcdGlmICggJ3ZhbHVlJyBpbiBvcmlnaW5hbERlc2NyaXB0b3IgKSB7XG4gIFx0XHRcdFx0b3JpZ2luYWxEZXNjcmlwdG9yLnZhbHVlID0gdmFsdWU7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0b3JpZ2luYWxEZXNjcmlwdG9yLnNldC5jYWxsKCB0aGlzLCB2YWx1ZSApO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0aWYgKCB3cmFwcGVyLmxvY2tlZCApIHJldHVybjtcbiAgXHRcdFx0c2V0dGluZyA9IHRydWU7XG4gIFx0XHRcdGRlcGVuZGFudHMuZm9yRWFjaCggZnVuY3Rpb24gKHJlZikge1xuICBcdFx0XHRcdHZhciByYWN0aXZlID0gcmVmLnJhY3RpdmU7XG4gIFx0XHRcdFx0dmFyIGtleXBhdGggPSByZWYua2V5cGF0aDtcblxuICBcdFx0XHRcdHJhY3RpdmUuc2V0KCBrZXlwYXRoLCB2YWx1ZSApO1xuICBcdFx0XHR9KTtcbiAgXHRcdFx0c2V0dGluZyA9IGZhbHNlO1xuICBcdFx0fSxcbiAgXHRcdGVudW1lcmFibGU6IHRydWVcbiAgXHR9O1xuXG4gIFx0ZGVzY3JpcHRvci5zZXQuX19tYWdpYyA9IHsgZGVwZW5kYW50czogZGVwZW5kYW50cywgb3JpZ2luYWxEZXNjcmlwdG9yOiBvcmlnaW5hbERlc2NyaXB0b3IgfTtcblxuICBcdHJldHVybiBkZXNjcmlwdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV2ZXJ0ICggZGVzY3JpcHRvciwgcmFjdGl2ZSwga2V5cGF0aCApIHtcbiAgXHRpZiAoICFkZXNjcmlwdG9yLnNldCB8fCAhZGVzY3JpcHRvci5zZXQuX19tYWdpYyApIHJldHVybiB0cnVlO1xuXG4gIFx0dmFyIGRlcGVuZGFudHMgPSBkZXNjcmlwdG9yLnNldC5fX21hZ2ljO1xuICBcdHZhciBpID0gZGVwZW5kYW50cy5sZW5ndGg7XG4gIFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHR2YXIgZGVwZW5kYW50ID0gZGVwZW5kYW50c1tpXTtcbiAgXHRcdGlmICggZGVwZW5kYW50LnJhY3RpdmUgPT09IHJhY3RpdmUgJiYgZGVwZW5kYW50LmtleXBhdGggPT09IGtleXBhdGggKSB7XG4gIFx0XHRcdGRlcGVuZGFudHMuc3BsaWNlKCBpLCAxICk7XG4gIFx0XHRcdHJldHVybiBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9XG4gIH1cblxuICB2YXIgTWFnaWNXcmFwcGVyID0gZnVuY3Rpb24gTWFnaWNXcmFwcGVyICggcmFjdGl2ZSwgdmFsdWUsIGtleXBhdGggKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG4gIFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuICBcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cbiAgXHR0aGlzLm9yaWdpbmFsRGVzY3JpcHRvcnMgPSB7fTtcblxuICBcdC8vIHdyYXAgYWxsIHByb3BlcnRpZXMgd2l0aCBnZXR0ZXJzXG4gIFx0T2JqZWN0LmtleXMoIHZhbHVlICkuZm9yRWFjaCggZnVuY3Rpb24gKCBrZXkgKSB7XG4gIFx0XHR2YXIgb3JpZ2luYWxEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciggdGhpcyQxLnZhbHVlLCBrZXkgKTtcbiAgXHRcdHRoaXMkMS5vcmlnaW5hbERlc2NyaXB0b3JzWyBrZXkgXSA9IG9yaWdpbmFsRGVzY3JpcHRvcjtcblxuICBcdFx0dmFyIGNoaWxkS2V5cGF0aCA9IGtleXBhdGggPyAoXCJcIiArIGtleXBhdGggKyBcIi5cIiArIChlc2NhcGVLZXkoIGtleSApKSkgOiBlc2NhcGVLZXkoIGtleSApO1xuXG4gIFx0XHR2YXIgZGVzY3JpcHRvciA9IGNyZWF0ZU9yV3JhcERlc2NyaXB0b3IoIG9yaWdpbmFsRGVzY3JpcHRvciwgcmFjdGl2ZSwgY2hpbGRLZXlwYXRoLCB0aGlzJDEgKTtcblxuXG5cbiAgXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcyQxLnZhbHVlLCBrZXksIGRlc2NyaXB0b3IgKTtcbiAgXHR9KTtcbiAgfTtcblxuICBNYWdpY1dyYXBwZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIFx0cmV0dXJuIHRoaXMudmFsdWU7XG4gIH07XG5cbiAgTWFnaWNXcmFwcGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0ICggdmFsdWUgKSB7XG4gIFx0cmV0dXJuIHRoaXMudmFsdWUgPT09IHZhbHVlO1xuICB9O1xuXG4gIE1hZ2ljV3JhcHBlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0ICgga2V5LCB2YWx1ZSApIHtcbiAgXHR0aGlzLnZhbHVlWyBrZXkgXSA9IHZhbHVlO1xuICB9O1xuXG4gIE1hZ2ljV3JhcHBlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdE9iamVjdC5rZXlzKCB0aGlzLnZhbHVlICkuZm9yRWFjaCggZnVuY3Rpb24gKCBrZXkgKSB7XG4gIFx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIHRoaXMkMS52YWx1ZSwga2V5ICk7XG4gIFx0XHRpZiAoICFkZXNjcmlwdG9yLnNldCB8fCAhZGVzY3JpcHRvci5zZXQuX19tYWdpYyApIHJldHVybjtcblxuICBcdFx0cmV2ZXJ0KCBkZXNjcmlwdG9yICk7XG5cbiAgXHRcdGlmICggZGVzY3JpcHRvci5zZXQuX19tYWdpYy5kZXBlbmRhbnRzLmxlbmd0aCA9PT0gMSApIHtcbiAgXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzJDEudmFsdWUsIGtleSwgZGVzY3JpcHRvci5zZXQuX19tYWdpYy5vcmlnaW5hbERlc2NyaXB0b3IgKTtcbiAgXHRcdH1cbiAgXHR9KTtcbiAgfTtcblxuICB2YXIgTWFnaWNBcnJheVdyYXBwZXIgPSBmdW5jdGlvbiBNYWdpY0FycmF5V3JhcHBlciAoIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICkge1xuICBcdHRoaXMudmFsdWUgPSBhcnJheTtcblxuICBcdHRoaXMubWFnaWMgPSB0cnVlO1xuXG4gIFx0dGhpcy5tYWdpY1dyYXBwZXIgPSBtYWdpY0FkYXB0b3IkMS53cmFwKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApO1xuICBcdHRoaXMuYXJyYXlXcmFwcGVyID0gYXJyYXlBZGFwdG9yLndyYXAoIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICk7XG4gIFx0dGhpcy5hcnJheVdyYXBwZXIubWFnaWMgPSB0aGlzLm1hZ2ljV3JhcHBlcjtcblxuICBcdC8vIHVnaCwgdGhpcyByZWFsbHkgaXMgYSB0ZXJyaWJsZSBoYWNrXG4gIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnX19tb2RlbCcsIHtcbiAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5hcnJheVdyYXBwZXIuX19tb2RlbDtcbiAgXHRcdH0sXG4gIFx0XHRzZXQ6IGZ1bmN0aW9uICggbW9kZWwgKSB7XG4gIFx0XHRcdHRoaXMuYXJyYXlXcmFwcGVyLl9fbW9kZWwgPSBtb2RlbDtcbiAgXHRcdH1cbiAgXHR9KTtcbiAgfTtcblxuICBNYWdpY0FycmF5V3JhcHBlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgXHRyZXR1cm4gdGhpcy52YWx1ZTtcbiAgfTtcblxuICBNYWdpY0FycmF5V3JhcHBlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gIFx0dGhpcy5hcnJheVdyYXBwZXIudGVhcmRvd24oKTtcbiAgXHR0aGlzLm1hZ2ljV3JhcHBlci50ZWFyZG93bigpO1xuICB9O1xuXG4gIE1hZ2ljQXJyYXlXcmFwcGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0ICggdmFsdWUgKSB7XG4gIFx0cmV0dXJuIHRoaXMuYXJyYXlXcmFwcGVyLnJlc2V0KCB2YWx1ZSApICYmIHRoaXMubWFnaWNXcmFwcGVyLnJlc2V0KCB2YWx1ZSApO1xuICB9O1xuXG4gIHZhciBtYWdpY0FycmF5QWRhcHRvciA9IHtcbiAgXHRmaWx0ZXI6IGZ1bmN0aW9uICggb2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlICkge1xuICBcdFx0cmV0dXJuIG1hZ2ljQWRhcHRvciQxLmZpbHRlciggb2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlICkgJiYgYXJyYXlBZGFwdG9yLmZpbHRlciggb2JqZWN0ICk7XG4gIFx0fSxcblxuICBcdHdyYXA6IGZ1bmN0aW9uICggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKSB7XG4gIFx0XHRyZXR1cm4gbmV3IE1hZ2ljQXJyYXlXcmFwcGVyKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApO1xuICBcdH1cbiAgfTtcblxuICAvLyBUT0RPIHRoaXMgaXMgcHJvYmFibHkgYSBiaXQgYW5hbCwgbWF5YmUgd2Ugc2hvdWxkIGxlYXZlIGl0IG91dFxuICBmdW5jdGlvbiBwcmV0dGlmeSAoIGZuQm9keSApIHtcbiAgXHR2YXIgbGluZXMgPSBmbkJvZHlcbiAgXHRcdC5yZXBsYWNlKCAvXlxcdCsvZ20sIGZ1bmN0aW9uICggdGFicyApIHsgcmV0dXJuIHRhYnMuc3BsaXQoICdcXHQnICkuam9pbiggJyAgJyApOyB9IClcbiAgXHRcdC5zcGxpdCggJ1xcbicgKTtcblxuICBcdHZhciBtaW5JbmRlbnQgPSBsaW5lcy5sZW5ndGggPCAyID8gMCA6XG4gIFx0XHRsaW5lcy5zbGljZSggMSApLnJlZHVjZSggZnVuY3Rpb24gKCBwcmV2LCBsaW5lICkge1xuICBcdFx0XHRyZXR1cm4gTWF0aC5taW4oIHByZXYsIC9eXFxzKi8uZXhlYyggbGluZSApWzBdLmxlbmd0aCApO1xuICBcdFx0fSwgSW5maW5pdHkgKTtcblxuICBcdHJldHVybiBsaW5lcy5tYXAoIGZ1bmN0aW9uICggbGluZSwgaSApIHtcbiAgXHRcdHJldHVybiAnICAgICcgKyAoIGkgPyBsaW5lLnN1YnN0cmluZyggbWluSW5kZW50ICkgOiBsaW5lICk7XG4gIFx0fSkuam9pbiggJ1xcbicgKTtcbiAgfVxuXG4gIC8vIERpdHRvLiBUaGlzIGZ1bmN0aW9uIHRydW5jYXRlcyB0aGUgc3RhY2sgdG8gb25seSBpbmNsdWRlIGFwcCBjb2RlXG4gIGZ1bmN0aW9uIHRydW5jYXRlU3RhY2sgKCBzdGFjayApIHtcbiAgXHRpZiAoICFzdGFjayApIHJldHVybiAnJztcblxuICBcdHZhciBsaW5lcyA9IHN0YWNrLnNwbGl0KCAnXFxuJyApO1xuICBcdHZhciBuYW1lID0gQ29tcHV0YXRpb24ubmFtZSArICcuZ2V0VmFsdWUnO1xuXG4gIFx0dmFyIHRydW5jYXRlZCA9IFtdO1xuXG4gIFx0dmFyIGxlbiA9IGxpbmVzLmxlbmd0aDtcbiAgXHRmb3IgKCB2YXIgaSA9IDE7IGkgPCBsZW47IGkgKz0gMSApIHtcbiAgXHRcdHZhciBsaW5lID0gbGluZXNbaV07XG5cbiAgXHRcdGlmICggfmxpbmUuaW5kZXhPZiggbmFtZSApICkge1xuICBcdFx0XHRyZXR1cm4gdHJ1bmNhdGVkLmpvaW4oICdcXG4nICk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0cnVuY2F0ZWQucHVzaCggbGluZSApO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBDb21wdXRhdGlvbiA9IChmdW5jdGlvbiAoTW9kZWwpIHtcbiAgXHRmdW5jdGlvbiBDb21wdXRhdGlvbiAoIHZpZXdtb2RlbCwgc2lnbmF0dXJlLCBrZXkgKSB7XG4gIFx0XHRNb2RlbC5jYWxsKCB0aGlzLCBudWxsLCBudWxsICk7XG5cbiAgXHRcdHRoaXMucm9vdCA9IHRoaXMucGFyZW50ID0gdmlld21vZGVsO1xuICBcdFx0dGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG5cbiAgXHRcdHRoaXMua2V5ID0ga2V5OyAvLyBub3QgYWN0dWFsbHkgdXNlZCwgYnV0IGhlbHBzIHdpdGggZGVidWdnaW5nXG4gIFx0XHR0aGlzLmlzRXhwcmVzc2lvbiA9IGtleSAmJiBrZXlbMF0gPT09ICdAJztcblxuICBcdFx0dGhpcy5pc1JlYWRvbmx5ID0gIXRoaXMuc2lnbmF0dXJlLnNldHRlcjtcblxuICBcdFx0dGhpcy5jb250ZXh0ID0gdmlld21vZGVsLmNvbXB1dGF0aW9uQ29udGV4dDtcblxuICBcdFx0dGhpcy5kZXBlbmRlbmNpZXMgPSBbXTtcblxuICBcdFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xuICBcdFx0dGhpcy5jaGlsZEJ5S2V5ID0ge307XG5cbiAgXHRcdHRoaXMuZGVwcyA9IFtdO1xuXG4gIFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICBcdFx0Ly8gVE9ETzogaXMgdGhlcmUgYSBsZXNzIGhhY2tpc2ggd2F5IHRvIGRvIHRoaXM/XG4gIFx0XHR0aGlzLnNodWZmbGUgPSB1bmRlZmluZWQ7XG4gIFx0fVxuXG4gIFx0Q29tcHV0YXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTW9kZWwgJiYgTW9kZWwucHJvdG90eXBlICk7XG4gIFx0Q29tcHV0YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29tcHV0YXRpb247XG5cbiAgXHRDb21wdXRhdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICggc2hvdWxkQ2FwdHVyZSApIHtcbiAgXHRcdGlmICggc2hvdWxkQ2FwdHVyZSApIGNhcHR1cmUoIHRoaXMgKTtcblxuICBcdFx0aWYgKCB0aGlzLmRpcnR5ICkge1xuICBcdFx0XHR0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIFx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gIFx0XHRcdGlmICggdGhpcy53cmFwcGVyICkgdGhpcy5uZXdXcmFwcGVyVmFsdWUgPSB0aGlzLnZhbHVlO1xuICBcdFx0XHR0aGlzLmFkYXB0KCk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlmIGNhcHR1cmluZywgdGhpcyB2YWx1ZSBuZWVkcyB0byBiZSB1bndyYXBwZWQgYmVjYXVzZSBpdCdzIGZvciBleHRlcm5hbCB1c2VcbiAgXHRcdHJldHVybiBzaG91bGRDYXB0dXJlICYmIHRoaXMud3JhcHBlciA/IHRoaXMud3JhcHBlclZhbHVlIDogdGhpcy52YWx1ZTtcbiAgXHR9O1xuXG4gIFx0Q29tcHV0YXRpb24ucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUgKCkge1xuICBcdFx0c3RhcnRDYXB0dXJpbmcoKTtcbiAgXHRcdHZhciByZXN1bHQ7XG5cbiAgXHRcdHRyeSB7XG4gIFx0XHRcdHJlc3VsdCA9IHRoaXMuc2lnbmF0dXJlLmdldHRlci5jYWxsKCB0aGlzLmNvbnRleHQgKTtcbiAgXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKCAoXCJGYWlsZWQgdG8gY29tcHV0ZSBcIiArICh0aGlzLmdldEtleXBhdGgoKSkgKyBcIjogXCIgKyAoZXJyLm1lc3NhZ2UgfHwgZXJyKSkgKTtcblxuICBcdFx0XHQvLyBUT0RPIHRoaXMgaXMgYWxsIHdlbGwgYW5kIGdvb2QgaW4gQ2hyb21lLCBidXQuLi5cbiAgXHRcdFx0Ly8gLi4uYWxzbywgc2hvdWxkIGVuY2Fwc3VsYXRlIHRoaXMgc3R1ZmYgYmV0dGVyLCBhbmQgb25seVxuICBcdFx0XHQvLyBzaG93IGl0IGlmIFJhY3RpdmUuREVCVUdcbiAgXHRcdFx0aWYgKCBoYXNDb25zb2xlICkge1xuICBcdFx0XHRcdGlmICggY29uc29sZS5ncm91cENvbGxhcHNlZCApIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoICclY3Nob3cgZGV0YWlscycsICdjb2xvcjogcmdiKDgyLCAxNDAsIDIyNCk7IGZvbnQtd2VpZ2h0OiBub3JtYWw7IHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOycgKTtcbiAgXHRcdFx0XHR2YXIgZnVuY3Rpb25Cb2R5ID0gcHJldHRpZnkoIHRoaXMuc2lnbmF0dXJlLmdldHRlclN0cmluZyApO1xuICBcdFx0XHRcdHZhciBzdGFjayA9IHRoaXMuc2lnbmF0dXJlLmdldHRlclVzZVN0YWNrID8gJ1xcblxcbicgKyB0cnVuY2F0ZVN0YWNrKCBlcnIuc3RhY2sgKSA6ICcnO1xuICBcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIChcIlwiICsgKGVyci5uYW1lKSArIFwiOiBcIiArIChlcnIubWVzc2FnZSkgKyBcIlxcblxcblwiICsgZnVuY3Rpb25Cb2R5ICsgXCJcIiArIHN0YWNrKSApO1xuICBcdFx0XHRcdGlmICggY29uc29sZS5ncm91cENvbGxhcHNlZCApIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR2YXIgZGVwZW5kZW5jaWVzID0gc3RvcENhcHR1cmluZygpO1xuICBcdFx0dGhpcy5zZXREZXBlbmRlbmNpZXMoIGRlcGVuZGVuY2llcyApO1xuXG4gIFx0XHQvLyBpZiBub3QgdGhlIGZpcnN0IGNvbXB1dGF0aW9uIGFuZCB0aGUgdmFsdWUgaXMgbm90IHRoZSBzYW1lLFxuICBcdFx0Ly8gcmVnaXN0ZXIgdGhlIGNoYW5nZSBmb3IgY2hhbmdlIGV2ZW50c1xuICBcdFx0aWYgKCAndmFsdWUnIGluIHRoaXMgJiYgcmVzdWx0ICE9PSB0aGlzLnZhbHVlICkge1xuICBcdFx0XHR0aGlzLnJlZ2lzdGVyQ2hhbmdlKCB0aGlzLmdldEtleXBhdGgoKSwgcmVzdWx0ICk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiByZXN1bHQ7XG4gIFx0fTtcblxuICBcdENvbXB1dGF0aW9uLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UkMSAoKSB7XG4gIFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICBcdFx0dGhpcy5saW5rcy5mb3JFYWNoKCBtYXJrZWQgKTtcbiAgXHRcdHRoaXMuZGVwcy5mb3JFYWNoKCBoYW5kbGVDaGFuZ2UgKTtcbiAgXHRcdHRoaXMuY2hpbGRyZW4uZm9yRWFjaCggaGFuZGxlQ2hhbmdlICk7XG4gIFx0XHR0aGlzLmNsZWFyVW5yZXNvbHZlZHMoKTsgLy8gVE9ETyBzYW1lIHF1ZXN0aW9uIGFzIG9uIE1vZGVsIC0gbmVjZXNzYXJ5IGZvciBwcmltaXRpdmVzP1xuICBcdH07XG5cbiAgXHRDb21wdXRhdGlvbi5wcm90b3R5cGUuam9pbktleSA9IGZ1bmN0aW9uIGpvaW5LZXkgKCBrZXkgKSB7XG4gIFx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gJycgKSByZXR1cm4gdGhpcztcblxuICBcdFx0aWYgKCAhdGhpcy5jaGlsZEJ5S2V5Lmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcbiAgXHRcdFx0dmFyIGNoaWxkID0gbmV3IENvbXB1dGF0aW9uQ2hpbGQoIHRoaXMsIGtleSApO1xuICBcdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goIGNoaWxkICk7XG4gIFx0XHRcdHRoaXMuY2hpbGRCeUtleVsga2V5IF0gPSBjaGlsZDtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMuY2hpbGRCeUtleVsga2V5IF07XG4gIFx0fTtcblxuICBcdENvbXB1dGF0aW9uLnByb3RvdHlwZS5tYXJrID0gZnVuY3Rpb24gbWFyayAoKSB7XG4gIFx0XHR0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICBcdH07XG5cbiAgXHRDb21wdXRhdGlvbi5wcm90b3R5cGUucmViaW5kaW5nID0gZnVuY3Rpb24gcmViaW5kaW5nICggbmV4dCwgcHJldmlvdXMgKSB7XG4gIFx0XHQvLyBjb21wdXRhdGlvbnMgd2lsbCBncmFiIGFsbCBvZiB0aGVpciBkZXBzIGFnYWluIGF1dG9tYWdpY2FsbHlcbiAgXHRcdGlmICggbmV4dCAhPT0gcHJldmlvdXMgKSB0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICBcdH07XG5cbiAgXHRDb21wdXRhdGlvbi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0ICggdmFsdWUgKSB7XG4gIFx0XHRpZiAoICF0aGlzLnNpZ25hdHVyZS5zZXR0ZXIgKSB7XG4gIFx0XHRcdHRocm93IG5ldyBFcnJvciggKFwiQ2Fubm90IHNldCByZWFkLW9ubHkgY29tcHV0ZWQgdmFsdWUgJ1wiICsgKHRoaXMua2V5KSArIFwiJ1wiKSApO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnNpZ25hdHVyZS5zZXR0ZXIoIHZhbHVlICk7XG4gIFx0XHR0aGlzLm1hcmsoKTtcbiAgXHR9O1xuXG4gIFx0Q29tcHV0YXRpb24ucHJvdG90eXBlLnNldERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uIHNldERlcGVuZGVuY2llcyAoIGRlcGVuZGVuY2llcyApIHtcbiAgXHRcdC8vIHVucmVnaXN0ZXIgYW55IHNvZnQgZGVwZW5kZW5jaWVzIHdlIG5vIGxvbmdlciBoYXZlXG4gIFx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dmFyIGkgPSB0aGlzLmRlcGVuZGVuY2llcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdFx0dmFyIG1vZGVsID0gdGhpcyQxLmRlcGVuZGVuY2llc1tpXTtcbiAgXHRcdFx0aWYgKCAhfmRlcGVuZGVuY2llcy5pbmRleE9mKCBtb2RlbCApICkgbW9kZWwudW5yZWdpc3RlciggdGhpcyQxICk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGFuZCBhZGQgYW55IG5ldyBvbmVzXG4gIFx0XHRpID0gZGVwZW5kZW5jaWVzLmxlbmd0aDtcbiAgXHRcdHdoaWxlICggaS0tICkge1xuICBcdFx0XHR2YXIgbW9kZWwkMSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgXHRcdFx0aWYgKCAhfnRoaXMkMS5kZXBlbmRlbmNpZXMuaW5kZXhPZiggbW9kZWwkMSApICkgbW9kZWwkMS5yZWdpc3RlciggdGhpcyQxICk7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICBcdH07XG5cbiAgXHRDb21wdXRhdGlvbi5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gIFx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dmFyIGkgPSB0aGlzLmRlcGVuZGVuY2llcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdFx0aWYgKCB0aGlzJDEuZGVwZW5kZW5jaWVzW2ldICkgdGhpcyQxLmRlcGVuZGVuY2llc1tpXS51bnJlZ2lzdGVyKCB0aGlzJDEgKTtcbiAgXHRcdH1cbiAgXHRcdGlmICggdGhpcy5yb290LmNvbXB1dGF0aW9uc1t0aGlzLmtleV0gPT09IHRoaXMgKSBkZWxldGUgdGhpcy5yb290LmNvbXB1dGF0aW9uc1t0aGlzLmtleV07XG4gIFx0XHRNb2RlbC5wcm90b3R5cGUudGVhcmRvd24uY2FsbCh0aGlzKTtcbiAgXHR9O1xuXG4gIFx0Q29tcHV0YXRpb24ucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyICggZGVwZW5kZW50ICkge1xuICBcdFx0TW9kZWwucHJvdG90eXBlLnVucmVnaXN0ZXIuY2FsbCggdGhpcywgZGVwZW5kZW50ICk7XG4gIFx0XHQvLyB0ZWFyIGRvd24gZXhwcmVzc2lvbnMgd2l0aCBubyBkZXBzLCBiZWNhdXNlIHRoZXkgd2lsbCBiZSByZXBsYWNlZCB3aGVuIG5lZWRlZFxuICBcdFx0aWYgKCB0aGlzLmlzRXhwcmVzc2lvbiAmJiB0aGlzLmRlcHMubGVuZ3RoID09PSAwICkgdGhpcy50ZWFyZG93bigpO1xuICBcdH07XG5cbiAgXHRyZXR1cm4gQ29tcHV0YXRpb247XG4gIH0oTW9kZWwpKTtcblxuICB2YXIgUmFjdGl2ZU1vZGVsID0gKGZ1bmN0aW9uIChNb2RlbCkge1xuICBcdGZ1bmN0aW9uIFJhY3RpdmVNb2RlbCAoIHJhY3RpdmUgKSB7XG4gIFx0XHRNb2RlbC5jYWxsKCB0aGlzLCBudWxsLCAnJyApO1xuICBcdFx0dGhpcy52YWx1ZSA9IHJhY3RpdmU7XG4gIFx0XHR0aGlzLmlzUm9vdCA9IHRydWU7XG4gIFx0XHR0aGlzLnJvb3QgPSB0aGlzO1xuICBcdFx0dGhpcy5hZGFwdG9ycyA9IFtdO1xuICBcdFx0dGhpcy5yYWN0aXZlID0gcmFjdGl2ZTtcbiAgXHRcdHRoaXMuY2hhbmdlcyA9IHt9O1xuICBcdH1cblxuICBcdFJhY3RpdmVNb2RlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNb2RlbCAmJiBNb2RlbC5wcm90b3R5cGUgKTtcbiAgXHRSYWN0aXZlTW9kZWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFjdGl2ZU1vZGVsO1xuXG4gIFx0UmFjdGl2ZU1vZGVsLnByb3RvdHlwZS5nZXRLZXlwYXRoID0gZnVuY3Rpb24gZ2V0S2V5cGF0aCgpIHtcbiAgXHRcdHJldHVybiAnQHRoaXMnO1xuICBcdH07XG5cbiAgXHRyZXR1cm4gUmFjdGl2ZU1vZGVsO1xuICB9KE1vZGVsKSk7XG5cbiAgdmFyIGhhc1Byb3AkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgdmFyIFJvb3RNb2RlbCA9IChmdW5jdGlvbiAoTW9kZWwpIHtcbiAgXHRmdW5jdGlvbiBSb290TW9kZWwgKCBvcHRpb25zICkge1xuICBcdFx0TW9kZWwuY2FsbCggdGhpcywgbnVsbCwgbnVsbCApO1xuXG4gIFx0XHQvLyBUT0RPIGRlcHJlY2F0ZSB0aGlzXG4gIFx0XHR0aGlzLmNoYW5nZXMgPSB7fTtcblxuICBcdFx0dGhpcy5pc1Jvb3QgPSB0cnVlO1xuICBcdFx0dGhpcy5yb290ID0gdGhpcztcbiAgXHRcdHRoaXMucmFjdGl2ZSA9IG9wdGlvbnMucmFjdGl2ZTsgLy8gVE9ETyBzZXZlciB0aGlzIGxpbmtcblxuICBcdFx0dGhpcy52YWx1ZSA9IG9wdGlvbnMuZGF0YTtcbiAgXHRcdHRoaXMuYWRhcHRvcnMgPSBvcHRpb25zLmFkYXB0O1xuICBcdFx0dGhpcy5hZGFwdCgpO1xuXG4gIFx0XHR0aGlzLmNvbXB1dGF0aW9uQ29udGV4dCA9IG9wdGlvbnMucmFjdGl2ZTtcbiAgXHRcdHRoaXMuY29tcHV0YXRpb25zID0ge307XG5cbiAgXHRcdC8vIFRPRE8gdGhpcyBpcyBvbmx5IGZvciBkZXByZWNhdGlvbiBvZiB1c2luZyBleHByZXNzaW9uIGtleXBhdGhzXG4gIFx0XHR0aGlzLmV4cHJlc3Npb25zID0ge307XG4gIFx0fVxuXG4gIFx0Um9vdE1vZGVsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1vZGVsICYmIE1vZGVsLnByb3RvdHlwZSApO1xuICBcdFJvb3RNb2RlbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb290TW9kZWw7XG5cbiAgXHRSb290TW9kZWwucHJvdG90eXBlLmFwcGx5Q2hhbmdlcyA9IGZ1bmN0aW9uIGFwcGx5Q2hhbmdlcyAoKSB7XG4gIFx0XHR0aGlzLl9jaGFuZ2VIYXNoID0ge307XG4gIFx0XHR0aGlzLmZsdXNoKCk7XG5cbiAgXHRcdHJldHVybiB0aGlzLl9jaGFuZ2VIYXNoO1xuICBcdH07XG5cbiAgXHRSb290TW9kZWwucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbiBjb21wdXRlICgga2V5LCBzaWduYXR1cmUgKSB7XG4gIFx0XHR2YXIgY29tcHV0YXRpb24gPSBuZXcgQ29tcHV0YXRpb24oIHRoaXMsIHNpZ25hdHVyZSwga2V5ICk7XG4gIFx0XHR0aGlzLmNvbXB1dGF0aW9uc1sga2V5IF0gPSBjb21wdXRhdGlvbjtcblxuICBcdFx0cmV0dXJuIGNvbXB1dGF0aW9uO1xuICBcdH07XG5cbiAgXHRSb290TW9kZWwucHJvdG90eXBlLmNyZWF0ZUxpbmsgPSBmdW5jdGlvbiBjcmVhdGVMaW5rICgga2V5cGF0aCwgdGFyZ2V0LCB0YXJnZXRQYXRoICkge1xuICBcdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHZhciBrZXlzID0gc3BsaXRLZXlwYXRoSSgga2V5cGF0aCApO1xuXG4gIFx0XHR2YXIgbW9kZWwgPSB0aGlzO1xuICBcdFx0d2hpbGUgKCBrZXlzLmxlbmd0aCApIHtcbiAgXHRcdFx0dmFyIGtleSA9IGtleXMuc2hpZnQoKTtcbiAgXHRcdFx0bW9kZWwgPSB0aGlzJDEuY2hpbGRCeUtleVsga2V5IF0gfHwgdGhpcyQxLmpvaW5LZXkoIGtleSApO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gbW9kZWwubGluayggdGFyZ2V0LCB0YXJnZXRQYXRoICk7XG4gIFx0fTtcblxuICBcdFJvb3RNb2RlbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICggc2hvdWxkQ2FwdHVyZSwgb3B0aW9ucyApIHtcbiAgXHRcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHRpZiAoIHNob3VsZENhcHR1cmUgKSBjYXB0dXJlKCB0aGlzICk7XG5cbiAgXHRcdGlmICggIW9wdGlvbnMgfHwgb3B0aW9ucy52aXJ0dWFsICE9PSBmYWxzZSApIHtcbiAgXHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMuZ2V0VmlydHVhbCgpO1xuICBcdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKCB0aGlzLmNvbXB1dGF0aW9ucyApO1xuICBcdFx0XHR2YXIgaSA9IGtleXMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdFx0XHR2YXIgY29tcHV0YXRpb24gPSB0aGlzJDEuY29tcHV0YXRpb25zWyBrZXlzW2ldIF07XG4gIFx0XHRcdFx0Ly8gZXhjbHVkZSB0ZW1wbGF0ZSBleHByZXNzaW9uc1xuICBcdFx0XHRcdGlmICggIWNvbXB1dGF0aW9uLmlzRXhwcmVzc2lvbiApIHtcbiAgXHRcdFx0XHRcdHJlc3VsdFsga2V5c1tpXSBdID0gY29tcHV0YXRpb24uZ2V0KCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLnZhbHVlO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRSb290TW9kZWwucHJvdG90eXBlLmdldEtleXBhdGggPSBmdW5jdGlvbiBnZXRLZXlwYXRoICgpIHtcbiAgXHRcdHJldHVybiAnJztcbiAgXHR9O1xuXG4gIFx0Um9vdE1vZGVsLnByb3RvdHlwZS5nZXRSYWN0aXZlTW9kZWwgPSBmdW5jdGlvbiBnZXRSYWN0aXZlTW9kZWwoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5yYWN0aXZlTW9kZWwgfHwgKCB0aGlzLnJhY3RpdmVNb2RlbCA9IG5ldyBSYWN0aXZlTW9kZWwoIHRoaXMucmFjdGl2ZSApICk7XG4gIFx0fTtcblxuICBcdFJvb3RNb2RlbC5wcm90b3R5cGUuZ2V0VmFsdWVDaGlsZHJlbiA9IGZ1bmN0aW9uIGdldFZhbHVlQ2hpbGRyZW4gKCkge1xuICBcdFx0dmFyIGNoaWxkcmVuID0gTW9kZWwucHJvdG90eXBlLmdldFZhbHVlQ2hpbGRyZW4uY2FsbCggdGhpcywgdGhpcy52YWx1ZSApO1xuXG4gIFx0XHR0aGlzLmNoaWxkcmVuLmZvckVhY2goIGZ1bmN0aW9uICggY2hpbGQgKSB7XG4gIFx0XHRcdGlmICggY2hpbGQuX2xpbmsgKSB7XG4gIFx0XHRcdFx0dmFyIGlkeCA9IGNoaWxkcmVuLmluZGV4T2YoIGNoaWxkICk7XG4gIFx0XHRcdFx0aWYgKCB+aWR4ICkgY2hpbGRyZW4uc3BsaWNlKCBpZHgsIDEsIGNoaWxkLl9saW5rICk7XG4gIFx0XHRcdFx0ZWxzZSBjaGlsZHJlbi5wdXNoKCBjaGlsZC5fbGluayApO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcblxuICBcdFx0Zm9yICggdmFyIGsgaW4gdGhpcy5jb21wdXRhdGlvbnMgKSB7XG4gIFx0XHRcdGNoaWxkcmVuLnB1c2goIHRoaXMuY29tcHV0YXRpb25zW2tdICk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBjaGlsZHJlbjtcbiAgXHR9O1xuXG4gIFx0Um9vdE1vZGVsLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UkMSAoKSB7XG4gIFx0XHR0aGlzLmRlcHMuZm9yRWFjaCggaGFuZGxlQ2hhbmdlICk7XG4gIFx0fTtcblxuICBcdFJvb3RNb2RlbC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzICgga2V5ICkge1xuICBcdFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcblxuICBcdFx0a2V5ID0gdW5lc2NhcGVLZXkoIGtleSApO1xuICBcdFx0aWYgKCBoYXNQcm9wJDEuY2FsbCggdmFsdWUsIGtleSApICkgcmV0dXJuIHRydWU7XG5cbiAgXHRcdC8vIG1hcHBpbmdzL2xpbmtzIGFuZCBjb21wdXRhdGlvbnNcbiAgXHRcdGlmICgga2V5IGluIHRoaXMuY29tcHV0YXRpb25zIHx8IHRoaXMuY2hpbGRCeUtleVtrZXldICYmIHRoaXMuY2hpbGRCeUtleVtrZXldLl9saW5rICkgcmV0dXJuIHRydWU7XG4gIFx0XHQvLyBUT0RPIHJlbW92ZSB0aGlzIGFmdGVyIGRlcHJlY2F0aW9uIGlzIGRvbmVcbiAgXHRcdGlmICgga2V5IGluIHRoaXMuZXhwcmVzc2lvbnMgKSByZXR1cm4gdHJ1ZTtcblxuICBcdFx0Ly8gV2UgY2xpbWIgdXAgdGhlIGNvbnN0cnVjdG9yIGNoYWluIHRvIGZpbmQgaWYgb25lIG9mIHRoZW0gY29udGFpbnMgdGhlIGtleVxuICBcdFx0dmFyIGNvbnN0cnVjdG9yID0gdmFsdWUuY29uc3RydWN0b3I7XG4gIFx0XHR3aGlsZSAoIGNvbnN0cnVjdG9yICE9PSBGdW5jdGlvbiAmJiBjb25zdHJ1Y3RvciAhPT0gQXJyYXkgJiYgY29uc3RydWN0b3IgIT09IE9iamVjdCApIHtcbiAgXHRcdFx0aWYgKCBoYXNQcm9wJDEuY2FsbCggY29uc3RydWN0b3IucHJvdG90eXBlLCBrZXkgKSApIHJldHVybiB0cnVlO1xuICBcdFx0XHRjb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yLmNvbnN0cnVjdG9yO1xuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0fTtcblxuICBcdFJvb3RNb2RlbC5wcm90b3R5cGUuam9pbktleSA9IGZ1bmN0aW9uIGpvaW5LZXkgKCBrZXksIG9wdHMgKSB7XG4gIFx0XHRpZiAoIGtleSA9PT0gJ0BnbG9iYWwnICkgcmV0dXJuIEdsb2JhbE1vZGVsJDE7XG4gIFx0XHRpZiAoIGtleSA9PT0gJ0B0aGlzJyApIHJldHVybiB0aGlzLmdldFJhY3RpdmVNb2RlbCgpO1xuXG4gIFx0XHRpZiAoIHRoaXMuZXhwcmVzc2lvbnMuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuICBcdFx0XHR3YXJuSWZEZWJ1ZyggKFwiQWNjZXNzaW5nIGV4cHJlc3Npb24ga2V5cGF0aHMgKFwiICsgKGtleS5zdWJzdHIoMSkpICsgXCIpIGZyb20gdGhlIGluc3RhbmNlIGlzIGRlcHJlY2F0ZWQuIFlvdSBjYW4gdXNlZCBhIGdldE5vZGVJbmZvIG9yIGV2ZW50IG9iamVjdCB0byBhY2Nlc3Mga2V5cGF0aHMgd2l0aCBleHByZXNzaW9uIGNvbnRleHQuXCIpICk7XG4gIFx0XHRcdHJldHVybiB0aGlzLmV4cHJlc3Npb25zWyBrZXkgXTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHRoaXMuY29tcHV0YXRpb25zLmhhc093blByb3BlcnR5KCBrZXkgKSA/IHRoaXMuY29tcHV0YXRpb25zWyBrZXkgXSA6XG4gIFx0XHQgICAgICAgTW9kZWwucHJvdG90eXBlLmpvaW5LZXkuY2FsbCggdGhpcywga2V5LCBvcHRzICk7XG4gIFx0fTtcblxuICBcdFJvb3RNb2RlbC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwICggbG9jYWxLZXksIG9yaWdpbiApIHtcbiAgXHRcdHZhciBsb2NhbCA9IHRoaXMuam9pbktleSggbG9jYWxLZXkgKTtcbiAgXHRcdGxvY2FsLmxpbmsoIG9yaWdpbiApO1xuICBcdH07XG5cbiAgXHRSb290TW9kZWwucHJvdG90eXBlLnJlYmluZGluZyA9IGZ1bmN0aW9uIHJlYmluZGluZyAoKSB7XG4gIFx0fTtcblxuICBcdFJvb3RNb2RlbC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0ICggdmFsdWUgKSB7XG4gIFx0XHQvLyBUT0RPIHdyYXBwaW5nIHJvb3Qgbm9kZSBpcyBhIGJhYWFhZCBpZGVhLiBXZSBzaG91bGQgcHJldmVudCB0aGlzXG4gIFx0XHR2YXIgd3JhcHBlciA9IHRoaXMud3JhcHBlcjtcbiAgXHRcdGlmICggd3JhcHBlciApIHtcbiAgXHRcdFx0dmFyIHNob3VsZFRlYXJkb3duID0gIXdyYXBwZXIucmVzZXQgfHwgd3JhcHBlci5yZXNldCggdmFsdWUgKSA9PT0gZmFsc2U7XG5cbiAgXHRcdFx0aWYgKCBzaG91bGRUZWFyZG93biApIHtcbiAgXHRcdFx0XHR3cmFwcGVyLnRlYXJkb3duKCk7XG4gIFx0XHRcdFx0dGhpcy53cmFwcGVyID0gbnVsbDtcbiAgXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG4gIFx0XHRcdFx0dGhpcy5hZGFwdCgpO1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG4gIFx0XHRcdHRoaXMuYWRhcHQoKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5kZXBzLmZvckVhY2goIGhhbmRsZUNoYW5nZSApO1xuICBcdFx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKCBtYXJrICk7XG4gIFx0XHR0aGlzLmNsZWFyVW5yZXNvbHZlZHMoKTsgLy8gVE9ETyBkbyB3ZSBuZWVkIHRvIGRvIHRoaXMgd2l0aCBwcmltaXRpdmUgdmFsdWVzPyBpZiBub3QsIHdoYXQgYWJvdXQgZS5nLiB1bnJlc29sdmVkIGBsZW5ndGhgIHByb3BlcnR5IG9mIG51bGwgLT4gc3RyaW5nP1xuICBcdH07XG5cbiAgXHRSb290TW9kZWwucHJvdG90eXBlLnJldHJpZXZlID0gZnVuY3Rpb24gcmV0cmlldmUgKCkge1xuICBcdFx0cmV0dXJuIHRoaXMud3JhcHBlciA/IHRoaXMud3JhcHBlci5nZXQoKSA6IHRoaXMudmFsdWU7XG4gIFx0fTtcblxuICBcdFJvb3RNb2RlbC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgXHRcdC8vIG5vb3BcbiAgXHR9O1xuXG4gIFx0cmV0dXJuIFJvb3RNb2RlbDtcbiAgfShNb2RlbCkpO1xuXG4gIGZ1bmN0aW9uIGdldENvbXB1dGF0aW9uU2lnbmF0dXJlICggcmFjdGl2ZSwga2V5LCBzaWduYXR1cmUgKSB7XG4gIFx0dmFyIGdldHRlcjtcbiAgXHR2YXIgc2V0dGVyO1xuXG4gIFx0Ly8gdXNlZnVsIGZvciBkZWJ1Z2dpbmdcbiAgXHR2YXIgZ2V0dGVyU3RyaW5nO1xuICBcdHZhciBnZXR0ZXJVc2VTdGFjaztcbiAgXHR2YXIgc2V0dGVyU3RyaW5nO1xuXG4gIFx0aWYgKCB0eXBlb2Ygc2lnbmF0dXJlID09PSAnZnVuY3Rpb24nICkge1xuICBcdFx0Z2V0dGVyID0gYmluZCggc2lnbmF0dXJlLCByYWN0aXZlICk7XG4gIFx0XHRnZXR0ZXJTdHJpbmcgPSBzaWduYXR1cmUudG9TdHJpbmcoKTtcbiAgXHRcdGdldHRlclVzZVN0YWNrID0gdHJ1ZTtcbiAgXHR9XG5cbiAgXHRpZiAoIHR5cGVvZiBzaWduYXR1cmUgPT09ICdzdHJpbmcnICkge1xuICBcdFx0Z2V0dGVyID0gY3JlYXRlRnVuY3Rpb25Gcm9tU3RyaW5nKCBzaWduYXR1cmUsIHJhY3RpdmUgKTtcbiAgXHRcdGdldHRlclN0cmluZyA9IHNpZ25hdHVyZTtcbiAgXHR9XG5cbiAgXHRpZiAoIHR5cGVvZiBzaWduYXR1cmUgPT09ICdvYmplY3QnICkge1xuICBcdFx0aWYgKCB0eXBlb2Ygc2lnbmF0dXJlLmdldCA9PT0gJ3N0cmluZycgKSB7XG4gIFx0XHRcdGdldHRlciA9IGNyZWF0ZUZ1bmN0aW9uRnJvbVN0cmluZyggc2lnbmF0dXJlLmdldCwgcmFjdGl2ZSApO1xuICBcdFx0XHRnZXR0ZXJTdHJpbmcgPSBzaWduYXR1cmUuZ2V0O1xuICBcdFx0fSBlbHNlIGlmICggdHlwZW9mIHNpZ25hdHVyZS5nZXQgPT09ICdmdW5jdGlvbicgKSB7XG4gIFx0XHRcdGdldHRlciA9IGJpbmQoIHNpZ25hdHVyZS5nZXQsIHJhY3RpdmUgKTtcbiAgXHRcdFx0Z2V0dGVyU3RyaW5nID0gc2lnbmF0dXJlLmdldC50b1N0cmluZygpO1xuICBcdFx0XHRnZXR0ZXJVc2VTdGFjayA9IHRydWU7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRmYXRhbCggJ2Alc2AgY29tcHV0YXRpb24gbXVzdCBoYXZlIGEgYGdldCgpYCBtZXRob2QnLCBrZXkgKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCB0eXBlb2Ygc2lnbmF0dXJlLnNldCA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgXHRcdFx0c2V0dGVyID0gYmluZCggc2lnbmF0dXJlLnNldCwgcmFjdGl2ZSApO1xuICBcdFx0XHRzZXR0ZXJTdHJpbmcgPSBzaWduYXR1cmUuc2V0LnRvU3RyaW5nKCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHtcbiAgXHRcdGdldHRlcjogZ2V0dGVyLFxuICBcdFx0c2V0dGVyOiBzZXR0ZXIsXG4gIFx0XHRnZXR0ZXJTdHJpbmc6IGdldHRlclN0cmluZyxcbiAgXHRcdHNldHRlclN0cmluZzogc2V0dGVyU3RyaW5nLFxuICBcdFx0Z2V0dGVyVXNlU3RhY2s6IGdldHRlclVzZVN0YWNrXG4gIFx0fTtcbiAgfVxuXG4gIHZhciBjb25zdHJ1Y3RIb29rID0gbmV3IEhvb2soICdjb25zdHJ1Y3QnICk7XG5cbiAgdmFyIHJlZ2lzdHJ5TmFtZXMkMSA9IFtcbiAgXHQnYWRhcHRvcnMnLFxuICBcdCdjb21wb25lbnRzJyxcbiAgXHQnZGVjb3JhdG9ycycsXG4gIFx0J2Vhc2luZycsXG4gIFx0J2V2ZW50cycsXG4gIFx0J2ludGVycG9sYXRvcnMnLFxuICBcdCdwYXJ0aWFscycsXG4gIFx0J3RyYW5zaXRpb25zJ1xuICBdO1xuXG4gIHZhciB1aWQgPSAwO1xuXG4gIGZ1bmN0aW9uIGNvbnN0cnVjdCAoIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG4gIFx0aWYgKCBSYWN0aXZlLkRFQlVHICkgd2VsY29tZSgpO1xuXG4gIFx0aW5pdGlhbGlzZVByb3BlcnRpZXMoIHJhY3RpdmUgKTtcblxuICBcdC8vIFRPRE8gcmVtb3ZlIHRoaXMsIGV2ZW50dWFsbHlcbiAgXHRkZWZpbmVQcm9wZXJ0eSggcmFjdGl2ZSwgJ2RhdGEnLCB7IGdldDogZGVwcmVjYXRlUmFjdGl2ZURhdGEgfSk7XG5cbiAgXHQvLyBUT0RPIGRvbid0IGFsbG93IGBvbmNvbnN0cnVjdGAgd2l0aCBgbmV3IFJhY3RpdmUoKWAsIHRoZXJlJ3Mgbm8gbmVlZCBmb3IgaXRcbiAgXHRjb25zdHJ1Y3RIb29rLmZpcmUoIHJhY3RpdmUsIG9wdGlvbnMgKTtcblxuICBcdC8vIEFkZCByZWdpc3RyaWVzXG4gIFx0cmVnaXN0cnlOYW1lcyQxLmZvckVhY2goIGZ1bmN0aW9uICggbmFtZSApIHtcbiAgXHRcdHJhY3RpdmVbIG5hbWUgXSA9IGV4dGVuZE9iaiggY3JlYXRlKCByYWN0aXZlLmNvbnN0cnVjdG9yWyBuYW1lIF0gfHwgbnVsbCApLCBvcHRpb25zWyBuYW1lIF0gKTtcbiAgXHR9KTtcblxuICBcdC8vIENyZWF0ZSBhIHZpZXdtb2RlbFxuICBcdHZhciB2aWV3bW9kZWwgPSBuZXcgUm9vdE1vZGVsKHtcbiAgXHRcdGFkYXB0OiBnZXRBZGFwdG9ycyggcmFjdGl2ZSwgcmFjdGl2ZS5hZGFwdCwgb3B0aW9ucyApLFxuICBcdFx0ZGF0YTogZGF0YUNvbmZpZ3VyYXRvci5pbml0KCByYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlLCBvcHRpb25zICksXG4gIFx0XHRyYWN0aXZlOiByYWN0aXZlXG4gIFx0fSk7XG5cbiAgXHRyYWN0aXZlLnZpZXdtb2RlbCA9IHZpZXdtb2RlbDtcblxuICBcdC8vIEFkZCBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gIFx0dmFyIGNvbXB1dGVkID0gZXh0ZW5kT2JqKCBjcmVhdGUoIHJhY3RpdmUuY29uc3RydWN0b3IucHJvdG90eXBlLmNvbXB1dGVkICksIG9wdGlvbnMuY29tcHV0ZWQgKTtcblxuICBcdGZvciAoIHZhciBrZXkgaW4gY29tcHV0ZWQgKSB7XG4gIFx0XHR2YXIgc2lnbmF0dXJlID0gZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUoIHJhY3RpdmUsIGtleSwgY29tcHV0ZWRbIGtleSBdICk7XG4gIFx0XHR2aWV3bW9kZWwuY29tcHV0ZSgga2V5LCBzaWduYXR1cmUgKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBjb21iaW5lJDIgKCBhcnJheXMgKSB7XG4gIFx0dmFyIHJlcyA9IFtdO1xuICBcdHZhciBhcmdzID0gcmVzLmNvbmNhdC5hcHBseSggcmVzLCBhcnJheXMgKTtcblxuICBcdHZhciBpID0gYXJncy5sZW5ndGg7XG4gIFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRpZiAoICF+cmVzLmluZGV4T2YoIGFyZ3NbaV0gKSApIHtcbiAgXHRcdFx0cmVzLnVuc2hpZnQoIGFyZ3NbaV0gKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gcmVzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QWRhcHRvcnMgKCByYWN0aXZlLCBwcm90b0FkYXB0LCBvcHRpb25zICkge1xuICBcdHByb3RvQWRhcHQgPSBwcm90b0FkYXB0Lm1hcCggbG9va3VwICk7XG4gIFx0dmFyIGFkYXB0ID0gZW5zdXJlQXJyYXkoIG9wdGlvbnMuYWRhcHQgKS5tYXAoIGxvb2t1cCApO1xuXG4gIFx0dmFyIGJ1aWx0aW5zID0gW107XG4gIFx0dmFyIHNyY3MgPSBbIHByb3RvQWRhcHQsIGFkYXB0IF07XG4gIFx0aWYgKCByYWN0aXZlLnBhcmVudCAmJiAhcmFjdGl2ZS5pc29sYXRlZCApIHtcbiAgXHRcdHNyY3MucHVzaCggcmFjdGl2ZS5wYXJlbnQudmlld21vZGVsLmFkYXB0b3JzICk7XG4gIFx0fVxuICBcdHNyY3MucHVzaCggYnVpbHRpbnMgKTtcblxuICBcdHZhciBtYWdpYyA9ICdtYWdpYycgaW4gb3B0aW9ucyA/IG9wdGlvbnMubWFnaWMgOiByYWN0aXZlLm1hZ2ljO1xuICBcdHZhciBtb2RpZnlBcnJheXMgPSAnbW9kaWZ5QXJyYXlzJyBpbiBvcHRpb25zID8gb3B0aW9ucy5tb2RpZnlBcnJheXMgOiByYWN0aXZlLm1vZGlmeUFycmF5cztcblxuICBcdGlmICggbWFnaWMgKSB7XG4gIFx0XHRpZiAoICFtYWdpY1N1cHBvcnRlZCApIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnR2V0dGVycyBhbmQgc2V0dGVycyAobWFnaWMgbW9kZSkgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyApO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIG1vZGlmeUFycmF5cyApIHtcbiAgXHRcdFx0YnVpbHRpbnMucHVzaCggbWFnaWNBcnJheUFkYXB0b3IgKTtcbiAgXHRcdH1cblxuICBcdFx0YnVpbHRpbnMucHVzaCggbWFnaWNBZGFwdG9yJDEgKTtcbiAgXHR9XG5cbiAgXHRpZiAoIG1vZGlmeUFycmF5cyApIHtcbiAgXHRcdGJ1aWx0aW5zLnB1c2goIGFycmF5QWRhcHRvciApO1xuICBcdH1cblxuICBcdHJldHVybiBjb21iaW5lJDIoIHNyY3MgKTtcblxuXG4gIFx0ZnVuY3Rpb24gbG9va3VwICggYWRhcHRvciApIHtcbiAgXHRcdGlmICggdHlwZW9mIGFkYXB0b3IgPT09ICdzdHJpbmcnICkge1xuICBcdFx0XHRhZGFwdG9yID0gZmluZEluVmlld0hpZXJhcmNoeSggJ2FkYXB0b3JzJywgcmFjdGl2ZSwgYWRhcHRvciApO1xuXG4gIFx0XHRcdGlmICggIWFkYXB0b3IgKSB7XG4gIFx0XHRcdFx0ZmF0YWwoIG1pc3NpbmdQbHVnaW4oIGFkYXB0b3IsICdhZGFwdG9yJyApICk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIGFkYXB0b3I7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGlzZVByb3BlcnRpZXMgKCByYWN0aXZlICkge1xuICBcdC8vIEdlbmVyYXRlIGEgdW5pcXVlIGlkZW50aWZpZXIsIGZvciBwbGFjZXMgd2hlcmUgeW91J2QgdXNlIGEgd2VhayBtYXAgaWYgaXRcbiAgXHQvLyBleGlzdGVkXG4gIFx0cmFjdGl2ZS5fZ3VpZCA9ICdyLScgKyB1aWQrKztcblxuICBcdC8vIGV2ZW50c1xuICBcdHJhY3RpdmUuX3N1YnMgPSBjcmVhdGUoIG51bGwgKTtcblxuICBcdC8vIHN0b3JhZ2UgZm9yIGl0ZW0gY29uZmlndXJhdGlvbiBmcm9tIGluc3RhbnRpYXRpb24gdG8gcmVzZXQsXG4gIFx0Ly8gbGlrZSBkeW5hbWljIGZ1bmN0aW9ucyBvciBvcmlnaW5hbCB2YWx1ZXNcbiAgXHRyYWN0aXZlLl9jb25maWcgPSB7fTtcblxuICBcdC8vIG5vZGVzIHJlZ2lzdHJ5XG4gIFx0cmFjdGl2ZS5ub2RlcyA9IHt9O1xuXG4gIFx0Ly8gZXZlbnRzXG4gIFx0cmFjdGl2ZS5ldmVudCA9IG51bGw7XG4gIFx0cmFjdGl2ZS5fZXZlbnRRdWV1ZSA9IFtdO1xuXG4gIFx0Ly8gbGl2ZSBxdWVyaWVzXG4gIFx0cmFjdGl2ZS5fbGl2ZVF1ZXJpZXMgPSBbXTtcbiAgXHRyYWN0aXZlLl9saXZlQ29tcG9uZW50UXVlcmllcyA9IFtdO1xuXG4gIFx0Ly8gb2JzZXJ2ZXJzXG4gIFx0cmFjdGl2ZS5fb2JzZXJ2ZXJzID0gW107XG5cbiAgXHRpZighcmFjdGl2ZS5jb21wb25lbnQpe1xuICBcdFx0cmFjdGl2ZS5yb290ID0gcmFjdGl2ZTtcbiAgXHRcdHJhY3RpdmUucGFyZW50ID0gcmFjdGl2ZS5jb250YWluZXIgPSBudWxsOyAvLyBUT0RPIGNvbnRhaW5lciBzdGlsbCBhcHBsaWNhYmxlP1xuICBcdH1cblxuICB9XG5cbiAgZnVuY3Rpb24gZGVwcmVjYXRlUmFjdGl2ZURhdGEgKCkge1xuICBcdHRocm93IG5ldyBFcnJvciggJ1VzaW5nIGByYWN0aXZlLmRhdGFgIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgLSB5b3UgbXVzdCB1c2UgdGhlIGByYWN0aXZlLmdldCgpYCBBUEkgaW5zdGVhZCcgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENoaWxkUXVldWUgKCBxdWV1ZSwgcmFjdGl2ZSApIHtcbiAgXHRyZXR1cm4gcXVldWVbIHJhY3RpdmUuX2d1aWQgXSB8fCAoIHF1ZXVlWyByYWN0aXZlLl9ndWlkIF0gPSBbXSApO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZSAoIGhvb2tRdWV1ZSwgcmFjdGl2ZSApIHtcbiAgXHR2YXIgY2hpbGRRdWV1ZSA9IGdldENoaWxkUXVldWUoIGhvb2tRdWV1ZS5xdWV1ZSwgcmFjdGl2ZSApO1xuXG4gIFx0aG9va1F1ZXVlLmhvb2suZmlyZSggcmFjdGl2ZSApO1xuXG4gIFx0Ly8gcXVldWUgaXMgXCJsaXZlXCIgYmVjYXVzZSBjb21wb25lbnRzIGNhbiBlbmQgdXAgYmVpbmdcbiAgXHQvLyBhZGRlZCB3aGlsZSBob29rcyBmaXJlIG9uIHBhcmVudHMgdGhhdCBtb2RpZnkgZGF0YSB2YWx1ZXMuXG4gIFx0d2hpbGUgKCBjaGlsZFF1ZXVlLmxlbmd0aCApIHtcbiAgXHRcdGZpcmUoIGhvb2tRdWV1ZSwgY2hpbGRRdWV1ZS5zaGlmdCgpICk7XG4gIFx0fVxuXG4gIFx0ZGVsZXRlIGhvb2tRdWV1ZS5xdWV1ZVsgcmFjdGl2ZS5fZ3VpZCBdO1xuICB9XG5cbiAgdmFyIEhvb2tRdWV1ZSA9IGZ1bmN0aW9uIEhvb2tRdWV1ZSAoIGV2ZW50ICkge1xuICBcdHRoaXMuaG9vayA9IG5ldyBIb29rKCBldmVudCApO1xuICBcdHRoaXMuaW5Qcm9jZXNzID0ge307XG4gIFx0dGhpcy5xdWV1ZSA9IHt9O1xuICB9O1xuXG4gIEhvb2tRdWV1ZS5wcm90b3R5cGUuYmVnaW4gPSBmdW5jdGlvbiBiZWdpbiAoIHJhY3RpdmUgKSB7XG4gIFx0dGhpcy5pblByb2Nlc3NbIHJhY3RpdmUuX2d1aWQgXSA9IHRydWU7XG4gIH07XG5cbiAgSG9va1F1ZXVlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQgKCByYWN0aXZlICkge1xuICBcdHZhciBwYXJlbnQgPSByYWN0aXZlLnBhcmVudDtcblxuICBcdC8vIElmIHRoaXMgaXMgKmlzbid0KiBhIGNoaWxkIG9mIGEgY29tcG9uZW50IHRoYXQncyBpbiBwcm9jZXNzLFxuICBcdC8vIGl0IHNob3VsZCBjYWxsIG1ldGhvZHMgb3IgZmlyZSBhdCB0aGlzIHBvaW50XG4gIFx0aWYgKCAhcGFyZW50IHx8ICF0aGlzLmluUHJvY2Vzc1sgcGFyZW50Ll9ndWlkIF0gKSB7XG4gIFx0XHRmaXJlKCB0aGlzLCByYWN0aXZlICk7XG4gIFx0fVxuICBcdC8vIGVsc2V3aXNlLCBoYW5kb2ZmIHRvIHBhcmVudCB0byBmaXJlIHdoZW4gcmVhZHlcbiAgXHRlbHNlIHtcbiAgXHRcdGdldENoaWxkUXVldWUoIHRoaXMucXVldWUsIHBhcmVudCApLnB1c2goIHJhY3RpdmUgKTtcbiAgXHR9XG5cbiAgXHRkZWxldGUgdGhpcy5pblByb2Nlc3NbIHJhY3RpdmUuX2d1aWQgXTtcbiAgfTtcblxuICB2YXIgY29uZmlnSG9vayA9IG5ldyBIb29rKCAnY29uZmlnJyApO1xuICB2YXIgaW5pdEhvb2sgPSBuZXcgSG9va1F1ZXVlKCAnaW5pdCcgKTtcblxuICBmdW5jdGlvbiBpbml0aWFsaXNlICggcmFjdGl2ZSwgdXNlck9wdGlvbnMsIG9wdGlvbnMgKSB7XG4gIFx0T2JqZWN0LmtleXMoIHJhY3RpdmUudmlld21vZGVsLmNvbXB1dGF0aW9ucyApLmZvckVhY2goIGZ1bmN0aW9uICgga2V5ICkge1xuICBcdFx0dmFyIGNvbXB1dGF0aW9uID0gcmFjdGl2ZS52aWV3bW9kZWwuY29tcHV0YXRpb25zWyBrZXkgXTtcblxuICBcdFx0aWYgKCByYWN0aXZlLnZpZXdtb2RlbC52YWx1ZS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG4gIFx0XHRcdGNvbXB1dGF0aW9uLnNldCggcmFjdGl2ZS52aWV3bW9kZWwudmFsdWVbIGtleSBdICk7XG4gIFx0XHR9XG4gIFx0fSk7XG5cbiAgXHQvLyBpbml0IGNvbmZpZyBmcm9tIFBhcmVudCBhbmQgb3B0aW9uc1xuICBcdGNvbmZpZy5pbml0KCByYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlLCB1c2VyT3B0aW9ucyApO1xuXG4gIFx0Y29uZmlnSG9vay5maXJlKCByYWN0aXZlICk7XG4gIFx0aW5pdEhvb2suYmVnaW4oIHJhY3RpdmUgKTtcblxuICBcdHZhciBmcmFnbWVudDtcblxuICBcdC8vIFJlbmRlciB2aXJ0dWFsIERPTVxuICBcdGlmICggcmFjdGl2ZS50ZW1wbGF0ZSApIHtcbiAgXHRcdHZhciBjc3NJZHM7XG5cbiAgXHRcdGlmICggb3B0aW9ucy5jc3NJZHMgfHwgcmFjdGl2ZS5jc3NJZCApIHtcbiAgXHRcdFx0Y3NzSWRzID0gb3B0aW9ucy5jc3NJZHMgPyBvcHRpb25zLmNzc0lkcy5zbGljZSgpIDogW107XG5cbiAgXHRcdFx0aWYgKCByYWN0aXZlLmNzc0lkICkge1xuICBcdFx0XHRcdGNzc0lkcy5wdXNoKCByYWN0aXZlLmNzc0lkICk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmFjdGl2ZS5mcmFnbWVudCA9IGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KHtcbiAgXHRcdFx0b3duZXI6IHJhY3RpdmUsXG4gIFx0XHRcdHRlbXBsYXRlOiByYWN0aXZlLnRlbXBsYXRlLFxuICBcdFx0XHRjc3NJZHM6IGNzc0lkc1xuICBcdFx0fSkuYmluZCggcmFjdGl2ZS52aWV3bW9kZWwgKTtcbiAgXHR9XG5cbiAgXHRpbml0SG9vay5lbmQoIHJhY3RpdmUgKTtcblxuICBcdGlmICggZnJhZ21lbnQgKSB7XG4gIFx0XHQvLyByZW5kZXIgYXV0b21hdGljYWxseSAoIGlmIGBlbGAgaXMgc3BlY2lmaWVkIClcbiAgXHRcdHZhciBlbCA9IGdldEVsZW1lbnQoIHJhY3RpdmUuZWwgKTtcbiAgXHRcdGlmICggZWwgKSB7XG4gIFx0XHRcdHZhciBwcm9taXNlID0gcmFjdGl2ZS5yZW5kZXIoIGVsLCByYWN0aXZlLmFwcGVuZCApO1xuXG4gIFx0XHRcdGlmICggUmFjdGl2ZS5ERUJVR19QUk9NSVNFUyApIHtcbiAgXHRcdFx0XHRwcm9taXNlWydjYXRjaCddKCBmdW5jdGlvbiAoIGVyciApIHtcbiAgXHRcdFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyggJ1Byb21pc2UgZGVidWdnaW5nIGlzIGVuYWJsZWQsIHRvIGhlbHAgc29sdmUgZXJyb3JzIHRoYXQgaGFwcGVuIGFzeW5jaHJvbm91c2x5LiBTb21lIGJyb3dzZXJzIHdpbGwgbG9nIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnMsIGluIHdoaWNoIGNhc2UgeW91IGNhbiBzYWZlbHkgZGlzYWJsZSBwcm9taXNlIGRlYnVnZ2luZzpcXG4gIFJhY3RpdmUuREVCVUdfUFJPTUlTRVMgPSBmYWxzZTsnICk7XG4gIFx0XHRcdFx0XHR3YXJuSWZEZWJ1ZyggJ0FuIGVycm9yIGhhcHBlbmVkIGR1cmluZyByZW5kZXJpbmcnLCB7IHJhY3RpdmU6IHJhY3RpdmUgfSk7XG4gIFx0XHRcdFx0XHRsb2dJZkRlYnVnKCBlcnIgKTtcblxuICBcdFx0XHRcdFx0dGhyb3cgZXJyO1xuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9XG5cbiAgdmFyIERPTUV2ZW50ID0gZnVuY3Rpb24gRE9NRXZlbnQgKCBuYW1lLCBvd25lciApIHtcbiAgXHRpZiAoIG5hbWUuaW5kZXhPZiggJyonICkgIT09IC0xICkge1xuICBcdFx0ZmF0YWwoIChcIk9ubHkgY29tcG9uZW50IHByb3h5LWV2ZW50cyBtYXkgY29udGFpbiBcXFwiKlxcXCIgd2lsZGNhcmRzLCA8XCIgKyAob3duZXIubmFtZSkgKyBcIiBvbi1cIiArIG5hbWUgKyBcIj1cXFwiLi4uXFxcIi8+IGlzIG5vdCB2YWxpZFwiKSApO1xuICBcdH1cblxuICBcdHRoaXMubmFtZSA9IG5hbWU7XG4gIFx0dGhpcy5vd25lciA9IG93bmVyO1xuICBcdHRoaXMubm9kZSA9IG51bGw7XG4gIFx0dGhpcy5oYW5kbGVyID0gbnVsbDtcbiAgfTtcblxuICBET01FdmVudC5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuICggZGlyZWN0aXZlICkge1xuICBcdHZhciBub2RlID0gdGhpcy5ub2RlID0gdGhpcy5vd25lci5ub2RlO1xuICBcdHZhciBuYW1lID0gdGhpcy5uYW1lO1xuXG4gIFx0aWYgKCAhKCAoXCJvblwiICsgbmFtZSkgaW4gbm9kZSApICkge1xuICBcdFx0d2Fybk9uY2UoIG1pc3NpbmdQbHVnaW4oIG5hbWUsICdldmVudHMnICkgKTtcbiAgXHRcdH1cblxuICBcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCBuYW1lLCB0aGlzLmhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIFx0XHRkaXJlY3RpdmUuZmlyZSh7XG4gIFx0XHRcdFx0bm9kZTogbm9kZSxcbiAgXHRcdFx0b3JpZ2luYWw6IGV2ZW50XG4gIFx0XHRcdH0pO1xuICBcdFx0fSwgZmFsc2UgKTtcbiAgfTtcblxuICBET01FdmVudC5wcm90b3R5cGUudW5saXN0ZW4gPSBmdW5jdGlvbiB1bmxpc3RlbiAoKSB7XG4gIFx0dGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHRoaXMubmFtZSwgdGhpcy5oYW5kbGVyLCBmYWxzZSApO1xuICB9O1xuXG4gIHZhciBDdXN0b21FdmVudCA9IGZ1bmN0aW9uIEN1c3RvbUV2ZW50ICggZXZlbnRQbHVnaW4sIG93bmVyICkge1xuICBcdHRoaXMuZXZlbnRQbHVnaW4gPSBldmVudFBsdWdpbjtcbiAgXHR0aGlzLm93bmVyID0gb3duZXI7XG4gIFx0dGhpcy5oYW5kbGVyID0gbnVsbDtcbiAgfTtcblxuICBDdXN0b21FdmVudC5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuICggZGlyZWN0aXZlICkge1xuICBcdHZhciBub2RlID0gdGhpcy5vd25lci5ub2RlO1xuXG4gIFx0dGhpcy5oYW5kbGVyID0gdGhpcy5ldmVudFBsdWdpbiggbm9kZSwgZnVuY3Rpb24gKCBldmVudCApIHtcbiAgXHRcdGlmICggZXZlbnQgPT09IHZvaWQgMCApIGV2ZW50ID0ge307XG5cbiAgXHRcdFx0ZXZlbnQubm9kZSA9IGV2ZW50Lm5vZGUgfHwgbm9kZTtcbiAgXHRcdGRpcmVjdGl2ZS5maXJlKCBldmVudCApO1xuICBcdH0pO1xuICB9O1xuXG4gIEN1c3RvbUV2ZW50LnByb3RvdHlwZS51bmxpc3RlbiA9IGZ1bmN0aW9uIHVubGlzdGVuICgpIHtcbiAgXHR0aGlzLmhhbmRsZXIudGVhcmRvd24oKTtcbiAgfTtcblxuICB2YXIgUmFjdGl2ZUV2ZW50ID0gZnVuY3Rpb24gUmFjdGl2ZUV2ZW50ICggcmFjdGl2ZSwgbmFtZSApIHtcbiAgXHR0aGlzLnJhY3RpdmUgPSByYWN0aXZlO1xuICBcdHRoaXMubmFtZSA9IG5hbWU7XG4gIFx0dGhpcy5oYW5kbGVyID0gbnVsbDtcbiAgfTtcblxuICBSYWN0aXZlRXZlbnQucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbiAoIGRpcmVjdGl2ZSApIHtcbiAgXHR2YXIgcmFjdGl2ZSA9IHRoaXMucmFjdGl2ZTtcblxuICBcdHRoaXMuaGFuZGxlciA9IHJhY3RpdmUub24oIHRoaXMubmFtZSwgZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIGV2ZW50O1xuXG4gIFx0XHQvLyBzZW1pLXdlYWsgdGVzdCwgYnV0IHdoYXQgZWxzZT8gdGFnIHRoZSBldmVudCBvYmogLl9pc0V2ZW50ID9cbiAgXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCAmJiBhcmd1bWVudHNbMF0gJiYgYXJndW1lbnRzWzBdLm5vZGUgKSB7XG4gIFx0XHRcdGV2ZW50ID0gQXJyYXkucHJvdG90eXBlLnNoaWZ0LmNhbGwoIGFyZ3VtZW50cyApO1xuICBcdFx0XHRldmVudC5jb21wb25lbnQgPSByYWN0aXZlO1xuICBcdFx0fVxuXG4gIFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcbiAgXHRcdGRpcmVjdGl2ZS5maXJlKCBldmVudCwgYXJncyApO1xuXG4gIFx0XHQvLyBjYW5jZWwgYnViYmxpbmdcbiAgXHRcdHJldHVybiBmYWxzZTtcbiAgXHR9KTtcbiAgfTtcblxuICBSYWN0aXZlRXZlbnQucHJvdG90eXBlLnVubGlzdGVuID0gZnVuY3Rpb24gdW5saXN0ZW4gKCkge1xuICBcdHRoaXMuaGFuZGxlci5jYW5jZWwoKTtcbiAgfTtcblxuICB2YXIgc3BlY2lhbFBhdHRlcm4gPSAvXihldmVudHxhcmd1bWVudHMpKFxcLi4rKT8kLztcbiAgdmFyIGRvbGxhckFyZ3NQYXR0ZXJuID0gL15cXCQoXFxkKykoXFwuLispPyQvO1xuXG4gIHZhciBFdmVudERpcmVjdGl2ZSA9IGZ1bmN0aW9uIEV2ZW50RGlyZWN0aXZlICggb3B0aW9ucyApIHtcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dGhpcy5vd25lciA9IG9wdGlvbnMub3duZXIgfHwgb3B0aW9ucy5wYXJlbnRGcmFnbWVudC5vd25lciB8fCBmaW5kRWxlbWVudCggb3B0aW9ucy5wYXJlbnRGcmFnbWVudCApO1xuICBcdHRoaXMuZWxlbWVudCA9IHRoaXMub3duZXIuYXR0cmlidXRlQnlOYW1lID8gdGhpcy5vd25lciA6IGZpbmRFbGVtZW50KCBvcHRpb25zLnBhcmVudEZyYWdtZW50ICk7XG4gIFx0dGhpcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gIFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5yYWN0aXZlID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudC5yYWN0aXZlO1xuXG4gIFx0dGhpcy5ldmVudHMgPSBbXTtcblxuICBcdGlmICggdGhpcy5lbGVtZW50LnR5cGUgPT09IENPTVBPTkVOVCApIHtcbiAgXHRcdHRoaXMudGVtcGxhdGUubi5zcGxpdCggJy0nICkuZm9yRWFjaCggZnVuY3Rpb24gKCBuICkge1xuICBcdFx0XHR0aGlzJDEuZXZlbnRzLnB1c2goIG5ldyBSYWN0aXZlRXZlbnQoIHRoaXMkMS5lbGVtZW50Lmluc3RhbmNlLCBuICkgKTtcbiAgXHRcdH0pO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR0aGlzLnRlbXBsYXRlLm4uc3BsaXQoICctJyApLmZvckVhY2goIGZ1bmN0aW9uICggbiApIHtcbiAgXHRcdFx0dmFyIGZuID0gZmluZEluVmlld0hpZXJhcmNoeSggJ2V2ZW50cycsIHRoaXMkMS5yYWN0aXZlLCBuICk7XG4gIFx0XHRcdC8vIHdlIG5lZWQgdG8gcGFzcyBpbiBcInRoaXNcIiBpbiBvcmRlciB0byBnZXRcbiAgXHRcdFx0Ly8gYWNjZXNzIHRvIG5vZGUgd2hlbiBpdCBpcyBjcmVhdGVkLlxuICBcdFx0XHR0aGlzJDEuZXZlbnRzLnB1c2goZm4gPyBuZXcgQ3VzdG9tRXZlbnQoIGZuLCB0aGlzJDEuZWxlbWVudCApIDogbmV3IERPTUV2ZW50KCBuLCB0aGlzJDEuZWxlbWVudCApKTtcbiAgXHRcdH0pO1xuICBcdH1cblxuICBcdHRoaXMuY29udGV4dCA9IG51bGw7XG5cbiAgXHQvLyBtZXRob2QgY2FsbHNcbiAgXHR0aGlzLnJlc29sdmVycyA9IG51bGw7XG4gIFx0dGhpcy5tb2RlbHMgPSBudWxsO1xuXG4gIFx0Ly8gaGFuZGxlciBkaXJlY3RpdmVcbiAgXHR0aGlzLmFjdGlvbiA9IG51bGw7XG4gIFx0dGhpcy5hcmdzID0gbnVsbDtcbiAgfTtcblxuICBFdmVudERpcmVjdGl2ZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIGJpbmQgKCkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHR0aGlzLmNvbnRleHQgPSB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmRDb250ZXh0KCk7XG5cbiAgXHR2YXIgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlLmY7XG5cbiAgXHRpZiAoIHRlbXBsYXRlLnggKSB7XG4gIFx0XHR0aGlzLmZuID0gZ2V0RnVuY3Rpb24oIHRlbXBsYXRlLngucywgdGVtcGxhdGUueC5yLmxlbmd0aCApO1xuICBcdFx0dGhpcy5yZXNvbHZlcnMgPSBbXTtcbiAgXHRcdHRoaXMubW9kZWxzID0gdGVtcGxhdGUueC5yLm1hcCggZnVuY3Rpb24gKCByZWYsIGkgKSB7XG4gIFx0XHRcdHZhciBzcGVjaWFsTWF0Y2ggPSBzcGVjaWFsUGF0dGVybi5leGVjKCByZWYgKTtcbiAgXHRcdFx0aWYgKCBzcGVjaWFsTWF0Y2ggKSB7XG4gIFx0XHRcdFx0Ly8gb24tY2xpY2s9XCJmb28oZXZlbnQubm9kZSlcIlxuICBcdFx0XHRcdHJldHVybiB7XG4gIFx0XHRcdFx0XHRzcGVjaWFsOiBzcGVjaWFsTWF0Y2hbMV0sXG4gIFx0XHRcdFx0XHRrZXlzOiBzcGVjaWFsTWF0Y2hbMl0gPyBzcGxpdEtleXBhdGhJKCBzcGVjaWFsTWF0Y2hbMl0uc3Vic3RyKDEpICkgOiBbXVxuICBcdFx0XHRcdH07XG4gIFx0XHRcdH1cblxuICBcdFx0XHR2YXIgZG9sbGFyTWF0Y2ggPSBkb2xsYXJBcmdzUGF0dGVybi5leGVjKCByZWYgKTtcbiAgXHRcdFx0aWYgKCBkb2xsYXJNYXRjaCApIHtcbiAgXHRcdFx0XHQvLyBvbi1jbGljaz1cImZvbygkMSlcIlxuICBcdFx0XHRcdHJldHVybiB7XG4gIFx0XHRcdFx0XHRzcGVjaWFsOiAnYXJndW1lbnRzJyxcbiAgXHRcdFx0XHRcdGtleXM6IFsgZG9sbGFyTWF0Y2hbMV0gLSAxIF0uY29uY2F0KCBkb2xsYXJNYXRjaFsyXSA/IHNwbGl0S2V5cGF0aEkoIGRvbGxhck1hdGNoWzJdLnN1YnN0ciggMSApICkgOiBbXSApXG4gIFx0XHRcdFx0fTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHZhciByZXNvbHZlcjtcblxuICBcdFx0XHR2YXIgbW9kZWwgPSByZXNvbHZlUmVmZXJlbmNlKCB0aGlzJDEucGFyZW50RnJhZ21lbnQsIHJlZiApO1xuICBcdFx0XHRpZiAoICFtb2RlbCApIHtcbiAgXHRcdFx0XHRyZXNvbHZlciA9IHRoaXMkMS5wYXJlbnRGcmFnbWVudC5yZXNvbHZlKCByZWYsIGZ1bmN0aW9uICggbW9kZWwgKSB7XG4gIFx0XHRcdFx0XHR0aGlzJDEubW9kZWxzW2ldID0gbW9kZWw7XG4gIFx0XHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMkMS5yZXNvbHZlcnMsIHJlc29sdmVyICk7XG4gIFx0XHRcdFx0XHRtb2RlbC5yZWdpc3RlciggdGhpcyQxICk7XG4gIFx0XHRcdFx0fSk7XG5cbiAgXHRcdFx0XHR0aGlzJDEucmVzb2x2ZXJzLnB1c2goIHJlc29sdmVyICk7XG4gIFx0XHRcdH0gZWxzZSBtb2RlbC5yZWdpc3RlciggdGhpcyQxICk7XG5cbiAgXHRcdFx0cmV0dXJuIG1vZGVsO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0ZWxzZSB7XG4gIFx0XHQvLyBUT0RPIGRlcHJlY2F0ZSB0aGlzIHN0eWxlIG9mIGRpcmVjdGl2ZVxuICBcdFx0dGhpcy5hY3Rpb24gPSB0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnID8gLy8gb24tY2xpY2s9J2ZvbydcbiAgXHRcdFx0dGVtcGxhdGUgOlxuICBcdFx0XHR0eXBlb2YgdGVtcGxhdGUubiA9PT0gJ3N0cmluZycgPyAvLyBvbi1jbGljaz0ne3tkeW5hbWljfX0nXG4gIFx0XHRcdFx0dGVtcGxhdGUubiA6XG4gIFx0XHRcdFx0bmV3IEZyYWdtZW50KHtcbiAgXHRcdFx0XHRcdG93bmVyOiB0aGlzLFxuICBcdFx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLm5cbiAgXHRcdFx0XHR9KTtcblxuICBcdFx0dGhpcy5hcmdzID0gdGVtcGxhdGUuYSA/IC8vIHN0YXRpYyBhcmd1bWVudHNcbiAgXHRcdFx0KCB0eXBlb2YgdGVtcGxhdGUuYSA9PT0gJ3N0cmluZycgPyBbIHRlbXBsYXRlLmEgXSA6IHRlbXBsYXRlLmEgKSA6XG4gIFx0XHRcdHRlbXBsYXRlLmQgPyAvLyBkeW5hbWljIGFyZ3VtZW50c1xuICBcdFx0XHRcdG5ldyBGcmFnbWVudCh7XG4gIFx0XHRcdFx0XHRvd25lcjogdGhpcyxcbiAgXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kXG4gIFx0XHRcdFx0fSkgOlxuICBcdFx0XHRcdFtdOyAvLyBubyBhcmd1bWVudHNcbiAgXHR9XG5cbiAgXHRpZiAoIHRoaXMuYWN0aW9uICYmIHR5cGVvZiB0aGlzLmFjdGlvbiAhPT0gJ3N0cmluZycgKSB0aGlzLmFjdGlvbi5iaW5kKCk7XG4gIFx0aWYgKCB0aGlzLmFyZ3MgJiYgdGVtcGxhdGUuZCApIHRoaXMuYXJncy5iaW5kKCk7XG4gIH07XG5cbiAgRXZlbnREaXJlY3RpdmUucHJvdG90eXBlLmJ1YmJsZSA9IGZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gIFx0aWYgKCAhdGhpcy5kaXJ0eSApIHtcbiAgXHRcdHRoaXMuZGlydHkgPSB0cnVlO1xuICBcdFx0dGhpcy5vd25lci5idWJibGUoKTtcbiAgXHR9XG4gIH07XG5cbiAgRXZlbnREaXJlY3RpdmUucHJvdG90eXBlLmRlc3Ryb3llZCA9IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gIFx0dGhpcy5ldmVudHMuZm9yRWFjaCggZnVuY3Rpb24gKCBlICkgeyByZXR1cm4gZS51bmxpc3RlbigpOyB9ICk7XG4gIH07XG5cbiAgRXZlbnREaXJlY3RpdmUucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbiBmaXJlICggZXZlbnQsIHBhc3NlZEFyZ3MgKSB7XG5cbiAgXHQvLyBhdWdtZW50IGV2ZW50IG9iamVjdFxuICBcdGlmICggcGFzc2VkQXJncyA9PT0gdm9pZCAwICkgcGFzc2VkQXJncyA9IFtdO1xuXG4gIFx0XHRpZiAoIGV2ZW50ICYmICFldmVudC5oYXNPd25Qcm9wZXJ0eSggJ19lbGVtZW50JyApICkge1xuICBcdFx0ICAgYWRkSGVscGVycyggZXZlbnQsIHRoaXMub3duZXIgKTtcbiAgXHR9XG5cbiAgXHRpZiAoIHRoaXMuZm4gKSB7XG4gIFx0XHR2YXIgdmFsdWVzID0gW107XG5cbiAgXHRcdGlmICggZXZlbnQgKSBwYXNzZWRBcmdzLnVuc2hpZnQoIGV2ZW50ICk7XG5cbiAgXHRcdGlmICggdGhpcy5tb2RlbHMgKSB7XG4gIFx0XHRcdHRoaXMubW9kZWxzLmZvckVhY2goIGZ1bmN0aW9uICggbW9kZWwgKSB7XG4gIFx0XHRcdFx0aWYgKCAhbW9kZWwgKSByZXR1cm4gdmFsdWVzLnB1c2goIHVuZGVmaW5lZCApO1xuXG4gIFx0XHRcdFx0aWYgKCBtb2RlbC5zcGVjaWFsICkge1xuICBcdFx0XHRcdFx0dmFyIG9iaiA9IG1vZGVsLnNwZWNpYWwgPT09ICdldmVudCcgPyBldmVudCA6IHBhc3NlZEFyZ3M7XG4gIFx0XHRcdFx0XHR2YXIga2V5cyA9IG1vZGVsLmtleXMuc2xpY2UoKTtcblxuICBcdFx0XHRcdFx0d2hpbGUgKCBrZXlzLmxlbmd0aCApIG9iaiA9IG9ialsga2V5cy5zaGlmdCgpIF07XG4gIFx0XHRcdFx0XHRyZXR1cm4gdmFsdWVzLnB1c2goIG9iaiApO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmICggbW9kZWwud3JhcHBlciApIHtcbiAgXHRcdFx0XHRcdHJldHVybiB2YWx1ZXMucHVzaCggbW9kZWwud3JhcHBlclZhbHVlICk7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0dmFsdWVzLnB1c2goIG1vZGVsLmdldCgpICk7XG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBtYWtlIGV2ZW50IGF2YWlsYWJsZSBhcyBgdGhpcy5ldmVudGBcbiAgXHRcdHZhciByYWN0aXZlID0gdGhpcy5yYWN0aXZlO1xuICBcdFx0dmFyIG9sZEV2ZW50ID0gcmFjdGl2ZS5ldmVudDtcblxuICBcdFx0cmFjdGl2ZS5ldmVudCA9IGV2ZW50O1xuICBcdFx0dmFyIHJlc3VsdCA9IHRoaXMuZm4uYXBwbHkoIHJhY3RpdmUsIHZhbHVlcyApLnBvcCgpO1xuXG4gIFx0XHQvLyBBdXRvIHByZXZlbnQgYW5kIHN0b3AgaWYgcmV0dXJuIGlzIGV4cGxpY2l0bHkgZmFsc2VcbiAgXHRcdGlmICggcmVzdWx0ID09PSBmYWxzZSApIHtcbiAgXHRcdFx0dmFyIG9yaWdpbmFsID0gZXZlbnQgPyBldmVudC5vcmlnaW5hbCA6IHVuZGVmaW5lZDtcbiAgXHRcdFx0aWYgKCBvcmlnaW5hbCApIHtcbiAgXHRcdFx0XHRvcmlnaW5hbC5wcmV2ZW50RGVmYXVsdCAmJiBvcmlnaW5hbC5wcmV2ZW50RGVmYXVsdCgpO1xuICBcdFx0XHRcdG9yaWdpbmFsLnN0b3BQcm9wYWdhdGlvbiAmJiBvcmlnaW5hbC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR3YXJuT25jZUlmRGVidWcoIChcImhhbmRsZXIgJ1wiICsgKHRoaXMudGVtcGxhdGUubikgKyBcIicgcmV0dXJuZWQgZmFsc2UsIGJ1dCB0aGVyZSBpcyBubyBldmVudCBhdmFpbGFibGUgdG8gY2FuY2VsXCIpICk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0cmFjdGl2ZS5ldmVudCA9IG9sZEV2ZW50O1xuICBcdH1cblxuICBcdGVsc2Uge1xuICBcdFx0dmFyIGFjdGlvbiA9IHRoaXMuYWN0aW9uLnRvU3RyaW5nKCk7XG4gIFx0XHR2YXIgYXJncyA9IHRoaXMudGVtcGxhdGUuZi5kID8gdGhpcy5hcmdzLmdldEFyZ3NMaXN0KCkgOiB0aGlzLmFyZ3M7XG5cbiAgXHRcdGlmICggcGFzc2VkQXJncy5sZW5ndGggKSBhcmdzID0gYXJncy5jb25jYXQoIHBhc3NlZEFyZ3MgKTtcblxuICBcdFx0aWYgKCBldmVudCApIGV2ZW50Lm5hbWUgPSBhY3Rpb247XG5cbiAgXHRcdGZpcmVFdmVudCggdGhpcy5yYWN0aXZlLCBhY3Rpb24sIHtcbiAgXHRcdFx0ZXZlbnQ6IGV2ZW50LFxuICBcdFx0XHRhcmdzOiBhcmdzXG4gIFx0XHR9KTtcbiAgXHR9XG4gIH07XG5cbiAgRXZlbnREaXJlY3RpdmUucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSAoKSB7fTtcblxuICBFdmVudERpcmVjdGl2ZS5wcm90b3R5cGUucmViaW5kaW5nID0gZnVuY3Rpb24gcmViaW5kaW5nICggbmV4dCwgcHJldmlvdXMgKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdGlmICggIXRoaXMubW9kZWxzICkgcmV0dXJuO1xuICBcdHZhciBpZHggPSB0aGlzLm1vZGVscy5pbmRleE9mKCBwcmV2aW91cyApO1xuXG4gIFx0aWYgKCB+aWR4ICkge1xuICBcdFx0dGhpcy5tb2RlbHMuc3BsaWNlKCBpZHgsIDEsIG5leHQgKTtcbiAgXHRcdHByZXZpb3VzLnVucmVnaXN0ZXIoIHRoaXMgKTtcbiAgXHRcdGlmICggbmV4dCApIG5leHQuYWRkU2h1ZmZsZVRhc2soIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5leHQucmVnaXN0ZXIoIHRoaXMkMSApOyB9ICk7XG4gIFx0fVxuICB9O1xuXG4gIEV2ZW50RGlyZWN0aXZlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKCkge1xuICBcdC8vIHJlbmRlciBldmVudHMgYWZ0ZXIgZXZlcnl0aGluZyBlbHNlLCBzbyB0aGV5IGZpcmUgYWZ0ZXIgYmluZGluZ3NcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5ldmVudHMuZm9yRWFjaCggZnVuY3Rpb24gKCBlICkgeyByZXR1cm4gZS5saXN0ZW4oIHRoaXMkMSApOyB9LCB0cnVlICk7IH0gKTtcbiAgfTtcblxuICBFdmVudERpcmVjdGl2ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHsgcmV0dXJuICcnOyB9O1xuXG4gIEV2ZW50RGlyZWN0aXZlLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiB1bmJpbmQkMSAoKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHZhciB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUuZjtcblxuICBcdGlmICggdGVtcGxhdGUubSApIHtcbiAgXHRcdGlmICggdGhpcy5yZXNvbHZlcnMgKSB0aGlzLnJlc29sdmVycy5mb3JFYWNoKCB1bmJpbmQgKTtcbiAgXHRcdHRoaXMucmVzb2x2ZXJzID0gW107XG5cbiAgXHRcdGlmICggdGhpcy5tb2RlbHMgKSB0aGlzLm1vZGVscy5mb3JFYWNoKCBmdW5jdGlvbiAoIG0gKSB7XG4gIFx0XHRcdGlmICggbS51bnJlZ2lzdGVyICkgbS51bnJlZ2lzdGVyKCB0aGlzJDEgKTtcbiAgXHRcdH0pO1xuICBcdFx0dGhpcy5tb2RlbHMgPSBudWxsO1xuICBcdH1cblxuICBcdGVsc2Uge1xuICBcdFx0Ly8gVE9ETyB0aGlzIGlzIGJyaXR0bGUgYW5kIG5vbi1leHBsaWNpdCwgZml4IGl0XG4gIFx0XHRpZiAoIHRoaXMuYWN0aW9uICYmIHRoaXMuYWN0aW9uLnVuYmluZCApIHRoaXMuYWN0aW9uLnVuYmluZCgpO1xuICBcdFx0aWYgKCB0aGlzLmFyZ3MgJiYgdGhpcy5hcmdzLnVuYmluZCApIHRoaXMuYXJncy51bmJpbmQoKTtcbiAgXHR9XG4gIH07XG5cbiAgRXZlbnREaXJlY3RpdmUucHJvdG90eXBlLnVucmVuZGVyID0gZnVuY3Rpb24gdW5yZW5kZXIgKCkge1xuICBcdHRoaXMuZXZlbnRzLmZvckVhY2goIGZ1bmN0aW9uICggZSApIHsgcmV0dXJuIGUudW5saXN0ZW4oKTsgfSApO1xuICB9O1xuXG4gIEV2ZW50RGlyZWN0aXZlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICBcdGlmICggdGhpcy5tZXRob2QgfHwgIXRoaXMuZGlydHkgKSByZXR1cm47IC8vIG5vdGhpbmcgdG8gZG9cblxuICBcdHRoaXMuZGlydHkgPSBmYWxzZTtcblxuICBcdC8vIHVnaCBsZWdhY3lcbiAgXHRpZiAoIHRoaXMuYWN0aW9uICYmIHRoaXMuYWN0aW9uLnVwZGF0ZSApIHRoaXMuYWN0aW9uLnVwZGF0ZSgpO1xuICBcdGlmICggdGhpcy5hcmdzICYmIHRoaXMuYXJncy51cGRhdGUgKSB0aGlzLmFyZ3MudXBkYXRlKCk7XG4gIH07XG5cbiAgLy8gVE9ETyBpdCdzIHVuZm9ydHVuYXRlIHRoYXQgdGhpcyBoYXMgdG8gcnVuIGV2ZXJ5IHRpbWUgYVxuICAvLyBjb21wb25lbnQgaXMgcmVuZGVyZWQuLi4gaXMgdGhlcmUgYSBiZXR0ZXIgd2F5P1xuICBmdW5jdGlvbiB1cGRhdGVMaXZlUXVlcmllcyAoIGNvbXBvbmVudCApIHtcbiAgXHQvLyBEb2VzIHRoaXMgbmVlZCB0byBiZSBhZGRlZCB0byBhbnkgbGl2ZSBxdWVyaWVzP1xuICBcdHZhciBpbnN0YW5jZSA9IGNvbXBvbmVudC5yYWN0aXZlO1xuXG4gIFx0ZG8ge1xuICBcdFx0dmFyIGxpdmVRdWVyaWVzID0gaW5zdGFuY2UuX2xpdmVDb21wb25lbnRRdWVyaWVzO1xuXG4gIFx0XHR2YXIgaSA9IGxpdmVRdWVyaWVzLmxlbmd0aDtcbiAgXHRcdHdoaWxlICggaS0tICkge1xuICBcdFx0XHR2YXIgbmFtZSA9IGxpdmVRdWVyaWVzW2ldO1xuICBcdFx0XHR2YXIgcXVlcnkgPSBsaXZlUXVlcmllc1sgKFwiX1wiICsgbmFtZSkgXTtcblxuICBcdFx0XHRpZiAoIHF1ZXJ5LnRlc3QoIGNvbXBvbmVudCApICkge1xuICBcdFx0XHRcdHF1ZXJ5LmFkZCggY29tcG9uZW50Lmluc3RhbmNlICk7XG4gIFx0XHRcdFx0Ly8ga2VlcCByZWdpc3RlciBvZiBhcHBsaWNhYmxlIHNlbGVjdG9ycywgZm9yIHdoZW4gd2UgdGVhcmRvd25cbiAgXHRcdFx0XHRjb21wb25lbnQubGl2ZVF1ZXJpZXMucHVzaCggcXVlcnkgKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH0gd2hpbGUgKCBpbnN0YW5jZSA9IGluc3RhbmNlLnBhcmVudCApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRnJvbUxpdmVDb21wb25lbnRRdWVyaWVzICggY29tcG9uZW50ICkge1xuICBcdHZhciBpbnN0YW5jZSA9IGNvbXBvbmVudC5yYWN0aXZlO1xuXG4gIFx0d2hpbGUgKCBpbnN0YW5jZSApIHtcbiAgXHRcdHZhciBxdWVyeSA9IGluc3RhbmNlLl9saXZlQ29tcG9uZW50UXVlcmllc1sgKFwiX1wiICsgKGNvbXBvbmVudC5uYW1lKSkgXTtcbiAgXHRcdGlmICggcXVlcnkgKSBxdWVyeS5yZW1vdmUoIGNvbXBvbmVudCApO1xuXG4gIFx0XHRpbnN0YW5jZSA9IGluc3RhbmNlLnBhcmVudDtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlRGlydHkgKCBxdWVyeSApIHtcbiAgXHRxdWVyeS5tYWtlRGlydHkoKTtcbiAgfVxuXG4gIHZhciB0ZWFyZG93bkhvb2sgPSBuZXcgSG9vayggJ3RlYXJkb3duJyApO1xuXG4gIHZhciBDb21wb25lbnQgPSAoZnVuY3Rpb24gKEl0ZW0pIHtcbiAgXHRmdW5jdGlvbiBDb21wb25lbnQgKCBvcHRpb25zLCBDb21wb25lbnRDb25zdHJ1Y3RvciApIHtcbiAgXHRcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHRJdGVtLmNhbGwoIHRoaXMsIG9wdGlvbnMgKTtcbiAgXHRcdHRoaXMudHlwZSA9IENPTVBPTkVOVDsgLy8gb3ZlcnJpZGUgRUxFTUVOVCBmcm9tIHN1cGVyXG5cbiAgXHRcdHZhciBpbnN0YW5jZSA9IGNyZWF0ZSggQ29tcG9uZW50Q29uc3RydWN0b3IucHJvdG90eXBlICk7XG5cbiAgXHRcdHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgXHRcdHRoaXMubmFtZSA9IG9wdGlvbnMudGVtcGxhdGUuZTtcbiAgXHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuXG4gIFx0XHR0aGlzLmxpdmVRdWVyaWVzID0gW107XG5cbiAgXHRcdGlmICggaW5zdGFuY2UuZWwgKSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKCAoXCJUaGUgPFwiICsgKHRoaXMubmFtZSkgKyBcIj4gY29tcG9uZW50IGhhcyBhIGRlZmF1bHQgJ2VsJyBwcm9wZXJ0eTsgaXQgaGFzIGJlZW4gZGlzcmVnYXJkZWRcIikgKTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIHBhcnRpYWxzID0gb3B0aW9ucy50ZW1wbGF0ZS5wIHx8IHt9O1xuICBcdFx0aWYgKCAhKCAnY29udGVudCcgaW4gcGFydGlhbHMgKSApIHBhcnRpYWxzLmNvbnRlbnQgPSBvcHRpb25zLnRlbXBsYXRlLmYgfHwgW107XG4gIFx0XHR0aGlzLl9wYXJ0aWFscyA9IHBhcnRpYWxzOyAvLyBURU1QXG5cbiAgXHRcdHRoaXMueWllbGRlcnMgPSB7fTtcblxuICBcdFx0Ly8gZmluZCBjb250YWluZXJcbiAgXHRcdHZhciBmcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG4gIFx0XHR2YXIgY29udGFpbmVyO1xuICBcdFx0d2hpbGUgKCBmcmFnbWVudCApIHtcbiAgXHRcdFx0aWYgKCBmcmFnbWVudC5vd25lci50eXBlID09PSBZSUVMREVSICkge1xuICBcdFx0XHRcdGNvbnRhaW5lciA9IGZyYWdtZW50Lm93bmVyLmNvbnRhaW5lcjtcbiAgXHRcdFx0XHRicmVhaztcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50O1xuICBcdFx0fVxuXG4gIFx0XHQvLyBhZGQgY29tcG9uZW50LWluc3RhbmNlLXNwZWNpZmljIHByb3BlcnRpZXNcbiAgXHRcdGluc3RhbmNlLnBhcmVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQucmFjdGl2ZTtcbiAgXHRcdGluc3RhbmNlLmNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBudWxsO1xuICBcdFx0aW5zdGFuY2Uucm9vdCA9IGluc3RhbmNlLnBhcmVudC5yb290O1xuICBcdFx0aW5zdGFuY2UuY29tcG9uZW50ID0gdGhpcztcblxuICBcdFx0Y29uc3RydWN0KCB0aGlzLmluc3RhbmNlLCB7IHBhcnRpYWxzOiBwYXJ0aWFscyB9KTtcblxuICBcdFx0Ly8gZm9yIGhhY2thYmlsaXR5LCB0aGlzIGNvdWxkIGJlIGFuIG9wZW4gb3B0aW9uXG4gIFx0XHQvLyBmb3IgYW55IHJhY3RpdmUgaW5zdGFuY2UsIGJ1dCBmb3Igbm93LCBqdXN0XG4gIFx0XHQvLyBmb3IgY29tcG9uZW50cyBhbmQganVzdCBmb3IgcmFjdGl2ZS4uLlxuICBcdFx0aW5zdGFuY2UuX2lubGluZVBhcnRpYWxzID0gcGFydGlhbHM7XG5cbiAgXHRcdHRoaXMuYXR0cmlidXRlQnlOYW1lID0ge307XG5cbiAgXHRcdHRoaXMuYXR0cmlidXRlcyA9IFtdO1xuICBcdFx0dmFyIGxlZnRvdmVycyA9IFtdO1xuICBcdFx0KCB0aGlzLnRlbXBsYXRlLm0gfHwgW10gKS5mb3JFYWNoKCBmdW5jdGlvbiAoIHRlbXBsYXRlICkge1xuICBcdFx0XHRzd2l0Y2ggKCB0ZW1wbGF0ZS50ICkge1xuICBcdFx0XHRcdGNhc2UgQVRUUklCVVRFOlxuICBcdFx0XHRcdGNhc2UgRVZFTlQ6XG4gIFx0XHRcdFx0Y2FzZSBUUkFOU0lUSU9OOlxuICBcdFx0XHRcdFx0dGhpcyQxLmF0dHJpYnV0ZXMucHVzaCggY3JlYXRlSXRlbSh7XG4gIFx0XHRcdFx0XHRcdG93bmVyOiB0aGlzJDEsXG4gIFx0XHRcdFx0XHRcdHBhcmVudEZyYWdtZW50OiB0aGlzJDEucGFyZW50RnJhZ21lbnQsXG4gIFx0XHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZVxuICBcdFx0XHRcdFx0fSkgKTtcbiAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gIFx0XHRcdFx0Y2FzZSBCSU5ESU5HX0ZMQUc6XG4gIFx0XHRcdFx0Y2FzZSBERUNPUkFUT1I6XG4gIFx0XHRcdFx0XHRicmVhaztcblxuICBcdFx0XHRcdGRlZmF1bHQ6XG4gIFx0XHRcdFx0XHRsZWZ0b3ZlcnMucHVzaCggdGVtcGxhdGUgKTtcbiAgXHRcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcblxuICBcdFx0dGhpcy5hdHRyaWJ1dGVzLnB1c2goIG5ldyBDb25kaXRpb25hbEF0dHJpYnV0ZSh7XG4gIFx0XHRcdG93bmVyOiB0aGlzLFxuICBcdFx0XHRwYXJlbnRGcmFnbWVudDogdGhpcy5wYXJlbnRGcmFnbWVudCxcbiAgXHRcdFx0dGVtcGxhdGU6IGxlZnRvdmVyc1xuICBcdFx0fSkgKTtcblxuICBcdFx0dGhpcy5ldmVudEhhbmRsZXJzID0gW107XG4gIFx0XHRpZiAoIHRoaXMudGVtcGxhdGUudiApIHRoaXMuc2V0dXBFdmVudHMoKTtcbiAgXHR9XG5cbiAgXHRDb21wb25lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSXRlbSAmJiBJdGVtLnByb3RvdHlwZSApO1xuICBcdENvbXBvbmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb21wb25lbnQ7XG5cbiAgXHRDb21wb25lbnQucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiBiaW5kJDEkJCAoKSB7XG4gIFx0XHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaCggYmluZCQxICk7XG5cbiAgXHRcdGluaXRpYWxpc2UoIHRoaXMuaW5zdGFuY2UsIHtcbiAgXHRcdFx0cGFydGlhbHM6IHRoaXMuX3BhcnRpYWxzXG4gIFx0XHR9LCB7XG4gIFx0XHRcdGNzc0lkczogdGhpcy5wYXJlbnRGcmFnbWVudC5jc3NJZHNcbiAgXHRcdH0pO1xuXG4gIFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaCggYmluZCQxICk7XG5cbiAgXHRcdHRoaXMuYm91bmQgPSB0cnVlO1xuICBcdH07XG5cbiAgXHRDb21wb25lbnQucHJvdG90eXBlLmJ1YmJsZSA9IGZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gIFx0XHRpZiAoICF0aGlzLmRpcnR5ICkge1xuICBcdFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0Q29tcG9uZW50LnByb3RvdHlwZS5jaGVja1lpZWxkZXJzID0gZnVuY3Rpb24gY2hlY2tZaWVsZGVycyAoKSB7XG4gIFx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0T2JqZWN0LmtleXMoIHRoaXMueWllbGRlcnMgKS5mb3JFYWNoKCBmdW5jdGlvbiAoIG5hbWUgKSB7XG4gIFx0XHRcdGlmICggdGhpcyQxLnlpZWxkZXJzWyBuYW1lIF0ubGVuZ3RoID4gMSApIHtcbiAgXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuICBcdFx0XHRcdHRocm93IG5ldyBFcnJvciggKFwiQSBjb21wb25lbnQgdGVtcGxhdGUgY2FuIG9ubHkgaGF2ZSBvbmUge3t5aWVsZFwiICsgKG5hbWUgPyAnICcgKyBuYW1lIDogJycpICsgXCJ9fSBkZWNsYXJhdGlvbiBhdCBhIHRpbWVcIikgKTtcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG4gIFx0fTtcblxuICBcdENvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveWVkID0gZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgXHRcdGlmICggdGhpcy5pbnN0YW5jZS5mcmFnbWVudCApIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZGVzdHJveWVkKCk7XG4gIFx0fTtcblxuICBcdENvbXBvbmVudC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gZGV0YWNoICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmRldGFjaCgpO1xuICBcdH07XG5cbiAgXHRDb21wb25lbnQucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiBmaW5kICggc2VsZWN0b3IgKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kKCBzZWxlY3RvciApO1xuICBcdH07XG5cbiAgXHRDb21wb25lbnQucHJvdG90eXBlLmZpbmRBbGwgPSBmdW5jdGlvbiBmaW5kQWxsICggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuICBcdFx0dGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcbiAgXHR9O1xuXG4gIFx0Q29tcG9uZW50LnByb3RvdHlwZS5maW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gZmluZENvbXBvbmVudCAoIG5hbWUgKSB7XG4gIFx0XHRpZiAoICFuYW1lIHx8IHRoaXMubmFtZSA9PT0gbmFtZSApIHJldHVybiB0aGlzLmluc3RhbmNlO1xuXG4gIFx0XHRpZiAoIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQgKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmRDb21wb25lbnQoIG5hbWUgKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0Q29tcG9uZW50LnByb3RvdHlwZS5maW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGZpbmRBbGxDb21wb25lbnRzICggbmFtZSwgcXVlcnkgKSB7XG4gIFx0XHRpZiAoIHF1ZXJ5LnRlc3QoIHRoaXMgKSApIHtcbiAgXHRcdFx0cXVlcnkuYWRkKCB0aGlzLmluc3RhbmNlICk7XG5cbiAgXHRcdFx0aWYgKCBxdWVyeS5saXZlICkge1xuICBcdFx0XHRcdHRoaXMubGl2ZVF1ZXJpZXMucHVzaCggcXVlcnkgKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBuYW1lLCBxdWVyeSApO1xuICBcdH07XG5cbiAgXHRDb21wb25lbnQucHJvdG90eXBlLmZpcnN0Tm9kZSA9IGZ1bmN0aW9uIGZpcnN0Tm9kZSAoIHNraXBQYXJlbnQgKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maXJzdE5vZGUoIHNraXBQYXJlbnQgKTtcbiAgXHR9O1xuXG4gIFx0Q29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIkMSQkICggdGFyZ2V0LCBvY2N1cGFudHMgKSB7XG4gIFx0XHRyZW5kZXIkMSggdGhpcy5pbnN0YW5jZSwgdGFyZ2V0LCBudWxsLCBvY2N1cGFudHMgKTtcblxuICBcdFx0dGhpcy5jaGVja1lpZWxkZXJzKCk7XG4gIFx0XHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaCggcmVuZGVyICk7XG4gIFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaCggcmVuZGVyICk7XG4gIFx0XHR1cGRhdGVMaXZlUXVlcmllcyggdGhpcyApO1xuXG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHR9O1xuXG4gIFx0Q29tcG9uZW50LnByb3RvdHlwZS5zZXR1cEV2ZW50cyA9IGZ1bmN0aW9uIHNldHVwRXZlbnRzICgpIHtcbiAgXHRcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHR2YXIgaGFuZGxlcnMgPSB0aGlzLmV2ZW50SGFuZGxlcnM7XG5cbiAgXHRcdE9iamVjdC5rZXlzKCB0aGlzLnRlbXBsYXRlLnYgKS5mb3JFYWNoKCBmdW5jdGlvbiAoIGtleSApIHtcbiAgXHRcdFx0dmFyIGV2ZW50TmFtZXMgPSBrZXkuc3BsaXQoICctJyApO1xuICBcdFx0XHR2YXIgdGVtcGxhdGUgPSB0aGlzJDEudGVtcGxhdGUudlsga2V5IF07XG5cbiAgXHRcdFx0ZXZlbnROYW1lcy5mb3JFYWNoKCBmdW5jdGlvbiAoIGV2ZW50TmFtZSApIHtcbiAgXHRcdFx0XHR2YXIgZXZlbnQgPSBuZXcgUmFjdGl2ZUV2ZW50KCB0aGlzJDEuaW5zdGFuY2UsIGV2ZW50TmFtZSApO1xuICBcdFx0XHRcdGhhbmRsZXJzLnB1c2goIG5ldyBFdmVudERpcmVjdGl2ZSggdGhpcyQxLCBldmVudCwgdGVtcGxhdGUgKSApO1xuICBcdFx0XHR9KTtcbiAgXHRcdH0pO1xuICBcdH07XG5cbiAgXHRDb21wb25lbnQucHJvdG90eXBlLnNodWZmbGVkID0gZnVuY3Rpb24gc2h1ZmZsZWQgKCkge1xuICBcdFx0dGhpcy5saXZlUXVlcmllcy5mb3JFYWNoKCBtYWtlRGlydHkgKTtcbiAgXHRcdEl0ZW0ucHJvdG90eXBlLnNodWZmbGVkLmNhbGwodGhpcyk7XG4gIFx0fTtcblxuICBcdENvbXBvbmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS50b0hUTUwoKTtcbiAgXHR9O1xuXG4gIFx0Q29tcG9uZW50LnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiB1bmJpbmQkMSAoKSB7XG4gIFx0XHR0aGlzLmJvdW5kID0gZmFsc2U7XG5cbiAgXHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKCB1bmJpbmQgKTtcblxuICBcdFx0dmFyIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZTtcbiAgXHRcdGluc3RhbmNlLnZpZXdtb2RlbC50ZWFyZG93bigpO1xuICBcdFx0aW5zdGFuY2UuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0XHRpbnN0YW5jZS5fb2JzZXJ2ZXJzLmZvckVhY2goIGNhbmNlbCApO1xuXG4gIFx0XHRyZW1vdmVGcm9tTGl2ZUNvbXBvbmVudFF1ZXJpZXMoIHRoaXMgKTtcblxuICBcdFx0aWYgKCBpbnN0YW5jZS5mcmFnbWVudC5yZW5kZXJlZCAmJiBpbnN0YW5jZS5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gKSB7XG4gIFx0XHRcdHJlbW92ZUZyb21BcnJheSggaW5zdGFuY2UuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCBpbnN0YW5jZSApO1xuICBcdFx0fVxuXG4gIFx0XHR0ZWFyZG93bkhvb2suZmlyZSggaW5zdGFuY2UgKTtcbiAgXHR9O1xuXG4gIFx0Q29tcG9uZW50LnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uIHVucmVuZGVyJDEgKCBzaG91bGREZXN0cm95ICkge1xuICBcdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcblxuICBcdFx0dGhpcy5zaG91bGREZXN0cm95ID0gc2hvdWxkRGVzdHJveTtcbiAgXHRcdHRoaXMuaW5zdGFuY2UudW5yZW5kZXIoKTtcbiAgXHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKCB1bnJlbmRlciApO1xuICBcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2goIHVucmVuZGVyICk7XG4gIFx0XHR0aGlzLmxpdmVRdWVyaWVzLmZvckVhY2goIGZ1bmN0aW9uICggcXVlcnkgKSB7IHJldHVybiBxdWVyeS5yZW1vdmUoIHRoaXMkMS5pbnN0YW5jZSApOyB9ICk7XG4gIFx0fTtcblxuICBcdENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlJDEgKCkge1xuICBcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuICBcdFx0dGhpcy5pbnN0YW5jZS5mcmFnbWVudC51cGRhdGUoKTtcbiAgXHRcdHRoaXMuY2hlY2tZaWVsZGVycygpO1xuICBcdFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2goIHVwZGF0ZSApO1xuICBcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2goIHVwZGF0ZSApO1xuICBcdH07XG5cbiAgXHRyZXR1cm4gQ29tcG9uZW50O1xuICB9KEl0ZW0pKTtcblxuICB2YXIgbWlzc2luZ0RlY29yYXRvciA9IHtcbiAgXHR1cGRhdGU6IG5vb3AsXG4gIFx0dGVhcmRvd246IG5vb3BcbiAgfTtcblxuICB2YXIgRGVjb3JhdG9yID0gZnVuY3Rpb24gRGVjb3JhdG9yICggb3B0aW9ucyApIHtcbiAgXHR0aGlzLm93bmVyID0gb3B0aW9ucy5vd25lciB8fCBvcHRpb25zLnBhcmVudEZyYWdtZW50Lm93bmVyIHx8IGZpbmRFbGVtZW50KCBvcHRpb25zLnBhcmVudEZyYWdtZW50ICk7XG4gIFx0dGhpcy5lbGVtZW50ID0gdGhpcy5vd25lci5hdHRyaWJ1dGVCeU5hbWUgPyB0aGlzLm93bmVyIDogZmluZEVsZW1lbnQoIG9wdGlvbnMucGFyZW50RnJhZ21lbnQgKTtcbiAgXHR0aGlzLnBhcmVudEZyYWdtZW50ID0gdGhpcy5vd25lci5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLnJhY3RpdmUgPSB0aGlzLm93bmVyLnJhY3RpdmU7XG4gIFx0dmFyIHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cbiAgXHR0aGlzLmR5bmFtaWNOYW1lID0gdHlwZW9mIHRlbXBsYXRlLmYubiA9PT0gJ29iamVjdCc7XG4gIFx0dGhpcy5keW5hbWljQXJncyA9ICEhdGVtcGxhdGUuZi5kO1xuXG4gIFx0aWYgKCB0aGlzLmR5bmFtaWNOYW1lICkge1xuICBcdFx0dGhpcy5uYW1lRnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoe1xuICBcdFx0XHRvd25lcjogdGhpcyxcbiAgXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmYublxuICBcdFx0fSk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHRoaXMubmFtZSA9IHRlbXBsYXRlLmYubiB8fCB0ZW1wbGF0ZS5mO1xuICBcdH1cblxuICBcdGlmICggdGhpcy5keW5hbWljQXJncyApIHtcbiAgXHRcdHRoaXMuYXJnc0ZyYWdtZW50ID0gbmV3IEZyYWdtZW50KHtcbiAgXHRcdFx0b3duZXI6IHRoaXMsXG4gIFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5mLmRcbiAgXHRcdH0pO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRpZiAoIHRlbXBsYXRlLmYuYSAmJiB0ZW1wbGF0ZS5mLmEucyApIHtcbiAgXHRcdFx0dGhpcy5hcmdzID0gW107XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLmFyZ3MgPSB0ZW1wbGF0ZS5mLmEgfHwgW107XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0dGhpcy5ub2RlID0gbnVsbDtcbiAgXHR0aGlzLmludGVybWVkaWFyeSA9IG51bGw7XG5cbiAgXHR0aGlzLmVsZW1lbnQuZGVjb3JhdG9ycy5wdXNoKCB0aGlzICk7XG4gIH07XG5cbiAgRGVjb3JhdG9yLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gYmluZCAoKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdGlmICggdGhpcy5keW5hbWljTmFtZSApIHtcbiAgXHRcdHRoaXMubmFtZUZyYWdtZW50LmJpbmQoKTtcbiAgXHRcdHRoaXMubmFtZSA9IHRoaXMubmFtZUZyYWdtZW50LnRvU3RyaW5nKCk7XG4gIFx0fVxuXG4gIFx0aWYgKCB0aGlzLmR5bmFtaWNBcmdzICkgdGhpcy5hcmdzRnJhZ21lbnQuYmluZCgpO1xuXG4gIFx0Ly8gVE9ETzogZHJ5IHRoaXMgdXAgb25jZSBkZXByZWNhdGlvbiBpcyBkb25lXG4gIFx0aWYgKCB0aGlzLnRlbXBsYXRlLmYuYSAmJiB0aGlzLnRlbXBsYXRlLmYuYS5zICkge1xuICBcdFx0dGhpcy5yZXNvbHZlcnMgPSBbXTtcbiAgXHRcdHRoaXMubW9kZWxzID0gdGhpcy50ZW1wbGF0ZS5mLmEuci5tYXAoIGZ1bmN0aW9uICggcmVmLCBpICkge1xuICBcdFx0XHR2YXIgcmVzb2x2ZXI7XG4gIFx0XHRcdHZhciBtb2RlbCA9IHJlc29sdmVSZWZlcmVuY2UoIHRoaXMkMS5wYXJlbnRGcmFnbWVudCwgcmVmICk7XG4gIFx0XHRcdGlmICggIW1vZGVsICkge1xuICBcdFx0XHRcdHJlc29sdmVyID0gdGhpcyQxLnBhcmVudEZyYWdtZW50LnJlc29sdmUoIHJlZiwgZnVuY3Rpb24gKCBtb2RlbCApIHtcbiAgXHRcdFx0XHRcdHRoaXMkMS5tb2RlbHNbaV0gPSBtb2RlbDtcbiAgXHRcdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcyQxLnJlc29sdmVycywgcmVzb2x2ZXIgKTtcbiAgXHRcdFx0XHRcdG1vZGVsLnJlZ2lzdGVyKCB0aGlzJDEgKTtcbiAgXHRcdFx0XHR9KTtcblxuICBcdFx0XHRcdHRoaXMkMS5yZXNvbHZlcnMucHVzaCggcmVzb2x2ZXIgKTtcbiAgXHRcdFx0fSBlbHNlIG1vZGVsLnJlZ2lzdGVyKCB0aGlzJDEgKTtcblxuICBcdFx0XHRyZXR1cm4gbW9kZWw7XG4gIFx0XHR9KTtcbiAgXHRcdHRoaXMuYXJnc0ZuID0gZ2V0RnVuY3Rpb24oIHRoaXMudGVtcGxhdGUuZi5hLnMsIHRoaXMudGVtcGxhdGUuZi5hLnIubGVuZ3RoICk7XG4gIFx0fVxuICB9O1xuXG4gIERlY29yYXRvci5wcm90b3R5cGUuYnViYmxlID0gZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgXHRpZiAoICF0aGlzLmRpcnR5ICkge1xuICBcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG4gIFx0XHR0aGlzLm93bmVyLmJ1YmJsZSgpO1xuICBcdH1cbiAgfTtcblxuICBEZWNvcmF0b3IucHJvdG90eXBlLmRlc3Ryb3llZCA9IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gIFx0aWYgKCB0aGlzLmludGVybWVkaWFyeSApIHRoaXMuaW50ZXJtZWRpYXJ5LnRlYXJkb3duKCk7XG4gIH07XG5cbiAgRGVjb3JhdG9yLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UgKCkgeyB0aGlzLmJ1YmJsZSgpOyB9O1xuXG4gIERlY29yYXRvci5wcm90b3R5cGUucmViaW5kaW5nID0gZnVuY3Rpb24gcmViaW5kaW5nICggbmV4dCwgcHJldmlvdXMsIHNhZmUgKSB7XG4gIFx0dmFyIGlkeCA9IHRoaXMubW9kZWxzLmluZGV4T2YoIHByZXZpb3VzICk7XG4gIFx0aWYgKCAhfmlkeCApIHJldHVybjtcblxuICBcdG5leHQgPSByZWJpbmRNYXRjaCggdGhpcy50ZW1wbGF0ZS5mLmEuclsgaWR4IF0sIG5leHQsIHByZXZpb3VzICk7XG4gIFx0aWYgKCBuZXh0ID09PSBwcmV2aW91cyApIHJldHVybjtcblxuICBcdHByZXZpb3VzLnVucmVnaXN0ZXIoIHRoaXMgKTtcbiAgXHR0aGlzLm1vZGVscy5zcGxpY2UoIGlkeCwgMSwgbmV4dCApO1xuICBcdGlmICggbmV4dCApIG5leHQuYWRkU2h1ZmZsZVJlZ2lzdGVyKCB0aGlzLCAnbWFyaycgKTtcblxuICBcdGlmICggIXNhZmUgKSB0aGlzLmJ1YmJsZSgpO1xuICB9O1xuXG4gIERlY29yYXRvci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uICgpIHtcbiAgXHRcdHZhciBmbiA9IGZpbmRJblZpZXdIaWVyYXJjaHkoICdkZWNvcmF0b3JzJywgdGhpcyQxLnJhY3RpdmUsIHRoaXMkMS5uYW1lICk7XG5cbiAgXHRcdGlmICggIWZuICkge1xuICBcdFx0XHR3YXJuT25jZSggbWlzc2luZ1BsdWdpbiggdGhpcyQxLm5hbWUsICdkZWNvcmF0b3InICkgKTtcbiAgXHRcdFx0dGhpcyQxLmludGVybWVkaWFyeSA9IG1pc3NpbmdEZWNvcmF0b3I7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcyQxLm5vZGUgPSB0aGlzJDEuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHR2YXIgYXJncztcbiAgXHRcdGlmICggdGhpcyQxLmFyZ3NGbiApIHtcbiAgXHRcdFx0YXJncyA9IHRoaXMkMS5tb2RlbHMubWFwKCBmdW5jdGlvbiAoIG1vZGVsICkge1xuICBcdFx0XHRcdGlmICggIW1vZGVsICkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICBcdFx0XHRcdHJldHVybiBtb2RlbC5nZXQoKTtcbiAgXHRcdFx0fSk7XG4gIFx0XHRcdGFyZ3MgPSB0aGlzJDEuYXJnc0ZuLmFwcGx5KCB0aGlzJDEucmFjdGl2ZSwgYXJncyApO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0YXJncyA9IHRoaXMkMS5keW5hbWljQXJncyA/IHRoaXMkMS5hcmdzRnJhZ21lbnQuZ2V0QXJnc0xpc3QoKSA6IHRoaXMkMS5hcmdzO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzJDEuaW50ZXJtZWRpYXJ5ID0gZm4uYXBwbHkoIHRoaXMkMS5yYWN0aXZlLCBbIHRoaXMkMS5ub2RlIF0uY29uY2F0KCBhcmdzICkgKTtcblxuICBcdFx0aWYgKCAhdGhpcyQxLmludGVybWVkaWFyeSB8fCAhdGhpcyQxLmludGVybWVkaWFyeS50ZWFyZG93biApIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAoXCJUaGUgJ1wiICsgKHRoaXMkMS5uYW1lKSArIFwiJyBkZWNvcmF0b3IgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdpdGggYSB0ZWFyZG93biBtZXRob2RcIikgKTtcbiAgXHRcdH1cbiAgXHR9LCB0cnVlICk7XG4gIFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIH07XG5cbiAgRGVjb3JhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHsgcmV0dXJuICcnOyB9O1xuXG4gIERlY29yYXRvci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gdW5iaW5kJDEgKCkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHRpZiAoIHRoaXMuZHluYW1pY05hbWUgKSB0aGlzLm5hbWVGcmFnbWVudC51bmJpbmQoKTtcbiAgXHRpZiAoIHRoaXMuZHluYW1pY0FyZ3MgKSB0aGlzLmFyZ3NGcmFnbWVudC51bmJpbmQoKTtcbiAgXHRpZiAoIHRoaXMucmVzb2x2ZXJzICkgdGhpcy5yZXNvbHZlcnMuZm9yRWFjaCggdW5iaW5kICk7XG4gIFx0aWYgKCB0aGlzLm1vZGVscyApIHRoaXMubW9kZWxzLmZvckVhY2goIGZ1bmN0aW9uICggbSApIHtcbiAgXHRcdGlmICggbSApIG0udW5yZWdpc3RlciggdGhpcyQxICk7XG4gIFx0fSk7XG4gIH07XG5cbiAgRGVjb3JhdG9yLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uIHVucmVuZGVyICggc2hvdWxkRGVzdHJveSApIHtcbiAgXHRpZiAoICggIXNob3VsZERlc3Ryb3kgfHwgdGhpcy5lbGVtZW50LnJlbmRlcmVkICkgJiYgdGhpcy5pbnRlcm1lZGlhcnkgKSB0aGlzLmludGVybWVkaWFyeS50ZWFyZG93bigpO1xuICBcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgfTtcblxuICBEZWNvcmF0b3IucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIFx0aWYgKCAhdGhpcy5kaXJ0eSApIHJldHVybjtcblxuICBcdHRoaXMuZGlydHkgPSBmYWxzZTtcblxuICBcdHZhciBuYW1lQ2hhbmdlZCA9IGZhbHNlO1xuXG4gIFx0aWYgKCB0aGlzLmR5bmFtaWNOYW1lICYmIHRoaXMubmFtZUZyYWdtZW50LmRpcnR5ICkge1xuICBcdFx0dmFyIG5hbWUgPSB0aGlzLm5hbWVGcmFnbWVudC50b1N0cmluZygpO1xuICBcdFx0bmFtZUNoYW5nZWQgPSBuYW1lICE9PSB0aGlzLm5hbWU7XG4gIFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuICBcdH1cblxuICBcdGlmICggdGhpcy5pbnRlcm1lZGlhcnkgKSB7XG4gIFx0XHRpZiAoIG5hbWVDaGFuZ2VkIHx8ICF0aGlzLmludGVybWVkaWFyeS51cGRhdGUgKSB7XG4gIFx0XHRcdHRoaXMudW5yZW5kZXIoKTtcbiAgXHRcdFx0dGhpcy5yZW5kZXIoKTtcbiAgXHRcdH1cbiAgXHRcdGVsc2Uge1xuICBcdFx0XHRpZiAoIHRoaXMuZHluYW1pY0FyZ3MgKSB7XG4gIFx0XHRcdFx0aWYgKCB0aGlzLmFyZ3NGcmFnbWVudC5kaXJ0eSApIHtcbiAgXHRcdFx0XHRcdHZhciBhcmdzID0gdGhpcy5hcmdzRnJhZ21lbnQuZ2V0QXJnc0xpc3QoKTtcbiAgXHRcdFx0XHRcdHRoaXMuaW50ZXJtZWRpYXJ5LnVwZGF0ZS5hcHBseSggdGhpcy5yYWN0aXZlLCBhcmdzICk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHRcdGVsc2UgaWYgKCB0aGlzLmFyZ3NGbiApIHtcbiAgXHRcdFx0XHR2YXIgYXJncyQxID0gdGhpcy5tb2RlbHMubWFwKCBmdW5jdGlvbiAoIG1vZGVsICkge1xuICBcdFx0XHRcdFx0aWYgKCAhbW9kZWwgKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIFx0XHRcdFx0XHRyZXR1cm4gbW9kZWwuZ2V0KCk7XG4gIFx0XHRcdFx0fSk7XG4gIFx0XHRcdFx0dGhpcy5pbnRlcm1lZGlhcnkudXBkYXRlLmFwcGx5KCB0aGlzLnJhY3RpdmUsIHRoaXMuYXJnc0ZuLmFwcGx5KCB0aGlzLnJhY3RpdmUsIGFyZ3MkMSApICk7XG4gIFx0XHRcdH1cbiAgXHRcdFx0ZWxzZSB7XG4gIFx0XHRcdFx0dGhpcy5pbnRlcm1lZGlhcnkudXBkYXRlLmFwcGx5KCB0aGlzLnJhY3RpdmUsIHRoaXMuYXJncyApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gbmVlZCB0byBydW4gdGhlc2UgZm9yIHVucmVuZGVyL3JlbmRlciBjYXNlc1xuICBcdC8vIHNvIGNhbid0IGp1c3QgYmUgaW4gY29uZGl0aW9uYWwgaWYgYWJvdmVcblxuICBcdGlmICggdGhpcy5keW5hbWljTmFtZSAmJiB0aGlzLm5hbWVGcmFnbWVudC5kaXJ0eSApIHtcbiAgXHRcdHRoaXMubmFtZUZyYWdtZW50LnVwZGF0ZSgpO1xuICBcdH1cblxuICBcdGlmICggdGhpcy5keW5hbWljQXJncyAmJiB0aGlzLmFyZ3NGcmFnbWVudC5kaXJ0eSApIHtcbiAgXHRcdHRoaXMuYXJnc0ZyYWdtZW50LnVwZGF0ZSgpO1xuICBcdH1cbiAgfTtcblxuICB2YXIgRG9jdHlwZSA9IChmdW5jdGlvbiAoSXRlbSkge1xuICBcdGZ1bmN0aW9uIERvY3R5cGUgKCkge1xuICBcdFx0SXRlbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBcdH1cblxuICBcdERvY3R5cGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSXRlbSAmJiBJdGVtLnByb3RvdHlwZSApO1xuICBcdERvY3R5cGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRG9jdHlwZTtcblxuICBcdERvY3R5cGUucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiBiaW5kICgpIHtcbiAgXHRcdC8vIG5vb3BcbiAgXHR9O1xuXG4gIFx0RG9jdHlwZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgXHRcdC8vIG5vb3BcbiAgXHR9O1xuXG4gIFx0RG9jdHlwZS5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gIFx0XHQvLyBub29wXG4gIFx0fTtcblxuICBcdERvY3R5cGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBcdFx0cmV0dXJuICc8IURPQ1RZUEUnICsgdGhpcy50ZW1wbGF0ZS5hICsgJz4nO1xuICBcdH07XG5cbiAgXHREb2N0eXBlLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiB1bmJpbmQgKCkge1xuICBcdFx0Ly8gbm9vcFxuICBcdH07XG5cbiAgXHREb2N0eXBlLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uIHVucmVuZGVyICgpIHtcbiAgXHRcdC8vIG5vb3BcbiAgXHR9O1xuXG4gIFx0RG9jdHlwZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgXHRcdC8vIG5vb3BcbiAgXHR9O1xuXG4gIFx0cmV0dXJuIERvY3R5cGU7XG4gIH0oSXRlbSkpO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpdmVRdWVyaWVzJDEgKCBlbGVtZW50ICkge1xuICBcdC8vIERvZXMgdGhpcyBuZWVkIHRvIGJlIGFkZGVkIHRvIGFueSBsaXZlIHF1ZXJpZXM/XG4gIFx0dmFyIG5vZGUgPSBlbGVtZW50Lm5vZGU7XG4gIFx0dmFyIGluc3RhbmNlID0gZWxlbWVudC5yYWN0aXZlO1xuXG4gIFx0ZG8ge1xuICBcdFx0dmFyIGxpdmVRdWVyaWVzID0gaW5zdGFuY2UuX2xpdmVRdWVyaWVzO1xuXG4gIFx0XHR2YXIgaSA9IGxpdmVRdWVyaWVzLmxlbmd0aDtcbiAgXHRcdHdoaWxlICggaS0tICkge1xuICBcdFx0XHR2YXIgc2VsZWN0b3IgPSBsaXZlUXVlcmllc1tpXTtcbiAgXHRcdFx0dmFyIHF1ZXJ5ID0gbGl2ZVF1ZXJpZXNbIChcIl9cIiArIHNlbGVjdG9yKSBdO1xuXG4gIFx0XHRcdGlmICggcXVlcnkudGVzdCggbm9kZSApICkge1xuICBcdFx0XHRcdHF1ZXJ5LmFkZCggbm9kZSApO1xuICBcdFx0XHRcdC8vIGtlZXAgcmVnaXN0ZXIgb2YgYXBwbGljYWJsZSBzZWxlY3RvcnMsIGZvciB3aGVuIHdlIHRlYXJkb3duXG4gIFx0XHRcdFx0ZWxlbWVudC5saXZlUXVlcmllcy5wdXNoKCBxdWVyeSApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSB3aGlsZSAoIGluc3RhbmNlID0gaW5zdGFuY2UucGFyZW50ICk7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuQWJvdXRBbWJpZ3VpdHkgKCBkZXNjcmlwdGlvbiwgcmFjdGl2ZSApIHtcbiAgXHR3YXJuT25jZUlmRGVidWcoIChcIlRoZSBcIiArIGRlc2NyaXB0aW9uICsgXCIgYmVpbmcgdXNlZCBmb3IgdHdvLXdheSBiaW5kaW5nIGlzIGFtYmlndW91cywgYW5kIG1heSBjYXVzZSB1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnNpZGVyIGluaXRpYWxpc2luZyB5b3VyIGRhdGEgdG8gZWxpbWluYXRlIHRoZSBhbWJpZ3VpdHlcIiksIHsgcmFjdGl2ZTogcmFjdGl2ZSB9KTtcbiAgfVxuXG4gIHZhciBCaW5kaW5nID0gZnVuY3Rpb24gQmluZGluZyAoIGVsZW1lbnQsIG5hbWUgKSB7XG4gIFx0aWYgKCBuYW1lID09PSB2b2lkIDAgKSBuYW1lID0gJ3ZhbHVlJztcblxuICBcdFx0dGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgXHR0aGlzLnJhY3RpdmUgPSBlbGVtZW50LnJhY3RpdmU7XG4gIFx0dGhpcy5hdHRyaWJ1dGUgPSBlbGVtZW50LmF0dHJpYnV0ZUJ5TmFtZVsgbmFtZSBdO1xuXG4gIFx0dmFyIGludGVycG9sYXRvciA9IHRoaXMuYXR0cmlidXRlLmludGVycG9sYXRvcjtcbiAgXHRpbnRlcnBvbGF0b3IudHdvd2F5QmluZGluZyA9IHRoaXM7XG5cbiAgXHR2YXIgbW9kZWwgPSBpbnRlcnBvbGF0b3IubW9kZWw7XG5cbiAgXHQvLyBub3QgYm91bmQ/XG4gIFx0aWYgKCAhbW9kZWwgKSB7XG4gIFx0XHQvLyB0cnkgdG8gZm9yY2UgcmVzb2x1dGlvblxuICBcdFx0aW50ZXJwb2xhdG9yLnJlc29sdmVyLmZvcmNlUmVzb2x1dGlvbigpO1xuICBcdFx0bW9kZWwgPSBpbnRlcnBvbGF0b3IubW9kZWw7XG5cbiAgXHRcdHdhcm5BYm91dEFtYmlndWl0eSggKFwiJ1wiICsgKGludGVycG9sYXRvci50ZW1wbGF0ZS5yKSArIFwiJyByZWZlcmVuY2VcIiksIHRoaXMucmFjdGl2ZSApO1xuICBcdFx0fVxuXG4gIFx0XHRlbHNlIGlmICggbW9kZWwuaXNVbnJlc29sdmVkICkge1xuICBcdFx0XHQvLyByZWZlcmVuY2UgZXhwcmVzc2lvbnMgKGUuZy4gZm9vW2Jhcl0pXG4gIFx0XHRcdG1vZGVsLmZvcmNlUmVzb2x1dGlvbigpO1xuICBcdFx0XHR3YXJuQWJvdXRBbWJpZ3VpdHkoICdleHByZXNzaW9uJywgdGhpcy5yYWN0aXZlICk7XG4gIFx0fVxuXG4gIFx0Ly8gVE9ETyBpbmNsdWRlIGluZGV4L2tleS9rZXlwYXRoIHJlZnMgYXMgcmVhZC1vbmx5XG4gIFx0ZWxzZSBpZiAoIG1vZGVsLmlzUmVhZG9ubHkgKSB7XG4gIFx0XHR2YXIga2V5cGF0aCA9IG1vZGVsLmdldEtleXBhdGgoKS5yZXBsYWNlKCAvXkAvLCAnJyApO1xuICBcdFx0d2Fybk9uY2VJZkRlYnVnKCAoXCJDYW5ub3QgdXNlIHR3by13YXkgYmluZGluZyBvbiA8XCIgKyAoZWxlbWVudC5uYW1lKSArIFwiPiBlbGVtZW50OiBcIiArIGtleXBhdGggKyBcIiBpcyByZWFkLW9ubHkuIFRvIHN1cHByZXNzIHRoaXMgd2FybmluZyB1c2UgPFwiICsgKGVsZW1lbnQubmFtZSkgKyBcIiB0d293YXk9J2ZhbHNlJy4uLj5cIiksIHsgcmFjdGl2ZTogdGhpcy5yYWN0aXZlIH0pO1xuICBcdFx0cmV0dXJuIGZhbHNlO1xuICBcdH1cblxuICBcdHRoaXMuYXR0cmlidXRlLmlzVHdvd2F5ID0gdHJ1ZTtcbiAgXHR0aGlzLm1vZGVsID0gbW9kZWw7XG5cbiAgXHQvLyBpbml0aWFsaXNlIHZhbHVlLCBpZiBpdCdzIHVuZGVmaW5lZFxuICBcdHZhciB2YWx1ZSA9IG1vZGVsLmdldCgpO1xuICBcdHRoaXMud2FzVW5kZWZpbmVkID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmdldEluaXRpYWxWYWx1ZSApIHtcbiAgXHRcdHZhbHVlID0gdGhpcy5nZXRJbml0aWFsVmFsdWUoKTtcbiAgXHRcdG1vZGVsLnNldCggdmFsdWUgKTtcbiAgXHR9XG4gIFx0dGhpcy5sYXN0VmFsKCB0cnVlLCB2YWx1ZSApO1xuXG4gIFx0dmFyIHBhcmVudEZvcm0gPSBmaW5kRWxlbWVudCggdGhpcy5lbGVtZW50LCBmYWxzZSwgJ2Zvcm0nICk7XG4gIFx0aWYgKCBwYXJlbnRGb3JtICkge1xuICBcdFx0dGhpcy5yZXNldFZhbHVlID0gdmFsdWU7XG4gIFx0XHRwYXJlbnRGb3JtLmZvcm1CaW5kaW5ncy5wdXNoKCB0aGlzICk7XG4gIFx0fVxuICB9O1xuXG4gIEJpbmRpbmcucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiBiaW5kICgpIHtcbiAgXHR0aGlzLm1vZGVsLnJlZ2lzdGVyVHdvd2F5QmluZGluZyggdGhpcyApO1xuICB9O1xuXG4gIEJpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSAoKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgXHRpZiAoIHRoaXMubGFzdFZhbCgpID09PSB2YWx1ZSApIHJldHVybjtcblxuICBcdHJ1bmxvb3Auc3RhcnQoIHRoaXMucm9vdCApO1xuICBcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG4gIFx0dGhpcy5tb2RlbC5zZXQoIHZhbHVlICk7XG4gIFx0dGhpcy5sYXN0VmFsKCB0cnVlLCB2YWx1ZSApO1xuXG4gIFx0Ly8gaWYgdGhlIHZhbHVlIGNoYW5nZXMgYmVmb3JlIG9ic2VydmVycyBmaXJlLCB1bmxvY2sgdG8gYmUgdXBkYXRhYmxlIGNhdXNlIHNvbWV0aGluZyB3ZWlyZCBhbmQgcG90ZW50aWFsbHkgZnJlZXp5IGlzIHVwXG4gIFx0aWYgKCB0aGlzLm1vZGVsLmdldCgpICE9PSB2YWx1ZSApIHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IGZhbHNlO1xuICBcdGVsc2UgcnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7IH0gKTtcblxuICBcdHJ1bmxvb3AuZW5kKCk7XG4gIH07XG5cbiAgQmluZGluZy5wcm90b3R5cGUubGFzdFZhbCA9IGZ1bmN0aW9uIGxhc3RWYWwgKCBzZXR0aW5nLCB2YWx1ZSApIHtcbiAgXHRpZiAoIHNldHRpbmcgKSB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuICBcdGVsc2UgcmV0dXJuIHRoaXMubGFzdFZhbHVlO1xuICB9O1xuXG4gIEJpbmRpbmcucHJvdG90eXBlLnJlYmluZGluZyA9IGZ1bmN0aW9uIHJlYmluZGluZyAoIG5leHQsIHByZXZpb3VzICkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHRpZiAoIHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbCA9PT0gcHJldmlvdXMgKSBwcmV2aW91cy51bnJlZ2lzdGVyVHdvd2F5QmluZGluZyggdGhpcyApO1xuICBcdGlmICggbmV4dCApIHtcbiAgXHRcdHRoaXMubW9kZWwgPSBuZXh0O1xuICBcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5leHQucmVnaXN0ZXJUd293YXlCaW5kaW5nKCB0aGlzJDEgKTsgfSApO1xuICBcdH1cbiAgfTtcblxuICBCaW5kaW5nLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKCkge1xuICBcdHRoaXMubm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuICBcdHRoaXMubm9kZS5fcmFjdGl2ZS5iaW5kaW5nID0gdGhpcztcbiAgXHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTsgLy8gVE9ETyBpcyB0aGlzIHVzZWQgYW55d2hlcmU/XG4gIH07XG5cbiAgXHRCaW5kaW5nLnByb3RvdHlwZS5zZXRGcm9tTm9kZSA9IGZ1bmN0aW9uIHNldEZyb21Ob2RlICggbm9kZSApIHtcbiAgXHRcdHRoaXMubW9kZWwuc2V0KCBub2RlLnZhbHVlICk7XG4gIH07XG5cbiAgQmluZGluZy5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gdW5iaW5kICgpIHtcbiAgXHR0aGlzLm1vZGVsLnVucmVnaXN0ZXJUd293YXlCaW5kaW5nKCB0aGlzICk7XG4gIH07XG5cbiAgQmluZGluZy5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiB1bnJlbmRlciAoKSB7XG4gIFx0XHQvLyBub29wP1xuICBcdH07XG5cbiAgLy8gVGhpcyBpcyB0aGUgaGFuZGxlciBmb3IgRE9NIGV2ZW50cyB0aGF0IHdvdWxkIGxlYWQgdG8gYSBjaGFuZ2UgaW4gdGhlIG1vZGVsXG4gIC8vIChpLmUuIGNoYW5nZSwgc29tZXRpbWVzLCBpbnB1dCwgYW5kIG9jY2FzaW9uYWxseSBjbGljayBhbmQga2V5dXApXG4gIGZ1bmN0aW9uIGhhbmRsZURvbUV2ZW50ICgpIHtcbiAgXHR0aGlzLl9yYWN0aXZlLmJpbmRpbmcuaGFuZGxlQ2hhbmdlKCk7XG4gIH1cblxuICB2YXIgQ2hlY2tib3hCaW5kaW5nID0gKGZ1bmN0aW9uIChCaW5kaW5nKSB7XG4gIFx0ZnVuY3Rpb24gQ2hlY2tib3hCaW5kaW5nICggZWxlbWVudCApIHtcbiAgXHRcdEJpbmRpbmcuY2FsbCggdGhpcywgZWxlbWVudCwgJ2NoZWNrZWQnICk7XG4gIFx0fVxuXG4gIFx0Q2hlY2tib3hCaW5kaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJpbmRpbmcgJiYgQmluZGluZy5wcm90b3R5cGUgKTtcbiAgXHRDaGVja2JveEJpbmRpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2hlY2tib3hCaW5kaW5nO1xuXG4gIFx0Q2hlY2tib3hCaW5kaW5nLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKCkge1xuICBcdFx0QmluZGluZy5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG5cbiAgXHRcdHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cbiAgXHRcdGlmICggdGhpcy5ub2RlLmF0dGFjaEV2ZW50ICkge1xuICBcdFx0XHR0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdENoZWNrYm94QmluZGluZy5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiB1bnJlbmRlciAoKSB7XG4gIFx0XHR0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuICBcdFx0dGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuICBcdH07XG5cbiAgXHRDaGVja2JveEJpbmRpbmcucHJvdG90eXBlLmdldEluaXRpYWxWYWx1ZSA9IGZ1bmN0aW9uIGdldEluaXRpYWxWYWx1ZSAoKSB7XG4gIFx0XHRyZXR1cm4gISF0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnY2hlY2tlZCcgKTtcbiAgXHR9O1xuXG4gIFx0Q2hlY2tib3hCaW5kaW5nLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGUuY2hlY2tlZDtcbiAgXHR9O1xuXG4gIFx0Q2hlY2tib3hCaW5kaW5nLnByb3RvdHlwZS5zZXRGcm9tTm9kZSA9IGZ1bmN0aW9uIHNldEZyb21Ob2RlICggbm9kZSApIHtcbiAgXHRcdHRoaXMubW9kZWwuc2V0KCBub2RlLmNoZWNrZWQgKTtcbiAgXHR9O1xuXG4gIFx0cmV0dXJuIENoZWNrYm94QmluZGluZztcbiAgfShCaW5kaW5nKSk7XG5cbiAgZnVuY3Rpb24gZ2V0QmluZGluZ0dyb3VwICggZ3JvdXAsIG1vZGVsLCBnZXRWYWx1ZSApIHtcbiAgXHR2YXIgaGFzaCA9IFwiXCIgKyBncm91cCArIFwiLWJpbmRpbmdHcm91cFwiO1xuICBcdHJldHVybiBtb2RlbFtoYXNoXSB8fCAoIG1vZGVsWyBoYXNoIF0gPSBuZXcgQmluZGluZ0dyb3VwKCBoYXNoLCBtb2RlbCwgZ2V0VmFsdWUgKSApO1xuICB9XG5cbiAgdmFyIEJpbmRpbmdHcm91cCA9IGZ1bmN0aW9uIEJpbmRpbmdHcm91cCAoIGhhc2gsIG1vZGVsLCBnZXRWYWx1ZSApIHtcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dGhpcy5tb2RlbCA9IG1vZGVsO1xuICBcdHRoaXMuaGFzaCA9IGhhc2g7XG4gIFx0dGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgXHRcdHRoaXMkMS52YWx1ZSA9IGdldFZhbHVlLmNhbGwodGhpcyQxKTtcbiAgXHRcdHJldHVybiB0aGlzJDEudmFsdWU7XG4gIFx0fTtcblxuICBcdHRoaXMuYmluZGluZ3MgPSBbXTtcbiAgfTtcblxuICBCaW5kaW5nR3JvdXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoIGJpbmRpbmcgKSB7XG4gIFx0dGhpcy5iaW5kaW5ncy5wdXNoKCBiaW5kaW5nICk7XG4gIH07XG5cbiAgQmluZGluZ0dyb3VwLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gYmluZCAoKSB7XG4gIFx0dGhpcy52YWx1ZSA9IHRoaXMubW9kZWwuZ2V0KCk7XG4gIFx0dGhpcy5tb2RlbC5yZWdpc3RlclR3b3dheUJpbmRpbmcoIHRoaXMgKTtcbiAgXHR0aGlzLmJvdW5kID0gdHJ1ZTtcbiAgfTtcblxuICBCaW5kaW5nR3JvdXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoIGJpbmRpbmcgKSB7XG4gIFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLmJpbmRpbmdzLCBiaW5kaW5nICk7XG4gIFx0aWYgKCAhdGhpcy5iaW5kaW5ncy5sZW5ndGggKSB7XG4gIFx0XHR0aGlzLnVuYmluZCgpO1xuICBcdH1cbiAgfTtcblxuICBCaW5kaW5nR3JvdXAucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uIHVuYmluZCAoKSB7XG4gIFx0dGhpcy5tb2RlbC51bnJlZ2lzdGVyVHdvd2F5QmluZGluZyggdGhpcyApO1xuICBcdHRoaXMuYm91bmQgPSBmYWxzZTtcbiAgXHRkZWxldGUgdGhpcy5tb2RlbFt0aGlzLmhhc2hdO1xuICB9O1xuXG4gIHZhciBwdXNoJDIgPSBbXS5wdXNoO1xuXG4gIGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICBcdHZhciBhbGwgPSB0aGlzLmJpbmRpbmdzLmZpbHRlcihmdW5jdGlvbiAoIGIgKSB7IHJldHVybiBiLm5vZGUgJiYgYi5ub2RlLmNoZWNrZWQ7IH0pLm1hcChmdW5jdGlvbiAoIGIgKSB7IHJldHVybiBiLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7IH0pO1xuICBcdHZhciByZXMgPSBbXTtcbiAgXHRhbGwuZm9yRWFjaChmdW5jdGlvbiAoIHYgKSB7IGlmICggIWFycmF5Q29udGFpbnMoIHJlcywgdiApICkgcmVzLnB1c2goIHYgKTsgfSk7XG4gIFx0cmV0dXJuIHJlcztcbiAgfVxuXG4gIHZhciBDaGVja2JveE5hbWVCaW5kaW5nID0gKGZ1bmN0aW9uIChCaW5kaW5nKSB7XG4gIFx0ZnVuY3Rpb24gQ2hlY2tib3hOYW1lQmluZGluZyAoIGVsZW1lbnQgKSB7XG4gIFx0XHRCaW5kaW5nLmNhbGwoIHRoaXMsIGVsZW1lbnQsICduYW1lJyApO1xuXG4gIFx0XHR0aGlzLmNoZWNrYm94TmFtZSA9IHRydWU7IC8vIHNvIHRoYXQgcmFjdGl2ZS51cGRhdGVNb2RlbCgpIGtub3dzIHdoYXQgdG8gZG8gd2l0aCB0aGlzXG5cbiAgXHRcdC8vIEVhY2ggaW5wdXQgaGFzIGEgcmVmZXJlbmNlIHRvIGFuIGFycmF5IGNvbnRhaW5pbmcgaXQgYW5kIGl0c1xuICBcdFx0Ly8gZ3JvdXAsIGFzIHR3by13YXkgYmluZGluZyBkZXBlbmRzIG9uIGJlaW5nIGFibGUgdG8gYXNjZXJ0YWluXG4gIFx0XHQvLyB0aGUgc3RhdHVzIG9mIGFsbCBpbnB1dHMgd2l0aGluIHRoZSBncm91cFxuICBcdFx0dGhpcy5ncm91cCA9IGdldEJpbmRpbmdHcm91cCggJ2NoZWNrYm94ZXMnLCB0aGlzLm1vZGVsLCBnZXRWYWx1ZSApO1xuICBcdFx0dGhpcy5ncm91cC5hZGQoIHRoaXMgKTtcblxuICBcdFx0aWYgKCB0aGlzLm5vSW5pdGlhbFZhbHVlICkge1xuICBcdFx0XHR0aGlzLmdyb3VwLm5vSW5pdGlhbFZhbHVlID0gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gSWYgbm8gaW5pdGlhbCB2YWx1ZSB3YXMgc2V0LCBhbmQgdGhpcyBpbnB1dCBpcyBjaGVja2VkLCB3ZVxuICBcdFx0Ly8gdXBkYXRlIHRoZSBtb2RlbFxuICBcdFx0aWYgKCB0aGlzLmdyb3VwLm5vSW5pdGlhbFZhbHVlICYmIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdjaGVja2VkJyApICkge1xuICBcdFx0XHR2YXIgZXhpc3RpbmdWYWx1ZSA9IHRoaXMubW9kZWwuZ2V0KCk7XG4gIFx0XHRcdHZhciBiaW5kaW5nVmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cbiAgXHRcdFx0aWYgKCAhYXJyYXlDb250YWlucyggZXhpc3RpbmdWYWx1ZSwgYmluZGluZ1ZhbHVlICkgKSB7XG4gIFx0XHRcdFx0cHVzaCQyLmNhbGwoIGV4aXN0aW5nVmFsdWUsIGJpbmRpbmdWYWx1ZSApOyAvLyB0byBhdm9pZCB0cmlnZ2VyaW5nIHJ1bmxvb3Agd2l0aCBhcnJheSBhZGFwdG9yXG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRDaGVja2JveE5hbWVCaW5kaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJpbmRpbmcgJiYgQmluZGluZy5wcm90b3R5cGUgKTtcbiAgXHRDaGVja2JveE5hbWVCaW5kaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENoZWNrYm94TmFtZUJpbmRpbmc7XG5cbiAgXHRDaGVja2JveE5hbWVCaW5kaW5nLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gYmluZCAoKSB7XG4gIFx0XHRpZiAoICF0aGlzLmdyb3VwLmJvdW5kICkge1xuICBcdFx0XHR0aGlzLmdyb3VwLmJpbmQoKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0Q2hlY2tib3hOYW1lQmluZGluZy5wcm90b3R5cGUuY2hhbmdlZCA9IGZ1bmN0aW9uIGNoYW5nZWQgKCkge1xuICBcdFx0dmFyIHdhc0NoZWNrZWQgPSAhIXRoaXMuaXNDaGVja2VkO1xuICBcdFx0dGhpcy5pc0NoZWNrZWQgPSB0aGlzLm5vZGUuY2hlY2tlZDtcbiAgXHRcdHJldHVybiB0aGlzLmlzQ2hlY2tlZCA9PT0gd2FzQ2hlY2tlZDtcbiAgXHR9O1xuXG4gIFx0Q2hlY2tib3hOYW1lQmluZGluZy5wcm90b3R5cGUuZ2V0SW5pdGlhbFZhbHVlID0gZnVuY3Rpb24gZ2V0SW5pdGlhbFZhbHVlICgpIHtcbiAgXHRcdC8vIFRoaXMgb25seSBnZXRzIGNhbGxlZCBvbmNlIHBlciBncm91cCAob2YgaW5wdXRzIHRoYXRcbiAgXHRcdC8vIHNoYXJlIGEgbmFtZSksIGJlY2F1c2UgaXQgb25seSBnZXRzIGNhbGxlZCBpZiB0aGVyZVxuICBcdFx0Ly8gaXNuJ3QgYW4gaW5pdGlhbCB2YWx1ZS4gQnkgdGhlIHNhbWUgdG9rZW4sIHdlIGNhbiBtYWtlXG4gIFx0XHQvLyBhIG5vdGUgb2YgdGhhdCBmYWN0IHRoYXQgdGhlcmUgd2FzIG5vIGluaXRpYWwgdmFsdWUsXG4gIFx0XHQvLyBhbmQgcG9wdWxhdGUgaXQgdXNpbmcgYW55IGBjaGVja2VkYCBhdHRyaWJ1dGVzIHRoYXRcbiAgXHRcdC8vIGV4aXN0ICh3aGljaCB1c2VycyBzaG91bGQgYXZvaWQsIGJ1dCB3aGljaCB3ZSBzaG91bGRcbiAgXHRcdC8vIHN1cHBvcnQgYW55d2F5IHRvIGF2b2lkIGJyZWFraW5nIGV4cGVjdGF0aW9ucylcbiAgXHRcdHRoaXMubm9Jbml0aWFsVmFsdWUgPSB0cnVlOyAvLyBUT0RPIGFyZSBub0luaXRpYWxWYWx1ZSBhbmQgd2FzVW5kZWZpbmVkIHRoZSBzYW1lIHRoaW5nP1xuICBcdFx0cmV0dXJuIFtdO1xuICBcdH07XG5cbiAgXHRDaGVja2JveE5hbWVCaW5kaW5nLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlJDEgKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZ3JvdXAudmFsdWU7XG4gIFx0fTtcblxuICBcdENoZWNrYm94TmFtZUJpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSAoKSB7XG4gIFx0XHR0aGlzLmlzQ2hlY2tlZCA9IHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG4gIFx0XHR0aGlzLmdyb3VwLnZhbHVlID0gdGhpcy5tb2RlbC5nZXQoKTtcbiAgXHRcdHZhciB2YWx1ZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcbiAgXHRcdGlmICggdGhpcy5pc0NoZWNrZWQgJiYgIWFycmF5Q29udGFpbnMoIHRoaXMuZ3JvdXAudmFsdWUsIHZhbHVlICkgKSB7XG4gIFx0XHRcdHRoaXMuZ3JvdXAudmFsdWUucHVzaCggdmFsdWUgKTtcbiAgXHRcdH0gZWxzZSBpZiAoICF0aGlzLmlzQ2hlY2tlZCAmJiBhcnJheUNvbnRhaW5zKCB0aGlzLmdyb3VwLnZhbHVlLCB2YWx1ZSApICkge1xuICBcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuZ3JvdXAudmFsdWUsIHZhbHVlICk7XG4gIFx0XHR9XG4gIFx0XHQvLyBtYWtlIHN1cmUgc3VwZXIga25vd3MgdGhlcmUncyBhIGNoYW5nZVxuICBcdFx0dGhpcy5sYXN0VmFsdWUgPSBudWxsO1xuICBcdFx0QmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwodGhpcyk7XG4gIFx0fTtcblxuICBcdENoZWNrYm94TmFtZUJpbmRpbmcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gIFx0XHRCaW5kaW5nLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcblxuICBcdFx0dmFyIG5vZGUgPSB0aGlzLm5vZGU7XG5cbiAgXHRcdHZhciBleGlzdGluZ1ZhbHVlID0gdGhpcy5tb2RlbC5nZXQoKTtcbiAgXHRcdHZhciBiaW5kaW5nVmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cbiAgXHRcdGlmICggaXNBcnJheSggZXhpc3RpbmdWYWx1ZSApICkge1xuICBcdFx0XHR0aGlzLmlzQ2hlY2tlZCA9IGFycmF5Q29udGFpbnMoIGV4aXN0aW5nVmFsdWUsIGJpbmRpbmdWYWx1ZSApO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5pc0NoZWNrZWQgPSBleGlzdGluZ1ZhbHVlID09IGJpbmRpbmdWYWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0bm9kZS5uYW1lID0gJ3t7JyArIHRoaXMubW9kZWwuZ2V0S2V5cGF0aCgpICsgJ319JztcbiAgXHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMuaXNDaGVja2VkO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblxuICBcdFx0Ly8gaW4gY2FzZSBvZiBJRSBlbWVyZ2VuY3ksIGJpbmQgdG8gY2xpY2sgZXZlbnQgYXMgd2VsbFxuICBcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuICBcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRDaGVja2JveE5hbWVCaW5kaW5nLnByb3RvdHlwZS5zZXRGcm9tTm9kZSA9IGZ1bmN0aW9uIHNldEZyb21Ob2RlICggbm9kZSApIHtcbiAgXHRcdHRoaXMuZ3JvdXAuYmluZGluZ3MuZm9yRWFjaCggZnVuY3Rpb24gKCBiaW5kaW5nICkgeyByZXR1cm4gYmluZGluZy53YXNVbmRlZmluZWQgPSB0cnVlOyB9ICk7XG5cbiAgXHRcdGlmICggbm9kZS5jaGVja2VkICkge1xuICBcdFx0XHR2YXIgdmFsdWVTb0ZhciA9IHRoaXMuZ3JvdXAuZ2V0VmFsdWUoKTtcbiAgXHRcdFx0dmFsdWVTb0Zhci5wdXNoKCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICkgKTtcblxuICBcdFx0XHR0aGlzLmdyb3VwLm1vZGVsLnNldCggdmFsdWVTb0ZhciApO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRDaGVja2JveE5hbWVCaW5kaW5nLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiB1bmJpbmQgKCkge1xuICBcdFx0dGhpcy5ncm91cC5yZW1vdmUoIHRoaXMgKTtcbiAgXHR9O1xuXG4gIFx0Q2hlY2tib3hOYW1lQmluZGluZy5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiB1bnJlbmRlciAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG4gIFx0fTtcblxuICBcdHJldHVybiBDaGVja2JveE5hbWVCaW5kaW5nO1xuICB9KEJpbmRpbmcpKTtcblxuICB2YXIgQ29udGVudEVkaXRhYmxlQmluZGluZyA9IChmdW5jdGlvbiAoQmluZGluZykge1xuICBcdGZ1bmN0aW9uIENvbnRlbnRFZGl0YWJsZUJpbmRpbmcgKCkge1xuICBcdFx0QmluZGluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBcdH1cblxuICBcdENvbnRlbnRFZGl0YWJsZUJpbmRpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmluZGluZyAmJiBCaW5kaW5nLnByb3RvdHlwZSApO1xuICBcdENvbnRlbnRFZGl0YWJsZUJpbmRpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udGVudEVkaXRhYmxlQmluZGluZztcblxuICBcdENvbnRlbnRFZGl0YWJsZUJpbmRpbmcucHJvdG90eXBlLmdldEluaXRpYWxWYWx1ZSA9IGZ1bmN0aW9uIGdldEluaXRpYWxWYWx1ZSAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmZyYWdtZW50ID8gdGhpcy5lbGVtZW50LmZyYWdtZW50LnRvU3RyaW5nKCkgOiAnJztcbiAgXHR9O1xuXG4gIFx0Q29udGVudEVkaXRhYmxlQmluZGluZy5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuaW5uZXJIVE1MO1xuICBcdH07XG5cbiAgXHRDb250ZW50RWRpdGFibGVCaW5kaW5nLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKCkge1xuICBcdFx0QmluZGluZy5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG5cbiAgXHRcdHZhciBub2RlID0gdGhpcy5ub2RlO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcbiAgXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2JsdXInLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblxuICBcdFx0aWYgKCAhdGhpcy5yYWN0aXZlLmxhenkgKSB7XG4gIFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2lucHV0JywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cbiAgXHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuICBcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0Q29udGVudEVkaXRhYmxlQmluZGluZy5wcm90b3R5cGUuc2V0RnJvbU5vZGUgPSBmdW5jdGlvbiBzZXRGcm9tTm9kZSAoIG5vZGUgKSB7XG4gIFx0XHR0aGlzLm1vZGVsLnNldCggbm9kZS5pbm5lckhUTUwgKTtcbiAgXHR9O1xuXG4gIFx0Q29udGVudEVkaXRhYmxlQmluZGluZy5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiB1bnJlbmRlciAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZTtcblxuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnYmx1cicsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdpbnB1dCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5dXAnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcbiAgXHR9O1xuXG4gIFx0cmV0dXJuIENvbnRlbnRFZGl0YWJsZUJpbmRpbmc7XG4gIH0oQmluZGluZykpO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUJsdXIgKCkge1xuICBcdGhhbmRsZURvbUV2ZW50LmNhbGwoIHRoaXMgKTtcblxuICBcdHZhciB2YWx1ZSA9IHRoaXMuX3JhY3RpdmUuYmluZGluZy5tb2RlbC5nZXQoKTtcbiAgXHR0aGlzLnZhbHVlID0gdmFsdWUgPT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZURlbGF5ICggZGVsYXkgKSB7XG4gIFx0dmFyIHRpbWVvdXQ7XG5cbiAgXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuICBcdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdGlmICggdGltZW91dCApIGNsZWFyVGltZW91dCggdGltZW91dCApO1xuXG4gIFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuICBcdFx0XHR2YXIgYmluZGluZyA9IHRoaXMkMS5fcmFjdGl2ZS5iaW5kaW5nO1xuICBcdFx0XHRpZiAoIGJpbmRpbmcucmVuZGVyZWQgKSBoYW5kbGVEb21FdmVudC5jYWxsKCB0aGlzJDEgKTtcbiAgXHRcdFx0dGltZW91dCA9IG51bGw7XG4gIFx0XHR9LCBkZWxheSApO1xuICBcdH07XG4gIH1cblxuICB2YXIgR2VuZXJpY0JpbmRpbmcgPSAoZnVuY3Rpb24gKEJpbmRpbmcpIHtcbiAgXHRmdW5jdGlvbiBHZW5lcmljQmluZGluZyAoKSB7XG4gIFx0XHRCaW5kaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIFx0fVxuXG4gIFx0R2VuZXJpY0JpbmRpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmluZGluZyAmJiBCaW5kaW5nLnByb3RvdHlwZSApO1xuICBcdEdlbmVyaWNCaW5kaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyaWNCaW5kaW5nO1xuXG4gIFx0R2VuZXJpY0JpbmRpbmcucHJvdG90eXBlLmdldEluaXRpYWxWYWx1ZSA9IGZ1bmN0aW9uIGdldEluaXRpYWxWYWx1ZSAoKSB7XG4gIFx0XHRyZXR1cm4gJyc7XG4gIFx0fTtcblxuICBcdEdlbmVyaWNCaW5kaW5nLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGUudmFsdWU7XG4gIFx0fTtcblxuICBcdEdlbmVyaWNCaW5kaW5nLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKCkge1xuICBcdFx0QmluZGluZy5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG5cbiAgXHRcdC8vIGFueSBsYXp5IHNldHRpbmcgZm9yIHRoaXMgZWxlbWVudCBvdmVycmlkZXMgdGhlIHJvb3RcbiAgXHRcdC8vIGlmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciwgaXQncyBhIHRpbWVvdXRcbiAgXHRcdHZhciBsYXp5ID0gdGhpcy5yYWN0aXZlLmxhenk7XG4gIFx0XHR2YXIgdGltZW91dCA9IGZhbHNlO1xuXG4gIFx0XHRpZiAoICdsYXp5JyBpbiB0aGlzLmVsZW1lbnQgKSB7XG4gIFx0XHRcdGxhenkgPSB0aGlzLmVsZW1lbnQubGF6eTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCBpc051bWVyaWMoIGxhenkgKSApIHtcbiAgXHRcdFx0dGltZW91dCA9ICtsYXp5O1xuICBcdFx0XHRsYXp5ID0gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuaGFuZGxlciA9IHRpbWVvdXQgPyBoYW5kbGVEZWxheSggdGltZW91dCApIDogaGFuZGxlRG9tRXZlbnQ7XG5cbiAgXHRcdHZhciBub2RlID0gdGhpcy5ub2RlO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblxuICBcdFx0aWYgKCAhbGF6eSApIHtcbiAgXHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnaW5wdXQnLCB0aGlzLmhhbmRsZXIsIGZhbHNlICk7XG5cbiAgXHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuICBcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgdGhpcy5oYW5kbGVyLCBmYWxzZSApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2JsdXInLCBoYW5kbGVCbHVyLCBmYWxzZSApO1xuICBcdH07XG5cbiAgXHRHZW5lcmljQmluZGluZy5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiB1bnJlbmRlciAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuICBcdFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuXG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcbiAgXHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2lucHV0JywgdGhpcy5oYW5kbGVyLCBmYWxzZSApO1xuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5dXAnLCB0aGlzLmhhbmRsZXIsIGZhbHNlICk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdibHVyJywgaGFuZGxlQmx1ciwgZmFsc2UgKTtcbiAgXHR9O1xuXG4gIFx0cmV0dXJuIEdlbmVyaWNCaW5kaW5nO1xuICB9KEJpbmRpbmcpKTtcblxuICB2YXIgRmlsZUJpbmRpbmcgPSAoZnVuY3Rpb24gKEdlbmVyaWNCaW5kaW5nKSB7XG4gIFx0ZnVuY3Rpb24gRmlsZUJpbmRpbmcgKCkge1xuICBcdFx0R2VuZXJpY0JpbmRpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXHR9XG5cbiAgXHRGaWxlQmluZGluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW5lcmljQmluZGluZyAmJiBHZW5lcmljQmluZGluZy5wcm90b3R5cGUgKTtcbiAgXHRGaWxlQmluZGluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGaWxlQmluZGluZztcblxuICBcdEZpbGVCaW5kaW5nLnByb3RvdHlwZS5nZXRJbml0aWFsVmFsdWUgPSBmdW5jdGlvbiBnZXRJbml0aWFsVmFsdWUgKCkge1xuICBcdFx0cmV0dXJuIHVuZGVmaW5lZDtcbiAgXHR9O1xuXG4gIFx0RmlsZUJpbmRpbmcucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUgKCkge1xuICBcdFx0cmV0dXJuIHRoaXMubm9kZS5maWxlcztcbiAgXHR9O1xuXG4gIFx0RmlsZUJpbmRpbmcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gIFx0XHR0aGlzLmVsZW1lbnQubGF6eSA9IGZhbHNlO1xuICBcdFx0R2VuZXJpY0JpbmRpbmcucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuICBcdH07XG5cbiAgXHRGaWxlQmluZGluZy5wcm90b3R5cGUuc2V0RnJvbU5vZGUgPSBmdW5jdGlvbiBzZXRGcm9tTm9kZSggbm9kZSApIHtcbiAgXHRcdHRoaXMubW9kZWwuc2V0KCBub2RlLmZpbGVzICk7XG4gIFx0fTtcblxuICBcdHJldHVybiBGaWxlQmluZGluZztcbiAgfShHZW5lcmljQmluZGluZykpO1xuXG4gIGZ1bmN0aW9uIGdldFNlbGVjdGVkT3B0aW9ucyAoIHNlbGVjdCApIHtcbiAgICAgIHJldHVybiBzZWxlY3Quc2VsZWN0ZWRPcHRpb25zXG4gIFx0XHQ/IHRvQXJyYXkoIHNlbGVjdC5zZWxlY3RlZE9wdGlvbnMgKVxuICBcdFx0OiBzZWxlY3Qub3B0aW9uc1xuICBcdFx0XHQ/IHRvQXJyYXkoIHNlbGVjdC5vcHRpb25zICkuZmlsdGVyKCBmdW5jdGlvbiAoIG9wdGlvbiApIHsgcmV0dXJuIG9wdGlvbi5zZWxlY3RlZDsgfSApXG4gIFx0XHRcdDogW107XG4gIH1cblxuICB2YXIgTXVsdGlwbGVTZWxlY3RCaW5kaW5nID0gKGZ1bmN0aW9uIChCaW5kaW5nKSB7XG4gIFx0ZnVuY3Rpb24gTXVsdGlwbGVTZWxlY3RCaW5kaW5nICgpIHtcbiAgXHRcdEJpbmRpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXHR9XG5cbiAgXHRNdWx0aXBsZVNlbGVjdEJpbmRpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmluZGluZyAmJiBCaW5kaW5nLnByb3RvdHlwZSApO1xuICBcdE11bHRpcGxlU2VsZWN0QmluZGluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNdWx0aXBsZVNlbGVjdEJpbmRpbmc7XG5cbiAgXHRNdWx0aXBsZVNlbGVjdEJpbmRpbmcucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gZm9yY2VVcGRhdGUgKCkge1xuICBcdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICBcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuICBcdFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuICBcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTsgfSApO1xuICBcdFx0XHR0aGlzLm1vZGVsLnNldCggdmFsdWUgKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0TXVsdGlwbGVTZWxlY3RCaW5kaW5nLnByb3RvdHlwZS5nZXRJbml0aWFsVmFsdWUgPSBmdW5jdGlvbiBnZXRJbml0aWFsVmFsdWUgKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5vcHRpb25zXG4gIFx0XHRcdC5maWx0ZXIoIGZ1bmN0aW9uICggb3B0aW9uICkgeyByZXR1cm4gb3B0aW9uLmdldEF0dHJpYnV0ZSggJ3NlbGVjdGVkJyApOyB9IClcbiAgXHRcdFx0Lm1hcCggZnVuY3Rpb24gKCBvcHRpb24gKSB7IHJldHVybiBvcHRpb24uZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7IH0gKTtcbiAgXHR9O1xuXG4gIFx0TXVsdGlwbGVTZWxlY3RCaW5kaW5nLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlICgpIHtcbiAgXHRcdHZhciBvcHRpb25zID0gdGhpcy5lbGVtZW50Lm5vZGUub3B0aW9ucztcbiAgXHRcdHZhciBsZW4gPSBvcHRpb25zLmxlbmd0aDtcblxuICBcdFx0dmFyIHNlbGVjdGVkVmFsdWVzID0gW107XG5cbiAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuICBcdFx0XHR2YXIgb3B0aW9uID0gb3B0aW9uc1tpXTtcblxuICBcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCApIHtcbiAgXHRcdFx0XHR2YXIgb3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG4gIFx0XHRcdFx0c2VsZWN0ZWRWYWx1ZXMucHVzaCggb3B0aW9uVmFsdWUgKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gc2VsZWN0ZWRWYWx1ZXM7XG4gIFx0fTtcblxuICBcdE11bHRpcGxlU2VsZWN0QmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlICgpIHtcbiAgXHRcdHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZTtcbiAgXHRcdHZhciBwcmV2aW91c1ZhbHVlID0gYXR0cmlidXRlLmdldFZhbHVlKCk7XG5cbiAgXHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICBcdFx0aWYgKCBwcmV2aW91c1ZhbHVlID09PSB1bmRlZmluZWQgfHwgIWFycmF5Q29udGVudHNNYXRjaCggdmFsdWUsIHByZXZpb3VzVmFsdWUgKSApIHtcbiAgXHRcdFx0QmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwodGhpcyk7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiB0aGlzO1xuICBcdH07XG5cbiAgXHRNdWx0aXBsZVNlbGVjdEJpbmRpbmcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gIFx0XHRCaW5kaW5nLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcblxuICBcdFx0dGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblxuICBcdFx0aWYgKCB0aGlzLm1vZGVsLmdldCgpID09PSB1bmRlZmluZWQgKSB7XG4gIFx0XHRcdC8vIGdldCB2YWx1ZSBmcm9tIERPTSwgaWYgcG9zc2libGVcbiAgXHRcdFx0dGhpcy5oYW5kbGVDaGFuZ2UoKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0TXVsdGlwbGVTZWxlY3RCaW5kaW5nLnByb3RvdHlwZS5zZXRGcm9tTm9kZSA9IGZ1bmN0aW9uIHNldEZyb21Ob2RlICggbm9kZSApIHtcbiAgXHRcdHZhciBzZWxlY3RlZE9wdGlvbnMgPSBnZXRTZWxlY3RlZE9wdGlvbnMoIG5vZGUgKTtcbiAgXHRcdHZhciBpID0gc2VsZWN0ZWRPcHRpb25zLmxlbmd0aDtcbiAgXHRcdHZhciByZXN1bHQgPSBuZXcgQXJyYXkoIGkgKTtcblxuICBcdFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRcdHZhciBvcHRpb24gPSBzZWxlY3RlZE9wdGlvbnNbaV07XG4gIFx0XHRcdHJlc3VsdFtpXSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5tb2RlbC5zZXQoIHJlc3VsdCApO1xuICBcdH07XG5cbiAgXHRNdWx0aXBsZVNlbGVjdEJpbmRpbmcucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUgKCkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKCAnVE9ETyBub3QgaW1wbGVtZW50ZWQgeWV0JyApO1xuICBcdH07XG5cbiAgXHRNdWx0aXBsZVNlbGVjdEJpbmRpbmcucHJvdG90eXBlLnVucmVuZGVyID0gZnVuY3Rpb24gdW5yZW5kZXIgKCkge1xuICBcdFx0dGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcbiAgXHR9O1xuXG4gIFx0TXVsdGlwbGVTZWxlY3RCaW5kaW5nLnByb3RvdHlwZS51cGRhdGVNb2RlbCA9IGZ1bmN0aW9uIHVwZGF0ZU1vZGVsICgpIHtcbiAgXHRcdGlmICggdGhpcy5hdHRyaWJ1dGUudmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhdGhpcy5hdHRyaWJ1dGUudmFsdWUubGVuZ3RoICkge1xuICBcdFx0XHR0aGlzLmtleXBhdGguc2V0KCB0aGlzLmluaXRpYWxWYWx1ZSApO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRyZXR1cm4gTXVsdGlwbGVTZWxlY3RCaW5kaW5nO1xuICB9KEJpbmRpbmcpKTtcblxuICB2YXIgTnVtZXJpY0JpbmRpbmcgPSAoZnVuY3Rpb24gKEdlbmVyaWNCaW5kaW5nKSB7XG4gIFx0ZnVuY3Rpb24gTnVtZXJpY0JpbmRpbmcgKCkge1xuICBcdFx0R2VuZXJpY0JpbmRpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXHR9XG5cbiAgXHROdW1lcmljQmluZGluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW5lcmljQmluZGluZyAmJiBHZW5lcmljQmluZGluZy5wcm90b3R5cGUgKTtcbiAgXHROdW1lcmljQmluZGluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOdW1lcmljQmluZGluZztcblxuICBcdE51bWVyaWNCaW5kaW5nLnByb3RvdHlwZS5nZXRJbml0aWFsVmFsdWUgPSBmdW5jdGlvbiBnZXRJbml0aWFsVmFsdWUgKCkge1xuICBcdFx0cmV0dXJuIHVuZGVmaW5lZDtcbiAgXHR9O1xuXG4gIFx0TnVtZXJpY0JpbmRpbmcucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUgKCkge1xuICBcdFx0dmFyIHZhbHVlID0gcGFyc2VGbG9hdCggdGhpcy5ub2RlLnZhbHVlICk7XG4gIFx0XHRyZXR1cm4gaXNOYU4oIHZhbHVlICkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgXHR9O1xuXG4gIFx0TnVtZXJpY0JpbmRpbmcucHJvdG90eXBlLnNldEZyb21Ob2RlID0gZnVuY3Rpb24gc2V0RnJvbU5vZGUoIG5vZGUgKSB7XG4gIFx0XHR2YXIgdmFsdWUgPSBwYXJzZUZsb2F0KCBub2RlLnZhbHVlICk7XG4gIFx0XHRpZiAoICFpc05hTiggdmFsdWUgKSApIHRoaXMubW9kZWwuc2V0KCB2YWx1ZSApO1xuICBcdH07XG5cbiAgXHRyZXR1cm4gTnVtZXJpY0JpbmRpbmc7XG4gIH0oR2VuZXJpY0JpbmRpbmcpKTtcblxuICB2YXIgc2libGluZ3MgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRTaWJsaW5ncyAoIGhhc2ggKSB7XG4gIFx0cmV0dXJuIHNpYmxpbmdzWyBoYXNoIF0gfHwgKCBzaWJsaW5nc1sgaGFzaCBdID0gW10gKTtcbiAgfVxuXG4gIHZhciBSYWRpb0JpbmRpbmcgPSAoZnVuY3Rpb24gKEJpbmRpbmcpIHtcbiAgXHRmdW5jdGlvbiBSYWRpb0JpbmRpbmcgKCBlbGVtZW50ICkge1xuICBcdFx0QmluZGluZy5jYWxsKCB0aGlzLCBlbGVtZW50LCAnY2hlY2tlZCcgKTtcblxuICBcdFx0dGhpcy5zaWJsaW5ncyA9IGdldFNpYmxpbmdzKCB0aGlzLnJhY3RpdmUuX2d1aWQgKyB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbmFtZScgKSApO1xuICBcdFx0dGhpcy5zaWJsaW5ncy5wdXNoKCB0aGlzICk7XG4gIFx0fVxuXG4gIFx0UmFkaW9CaW5kaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJpbmRpbmcgJiYgQmluZGluZy5wcm90b3R5cGUgKTtcbiAgXHRSYWRpb0JpbmRpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFkaW9CaW5kaW5nO1xuXG4gIFx0UmFkaW9CaW5kaW5nLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGUuY2hlY2tlZDtcbiAgXHR9O1xuXG4gIFx0UmFkaW9CaW5kaW5nLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UgKCkge1xuICBcdFx0cnVubG9vcC5zdGFydCggdGhpcy5yb290ICk7XG5cbiAgXHRcdHRoaXMuc2libGluZ3MuZm9yRWFjaCggZnVuY3Rpb24gKCBiaW5kaW5nICkge1xuICBcdFx0XHRiaW5kaW5nLm1vZGVsLnNldCggYmluZGluZy5nZXRWYWx1ZSgpICk7XG4gIFx0XHR9KTtcblxuICBcdFx0cnVubG9vcC5lbmQoKTtcbiAgXHR9O1xuXG4gIFx0UmFkaW9CaW5kaW5nLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKCkge1xuICBcdFx0QmluZGluZy5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG5cbiAgXHRcdHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cbiAgXHRcdGlmICggdGhpcy5ub2RlLmF0dGFjaEV2ZW50ICkge1xuICBcdFx0XHR0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdFJhZGlvQmluZGluZy5wcm90b3R5cGUuc2V0RnJvbU5vZGUgPSBmdW5jdGlvbiBzZXRGcm9tTm9kZSAoIG5vZGUgKSB7XG4gIFx0XHR0aGlzLm1vZGVsLnNldCggbm9kZS5jaGVja2VkICk7XG4gIFx0fTtcblxuICBcdFJhZGlvQmluZGluZy5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gdW5iaW5kICgpIHtcbiAgXHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5zaWJsaW5ncywgdGhpcyApO1xuICBcdH07XG5cbiAgXHRSYWRpb0JpbmRpbmcucHJvdG90eXBlLnVucmVuZGVyID0gZnVuY3Rpb24gdW5yZW5kZXIgKCkge1xuICBcdFx0dGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcbiAgXHRcdHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcbiAgXHR9O1xuXG4gIFx0cmV0dXJuIFJhZGlvQmluZGluZztcbiAgfShCaW5kaW5nKSk7XG5cbiAgZnVuY3Rpb24gZ2V0VmFsdWUkMSgpIHtcbiAgXHR2YXIgY2hlY2tlZCA9IHRoaXMuYmluZGluZ3MuZmlsdGVyKCBmdW5jdGlvbiAoIGIgKSB7IHJldHVybiBiLm5vZGUuY2hlY2tlZDsgfSApO1xuICBcdGlmICggY2hlY2tlZC5sZW5ndGggPiAwICkge1xuICBcdFx0cmV0dXJuIGNoZWNrZWRbMF0uZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcbiAgXHR9XG4gIH1cblxuICB2YXIgUmFkaW9OYW1lQmluZGluZyA9IChmdW5jdGlvbiAoQmluZGluZykge1xuICBcdGZ1bmN0aW9uIFJhZGlvTmFtZUJpbmRpbmcgKCBlbGVtZW50ICkge1xuICBcdFx0QmluZGluZy5jYWxsKCB0aGlzLCBlbGVtZW50LCAnbmFtZScgKTtcblxuICBcdFx0dGhpcy5ncm91cCA9IGdldEJpbmRpbmdHcm91cCggJ3JhZGlvbmFtZScsIHRoaXMubW9kZWwsIGdldFZhbHVlJDEgKTtcbiAgXHRcdHRoaXMuZ3JvdXAuYWRkKCB0aGlzICk7XG5cbiAgXHRcdGlmICggZWxlbWVudC5jaGVja2VkICkge1xuICBcdFx0XHR0aGlzLmdyb3VwLnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICBcdFx0fVxuICBcdH1cblxuICBcdFJhZGlvTmFtZUJpbmRpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmluZGluZyAmJiBCaW5kaW5nLnByb3RvdHlwZSApO1xuICBcdFJhZGlvTmFtZUJpbmRpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFkaW9OYW1lQmluZGluZztcblxuICBcdFJhZGlvTmFtZUJpbmRpbmcucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiBiaW5kICgpIHtcbiAgXHRcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHRpZiAoICF0aGlzLmdyb3VwLmJvdW5kICkge1xuICBcdFx0XHR0aGlzLmdyb3VwLmJpbmQoKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gdXBkYXRlIG5hbWUga2V5cGF0aCB3aGVuIG5lY2Vzc2FyeVxuICBcdFx0dGhpcy5uYW1lQXR0cmlidXRlQmluZGluZyA9IHtcbiAgXHRcdFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEubm9kZS5uYW1lID0gXCJ7e1wiICsgKHRoaXMkMS5tb2RlbC5nZXRLZXlwYXRoKCkpICsgXCJ9fVwiOyB9XG4gIFx0XHR9O1xuXG4gIFx0XHR0aGlzLm1vZGVsLmdldEtleXBhdGhNb2RlbCgpLnJlZ2lzdGVyKCB0aGlzLm5hbWVBdHRyaWJ1dGVCaW5kaW5nICk7XG4gIFx0fTtcblxuICBcdFJhZGlvTmFtZUJpbmRpbmcucHJvdG90eXBlLmdldEluaXRpYWxWYWx1ZSA9IGZ1bmN0aW9uIGdldEluaXRpYWxWYWx1ZSAoKSB7XG4gIFx0XHRpZiAoIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdjaGVja2VkJyApICkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRSYWRpb05hbWVCaW5kaW5nLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlJDEgKCkge1xuICBcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcbiAgXHR9O1xuXG4gIFx0UmFkaW9OYW1lQmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlICgpIHtcbiAgXHRcdC8vIElmIHRoaXMgPGlucHV0PiBpcyB0aGUgb25lIHRoYXQncyBjaGVja2VkLCB0aGVuIHRoZSB2YWx1ZSBvZiBpdHNcbiAgXHRcdC8vIGBuYW1lYCBtb2RlbCBnZXRzIHNldCB0byBpdHMgdmFsdWVcbiAgXHRcdGlmICggdGhpcy5ub2RlLmNoZWNrZWQgKSB7XG4gIFx0XHRcdHRoaXMuZ3JvdXAudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gIFx0XHRcdEJpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZS5jYWxsKHRoaXMpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRSYWRpb05hbWVCaW5kaW5nLnByb3RvdHlwZS5sYXN0VmFsID0gZnVuY3Rpb24gbGFzdFZhbCAoIHNldHRpbmcsIHZhbHVlICkge1xuICBcdFx0aWYgKCAhdGhpcy5ncm91cCApIHJldHVybjtcbiAgXHRcdGlmICggc2V0dGluZyApIHRoaXMuZ3JvdXAubGFzdFZhbHVlID0gdmFsdWU7XG4gIFx0XHRlbHNlIHJldHVybiB0aGlzLmdyb3VwLmxhc3RWYWx1ZTtcbiAgXHR9O1xuXG4gIFx0UmFkaW9OYW1lQmluZGluZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgXHRcdEJpbmRpbmcucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuXG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZTtcblxuICBcdFx0bm9kZS5uYW1lID0gXCJ7e1wiICsgKHRoaXMubW9kZWwuZ2V0S2V5cGF0aCgpKSArIFwifX1cIjtcbiAgXHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMubW9kZWwuZ2V0KCkgPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXG4gIFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblxuICBcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuICBcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRSYWRpb05hbWVCaW5kaW5nLnByb3RvdHlwZS5zZXRGcm9tTm9kZSA9IGZ1bmN0aW9uIHNldEZyb21Ob2RlICggbm9kZSApIHtcbiAgXHRcdGlmICggbm9kZS5jaGVja2VkICkge1xuICBcdFx0XHR0aGlzLmdyb3VwLm1vZGVsLnNldCggdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApICk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdFJhZGlvTmFtZUJpbmRpbmcucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uIHVuYmluZCAoKSB7XG4gIFx0XHR0aGlzLmdyb3VwLnJlbW92ZSggdGhpcyApO1xuXG4gIFx0XHR0aGlzLm1vZGVsLmdldEtleXBhdGhNb2RlbCgpLnVucmVnaXN0ZXIoIHRoaXMubmFtZUF0dHJpYnV0ZUJpbmRpbmcgKTtcbiAgXHR9O1xuXG4gIFx0UmFkaW9OYW1lQmluZGluZy5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiB1bnJlbmRlciAoKSB7XG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZTtcblxuICBcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG4gIFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuICBcdH07XG5cbiAgXHRyZXR1cm4gUmFkaW9OYW1lQmluZGluZztcbiAgfShCaW5kaW5nKSk7XG5cbiAgdmFyIFNpbmdsZVNlbGVjdEJpbmRpbmcgPSAoZnVuY3Rpb24gKEJpbmRpbmcpIHtcbiAgXHRmdW5jdGlvbiBTaW5nbGVTZWxlY3RCaW5kaW5nICgpIHtcbiAgXHRcdEJpbmRpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXHR9XG5cbiAgXHRTaW5nbGVTZWxlY3RCaW5kaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJpbmRpbmcgJiYgQmluZGluZy5wcm90b3R5cGUgKTtcbiAgXHRTaW5nbGVTZWxlY3RCaW5kaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNpbmdsZVNlbGVjdEJpbmRpbmc7XG5cbiAgXHRTaW5nbGVTZWxlY3RCaW5kaW5nLnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIGZvcmNlVXBkYXRlICgpIHtcbiAgXHRcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cbiAgXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcbiAgXHRcdFx0dGhpcy5hdHRyaWJ1dGUubG9ja2VkID0gdHJ1ZTtcbiAgXHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7IH0gKTtcbiAgXHRcdFx0dGhpcy5tb2RlbC5zZXQoIHZhbHVlICk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdFNpbmdsZVNlbGVjdEJpbmRpbmcucHJvdG90eXBlLmdldEluaXRpYWxWYWx1ZSA9IGZ1bmN0aW9uIGdldEluaXRpYWxWYWx1ZSAoKSB7XG4gIFx0XHRpZiAoIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKSAhPT0gdW5kZWZpbmVkICkge1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBvcHRpb25zID0gdGhpcy5lbGVtZW50Lm9wdGlvbnM7XG4gIFx0XHR2YXIgbGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHRcdGlmICggIWxlbiApIHJldHVybjtcblxuICBcdFx0dmFyIHZhbHVlO1xuICBcdFx0dmFyIG9wdGlvbldhc1NlbGVjdGVkO1xuICBcdFx0dmFyIGkgPSBsZW47XG5cbiAgXHRcdC8vIHRha2UgdGhlIGZpbmFsIHNlbGVjdGVkIG9wdGlvbi4uLlxuICBcdFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRcdHZhciBvcHRpb24gPSBvcHRpb25zW2ldO1xuXG4gIFx0XHRcdGlmICggb3B0aW9uLmdldEF0dHJpYnV0ZSggJ3NlbGVjdGVkJyApICkge1xuICBcdFx0XHRcdGlmICggIW9wdGlvbi5nZXRBdHRyaWJ1dGUoICdkaXNhYmxlZCcgKSApIHtcbiAgXHRcdFx0XHRcdHZhbHVlID0gb3B0aW9uLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdG9wdGlvbldhc1NlbGVjdGVkID0gdHJ1ZTtcbiAgXHRcdFx0XHRicmVhaztcbiAgXHRcdFx0fVxuICBcdFx0fVxuXG4gIFx0XHQvLyBvciB0aGUgZmlyc3Qgbm9uLWRpc2FibGVkIG9wdGlvbiwgaWYgbm9uZSBhcmUgc2VsZWN0ZWRcbiAgXHRcdGlmICggIW9wdGlvbldhc1NlbGVjdGVkICkge1xuICBcdFx0XHR3aGlsZSAoICsraSA8IGxlbiApIHtcbiAgXHRcdFx0XHRpZiAoICFvcHRpb25zW2ldLmdldEF0dHJpYnV0ZSggJ2Rpc2FibGVkJyApICkge1xuICBcdFx0XHRcdFx0dmFsdWUgPSBvcHRpb25zW2ldLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuICBcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFRoaXMgaXMgYW4gb3B0aW1pc2F0aW9uIChha2EgaGFjaykgdGhhdCBhbGxvd3MgdXMgdG8gZm9yZ28gc29tZVxuICBcdFx0Ly8gb3RoZXIgbW9yZSBleHBlbnNpdmUgd29ya1xuICBcdFx0Ly8gVE9ETyBkb2VzIGl0IHN0aWxsIHdvcms/IHNlZW1zIGF0IG9kZHMgd2l0aCBuZXcgYXJjaGl0ZWN0dXJlXG4gIFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG4gIFx0XHRcdHRoaXMuZWxlbWVudC5hdHRyaWJ1dGVCeU5hbWUudmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIHZhbHVlO1xuICBcdH07XG5cbiAgXHRTaW5nbGVTZWxlY3RCaW5kaW5nLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlICgpIHtcbiAgXHRcdHZhciBvcHRpb25zID0gdGhpcy5ub2RlLm9wdGlvbnM7XG4gIFx0XHR2YXIgbGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cbiAgXHRcdHZhciBpO1xuICBcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcbiAgXHRcdFx0dmFyIG9wdGlvbiA9IG9wdGlvbnNbaV07XG5cbiAgXHRcdFx0aWYgKCBvcHRpb25zW2ldLnNlbGVjdGVkICYmICFvcHRpb25zW2ldLmRpc2FibGVkICkge1xuICBcdFx0XHRcdHJldHVybiBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0U2luZ2xlU2VsZWN0QmluZGluZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgXHRcdEJpbmRpbmcucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMpO1xuICBcdFx0dGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcbiAgXHR9O1xuXG4gIFx0U2luZ2xlU2VsZWN0QmluZGluZy5wcm90b3R5cGUuc2V0RnJvbU5vZGUgPSBmdW5jdGlvbiBzZXRGcm9tTm9kZSAoIG5vZGUgKSB7XG4gIFx0XHR2YXIgb3B0aW9uID0gZ2V0U2VsZWN0ZWRPcHRpb25zKCBub2RlIClbMF07XG4gIFx0XHR0aGlzLm1vZGVsLnNldCggb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlICk7XG4gIFx0fTtcblxuICBcdC8vIFRPRE8gdGhpcyBtZXRob2QgaXMgYW4gYW5vbWFseS4uLiBpcyBpdCBuZWNlc3Nhcnk/XG4gIFx0U2luZ2xlU2VsZWN0QmluZGluZy5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiBzZXRWYWx1ZSAoIHZhbHVlICkge1xuICBcdFx0dGhpcy5tb2RlbC5zZXQoIHZhbHVlICk7XG4gIFx0fTtcblxuICBcdFNpbmdsZVNlbGVjdEJpbmRpbmcucHJvdG90eXBlLnVucmVuZGVyID0gZnVuY3Rpb24gdW5yZW5kZXIgKCkge1xuICBcdFx0dGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcbiAgXHR9O1xuXG4gIFx0cmV0dXJuIFNpbmdsZVNlbGVjdEJpbmRpbmc7XG4gIH0oQmluZGluZykpO1xuXG4gIGZ1bmN0aW9uIGlzQmluZGFibGUgKCBhdHRyaWJ1dGUgKSB7XG4gIFx0cmV0dXJuIGF0dHJpYnV0ZSAmJlxuICBcdFx0ICAgYXR0cmlidXRlLnRlbXBsYXRlLmYgJiZcbiAgXHQgICAgICAgYXR0cmlidXRlLnRlbXBsYXRlLmYubGVuZ3RoID09PSAxICYmXG4gIFx0ICAgICAgIGF0dHJpYnV0ZS50ZW1wbGF0ZS5mWzBdLnQgPT09IElOVEVSUE9MQVRPUiAmJlxuICBcdCAgICAgICAhYXR0cmlidXRlLnRlbXBsYXRlLmZbMF0ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdEJpbmRpbmcgKCBlbGVtZW50ICkge1xuICBcdHZhciBhdHRyaWJ1dGVzID0gZWxlbWVudC5hdHRyaWJ1dGVCeU5hbWU7XG5cbiAgXHQvLyBjb250ZW50ZWRpdGFibGUgLSBiaW5kIGlmIHRoZSBjb250ZW50ZWRpdGFibGUgYXR0cmlidXRlIGlzIHRydWVcbiAgXHQvLyBvciBpcyBiaW5kYWJsZSBhbmQgbWF5IHRodXMgYmVjb21lIHRydWUuLi5cbiAgXHRpZiAoIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnY29udGVudGVkaXRhYmxlJyApIHx8IGlzQmluZGFibGUoIGF0dHJpYnV0ZXMuY29udGVudGVkaXRhYmxlICkgKSB7XG4gIFx0XHQvLyAuLi5hbmQgdGhpcyBlbGVtZW50IGFsc28gaGFzIGEgdmFsdWUgYXR0cmlidXRlIHRvIGJpbmRcbiAgXHRcdHJldHVybiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgPyBDb250ZW50RWRpdGFibGVCaW5kaW5nIDogbnVsbDtcbiAgXHR9XG5cbiAgXHQvLyA8aW5wdXQ+XG4gIFx0aWYgKCBlbGVtZW50Lm5hbWUgPT09ICdpbnB1dCcgKSB7XG4gIFx0XHR2YXIgdHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndHlwZScgKTtcblxuICBcdFx0aWYgKCB0eXBlID09PSAncmFkaW8nIHx8IHR5cGUgPT09ICdjaGVja2JveCcgKSB7XG4gIFx0XHRcdHZhciBiaW5kTmFtZSA9IGlzQmluZGFibGUoIGF0dHJpYnV0ZXMubmFtZSApO1xuICBcdFx0XHR2YXIgYmluZENoZWNrZWQgPSBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLmNoZWNrZWQgKTtcblxuICBcdFx0XHQvLyBmb3IgcmFkaW9zIHdlIGNhbiBlaXRoZXIgYmluZCB0aGUgbmFtZSBhdHRyaWJ1dGUsIG9yIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSAtIG5vdCBib3RoXG4gIFx0XHRcdGlmICggYmluZE5hbWUgJiYgYmluZENoZWNrZWQgKSB7XG4gIFx0XHRcdFx0aWYgKCB0eXBlID09PSAncmFkaW8nICkge1xuICBcdFx0XHRcdFx0d2FybklmRGVidWcoICdBIHJhZGlvIGlucHV0IGNhbiBoYXZlIHR3by13YXkgYmluZGluZyBvbiBpdHMgbmFtZSBhdHRyaWJ1dGUsIG9yIGl0cyBjaGVja2VkIGF0dHJpYnV0ZSAtIG5vdCBib3RoJywgeyByYWN0aXZlOiBlbGVtZW50LnJvb3QgfSk7XG4gIFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdC8vIEEgY2hlY2tib3ggd2l0aCBiaW5kaW5ncyBmb3IgYm90aCBuYW1lIGFuZCBjaGVja2VkIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMvMTc0OVxuICBcdFx0XHRcdFx0cmV0dXJuIENoZWNrYm94QmluZGluZztcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIGJpbmROYW1lICkge1xuICBcdFx0XHRcdHJldHVybiB0eXBlID09PSAncmFkaW8nID8gUmFkaW9OYW1lQmluZGluZyA6IENoZWNrYm94TmFtZUJpbmRpbmc7XG4gIFx0XHRcdH1cblxuICBcdFx0XHRpZiAoIGJpbmRDaGVja2VkICkge1xuICBcdFx0XHRcdHJldHVybiB0eXBlID09PSAncmFkaW8nID8gUmFkaW9CaW5kaW5nIDogQ2hlY2tib3hCaW5kaW5nO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGlmICggdHlwZSA9PT0gJ2ZpbGUnICYmIGlzQmluZGFibGUoIGF0dHJpYnV0ZXMudmFsdWUgKSApIHtcbiAgXHRcdFx0cmV0dXJuIEZpbGVCaW5kaW5nO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIGlzQmluZGFibGUoIGF0dHJpYnV0ZXMudmFsdWUgKSApIHtcbiAgXHRcdFx0cmV0dXJuICggdHlwZSA9PT0gJ251bWJlcicgfHwgdHlwZSA9PT0gJ3JhbmdlJyApID8gTnVtZXJpY0JpbmRpbmcgOiBHZW5lcmljQmluZGluZztcbiAgXHRcdH1cblxuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fVxuXG4gIFx0Ly8gPHNlbGVjdD5cbiAgXHRpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ3NlbGVjdCcgJiYgaXNCaW5kYWJsZSggYXR0cmlidXRlcy52YWx1ZSApICkge1xuICBcdFx0cmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbXVsdGlwbGUnICkgPyBNdWx0aXBsZVNlbGVjdEJpbmRpbmcgOiBTaW5nbGVTZWxlY3RCaW5kaW5nO1xuICBcdH1cblxuICBcdC8vIDx0ZXh0YXJlYT5cbiAgXHRpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ3RleHRhcmVhJyAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG4gIFx0XHRyZXR1cm4gR2VuZXJpY0JpbmRpbmc7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gbWFrZURpcnR5JDEgKCBxdWVyeSApIHtcbiAgXHRxdWVyeS5tYWtlRGlydHkoKTtcbiAgfVxuXG4gIHZhciBlbmRzV2l0aFNlbWkgPSAvO1xccyokLztcblxuICB2YXIgRWxlbWVudCA9IChmdW5jdGlvbiAoSXRlbSkge1xuICBcdGZ1bmN0aW9uIEVsZW1lbnQgKCBvcHRpb25zICkge1xuICBcdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdEl0ZW0uY2FsbCggdGhpcywgb3B0aW9ucyApO1xuXG4gIFx0XHR0aGlzLmxpdmVRdWVyaWVzID0gW107IC8vIFRPRE8gcmFyZSBjYXNlLiBjYW4gd2UgaGFuZGxlIGRpZmZlcmVudGx5P1xuXG4gIFx0XHR0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLmUudG9Mb3dlckNhc2UoKTtcbiAgXHRcdHRoaXMuaXNWb2lkID0gdm9pZEVsZW1lbnROYW1lcy50ZXN0KCB0aGlzLm5hbWUgKTtcblxuICBcdFx0Ly8gZmluZCBwYXJlbnQgZWxlbWVudFxuICBcdFx0dGhpcy5wYXJlbnQgPSBmaW5kRWxlbWVudCggdGhpcy5wYXJlbnRGcmFnbWVudCwgZmFsc2UgKTtcblxuICBcdFx0aWYgKCB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5uYW1lID09PSAnb3B0aW9uJyApIHtcbiAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAoXCJBbiA8b3B0aW9uPiBlbGVtZW50IGNhbm5vdCBjb250YWluIG90aGVyIGVsZW1lbnRzIChlbmNvdW50ZXJlZCA8XCIgKyAodGhpcy5uYW1lKSArIFwiPilcIikgKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5kZWNvcmF0b3JzID0gW107XG5cbiAgXHRcdC8vIGNyZWF0ZSBhdHRyaWJ1dGVzXG4gIFx0XHR0aGlzLmF0dHJpYnV0ZUJ5TmFtZSA9IHt9O1xuXG4gIFx0XHR0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcbiAgXHRcdHZhciBsZWZ0b3ZlcnMgPSBbXTtcbiAgXHRcdCggdGhpcy50ZW1wbGF0ZS5tIHx8IFtdICkuZm9yRWFjaCggZnVuY3Rpb24gKCB0ZW1wbGF0ZSApIHtcbiAgXHRcdFx0c3dpdGNoICggdGVtcGxhdGUudCApIHtcbiAgXHRcdFx0XHRjYXNlIEFUVFJJQlVURTpcbiAgXHRcdFx0XHRjYXNlIEJJTkRJTkdfRkxBRzpcbiAgXHRcdFx0XHRjYXNlIERFQ09SQVRPUjpcbiAgXHRcdFx0XHRjYXNlIEVWRU5UOlxuICBcdFx0XHRcdGNhc2UgVFJBTlNJVElPTjpcbiAgXHRcdFx0XHRcdHRoaXMkMS5hdHRyaWJ1dGVzLnB1c2goIGNyZWF0ZUl0ZW0oe1xuICBcdFx0XHRcdFx0XHRvd25lcjogdGhpcyQxLFxuICBcdFx0XHRcdFx0XHRwYXJlbnRGcmFnbWVudDogdGhpcyQxLnBhcmVudEZyYWdtZW50LFxuICBcdFx0XHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGVcbiAgXHRcdFx0XHRcdH0pICk7XG4gIFx0XHRcdFx0XHRicmVhaztcblxuICBcdFx0XHRcdGRlZmF1bHQ6XG4gIFx0XHRcdFx0XHRsZWZ0b3ZlcnMucHVzaCggdGVtcGxhdGUgKTtcbiAgXHRcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHR9XG4gIFx0XHR9KTtcblxuICBcdFx0aWYgKCBsZWZ0b3ZlcnMubGVuZ3RoICkge1xuICBcdFx0XHR0aGlzLmF0dHJpYnV0ZXMucHVzaCggbmV3IENvbmRpdGlvbmFsQXR0cmlidXRlKHtcbiAgXHRcdFx0XHRvd25lcjogdGhpcyxcbiAgXHRcdFx0XHRwYXJlbnRGcmFnbWVudDogdGhpcy5wYXJlbnRGcmFnbWVudCxcbiAgXHRcdFx0XHR0ZW1wbGF0ZTogbGVmdG92ZXJzXG4gIFx0XHRcdH0pICk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBpID0gdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aDtcbiAgXHRcdHdoaWxlICggaS0tICkge1xuICBcdFx0XHR2YXIgYXR0ciA9IHRoaXMkMS5hdHRyaWJ1dGVzWyBpIF07XG4gIFx0XHRcdGlmICggYXR0ci5uYW1lID09PSAndHlwZScgKSB0aGlzJDEuYXR0cmlidXRlcy51bnNoaWZ0KCB0aGlzJDEuYXR0cmlidXRlcy5zcGxpY2UoIGksIDEgKVsgMCBdICk7XG4gIFx0XHRcdGVsc2UgaWYgKCBhdHRyLm5hbWUgPT09ICdtYXgnICkgdGhpcyQxLmF0dHJpYnV0ZXMudW5zaGlmdCggdGhpcyQxLmF0dHJpYnV0ZXMuc3BsaWNlKCBpLCAxIClbIDAgXSApO1xuICBcdFx0XHRlbHNlIGlmICggYXR0ci5uYW1lID09PSAnbWluJyApIHRoaXMkMS5hdHRyaWJ1dGVzLnVuc2hpZnQoIHRoaXMkMS5hdHRyaWJ1dGVzLnNwbGljZSggaSwgMSApWyAwIF0gKTtcbiAgXHRcdFx0ZWxzZSBpZiAoIGF0dHIubmFtZSA9PT0gJ2NsYXNzJyApIHRoaXMkMS5hdHRyaWJ1dGVzLnVuc2hpZnQoIHRoaXMkMS5hdHRyaWJ1dGVzLnNwbGljZSggaSwgMSApWyAwIF0gKTtcbiAgXHRcdFx0ZWxzZSBpZiAoIGF0dHIubmFtZSA9PT0gJ3ZhbHVlJyApIHtcbiAgXHRcdFx0XHR0aGlzJDEuYXR0cmlidXRlcy5wdXNoKCB0aGlzJDEuYXR0cmlidXRlcy5zcGxpY2UoIGksIDEgKVsgMCBdICk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gY3JlYXRlIGNoaWxkcmVuXG4gIFx0XHRpZiAoIG9wdGlvbnMudGVtcGxhdGUuZiAmJiAhb3B0aW9ucy5kZWZlckNvbnRlbnQgKSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoe1xuICBcdFx0XHRcdHRlbXBsYXRlOiBvcHRpb25zLnRlbXBsYXRlLmYsXG4gIFx0XHRcdFx0b3duZXI6IHRoaXMsXG4gIFx0XHRcdFx0Y3NzSWRzOiBudWxsXG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmJpbmRpbmcgPSBudWxsOyAvLyBmaWxsZWQgaW4gbGF0ZXJcbiAgXHR9XG5cbiAgXHRFbGVtZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEl0ZW0gJiYgSXRlbS5wcm90b3R5cGUgKTtcbiAgXHRFbGVtZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVsZW1lbnQ7XG5cbiAgXHRFbGVtZW50LnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gYmluZCQxJCQgKCkge1xuICBcdFx0dGhpcy5hdHRyaWJ1dGVzLmJpbmRpbmcgPSB0cnVlO1xuICBcdFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2goIGJpbmQkMSApO1xuICBcdFx0dGhpcy5hdHRyaWJ1dGVzLmJpbmRpbmcgPSBmYWxzZTtcblxuICBcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkgdGhpcy5mcmFnbWVudC5iaW5kKCk7XG5cbiAgXHRcdC8vIGNyZWF0ZSB0d28td2F5IGJpbmRpbmcgaWYgbmVjZXNzYXJ5XG4gIFx0XHRpZiAoICF0aGlzLmJpbmRpbmcgKSB0aGlzLnJlY3JlYXRlVHdvd2F5QmluZGluZygpO1xuICBcdH07XG5cbiAgXHRFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVUd293YXlCaW5kaW5nID0gZnVuY3Rpb24gY3JlYXRlVHdvd2F5QmluZGluZyAoKSB7XG4gIFx0XHR2YXIgc2hvdWxkQmluZCA9ICd0d293YXknIGluIHRoaXMgPyB0aGlzLnR3b3dheSA6IHRoaXMucmFjdGl2ZS50d293YXk7XG5cbiAgXHRcdGlmICggIXNob3VsZEJpbmQgKSByZXR1cm4gbnVsbDtcblxuICBcdFx0dmFyIEJpbmRpbmcgPSBzZWxlY3RCaW5kaW5nKCB0aGlzICk7XG5cbiAgXHRcdGlmICggIUJpbmRpbmcgKSByZXR1cm4gbnVsbDtcblxuICBcdFx0dmFyIGJpbmRpbmcgPSBuZXcgQmluZGluZyggdGhpcyApO1xuXG4gIFx0XHRyZXR1cm4gYmluZGluZyAmJiBiaW5kaW5nLm1vZGVsID9cbiAgXHRcdFx0YmluZGluZyA6XG4gIFx0XHRcdG51bGw7XG4gIFx0fTtcblxuICBcdEVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3llZCA9IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gIFx0XHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaCggZnVuY3Rpb24gKCBhICkgeyByZXR1cm4gYS5kZXN0cm95ZWQoKTsgfSApO1xuICBcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkgdGhpcy5mcmFnbWVudC5kZXN0cm95ZWQoKTtcbiAgXHR9O1xuXG4gIFx0RWxlbWVudC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gZGV0YWNoICgpIHtcbiAgXHRcdC8vIGlmIHRoaXMgZWxlbWVudCBpcyBubyBsb25nZXIgcmVuZGVyZWQsIHRoZSB0cmFuc2l0aW9ucyBhcmUgY29tcGxldGUgYW5kIHRoZSBhdHRyaWJ1dGVzIGNhbiBiZSB0b3JuIGRvd25cbiAgXHRcdGlmICggIXRoaXMucmVuZGVyZWQgKSB0aGlzLmRlc3Ryb3llZCgpO1xuXG4gIFx0XHRyZXR1cm4gZGV0YWNoTm9kZSggdGhpcy5ub2RlICk7XG4gIFx0fTtcblxuICBcdEVsZW1lbnQucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiBmaW5kICggc2VsZWN0b3IgKSB7XG4gIFx0XHRpZiAoIG1hdGNoZXMoIHRoaXMubm9kZSwgc2VsZWN0b3IgKSApIHJldHVybiB0aGlzLm5vZGU7XG4gIFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdEVsZW1lbnQucHJvdG90eXBlLmZpbmRBbGwgPSBmdW5jdGlvbiBmaW5kQWxsICggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuICBcdFx0Ly8gQWRkIHRoaXMgbm9kZSB0byB0aGUgcXVlcnksIGlmIGFwcGxpY2FibGUsIGFuZCByZWdpc3RlciB0aGVcbiAgXHRcdC8vIHF1ZXJ5IG9uIHRoaXMgZWxlbWVudFxuICBcdFx0dmFyIG1hdGNoZXMgPSBxdWVyeS50ZXN0KCB0aGlzLm5vZGUgKTtcbiAgXHRcdGlmICggbWF0Y2hlcyApIHtcbiAgXHRcdFx0cXVlcnkuYWRkKCB0aGlzLm5vZGUgKTtcbiAgXHRcdFx0aWYgKCBxdWVyeS5saXZlICkgdGhpcy5saXZlUXVlcmllcy5wdXNoKCBxdWVyeSApO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQuZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdEVsZW1lbnQucHJvdG90eXBlLmZpbmRDb21wb25lbnQgPSBmdW5jdGlvbiBmaW5kQ29tcG9uZW50ICggbmFtZSApIHtcbiAgXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcbiAgXHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudCggbmFtZSApO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRFbGVtZW50LnByb3RvdHlwZS5maW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGZpbmRBbGxDb21wb25lbnRzICggbmFtZSwgcXVlcnkgKSB7XG4gIFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoIG5hbWUsIHF1ZXJ5ICk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdEVsZW1lbnQucHJvdG90eXBlLmZpbmROZXh0Tm9kZSA9IGZ1bmN0aW9uIGZpbmROZXh0Tm9kZSAoKSB7XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9O1xuXG4gIFx0RWxlbWVudC5wcm90b3R5cGUuZmlyc3ROb2RlID0gZnVuY3Rpb24gZmlyc3ROb2RlICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fTtcblxuICBcdEVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZSAoIG5hbWUgKSB7XG4gIFx0XHR2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVCeU5hbWVbIG5hbWUgXTtcbiAgXHRcdHJldHVybiBhdHRyaWJ1dGUgPyBhdHRyaWJ1dGUuZ2V0VmFsdWUoKSA6IHVuZGVmaW5lZDtcbiAgXHR9O1xuXG4gIFx0RWxlbWVudC5wcm90b3R5cGUucmVjcmVhdGVUd293YXlCaW5kaW5nID0gZnVuY3Rpb24gcmVjcmVhdGVUd293YXlCaW5kaW5nICgpIHtcbiAgXHRcdGlmICggdGhpcy5iaW5kaW5nICkge1xuICBcdFx0XHR0aGlzLmJpbmRpbmcudW5iaW5kKCk7XG4gIFx0XHRcdHRoaXMuYmluZGluZy51bnJlbmRlcigpO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIHRoaXMuYmluZGluZyA9IHRoaXMuY3JlYXRlVHdvd2F5QmluZGluZygpICkge1xuICBcdFx0XHR0aGlzLmJpbmRpbmcuYmluZCgpO1xuICBcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB0aGlzLmJpbmRpbmcucmVuZGVyKCk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdEVsZW1lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciQxICggdGFyZ2V0LCBvY2N1cGFudHMgKSB7XG4gIFx0XHQvLyBUT0RPIGRldGVybWluZSBjb3JyZWN0IG5hbWVzcGFjZVxuICBcdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHRoaXMubmFtZXNwYWNlID0gZ2V0TmFtZXNwYWNlKCB0aGlzICk7XG5cbiAgXHRcdHZhciBub2RlO1xuICBcdFx0dmFyIGV4aXN0aW5nID0gZmFsc2U7XG5cbiAgXHRcdGlmICggb2NjdXBhbnRzICkge1xuICBcdFx0XHR2YXIgbjtcbiAgXHRcdFx0d2hpbGUgKCAoIG4gPSBvY2N1cGFudHMuc2hpZnQoKSApICkge1xuICBcdFx0XHRcdGlmICggbi5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSB0aGlzJDEudGVtcGxhdGUuZS50b1VwcGVyQ2FzZSgpICYmIG4ubmFtZXNwYWNlVVJJID09PSB0aGlzJDEubmFtZXNwYWNlICkge1xuICBcdFx0XHRcdFx0dGhpcyQxLm5vZGUgPSBub2RlID0gbjtcbiAgXHRcdFx0XHRcdGV4aXN0aW5nID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdGJyZWFrO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRkZXRhY2hOb2RlKCBuICk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGlmICggIW5vZGUgKSB7XG4gIFx0XHRcdG5vZGUgPSBjcmVhdGVFbGVtZW50KCB0aGlzLnRlbXBsYXRlLmUsIHRoaXMubmFtZXNwYWNlLCB0aGlzLmdldEF0dHJpYnV0ZSggJ2lzJyApICk7XG4gIFx0XHRcdHRoaXMubm9kZSA9IG5vZGU7XG4gIFx0XHR9XG5cbiAgXHRcdGRlZmluZVByb3BlcnR5KCBub2RlLCAnX3JhY3RpdmUnLCB7XG4gIFx0XHRcdHZhbHVlOiB7XG4gIFx0XHRcdFx0cHJveHk6IHRoaXNcbiAgXHRcdFx0fVxuICBcdFx0fSk7XG5cbiAgXHRcdC8vIElzIHRoaXMgYSB0b3AtbGV2ZWwgbm9kZSBvZiBhIGNvbXBvbmVudD8gSWYgc28sIHdlIG1heSBuZWVkIHRvIGFkZFxuICBcdFx0Ly8gYSBkYXRhLXJhY3RpdmUtY3NzIGF0dHJpYnV0ZSwgZm9yIENTUyBlbmNhcHN1bGF0aW9uXG4gIFx0XHRpZiAoIHRoaXMucGFyZW50RnJhZ21lbnQuY3NzSWRzICkge1xuICBcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSggJ2RhdGEtcmFjdGl2ZS1jc3MnLCB0aGlzLnBhcmVudEZyYWdtZW50LmNzc0lkcy5tYXAoIGZ1bmN0aW9uICggeCApIHsgcmV0dXJuIChcIntcIiArIHggKyBcIn1cIik7IH0gKS5qb2luKCAnICcgKSApO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIGV4aXN0aW5nICYmIHRoaXMuZm91bmROb2RlICkgdGhpcy5mb3VuZE5vZGUoIG5vZGUgKTtcblxuICBcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuICBcdFx0XHR2YXIgY2hpbGRyZW4gPSBleGlzdGluZyA/IHRvQXJyYXkoIG5vZGUuY2hpbGROb2RlcyApIDogdW5kZWZpbmVkO1xuXG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQucmVuZGVyKCBub2RlLCBjaGlsZHJlbiApO1xuXG4gIFx0XHRcdC8vIGNsZWFuIHVwIGxlZnRvdmVyIGNoaWxkcmVuXG4gIFx0XHRcdGlmICggY2hpbGRyZW4gKSB7XG4gIFx0XHRcdFx0Y2hpbGRyZW4uZm9yRWFjaCggZGV0YWNoTm9kZSApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdGlmICggZXhpc3RpbmcgKSB7XG4gIFx0XHRcdC8vIHN0b3JlIGluaXRpYWwgdmFsdWVzIGZvciB0d28td2F5IGJpbmRpbmdcbiAgXHRcdFx0aWYgKCB0aGlzLmJpbmRpbmcgJiYgdGhpcy5iaW5kaW5nLndhc1VuZGVmaW5lZCApIHRoaXMuYmluZGluZy5zZXRGcm9tTm9kZSggbm9kZSApO1xuICBcdFx0XHQvLyByZW1vdmUgdW51c2VkIGF0dHJpYnV0ZXNcbiAgXHRcdFx0dmFyIGkgPSBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoO1xuICBcdFx0XHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdFx0XHR2YXIgbmFtZSA9IG5vZGUuYXR0cmlidXRlc1tpXS5uYW1lO1xuICBcdFx0XHRcdGlmICggISggbmFtZSBpbiB0aGlzJDEuYXR0cmlidXRlQnlOYW1lICkgKSBub2RlLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKCByZW5kZXIgKTtcblxuICBcdFx0aWYgKCB0aGlzLmJpbmRpbmcgKSB0aGlzLmJpbmRpbmcucmVuZGVyKCk7XG5cbiAgXHRcdHVwZGF0ZUxpdmVRdWVyaWVzJDEoIHRoaXMgKTtcblxuICBcdFx0aWYgKCB0aGlzLl9pbnRyb1RyYW5zaXRpb24gJiYgdGhpcy5yYWN0aXZlLnRyYW5zaXRpb25zRW5hYmxlZCApIHtcbiAgXHRcdFx0dGhpcy5faW50cm9UcmFuc2l0aW9uLmlzSW50cm8gPSB0cnVlO1xuICBcdFx0XHRydW5sb29wLnJlZ2lzdGVyVHJhbnNpdGlvbiggdGhpcy5faW50cm9UcmFuc2l0aW9uICk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICggIWV4aXN0aW5nICkge1xuICBcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIG5vZGUgKTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0fTtcblxuICBcdEVsZW1lbnQucHJvdG90eXBlLnNodWZmbGVkID0gZnVuY3Rpb24gc2h1ZmZsZWQgKCkge1xuICBcdFx0dGhpcy5saXZlUXVlcmllcy5mb3JFYWNoKCBtYWtlRGlydHkkMSApO1xuICBcdFx0SXRlbS5wcm90b3R5cGUuc2h1ZmZsZWQuY2FsbCh0aGlzKTtcbiAgXHR9O1xuXG4gIFx0RWxlbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIFx0XHR2YXIgdGFnTmFtZSA9IHRoaXMudGVtcGxhdGUuZTtcblxuICBcdFx0dmFyIGF0dHJzID0gdGhpcy5hdHRyaWJ1dGVzLm1hcCggc3RyaW5naWZ5QXR0cmlidXRlICkuam9pbiggJycgKTtcblxuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gc2VsZWN0ZWQgb3B0aW9uc1xuICBcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdvcHRpb24nICYmIHRoaXMuaXNTZWxlY3RlZCgpICkge1xuICBcdFx0XHRhdHRycyArPSAnIHNlbGVjdGVkJztcbiAgXHRcdH1cblxuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gdHdvLXdheSByYWRpbyBuYW1lIGJpbmRpbmdzXG4gIFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ2lucHV0JyAmJiBpbnB1dElzQ2hlY2tlZFJhZGlvKCB0aGlzICkgKSB7XG4gIFx0XHRcdGF0dHJzICs9ICcgY2hlY2tlZCc7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIFNwZWNpYWwgY2FzZSBzdHlsZSBhbmQgY2xhc3MgYXR0cmlidXRlcyBhbmQgZGlyZWN0aXZlc1xuICBcdFx0dmFyIHN0eWxlLCBjbHM7XG4gIFx0XHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaCggZnVuY3Rpb24gKCBhdHRyICkge1xuICBcdFx0XHRpZiAoIGF0dHIubmFtZSA9PT0gJ2NsYXNzJyApIHtcbiAgXHRcdFx0XHRjbHMgPSAoIGNscyB8fCAnJyApICsgKCBjbHMgPyAnICcgOiAnJyApICsgc2FmZUF0dHJpYnV0ZVN0cmluZyggYXR0ci5nZXRTdHJpbmcoKSApO1xuICBcdFx0XHR9IGVsc2UgaWYgKCBhdHRyLm5hbWUgPT09ICdzdHlsZScgKSB7XG4gIFx0XHRcdFx0c3R5bGUgPSAoIHN0eWxlIHx8ICcnICkgKyAoIHN0eWxlID8gJyAnIDogJycgKSArIHNhZmVBdHRyaWJ1dGVTdHJpbmcoIGF0dHIuZ2V0U3RyaW5nKCkgKTtcbiAgXHRcdFx0XHRpZiAoIHN0eWxlICYmICFlbmRzV2l0aFNlbWkudGVzdCggc3R5bGUgKSApIHN0eWxlICs9ICc7JztcbiAgXHRcdFx0fSBlbHNlIGlmICggYXR0ci5zdHlsZU5hbWUgKSB7XG4gIFx0XHRcdFx0c3R5bGUgPSAoIHN0eWxlIHx8ICcnICkgKyAoIHN0eWxlID8gJyAnIDogJycgKSArICBcIlwiICsgKGRlY2FtZWxpemUoIGF0dHIuc3R5bGVOYW1lICkpICsgXCI6IFwiICsgKHNhZmVBdHRyaWJ1dGVTdHJpbmcoIGF0dHIuZ2V0U3RyaW5nKCkgKSkgKyBcIjtcIjtcbiAgXHRcdFx0fSBlbHNlIGlmICggYXR0ci5pbmxpbmVDbGFzcyAmJiBhdHRyLmdldFZhbHVlKCkgKSB7XG4gIFx0XHRcdFx0Y2xzID0gKCBjbHMgfHwgJycgKSArICggY2xzID8gJyAnIDogJycgKSArIGF0dHIuaW5saW5lQ2xhc3M7XG4gIFx0XHRcdH1cbiAgXHRcdH0pO1xuICBcdFx0Ly8gcHV0IGNsYXNzZXMgZmlyc3QsIHRoZW4gaW5saW5lIHN0eWxlXG4gIFx0XHRpZiAoIHN0eWxlICE9PSB1bmRlZmluZWQgKSBhdHRycyA9ICcgc3R5bGUnICsgKCBzdHlsZSA/IChcIj1cXFwiXCIgKyBzdHlsZSArIFwiXFxcIlwiKSA6ICcnICkgKyBhdHRycztcbiAgXHRcdGlmICggY2xzICE9PSB1bmRlZmluZWQgKSBhdHRycyA9ICcgY2xhc3MnICsgKGNscyA/IChcIj1cXFwiXCIgKyBjbHMgKyBcIlxcXCJcIikgOiAnJykgKyBhdHRycztcblxuICBcdFx0dmFyIHN0ciA9IFwiPFwiICsgdGFnTmFtZSArIFwiXCIgKyBhdHRycyArIFwiPlwiO1xuXG4gIFx0XHRpZiAoIHRoaXMuaXNWb2lkICkgcmV0dXJuIHN0cjtcblxuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gdGV4dGFyZWFcbiAgXHRcdGlmICggdGhpcy5uYW1lID09PSAndGV4dGFyZWEnICYmIHRoaXMuZ2V0QXR0cmlidXRlKCAndmFsdWUnICkgIT09IHVuZGVmaW5lZCApIHtcbiAgXHRcdFx0c3RyICs9IGVzY2FwZUh0bWwoIHRoaXMuZ2V0QXR0cmlidXRlKCAndmFsdWUnICkgKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gY29udGVudGVkaXRhYmxlXG4gIFx0XHRlbHNlIGlmICggdGhpcy5nZXRBdHRyaWJ1dGUoICdjb250ZW50ZWRpdGFibGUnICkgIT09IHVuZGVmaW5lZCApIHtcbiAgXHRcdFx0c3RyICs9ICggdGhpcy5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKSB8fCAnJyApO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG4gIFx0XHRcdHN0ciArPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCAhL14oPzpzY3JpcHR8c3R5bGUpJC9pLnRlc3QoIHRoaXMudGVtcGxhdGUuZSApICk7IC8vIGVzY2FwZSB0ZXh0IHVubGVzcyBzY3JpcHQvc3R5bGVcbiAgXHRcdH1cblxuICBcdFx0c3RyICs9IFwiPC9cIiArIHRhZ05hbWUgKyBcIj5cIjtcbiAgXHRcdHJldHVybiBzdHI7XG4gIFx0fTtcblxuICBcdEVsZW1lbnQucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uIHVuYmluZCQxICgpIHtcbiAgXHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKCB1bmJpbmQgKTtcblxuICBcdFx0aWYgKCB0aGlzLmJpbmRpbmcgKSB0aGlzLmJpbmRpbmcudW5iaW5kKCk7XG4gIFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdH07XG5cbiAgXHRFbGVtZW50LnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uIHVucmVuZGVyICggc2hvdWxkRGVzdHJveSApIHtcbiAgXHRcdGlmICggIXRoaXMucmVuZGVyZWQgKSByZXR1cm47XG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG5cbiAgXHRcdC8vIHVucmVuZGVyaW5nIGJlZm9yZSBpbnRybyBjb21wbGV0ZWQ/IGNvbXBsZXRlIGl0IG5vd1xuICBcdFx0Ly8gVE9ETyBzaG91bGQgYmUgYW4gQVBJIGZvciBhYm9ydGluZyB0cmFuc2l0aW9uc1xuICBcdFx0dmFyIHRyYW5zaXRpb24gPSB0aGlzLl9pbnRyb1RyYW5zaXRpb247XG4gIFx0XHRpZiAoIHRyYW5zaXRpb24gJiYgdHJhbnNpdGlvbi5jb21wbGV0ZSApIHRyYW5zaXRpb24uY29tcGxldGUoKTtcblxuICBcdFx0Ly8gRGV0YWNoIGFzIHNvb24gYXMgd2UgY2FuXG4gIFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgKSB7XG4gIFx0XHRcdC8vIDxvcHRpb24+IGVsZW1lbnRzIGRldGFjaCBpbW1lZGlhdGVseSwgc28gdGhhdFxuICBcdFx0XHQvLyB0aGVpciBwYXJlbnQgPHNlbGVjdD4gZWxlbWVudCBzeW5jcyBjb3JyZWN0bHksIGFuZFxuICBcdFx0XHQvLyBzaW5jZSBvcHRpb24gZWxlbWVudHMgY2FuJ3QgaGF2ZSB0cmFuc2l0aW9ucyBhbnl3YXlcbiAgXHRcdFx0dGhpcy5kZXRhY2goKTtcbiAgXHRcdH0gZWxzZSBpZiAoIHNob3VsZERlc3Ryb3kgKSB7XG4gIFx0XHRcdHJ1bmxvb3AuZGV0YWNoV2hlblJlYWR5KCB0aGlzICk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoKTtcblxuICBcdFx0aWYgKCB0aGlzLmJpbmRpbmcgKSB0aGlzLmJpbmRpbmcudW5yZW5kZXIoKTtcblxuICBcdFx0Ly8gb3V0cm8gdHJhbnNpdGlvblxuICBcdFx0aWYgKCB0aGlzLl9vdXRyb1RyYW5zaXRpb24gJiYgdGhpcy5yYWN0aXZlLnRyYW5zaXRpb25zRW5hYmxlZCApIHtcbiAgXHRcdFx0dGhpcy5fb3V0cm9UcmFuc2l0aW9uLmlzSW50cm8gPSBmYWxzZTtcbiAgXHRcdFx0cnVubG9vcC5yZWdpc3RlclRyYW5zaXRpb24oIHRoaXMuX291dHJvVHJhbnNpdGlvbiApO1xuICBcdFx0fVxuXG4gIFx0XHRyZW1vdmVGcm9tTGl2ZVF1ZXJpZXMoIHRoaXMgKTtcbiAgXHRcdC8vIFRPRE8gZm9ybXMgYXJlIGEgc3BlY2lhbCBjYXNlXG4gIFx0fTtcblxuICBcdEVsZW1lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSQxICgpIHtcbiAgXHRcdGlmICggdGhpcy5kaXJ0eSApIHtcbiAgXHRcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuXG4gIFx0XHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKCB1cGRhdGUgKTtcblxuICBcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB0aGlzLmZyYWdtZW50LnVwZGF0ZSgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRyZXR1cm4gRWxlbWVudDtcbiAgfShJdGVtKSk7XG5cbiAgZnVuY3Rpb24gaW5wdXRJc0NoZWNrZWRSYWRpbyAoIGVsZW1lbnQgKSB7XG4gIFx0dmFyIGF0dHJpYnV0ZXMgPSBlbGVtZW50LmF0dHJpYnV0ZUJ5TmFtZTtcblxuICBcdHZhciB0eXBlQXR0cmlidXRlICA9IGF0dHJpYnV0ZXMudHlwZTtcbiAgXHR2YXIgdmFsdWVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnZhbHVlO1xuICBcdHZhciBuYW1lQXR0cmlidXRlICA9IGF0dHJpYnV0ZXMubmFtZTtcblxuICBcdGlmICggIXR5cGVBdHRyaWJ1dGUgfHwgKCB0eXBlQXR0cmlidXRlLnZhbHVlICE9PSAncmFkaW8nICkgfHwgIXZhbHVlQXR0cmlidXRlIHx8ICFuYW1lQXR0cmlidXRlLmludGVycG9sYXRvciApIHtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAoIHZhbHVlQXR0cmlidXRlLmdldFZhbHVlKCkgPT09IG5hbWVBdHRyaWJ1dGUuaW50ZXJwb2xhdG9yLm1vZGVsLmdldCgpICkge1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5QXR0cmlidXRlICggYXR0cmlidXRlICkge1xuICBcdHZhciBzdHIgPSBhdHRyaWJ1dGUudG9TdHJpbmcoKTtcbiAgXHRyZXR1cm4gc3RyID8gJyAnICsgc3RyIDogJyc7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVGcm9tTGl2ZVF1ZXJpZXMgKCBlbGVtZW50ICkge1xuICBcdHZhciBpID0gZWxlbWVudC5saXZlUXVlcmllcy5sZW5ndGg7XG4gIFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHR2YXIgcXVlcnkgPSBlbGVtZW50LmxpdmVRdWVyaWVzW2ldO1xuICBcdFx0cXVlcnkucmVtb3ZlKCBlbGVtZW50Lm5vZGUgKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXROYW1lc3BhY2UgKCBlbGVtZW50ICkge1xuICBcdC8vIFVzZSBzcGVjaWZpZWQgbmFtZXNwYWNlLi4uXG4gIFx0dmFyIHhtbG5zID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd4bWxucycgKTtcbiAgXHRpZiAoIHhtbG5zICkgcmV0dXJuIHhtbG5zO1xuXG4gIFx0Ly8gLi4ub3IgU1ZHIG5hbWVzcGFjZSwgaWYgdGhpcyBpcyBhbiA8c3ZnPiBlbGVtZW50XG4gIFx0aWYgKCBlbGVtZW50Lm5hbWUgPT09ICdzdmcnICkgcmV0dXJuIHN2ZyQxO1xuXG4gIFx0dmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50O1xuXG4gIFx0aWYgKCBwYXJlbnQgKSB7XG4gIFx0XHQvLyAuLi5vciBIVE1MLCBpZiB0aGUgcGFyZW50IGlzIGEgPGZvcmVpZ25PYmplY3Q+XG4gIFx0XHRpZiAoIHBhcmVudC5uYW1lID09PSAnZm9yZWlnbm9iamVjdCcgKSByZXR1cm4gaHRtbDtcblxuICBcdFx0Ly8gLi4ub3IgaW5oZXJpdCBmcm9tIHRoZSBwYXJlbnQgbm9kZVxuICBcdFx0cmV0dXJuIHBhcmVudC5ub2RlLm5hbWVzcGFjZVVSSTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gZWxlbWVudC5yYWN0aXZlLmVsLm5hbWVzcGFjZVVSSTtcbiAgfVxuXG4gIHZhciBGb3JtID0gKGZ1bmN0aW9uIChFbGVtZW50KSB7XG4gIFx0ZnVuY3Rpb24gRm9ybSAoIG9wdGlvbnMgKSB7XG4gIFx0XHRFbGVtZW50LmNhbGwoIHRoaXMsIG9wdGlvbnMgKTtcbiAgXHRcdHRoaXMuZm9ybUJpbmRpbmdzID0gW107XG4gIFx0fVxuXG4gIFx0Rm9ybS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFbGVtZW50ICYmIEVsZW1lbnQucHJvdG90eXBlICk7XG4gIFx0Rm9ybS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGb3JtO1xuXG4gIFx0Rm9ybS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICggdGFyZ2V0LCBvY2N1cGFudHMgKSB7XG4gIFx0XHRFbGVtZW50LnByb3RvdHlwZS5yZW5kZXIuY2FsbCggdGhpcywgdGFyZ2V0LCBvY2N1cGFudHMgKTtcbiAgXHRcdHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCAncmVzZXQnLCBoYW5kbGVSZXNldCwgZmFsc2UgKTtcbiAgXHR9O1xuXG4gIFx0Rm9ybS5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiB1bnJlbmRlciAoIHNob3VsZERlc3Ryb3kgKSB7XG4gIFx0XHR0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3Jlc2V0JywgaGFuZGxlUmVzZXQsIGZhbHNlICk7XG4gIFx0XHRFbGVtZW50LnByb3RvdHlwZS51bnJlbmRlci5jYWxsKCB0aGlzLCBzaG91bGREZXN0cm95ICk7XG4gIFx0fTtcblxuICBcdHJldHVybiBGb3JtO1xuICB9KEVsZW1lbnQpKTtcblxuICBmdW5jdGlvbiBoYW5kbGVSZXNldCAoKSB7XG4gIFx0dmFyIGVsZW1lbnQgPSB0aGlzLl9yYWN0aXZlLnByb3h5O1xuXG4gIFx0cnVubG9vcC5zdGFydCgpO1xuICBcdGVsZW1lbnQuZm9ybUJpbmRpbmdzLmZvckVhY2goIHVwZGF0ZU1vZGVsJDEgKTtcbiAgXHRydW5sb29wLmVuZCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTW9kZWwkMSAoIGJpbmRpbmcgKSB7XG4gIFx0YmluZGluZy5tb2RlbC5zZXQoIGJpbmRpbmcucmVzZXRWYWx1ZSApO1xuICB9XG5cbiAgdmFyIE11c3RhY2hlID0gKGZ1bmN0aW9uIChJdGVtKSB7XG4gIFx0ZnVuY3Rpb24gTXVzdGFjaGUgKCBvcHRpb25zICkge1xuICBcdFx0SXRlbS5jYWxsKCB0aGlzLCBvcHRpb25zICk7XG5cbiAgXHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuICBcdFx0dGhpcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gIFx0XHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgXHRcdGlmICggb3B0aW9ucy5vd25lciApIHRoaXMucGFyZW50ID0gb3B0aW9ucy5vd25lcjtcblxuICBcdFx0dGhpcy5pc1N0YXRpYyA9ICEhb3B0aW9ucy50ZW1wbGF0ZS5zO1xuXG4gIFx0XHR0aGlzLm1vZGVsID0gbnVsbDtcbiAgXHRcdHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgXHR9XG5cbiAgXHRNdXN0YWNoZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJdGVtICYmIEl0ZW0ucHJvdG90eXBlICk7XG4gIFx0TXVzdGFjaGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTXVzdGFjaGU7XG5cbiAgXHRNdXN0YWNoZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIGJpbmQgKCkge1xuICBcdFx0Ly8gdHJ5IHRvIGZpbmQgYSBtb2RlbCBmb3IgdGhpcyB2aWV3XG4gIFx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dmFyIG1vZGVsID0gcmVzb2x2ZSQyKCB0aGlzLnBhcmVudEZyYWdtZW50LCB0aGlzLnRlbXBsYXRlICk7XG4gIFx0XHR2YXIgdmFsdWUgPSBtb2RlbCA/IG1vZGVsLmdldCgpIDogdW5kZWZpbmVkO1xuXG4gIFx0XHRpZiAoIHRoaXMuaXNTdGF0aWMgKSB7XG4gIFx0XHRcdHRoaXMubW9kZWwgPSB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0gfTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIG1vZGVsICkge1xuICBcdFx0XHRtb2RlbC5yZWdpc3RlciggdGhpcyApO1xuICBcdFx0XHR0aGlzLm1vZGVsID0gbW9kZWw7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLnJlc29sdmVyID0gdGhpcy5wYXJlbnRGcmFnbWVudC5yZXNvbHZlKCB0aGlzLnRlbXBsYXRlLnIsIGZ1bmN0aW9uICggbW9kZWwgKSB7XG4gIFx0XHRcdFx0dGhpcyQxLm1vZGVsID0gbW9kZWw7XG4gIFx0XHRcdFx0bW9kZWwucmVnaXN0ZXIoIHRoaXMkMSApO1xuXG4gIFx0XHRcdFx0dGhpcyQxLmhhbmRsZUNoYW5nZSgpO1xuICBcdFx0XHRcdHRoaXMkMS5yZXNvbHZlciA9IG51bGw7XG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRNdXN0YWNoZS5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlICgpIHtcbiAgXHRcdHRoaXMuYnViYmxlKCk7XG4gIFx0fTtcblxuICBcdE11c3RhY2hlLnByb3RvdHlwZS5yZWJpbmRpbmcgPSBmdW5jdGlvbiByZWJpbmRpbmcgKCBuZXh0LCBwcmV2aW91cywgc2FmZSApIHtcbiAgXHRcdG5leHQgPSByZWJpbmRNYXRjaCggdGhpcy50ZW1wbGF0ZSwgbmV4dCwgcHJldmlvdXMgKTtcbiAgXHRcdGlmICggdGhpc1snc3RhdGljJ10gKSByZXR1cm4gZmFsc2U7XG4gIFx0XHRpZiAoIG5leHQgPT09IHRoaXMubW9kZWwgKSByZXR1cm4gZmFsc2U7XG5cbiAgXHRcdGlmICggdGhpcy5tb2RlbCApIHtcbiAgXHRcdFx0dGhpcy5tb2RlbC51bnJlZ2lzdGVyKCB0aGlzICk7XG4gIFx0XHR9XG4gIFx0XHRpZiAoIG5leHQgKSBuZXh0LmFkZFNodWZmbGVSZWdpc3RlciggdGhpcywgJ21hcmsnICk7XG4gIFx0XHR0aGlzLm1vZGVsID0gbmV4dDtcbiAgXHRcdGlmICggIXNhZmUgKSB0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICBcdFx0cmV0dXJuIHRydWU7XG4gIFx0fTtcblxuICBcdE11c3RhY2hlLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiB1bmJpbmQgKCkge1xuICBcdFx0aWYgKCAhdGhpcy5pc1N0YXRpYyApIHtcbiAgXHRcdFx0dGhpcy5tb2RlbCAmJiB0aGlzLm1vZGVsLnVucmVnaXN0ZXIoIHRoaXMgKTtcbiAgXHRcdFx0dGhpcy5tb2RlbCA9IHVuZGVmaW5lZDtcbiAgXHRcdFx0dGhpcy5yZXNvbHZlciAmJiB0aGlzLnJlc29sdmVyLnVuYmluZCgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRyZXR1cm4gTXVzdGFjaGU7XG4gIH0oSXRlbSkpO1xuXG4gIHZhciBJbnRlcnBvbGF0b3IgPSAoZnVuY3Rpb24gKE11c3RhY2hlKSB7XG4gIFx0ZnVuY3Rpb24gSW50ZXJwb2xhdG9yICgpIHtcbiAgXHRcdE11c3RhY2hlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIFx0fVxuXG4gIFx0SW50ZXJwb2xhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE11c3RhY2hlICYmIE11c3RhY2hlLnByb3RvdHlwZSApO1xuICBcdEludGVycG9sYXRvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnRlcnBvbGF0b3I7XG5cbiAgXHRJbnRlcnBvbGF0b3IucHJvdG90eXBlLmJ1YmJsZSA9IGZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gIFx0XHRpZiAoIHRoaXMub3duZXIgKSB0aGlzLm93bmVyLmJ1YmJsZSgpO1xuICBcdFx0TXVzdGFjaGUucHJvdG90eXBlLmJ1YmJsZS5jYWxsKHRoaXMpO1xuICBcdH07XG5cbiAgXHRJbnRlcnBvbGF0b3IucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIGRldGFjaCAoKSB7XG4gIFx0XHRyZXR1cm4gZGV0YWNoTm9kZSggdGhpcy5ub2RlICk7XG4gIFx0fTtcblxuICBcdEludGVycG9sYXRvci5wcm90b3R5cGUuZmlyc3ROb2RlID0gZnVuY3Rpb24gZmlyc3ROb2RlICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGU7XG4gIFx0fTtcblxuICBcdEludGVycG9sYXRvci5wcm90b3R5cGUuZ2V0U3RyaW5nID0gZnVuY3Rpb24gZ2V0U3RyaW5nICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm1vZGVsID8gc2FmZVRvU3RyaW5nVmFsdWUoIHRoaXMubW9kZWwuZ2V0KCkgKSA6ICcnO1xuICBcdH07XG5cbiAgXHRJbnRlcnBvbGF0b3IucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAoIHRhcmdldCwgb2NjdXBhbnRzICkge1xuICBcdFx0aWYgKCBpbkF0dHJpYnV0ZXMoKSApIHJldHVybjtcbiAgXHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0U3RyaW5nKCk7XG5cbiAgXHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXG4gIFx0XHRpZiAoIG9jY3VwYW50cyApIHtcbiAgXHRcdFx0dmFyIG4gPSBvY2N1cGFudHNbMF07XG4gIFx0XHRcdGlmICggbiAmJiBuLm5vZGVUeXBlID09PSAzICkge1xuICBcdFx0XHRcdG9jY3VwYW50cy5zaGlmdCgpO1xuICBcdFx0XHRcdGlmICggbi5ub2RlVmFsdWUgIT09IHZhbHVlICkge1xuICBcdFx0XHRcdFx0bi5ub2RlVmFsdWUgPSB2YWx1ZTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0biA9IHRoaXMubm9kZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZSggdmFsdWUgKTtcbiAgXHRcdFx0XHRpZiAoIG9jY3VwYW50c1swXSApIHtcbiAgXHRcdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIG4sIG9jY3VwYW50c1swXSApO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIG4gKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLm5vZGUgPSBuO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5ub2RlID0gZG9jLmNyZWF0ZVRleHROb2RlKCB2YWx1ZSApO1xuICBcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIHRoaXMubm9kZSApO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRJbnRlcnBvbGF0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCBlc2NhcGUgKSB7XG4gIFx0XHR2YXIgc3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTtcbiAgXHRcdHJldHVybiBlc2NhcGUgPyBlc2NhcGVIdG1sKCBzdHJpbmcgKSA6IHN0cmluZztcbiAgXHR9O1xuXG4gIFx0SW50ZXJwb2xhdG9yLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uIHVucmVuZGVyICggc2hvdWxkRGVzdHJveSApIHtcbiAgXHRcdGlmICggc2hvdWxkRGVzdHJveSApIHRoaXMuZGV0YWNoKCk7XG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gIFx0fTtcblxuICBcdEludGVycG9sYXRvci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgXHRcdGlmICggdGhpcy5kaXJ0eSApIHtcbiAgXHRcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuICBcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG4gIFx0XHRcdFx0dGhpcy5ub2RlLmRhdGEgPSB0aGlzLmdldFN0cmluZygpO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdEludGVycG9sYXRvci5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uIHZhbHVlT2YgKCkge1xuICBcdFx0cmV0dXJuIHRoaXMubW9kZWwgPyB0aGlzLm1vZGVsLmdldCgpIDogdW5kZWZpbmVkO1xuICBcdH07XG5cbiAgXHRyZXR1cm4gSW50ZXJwb2xhdG9yO1xuICB9KE11c3RhY2hlKSk7XG5cbiAgdmFyIElucHV0ID0gKGZ1bmN0aW9uIChFbGVtZW50KSB7XG4gIFx0ZnVuY3Rpb24gSW5wdXQgKCkge1xuICBcdFx0RWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBcdH1cblxuICBcdElucHV0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVsZW1lbnQgJiYgRWxlbWVudC5wcm90b3R5cGUgKTtcbiAgXHRJbnB1dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnB1dDtcblxuICBcdElucHV0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKCB0YXJnZXQsIG9jY3VwYW50cyApIHtcbiAgXHRcdEVsZW1lbnQucHJvdG90eXBlLnJlbmRlci5jYWxsKCB0aGlzLCB0YXJnZXQsIG9jY3VwYW50cyApO1xuICBcdFx0dGhpcy5ub2RlLmRlZmF1bHRWYWx1ZSA9IHRoaXMubm9kZS52YWx1ZTtcbiAgXHR9O1xuXG4gIFx0cmV0dXJuIElucHV0O1xuICB9KEVsZW1lbnQpKTtcblxuICB2YXIgTWFwcGluZyA9IChmdW5jdGlvbiAoSXRlbSkge1xuICBcdGZ1bmN0aW9uIE1hcHBpbmcgKCBvcHRpb25zICkge1xuICBcdFx0SXRlbS5jYWxsKCB0aGlzLCBvcHRpb25zICk7XG5cbiAgXHRcdHRoaXMubmFtZSA9IG9wdGlvbnMudGVtcGxhdGUubjtcblxuICBcdFx0dGhpcy5vd25lciA9IG9wdGlvbnMub3duZXIgfHwgb3B0aW9ucy5wYXJlbnRGcmFnbWVudC5vd25lciB8fCBvcHRpb25zLmVsZW1lbnQgfHwgZmluZEVsZW1lbnQoIG9wdGlvbnMucGFyZW50RnJhZ21lbnQgKTtcbiAgXHRcdHRoaXMuZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudCB8fCAodGhpcy5vd25lci5hdHRyaWJ1dGVCeU5hbWUgPyB0aGlzLm93bmVyIDogZmluZEVsZW1lbnQoIG9wdGlvbnMucGFyZW50RnJhZ21lbnQgKSApO1xuICBcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnRGcmFnbWVudDsgLy8gc2hhcmVkXG4gIFx0XHR0aGlzLnJhY3RpdmUgPSB0aGlzLnBhcmVudEZyYWdtZW50LnJhY3RpdmU7XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnQgPSBudWxsO1xuXG4gIFx0XHR0aGlzLmVsZW1lbnQuYXR0cmlidXRlQnlOYW1lWyB0aGlzLm5hbWUgXSA9IHRoaXM7XG5cbiAgXHRcdHRoaXMudmFsdWUgPSBvcHRpb25zLnRlbXBsYXRlLmY7XG4gIFx0fVxuXG4gIFx0TWFwcGluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJdGVtICYmIEl0ZW0ucHJvdG90eXBlICk7XG4gIFx0TWFwcGluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXBwaW5nO1xuXG4gIFx0TWFwcGluZy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIGJpbmQgKCkge1xuICBcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LmJpbmQoKTtcbiAgXHRcdH1cblxuICBcdFx0dmFyIHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZS5mO1xuICBcdFx0dmFyIHZpZXdtb2RlbCA9IHRoaXMuZWxlbWVudC5pbnN0YW5jZS52aWV3bW9kZWw7XG5cbiAgXHRcdGlmICggdGVtcGxhdGUgPT09IDAgKSB7XG4gIFx0XHRcdC8vIGVtcHR5IGF0dHJpYnV0ZXMgYXJlIGB0cnVlYFxuICBcdFx0XHR2aWV3bW9kZWwuam9pbktleSggdGhpcy5uYW1lICkuc2V0KCB0cnVlICk7XG4gIFx0XHR9XG5cbiAgXHRcdGVsc2UgaWYgKCB0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnICkge1xuICBcdFx0XHR2YXIgcGFyc2VkID0gcGFyc2VKU09OKCB0ZW1wbGF0ZSApO1xuICBcdFx0XHR2aWV3bW9kZWwuam9pbktleSggdGhpcy5uYW1lICkuc2V0KCBwYXJzZWQgPyBwYXJzZWQudmFsdWUgOiB0ZW1wbGF0ZSApO1xuICBcdFx0fVxuXG4gIFx0XHRlbHNlIGlmICggaXNBcnJheSggdGVtcGxhdGUgKSApIHtcbiAgXHRcdFx0Y3JlYXRlTWFwcGluZyggdGhpcywgdHJ1ZSApO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRNYXBwaW5nLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKCkge307XG5cbiAgXHRNYXBwaW5nLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiB1bmJpbmQgKCkge1xuICBcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkgdGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHRcdGlmICggdGhpcy5ib3VuZEZyYWdtZW50ICkgdGhpcy5ib3VuZEZyYWdtZW50LnVuYmluZCgpO1xuXG4gIFx0XHRpZiAoIHRoaXMuZWxlbWVudC5ib3VuZCApIHtcbiAgXHRcdFx0aWYgKCB0aGlzLmxpbmsudGFyZ2V0ID09PSB0aGlzLm1vZGVsICkgdGhpcy5saW5rLm93bmVyLnVubGluaygpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRNYXBwaW5nLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uIHVucmVuZGVyICgpIHt9O1xuXG4gIFx0TWFwcGluZy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgXHRcdGlmICggdGhpcy5kaXJ0eSApIHtcbiAgXHRcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuICBcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB0aGlzLmZyYWdtZW50LnVwZGF0ZSgpO1xuICBcdFx0XHRpZiAoIHRoaXMuYm91bmRGcmFnbWVudCApIHRoaXMuYm91bmRGcmFnbWVudC51cGRhdGUoKTtcbiAgXHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkgdGhpcy51cGRhdGVEZWxlZ2F0ZSgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRyZXR1cm4gTWFwcGluZztcbiAgfShJdGVtKSk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlTWFwcGluZyAoIGl0ZW0gKSB7XG4gIFx0dmFyIHRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZS5mO1xuICBcdHZhciB2aWV3bW9kZWwgPSBpdGVtLmVsZW1lbnQuaW5zdGFuY2Uudmlld21vZGVsO1xuICBcdHZhciBjaGlsZERhdGEgPSB2aWV3bW9kZWwudmFsdWU7XG5cbiAgXHRpZiAoIHRlbXBsYXRlLmxlbmd0aCA9PT0gMSAmJiB0ZW1wbGF0ZVswXS50ID09PSBJTlRFUlBPTEFUT1IgKSB7XG4gIFx0XHRpdGVtLm1vZGVsID0gcmVzb2x2ZSQyKCBpdGVtLnBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZVswXSApO1xuXG4gIFx0XHRpZiAoICFpdGVtLm1vZGVsICkge1xuICBcdFx0XHR3YXJuT25jZUlmRGVidWcoIChcIlRoZSBcIiArIChpdGVtLm5hbWUpICsgXCI9J3t7XCIgKyAodGVtcGxhdGVbMF0ucikgKyBcIn19JyBtYXBwaW5nIGlzIGFtYmlndW91cywgYW5kIG1heSBjYXVzZSB1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnNpZGVyIGluaXRpYWxpc2luZyB5b3VyIGRhdGEgdG8gZWxpbWluYXRlIHRoZSBhbWJpZ3VpdHlcIiksIHsgcmFjdGl2ZTogaXRlbS5lbGVtZW50Lmluc3RhbmNlIH0pOyAvLyBUT0RPIGFkZCBkb2NzIHBhZ2UgZXhwbGFpbmluZyBpdGVtXG4gIFx0XHRcdGl0ZW0ucGFyZW50RnJhZ21lbnQucmFjdGl2ZS5nZXQoIGl0ZW0ubmFtZSApOyAvLyBzaWRlLWVmZmVjdDogY3JlYXRlIG1hcHBpbmdzIGFzIG5lY2Vzc2FyeVxuICBcdFx0XHRpdGVtLm1vZGVsID0gaXRlbS5wYXJlbnRGcmFnbWVudC5maW5kQ29udGV4dCgpLmpvaW5LZXkoIGl0ZW0ubmFtZSApO1xuICBcdFx0fVxuXG4gIFx0XHRpdGVtLmxpbmsgPSB2aWV3bW9kZWwuY3JlYXRlTGluayggaXRlbS5uYW1lLCBpdGVtLm1vZGVsLCB0ZW1wbGF0ZVswXS5yICk7XG5cbiAgXHRcdGlmICggaXRlbS5tb2RlbC5nZXQoKSA9PT0gdW5kZWZpbmVkICYmIGl0ZW0ubmFtZSBpbiBjaGlsZERhdGEgKSB7XG4gIFx0XHRcdGl0ZW0ubW9kZWwuc2V0KCBjaGlsZERhdGFbIGl0ZW0ubmFtZSBdICk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0ZWxzZSB7XG4gIFx0XHRpdGVtLmJvdW5kRnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoe1xuICBcdFx0XHRvd25lcjogaXRlbSxcbiAgXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlXG4gIFx0XHR9KS5iaW5kKCk7XG5cbiAgXHRcdGl0ZW0ubW9kZWwgPSB2aWV3bW9kZWwuam9pbktleSggaXRlbS5uYW1lICk7XG4gIFx0XHRpdGVtLm1vZGVsLnNldCggaXRlbS5ib3VuZEZyYWdtZW50LnZhbHVlT2YoKSApO1xuXG4gIFx0XHQvLyBpdGVtIGlzIGEgKmJpdCogb2YgYSBoYWNrXG4gIFx0XHRpdGVtLmJvdW5kRnJhZ21lbnQuYnViYmxlID0gZnVuY3Rpb24gKCkge1xuICBcdFx0XHRGcmFnbWVudC5wcm90b3R5cGUuYnViYmxlLmNhbGwoIGl0ZW0uYm91bmRGcmFnbWVudCApO1xuICBcdFx0XHQvLyBkZWZlciB0aGlzIHRvIGF2b2lkIG11Y2tpbmcgYXJvdW5kIG1vZGVsIGRlcHMgaWYgdGhlcmUgaGFwcGVucyB0byBiZSBhbiBleHByZXNzaW9uIGludm9sdmVkXG4gIFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKGZ1bmN0aW9uICgpIHtcbiAgXHRcdFx0XHRpdGVtLmJvdW5kRnJhZ21lbnQudXBkYXRlKCk7XG4gIFx0XHRcdFx0aXRlbS5tb2RlbC5zZXQoIGl0ZW0uYm91bmRGcmFnbWVudC52YWx1ZU9mKCkgKTtcbiAgXHRcdFx0fSk7XG4gIFx0XHR9O1xuICBcdH1cbiAgfVxuXG4gIHZhciBPcHRpb24gPSAoZnVuY3Rpb24gKEVsZW1lbnQpIHtcbiAgXHRmdW5jdGlvbiBPcHRpb24gKCBvcHRpb25zICkge1xuICBcdFx0dmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgXHRcdGlmICggIXRlbXBsYXRlLmEgKSB0ZW1wbGF0ZS5hID0ge307XG5cbiAgXHRcdC8vIElmIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgaXMgbWlzc2luZywgdXNlIHRoZSBlbGVtZW50J3MgY29udGVudCxcbiAgXHRcdC8vIGFzIGxvbmcgYXMgaXQgaXNuJ3QgZGlzYWJsZWRcbiAgXHRcdGlmICggdGVtcGxhdGUuYS52YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoICdkaXNhYmxlZCcgaW4gdGVtcGxhdGUuYSApICkge1xuICBcdFx0XHR0ZW1wbGF0ZS5hLnZhbHVlID0gdGVtcGxhdGUuZiB8fCAnJztcbiAgXHRcdH1cblxuICBcdFx0RWxlbWVudC5jYWxsKCB0aGlzLCBvcHRpb25zICk7XG5cbiAgXHRcdHRoaXMuc2VsZWN0ID0gZmluZEVsZW1lbnQoIHRoaXMucGFyZW50IHx8IHRoaXMucGFyZW50RnJhZ21lbnQsIGZhbHNlLCAnc2VsZWN0JyApO1xuICBcdH1cblxuICBcdE9wdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFbGVtZW50ICYmIEVsZW1lbnQucHJvdG90eXBlICk7XG4gIFx0T3B0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9wdGlvbjtcblxuICBcdE9wdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIGJpbmQgKCkge1xuICBcdFx0aWYgKCAhdGhpcy5zZWxlY3QgKSB7XG4gIFx0XHRcdEVsZW1lbnQucHJvdG90eXBlLmJpbmQuY2FsbCh0aGlzKTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBJZiB0aGUgc2VsZWN0IGhhcyBhIHZhbHVlLCBpdCBvdmVycmlkZXMgdGhlIGBzZWxlY3RlZGAgYXR0cmlidXRlIG9uXG4gIFx0XHQvLyB0aGlzIG9wdGlvbiAtIHNvIHdlIGRlbGV0ZSB0aGUgYXR0cmlidXRlXG4gIFx0XHR2YXIgc2VsZWN0ZWRBdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZUJ5TmFtZS5zZWxlY3RlZDtcbiAgXHRcdGlmICggc2VsZWN0ZWRBdHRyaWJ1dGUgJiYgdGhpcy5zZWxlY3QuZ2V0QXR0cmlidXRlKCAndmFsdWUnICkgIT09IHVuZGVmaW5lZCApIHtcbiAgXHRcdFx0dmFyIGluZGV4ID0gdGhpcy5hdHRyaWJ1dGVzLmluZGV4T2YoIHNlbGVjdGVkQXR0cmlidXRlICk7XG4gIFx0XHRcdHRoaXMuYXR0cmlidXRlcy5zcGxpY2UoIGluZGV4LCAxICk7XG4gIFx0XHRcdGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZUJ5TmFtZS5zZWxlY3RlZDtcbiAgXHRcdH1cblxuICBcdFx0RWxlbWVudC5wcm90b3R5cGUuYmluZC5jYWxsKHRoaXMpO1xuICBcdFx0dGhpcy5zZWxlY3Qub3B0aW9ucy5wdXNoKCB0aGlzICk7XG4gIFx0fTtcblxuICBcdE9wdGlvbi5wcm90b3R5cGUuYnViYmxlID0gZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgXHRcdC8vIGlmIHdlJ3JlIHVzaW5nIGNvbnRlbnQgYXMgdmFsdWUsIG1heSBuZWVkIHRvIHVwZGF0ZSBoZXJlXG4gIFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuICBcdFx0aWYgKCB0aGlzLm5vZGUgJiYgdGhpcy5ub2RlLnZhbHVlICE9PSB2YWx1ZSApIHtcbiAgXHRcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG4gIFx0XHR9XG4gIFx0XHRFbGVtZW50LnByb3RvdHlwZS5idWJibGUuY2FsbCh0aGlzKTtcbiAgXHR9O1xuXG4gIFx0T3B0aW9uLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUgKCBuYW1lICkge1xuICBcdFx0dmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlQnlOYW1lWyBuYW1lIF07XG4gIFx0XHRyZXR1cm4gYXR0cmlidXRlID8gYXR0cmlidXRlLmdldFZhbHVlKCkgOiBuYW1lID09PSAndmFsdWUnICYmIHRoaXMuZnJhZ21lbnQgPyB0aGlzLmZyYWdtZW50LnZhbHVlT2YoKSA6IHVuZGVmaW5lZDtcbiAgXHR9O1xuXG4gIFx0T3B0aW9uLnByb3RvdHlwZS5pc1NlbGVjdGVkID0gZnVuY3Rpb24gaXNTZWxlY3RlZCAoKSB7XG4gIFx0XHR2YXIgb3B0aW9uVmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXG4gIFx0XHRpZiAoIG9wdGlvblZhbHVlID09PSB1bmRlZmluZWQgfHwgIXRoaXMuc2VsZWN0ICkge1xuICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBzZWxlY3RWYWx1ZSA9IHRoaXMuc2VsZWN0LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXG4gIFx0XHRpZiAoIHNlbGVjdFZhbHVlID09IG9wdGlvblZhbHVlICkge1xuICBcdFx0XHRyZXR1cm4gdHJ1ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCB0aGlzLnNlbGVjdC5nZXRBdHRyaWJ1dGUoICdtdWx0aXBsZScgKSAmJiBpc0FycmF5KCBzZWxlY3RWYWx1ZSApICkge1xuICBcdFx0XHR2YXIgaSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcbiAgXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRcdFx0aWYgKCBzZWxlY3RWYWx1ZVtpXSA9PSBvcHRpb25WYWx1ZSApIHtcbiAgXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH07XG5cbiAgXHRPcHRpb24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAoIHRhcmdldCwgb2NjdXBhbnRzICkge1xuICBcdFx0RWxlbWVudC5wcm90b3R5cGUucmVuZGVyLmNhbGwoIHRoaXMsIHRhcmdldCwgb2NjdXBhbnRzICk7XG5cbiAgXHRcdGlmICggIXRoaXMuYXR0cmlidXRlQnlOYW1lLnZhbHVlICkge1xuICBcdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUudmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRPcHRpb24ucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uIHVuYmluZCAoKSB7XG4gIFx0XHRFbGVtZW50LnByb3RvdHlwZS51bmJpbmQuY2FsbCh0aGlzKTtcblxuICBcdFx0aWYgKCB0aGlzLnNlbGVjdCApIHtcbiAgXHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLnNlbGVjdC5vcHRpb25zLCB0aGlzICk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdHJldHVybiBPcHRpb247XG4gIH0oRWxlbWVudCkpO1xuXG4gIGZ1bmN0aW9uIGdldFBhcnRpYWxUZW1wbGF0ZSAoIHJhY3RpdmUsIG5hbWUsIHBhcmVudEZyYWdtZW50ICkge1xuICBcdC8vIElmIHRoZSBwYXJ0aWFsIGluIGluc3RhbmNlIG9yIHZpZXcgaGVpcmFyY2h5IGluc3RhbmNlcywgZ3JlYXRcbiAgXHR2YXIgcGFydGlhbCA9IGdldFBhcnRpYWxGcm9tUmVnaXN0cnkoIHJhY3RpdmUsIG5hbWUsIHBhcmVudEZyYWdtZW50IHx8IHt9ICk7XG4gIFx0aWYgKCBwYXJ0aWFsICkgcmV0dXJuIHBhcnRpYWw7XG5cbiAgXHQvLyBEb2VzIGl0IGV4aXN0IG9uIHRoZSBwYWdlIGFzIGEgc2NyaXB0IHRhZz9cbiAgXHRwYXJ0aWFsID0gcGFyc2VyLmZyb21JZCggbmFtZSwgeyBub1Rocm93OiB0cnVlIH0gKTtcbiAgXHRpZiAoIHBhcnRpYWwgKSB7XG4gIFx0XHQvLyBwYXJzZSBhbmQgcmVnaXN0ZXIgdG8gdGhpcyByYWN0aXZlIGluc3RhbmNlXG4gIFx0XHR2YXIgcGFyc2VkID0gcGFyc2VyLnBhcnNlRm9yKCBwYXJ0aWFsLCByYWN0aXZlICk7XG5cbiAgXHRcdC8vIHJlZ2lzdGVyIGV4dHJhIHBhcnRpYWxzIG9uIHRoZSByYWN0aXZlIGluc3RhbmNlIGlmIHRoZXkgZG9uJ3QgYWxyZWFkeSBleGlzdFxuICBcdFx0aWYgKCBwYXJzZWQucCApIGZpbGxHYXBzKCByYWN0aXZlLnBhcnRpYWxzLCBwYXJzZWQucCApO1xuXG4gIFx0XHQvLyByZWdpc3RlciAoYW5kIHJldHVybiBtYWluIHBhcnRpYWwgaWYgdGhlcmUgYXJlIG90aGVycyBpbiB0aGUgdGVtcGxhdGUpXG4gIFx0XHRyZXR1cm4gcmFjdGl2ZS5wYXJ0aWFsc1sgbmFtZSBdID0gcGFyc2VkLnQ7XG4gIFx0fVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFydGlhbEZyb21SZWdpc3RyeSAoIHJhY3RpdmUsIG5hbWUsIHBhcmVudEZyYWdtZW50ICkge1xuICBcdC8vIGlmIHRoZXJlIHdhcyBhbiBpbnN0YW5jZSB1cC1oaWVyYXJjaHksIGNvb2xcbiAgXHR2YXIgcGFydGlhbCA9IGZpbmRQYXJlbnRQYXJ0aWFsKCBuYW1lLCBwYXJlbnRGcmFnbWVudC5vd25lciApO1xuICBcdGlmICggcGFydGlhbCApIHJldHVybiBwYXJ0aWFsO1xuXG4gIFx0Ly8gZmluZCBmaXJzdCBpbnN0YW5jZSBpbiB0aGUgcmFjdGl2ZSBvciB2aWV3IGhpZXJhcmNoeSB0aGF0IGhhcyB0aGlzIHBhcnRpYWxcbiAgXHR2YXIgaW5zdGFuY2UgPSBmaW5kSW5zdGFuY2UoICdwYXJ0aWFscycsIHJhY3RpdmUsIG5hbWUgKTtcblxuICBcdGlmICggIWluc3RhbmNlICkgeyByZXR1cm47IH1cblxuICBcdHBhcnRpYWwgPSBpbnN0YW5jZS5wYXJ0aWFsc1sgbmFtZSBdO1xuXG4gIFx0Ly8gcGFydGlhbCBpcyBhIGZ1bmN0aW9uP1xuICBcdHZhciBmbjtcbiAgXHRpZiAoIHR5cGVvZiBwYXJ0aWFsID09PSAnZnVuY3Rpb24nICkge1xuICBcdFx0Zm4gPSBwYXJ0aWFsLmJpbmQoIGluc3RhbmNlICk7XG4gIFx0XHRmbi5pc093bmVyID0gaW5zdGFuY2UucGFydGlhbHMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIFx0XHRwYXJ0aWFsID0gZm4uY2FsbCggcmFjdGl2ZSwgcGFyc2VyICk7XG4gIFx0fVxuXG4gIFx0aWYgKCAhcGFydGlhbCAmJiBwYXJ0aWFsICE9PSAnJyApIHtcbiAgXHRcdHdhcm5JZkRlYnVnKCBub1JlZ2lzdHJ5RnVuY3Rpb25SZXR1cm4sIG5hbWUsICdwYXJ0aWFsJywgJ3BhcnRpYWwnLCB7IHJhY3RpdmU6IHJhY3RpdmUgfSk7XG4gIFx0XHRyZXR1cm47XG4gIFx0fVxuXG4gIFx0Ly8gSWYgdGhpcyB3YXMgYWRkZWQgbWFudWFsbHkgdG8gdGhlIHJlZ2lzdHJ5LFxuICBcdC8vIGJ1dCBoYXNuJ3QgYmVlbiBwYXJzZWQsIHBhcnNlIGl0IG5vd1xuICBcdGlmICggIXBhcnNlci5pc1BhcnNlZCggcGFydGlhbCApICkge1xuICBcdFx0Ly8gdXNlIHRoZSBwYXJzZU9wdGlvbnMgb2YgdGhlIHJhY3RpdmUgaW5zdGFuY2Ugb24gd2hpY2ggaXQgd2FzIGZvdW5kXG4gIFx0XHR2YXIgcGFyc2VkID0gcGFyc2VyLnBhcnNlRm9yKCBwYXJ0aWFsLCBpbnN0YW5jZSApO1xuXG4gIFx0XHQvLyBQYXJ0aWFscyBjYW5ub3QgY29udGFpbiBuZXN0ZWQgcGFydGlhbHMhXG4gIFx0XHQvLyBUT0RPIGFkZCBhIHRlc3QgZm9yIHRoaXNcbiAgXHRcdGlmICggcGFyc2VkLnAgKSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKCAnUGFydGlhbHMgKHt7PiVzfX0pIGNhbm5vdCBjb250YWluIG5lc3RlZCBpbmxpbmUgcGFydGlhbHMnLCBuYW1lLCB7IHJhY3RpdmU6IHJhY3RpdmUgfSk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlmIGZuLCB1c2UgaW5zdGFuY2UgdG8gc3RvcmUgcmVzdWx0LCBvdGhlcndpc2UgbmVlZHMgdG8gZ29cbiAgXHRcdC8vIGluIHRoZSBjb3JyZWN0IHBvaW50IGluIHByb3RvdHlwZSBjaGFpbiBvbiBpbnN0YW5jZSBvciBjb25zdHJ1Y3RvclxuICBcdFx0dmFyIHRhcmdldCA9IGZuID8gaW5zdGFuY2UgOiBmaW5kT3duZXIoIGluc3RhbmNlLCBuYW1lICk7XG5cbiAgXHRcdC8vIG1heSBiZSBhIHRlbXBsYXRlIHdpdGggcGFydGlhbHMsIHdoaWNoIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCBhbmQgbWFpbiB0ZW1wbGF0ZSBleHRyYWN0ZWRcbiAgXHRcdHRhcmdldC5wYXJ0aWFsc1sgbmFtZSBdID0gcGFydGlhbCA9IHBhcnNlZC50O1xuICBcdH1cblxuICBcdC8vIHN0b3JlIGZvciByZXNldFxuICBcdGlmICggZm4gKSBwYXJ0aWFsLl9mbiA9IGZuO1xuXG4gIFx0cmV0dXJuIHBhcnRpYWwudiA/IHBhcnRpYWwudCA6IHBhcnRpYWw7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kT3duZXIgKCByYWN0aXZlLCBrZXkgKSB7XG4gIFx0cmV0dXJuIHJhY3RpdmUucGFydGlhbHMuaGFzT3duUHJvcGVydHkoIGtleSApXG4gIFx0XHQ/IHJhY3RpdmVcbiAgXHRcdDogZmluZENvbnN0cnVjdG9yKCByYWN0aXZlLmNvbnN0cnVjdG9yLCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZENvbnN0cnVjdG9yICggY29uc3RydWN0b3IsIGtleSApIHtcbiAgXHRpZiAoICFjb25zdHJ1Y3RvciApIHsgcmV0dXJuOyB9XG4gIFx0cmV0dXJuIGNvbnN0cnVjdG9yLnBhcnRpYWxzLmhhc093blByb3BlcnR5KCBrZXkgKVxuICBcdFx0PyBjb25zdHJ1Y3RvclxuICBcdFx0OiBmaW5kQ29uc3RydWN0b3IoIGNvbnN0cnVjdG9yLl9QYXJlbnQsIGtleSApO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFBhcmVudFBhcnRpYWwoIG5hbWUsIHBhcmVudCApIHtcbiAgXHRpZiAoIHBhcmVudCApIHtcbiAgXHRcdGlmICggcGFyZW50LnRlbXBsYXRlICYmIHBhcmVudC50ZW1wbGF0ZS5wICYmIHBhcmVudC50ZW1wbGF0ZS5wW25hbWVdICkge1xuICBcdFx0XHRyZXR1cm4gcGFyZW50LnRlbXBsYXRlLnBbbmFtZV07XG4gIFx0XHR9IGVsc2UgaWYgKCBwYXJlbnQucGFyZW50RnJhZ21lbnQgJiYgcGFyZW50LnBhcmVudEZyYWdtZW50Lm93bmVyICkge1xuICBcdFx0XHRyZXR1cm4gZmluZFBhcmVudFBhcnRpYWwoIG5hbWUsIHBhcmVudC5wYXJlbnRGcmFnbWVudC5vd25lciApO1xuICBcdFx0fVxuICBcdH1cbiAgfVxuXG4gIHZhciBQYXJ0aWFsID0gKGZ1bmN0aW9uIChNdXN0YWNoZSkge1xuICBcdGZ1bmN0aW9uIFBhcnRpYWwgKCkge1xuICBcdFx0TXVzdGFjaGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXHR9XG5cbiAgXHRQYXJ0aWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE11c3RhY2hlICYmIE11c3RhY2hlLnByb3RvdHlwZSApO1xuICBcdFBhcnRpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFydGlhbDtcblxuICBcdFBhcnRpYWwucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiBiaW5kICgpIHtcbiAgXHRcdC8vIGtlZXAgdHJhY2sgb2YgdGhlIHJlZmVyZW5jZSBuYW1lIGZvciBmdXR1cmUgcmVzZXRzXG4gIFx0XHR0aGlzLnJlZk5hbWUgPSB0aGlzLnRlbXBsYXRlLnI7XG5cbiAgXHRcdC8vIG5hbWUgbWF0Y2hlcyB0YWtlIHByaW9yaXR5IG92ZXIgZXhwcmVzc2lvbnNcbiAgXHRcdHZhciB0ZW1wbGF0ZSA9IHRoaXMucmVmTmFtZSA/IGdldFBhcnRpYWxUZW1wbGF0ZSggdGhpcy5yYWN0aXZlLCB0aGlzLnJlZk5hbWUsIHRoaXMucGFyZW50RnJhZ21lbnQgKSB8fCBudWxsIDogbnVsbDtcbiAgXHRcdHZhciB0ZW1wbGF0ZU9iajtcblxuICBcdFx0aWYgKCB0ZW1wbGF0ZSApIHtcbiAgXHRcdFx0dGhpcy5uYW1lZCA9IHRydWU7XG4gIFx0XHRcdHRoaXMuc2V0VGVtcGxhdGUoIHRoaXMudGVtcGxhdGUuciwgdGVtcGxhdGUgKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCAhdGVtcGxhdGUgKSB7XG4gIFx0XHRcdE11c3RhY2hlLnByb3RvdHlwZS5iaW5kLmNhbGwodGhpcyk7XG4gIFx0XHRcdGlmICggdGhpcy5tb2RlbCAmJiAoIHRlbXBsYXRlT2JqID0gdGhpcy5tb2RlbC5nZXQoKSApICYmIHR5cGVvZiB0ZW1wbGF0ZU9iaiA9PT0gJ29iamVjdCcgJiYgKCB0eXBlb2YgdGVtcGxhdGVPYmoudGVtcGxhdGUgPT09ICdzdHJpbmcnIHx8IGlzQXJyYXkoIHRlbXBsYXRlT2JqLnQgKSApICkge1xuICBcdFx0XHRcdGlmICggdGVtcGxhdGVPYmoudGVtcGxhdGUgKSB7XG4gIFx0XHRcdFx0XHR0aGlzLnNvdXJjZSA9IHRlbXBsYXRlT2JqLnRlbXBsYXRlO1xuICBcdFx0XHRcdFx0dGVtcGxhdGVPYmogPSBwYXJzZVBhcnRpYWwoIHRoaXMudGVtcGxhdGUuciwgdGVtcGxhdGVPYmoudGVtcGxhdGUsIHRoaXMucmFjdGl2ZSApO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHR0aGlzLnNvdXJjZSA9IHRlbXBsYXRlT2JqLnQ7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHRcdHRoaXMuc2V0VGVtcGxhdGUoIHRoaXMudGVtcGxhdGUuciwgdGVtcGxhdGVPYmoudCApO1xuICBcdFx0XHR9IGVsc2UgaWYgKCAoICF0aGlzLm1vZGVsIHx8IHR5cGVvZiB0aGlzLm1vZGVsLmdldCgpICE9PSAnc3RyaW5nJyApICYmIHRoaXMucmVmTmFtZSApIHtcbiAgXHRcdFx0XHR0aGlzLnNldFRlbXBsYXRlKCB0aGlzLnJlZk5hbWUsIHRlbXBsYXRlICk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0dGhpcy5zZXRUZW1wbGF0ZSggdGhpcy5tb2RlbC5nZXQoKSApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoe1xuICBcdFx0XHRvd25lcjogdGhpcyxcbiAgXHRcdFx0dGVtcGxhdGU6IHRoaXMucGFydGlhbFRlbXBsYXRlXG4gIFx0XHR9KS5iaW5kKCk7XG4gIFx0fTtcblxuICBcdFBhcnRpYWwucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIGRldGFjaCAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcbiAgXHR9O1xuXG4gIFx0UGFydGlhbC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIGZpbmQgKCBzZWxlY3RvciApIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG4gIFx0fTtcblxuICBcdFBhcnRpYWwucHJvdG90eXBlLmZpbmRBbGwgPSBmdW5jdGlvbiBmaW5kQWxsICggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcbiAgXHR9O1xuXG4gIFx0UGFydGlhbC5wcm90b3R5cGUuZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIGZpbmRDb21wb25lbnQgKCBuYW1lICkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudCggbmFtZSApO1xuICBcdH07XG5cbiAgXHRQYXJ0aWFsLnByb3RvdHlwZS5maW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGZpbmRBbGxDb21wb25lbnRzICggbmFtZSwgcXVlcnkgKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBuYW1lLCBxdWVyeSApO1xuICBcdH07XG5cbiAgXHRQYXJ0aWFsLnByb3RvdHlwZS5maXJzdE5vZGUgPSBmdW5jdGlvbiBmaXJzdE5vZGUgKCBza2lwUGFyZW50ICkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmlyc3ROb2RlKCBza2lwUGFyZW50ICk7XG4gIFx0fTtcblxuICBcdFBhcnRpYWwucHJvdG90eXBlLmZvcmNlUmVzZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uIGZvcmNlUmVzZXRUZW1wbGF0ZSAoKSB7XG4gIFx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dGhpcy5wYXJ0aWFsVGVtcGxhdGUgPSB1bmRlZmluZWQ7XG5cbiAgXHRcdC8vIG9uIHJlc2V0LCBjaGVjayBmb3IgdGhlIHJlZmVyZW5jZSBuYW1lIGZpcnN0XG4gIFx0XHRpZiAoIHRoaXMucmVmTmFtZSApIHtcbiAgXHRcdFx0dGhpcy5wYXJ0aWFsVGVtcGxhdGUgPSBnZXRQYXJ0aWFsVGVtcGxhdGUoIHRoaXMucmFjdGl2ZSwgdGhpcy5yZWZOYW1lLCB0aGlzLnBhcmVudEZyYWdtZW50ICk7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIHRoZW4gbG9vayBmb3IgdGhlIHJlc29sdmVkIG5hbWVcbiAgXHRcdGlmICggIXRoaXMucGFydGlhbFRlbXBsYXRlICkge1xuICBcdFx0XHR0aGlzLnBhcnRpYWxUZW1wbGF0ZSA9IGdldFBhcnRpYWxUZW1wbGF0ZSggdGhpcy5yYWN0aXZlLCB0aGlzLm5hbWUsIHRoaXMucGFyZW50RnJhZ21lbnQgKTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCAhdGhpcy5wYXJ0aWFsVGVtcGxhdGUgKSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyggKFwiQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZm9yIHBhcnRpYWwgJ1wiICsgKHRoaXMubmFtZSkgKyBcIidcIikgKTtcbiAgXHRcdFx0dGhpcy5wYXJ0aWFsVGVtcGxhdGUgPSBbXTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCB0aGlzLmluQXR0cmlidXRlICkge1xuICBcdFx0XHRkb0luQXR0cmlidXRlcyggZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmZyYWdtZW50LnJlc2V0VGVtcGxhdGUoIHRoaXMkMS5wYXJ0aWFsVGVtcGxhdGUgKTsgfSApO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC5yZXNldFRlbXBsYXRlKCB0aGlzLnBhcnRpYWxUZW1wbGF0ZSApO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLmJ1YmJsZSgpO1xuICBcdH07XG5cbiAgXHRQYXJ0aWFsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKCB0YXJnZXQsIG9jY3VwYW50cyApIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQucmVuZGVyKCB0YXJnZXQsIG9jY3VwYW50cyApO1xuICBcdH07XG5cbiAgXHRQYXJ0aWFsLnByb3RvdHlwZS5zZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uIHNldFRlbXBsYXRlICggbmFtZSwgdGVtcGxhdGUgKSB7XG4gIFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXG4gIFx0XHRpZiAoICF0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZSAhPT0gbnVsbCApIHRlbXBsYXRlID0gZ2V0UGFydGlhbFRlbXBsYXRlKCB0aGlzLnJhY3RpdmUsIG5hbWUsIHRoaXMucGFyZW50RnJhZ21lbnQgKTtcblxuICBcdFx0aWYgKCAhdGVtcGxhdGUgKSB7XG4gIFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyggKFwiQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZm9yIHBhcnRpYWwgJ1wiICsgbmFtZSArIFwiJ1wiKSApO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzLnBhcnRpYWxUZW1wbGF0ZSA9IHRlbXBsYXRlIHx8IFtdO1xuICBcdH07XG5cbiAgXHRQYXJ0aWFsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICggZXNjYXBlICkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoIGVzY2FwZSApO1xuICBcdH07XG5cbiAgXHRQYXJ0aWFsLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiB1bmJpbmQgKCkge1xuICBcdFx0TXVzdGFjaGUucHJvdG90eXBlLnVuYmluZC5jYWxsKHRoaXMpO1xuICBcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcbiAgXHR9O1xuXG4gIFx0UGFydGlhbC5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiB1bnJlbmRlciAoIHNob3VsZERlc3Ryb3kgKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKCBzaG91bGREZXN0cm95ICk7XG4gIFx0fTtcblxuICBcdFBhcnRpYWwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIFx0XHR2YXIgdGVtcGxhdGU7XG5cbiAgXHRcdGlmICggdGhpcy5kaXJ0eSApIHtcbiAgXHRcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuXG4gIFx0XHRcdGlmICggIXRoaXMubmFtZWQgKSB7XG4gIFx0XHRcdFx0aWYgKCB0aGlzLm1vZGVsICkge1xuICBcdFx0XHRcdFx0dGVtcGxhdGUgPSB0aGlzLm1vZGVsLmdldCgpO1xuICBcdFx0XHRcdH1cblxuICBcdFx0XHRcdGlmICggdGVtcGxhdGUgJiYgdHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyAmJiB0ZW1wbGF0ZSAhPT0gdGhpcy5uYW1lICkge1xuICBcdFx0XHRcdFx0dGhpcy5zZXRUZW1wbGF0ZSggdGVtcGxhdGUgKTtcbiAgXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQucmVzZXRUZW1wbGF0ZSggdGhpcy5wYXJ0aWFsVGVtcGxhdGUgKTtcbiAgXHRcdFx0XHR9IGVsc2UgaWYgKCB0ZW1wbGF0ZSAmJiB0eXBlb2YgdGVtcGxhdGUgPT09ICdvYmplY3QnICYmICggdHlwZW9mIHRlbXBsYXRlLnRlbXBsYXRlID09PSAnc3RyaW5nJyB8fCBpc0FycmF5KCB0ZW1wbGF0ZS50ICkgKSApIHtcbiAgXHRcdFx0XHRcdGlmICggdGVtcGxhdGUudCAhPT0gdGhpcy5zb3VyY2UgJiYgdGVtcGxhdGUudGVtcGxhdGUgIT09IHRoaXMuc291cmNlICkge1xuICBcdFx0XHRcdFx0XHRpZiAoIHRlbXBsYXRlLnRlbXBsYXRlICkge1xuICBcdFx0XHRcdFx0XHRcdHRoaXMuc291cmNlID0gdGVtcGxhdGUudGVtcGxhdGU7XG4gIFx0XHRcdFx0XHRcdFx0dGVtcGxhdGUgPSBwYXJzZVBhcnRpYWwoIHRoaXMubmFtZSwgdGVtcGxhdGUudGVtcGxhdGUsIHRoaXMucmFjdGl2ZSApO1xuICBcdFx0XHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0XHRcdHRoaXMuc291cmNlID0gdGVtcGxhdGUudDtcbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHR0aGlzLnNldFRlbXBsYXRlKCB0aGlzLm5hbWUsIHRlbXBsYXRlLnQgKTtcbiAgXHRcdFx0XHRcdFx0dGhpcy5mcmFnbWVudC5yZXNldFRlbXBsYXRlKCB0aGlzLnBhcnRpYWxUZW1wbGF0ZSApO1xuICBcdFx0XHRcdFx0fVxuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHRoaXMuZnJhZ21lbnQudXBkYXRlKCk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdHJldHVybiBQYXJ0aWFsO1xuICB9KE11c3RhY2hlKSk7XG5cbiAgZnVuY3Rpb24gcGFyc2VQYXJ0aWFsKCBuYW1lLCBwYXJ0aWFsLCByYWN0aXZlICkge1xuICBcdHZhciBwYXJzZWQ7XG5cbiAgXHR0cnkge1xuICBcdFx0cGFyc2VkID0gcGFyc2VyLnBhcnNlKCBwYXJ0aWFsLCBwYXJzZXIuZ2V0UGFyc2VPcHRpb25zKCByYWN0aXZlICkgKTtcbiAgXHR9IGNhdGNoIChlKSB7XG4gIFx0XHR3YXJuSWZEZWJ1ZyggKFwiQ291bGQgbm90IHBhcnNlIHBhcnRpYWwgZnJvbSBleHByZXNzaW9uICdcIiArIG5hbWUgKyBcIidcXG5cIiArIChlLm1lc3NhZ2UpKSApO1xuICBcdH1cblxuICBcdHJldHVybiBwYXJzZWQgfHwgeyB0OiBbXSB9O1xuICB9XG5cbiAgdmFyIFJlcGVhdGVkRnJhZ21lbnQgPSBmdW5jdGlvbiBSZXBlYXRlZEZyYWdtZW50ICggb3B0aW9ucyApIHtcbiAgXHR0aGlzLnBhcmVudCA9IG9wdGlvbnMub3duZXIucGFyZW50RnJhZ21lbnQ7XG5cbiAgXHQvLyBiaXQgb2YgYSBoYWNrLCBzbyByZWZlcmVuY2UgcmVzb2x1dGlvbiB3b3JrcyB3aXRob3V0IGFub3RoZXJcbiAgXHQvLyBsYXllciBvZiBpbmRpcmVjdGlvblxuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSB0aGlzO1xuICBcdHRoaXMub3duZXIgPSBvcHRpb25zLm93bmVyO1xuICBcdHRoaXMucmFjdGl2ZSA9IHRoaXMucGFyZW50LnJhY3RpdmU7XG5cbiAgXHQvLyBlbmNhcHN1bGF0ZWQgc3R5bGVzIHNob3VsZCBiZSBpbmhlcml0ZWQgdW50aWwgdGhleSBnZXQgYXBwbGllZCBieSBhbiBlbGVtZW50XG4gIFx0dGhpcy5jc3NJZHMgPSAnY3NzSWRzJyBpbiBvcHRpb25zID8gb3B0aW9ucy5jc3NJZHMgOiAoIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuY3NzSWRzIDogbnVsbCApO1xuXG4gIFx0dGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgXHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gIFx0dGhpcy5pdGVyYXRpb25zID0gW107XG5cbiAgXHR0aGlzLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblxuICBcdHRoaXMuaW5kZXhSZWYgPSBvcHRpb25zLmluZGV4UmVmO1xuICBcdHRoaXMua2V5UmVmID0gb3B0aW9ucy5rZXlSZWY7XG5cbiAgXHR0aGlzLnBlbmRpbmdOZXdJbmRpY2VzID0gbnVsbDtcbiAgXHR0aGlzLnByZXZpb3VzSXRlcmF0aW9ucyA9IG51bGw7XG5cbiAgXHQvLyB0cmFjayBhcnJheSB2ZXJzdXMgb2JqZWN0IHNvIHVwZGF0ZXMgb2YgdHlwZSByZXN0XG4gIFx0dGhpcy5pc0FycmF5ID0gZmFsc2U7XG4gIH07XG5cbiAgUmVwZWF0ZWRGcmFnbWVudC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIGJpbmQgKCBjb250ZXh0ICkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICBcdHZhciB2YWx1ZSA9IGNvbnRleHQuZ2V0KCk7XG5cbiAgXHQvLyB7eyNlYWNoIGFycmF5fX0uLi5cbiAgXHRpZiAoIHRoaXMuaXNBcnJheSA9IGlzQXJyYXkoIHZhbHVlICkgKSB7XG4gIFx0XHQvLyB3ZSBjYW4ndCB1c2UgbWFwLCBiZWNhdXNlIG9mIHNwYXJzZSBhcnJheXNcbiAgXHRcdHRoaXMuaXRlcmF0aW9ucyA9IFtdO1xuICBcdFx0dmFyIG1heCA9IHZhbHVlLmxlbmd0aDtcbiAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1heDsgaSArPSAxICkge1xuICBcdFx0XHR0aGlzJDEuaXRlcmF0aW9uc1tpXSA9IHRoaXMkMS5jcmVhdGVJdGVyYXRpb24oIGksIGkgKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyB7eyNlYWNoIG9iamVjdH19Li4uXG4gIFx0ZWxzZSBpZiAoIGlzT2JqZWN0KCB2YWx1ZSApICkge1xuICBcdFx0dGhpcy5pc0FycmF5ID0gZmFsc2U7XG5cbiAgXHRcdC8vIFRPRE8gdGhpcyBpcyBhIGRyZWFkZnVsIGhhY2suIFRoZXJlIG11c3QgYmUgYSBuZWF0ZXIgd2F5XG4gIFx0XHRpZiAoIHRoaXMuaW5kZXhSZWYgKSB7XG4gIFx0XHRcdHZhciByZWZzID0gdGhpcy5pbmRleFJlZi5zcGxpdCggJywnICk7XG4gIFx0XHRcdHRoaXMua2V5UmVmID0gcmVmc1swXTtcbiAgXHRcdFx0dGhpcy5pbmRleFJlZiA9IHJlZnNbMV07XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMuaXRlcmF0aW9ucyA9IE9iamVjdC5rZXlzKCB2YWx1ZSApLm1hcCggZnVuY3Rpb24gKCBrZXksIGluZGV4ICkge1xuICBcdFx0XHRyZXR1cm4gdGhpcyQxLmNyZWF0ZUl0ZXJhdGlvbigga2V5LCBpbmRleCApO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgUmVwZWF0ZWRGcmFnbWVudC5wcm90b3R5cGUuYnViYmxlID0gZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgXHR0aGlzLm93bmVyLmJ1YmJsZSgpO1xuICB9O1xuXG4gIFJlcGVhdGVkRnJhZ21lbnQucHJvdG90eXBlLmNyZWF0ZUl0ZXJhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdGlvbiAoIGtleSwgaW5kZXggKSB7XG4gIFx0dmFyIGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KHtcbiAgXHRcdG93bmVyOiB0aGlzLFxuICBcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGVcbiAgXHR9KTtcblxuICBcdC8vIFRPRE8gdGhpcyBpcyBhIGJpdCBoYWNreVxuICBcdGZyYWdtZW50LmtleSA9IGtleTtcbiAgXHRmcmFnbWVudC5pbmRleCA9IGluZGV4O1xuICBcdGZyYWdtZW50LmlzSXRlcmF0aW9uID0gdHJ1ZTtcblxuICBcdHZhciBtb2RlbCA9IHRoaXMuY29udGV4dC5qb2luS2V5KCBrZXkgKTtcblxuICBcdC8vIHNldCB1cCBhbiBpdGVyYXRpb24gYWxpYXMgaWYgdGhlcmUgaXMgb25lXG4gIFx0aWYgKCB0aGlzLm93bmVyLnRlbXBsYXRlLnogKSB7XG4gIFx0XHRmcmFnbWVudC5hbGlhc2VzID0ge307XG4gIFx0XHRmcmFnbWVudC5hbGlhc2VzWyB0aGlzLm93bmVyLnRlbXBsYXRlLnpbMF0ubiBdID0gbW9kZWw7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGZyYWdtZW50LmJpbmQoIG1vZGVsICk7XG4gIH07XG5cbiAgUmVwZWF0ZWRGcmFnbWVudC5wcm90b3R5cGUuZGVzdHJveWVkID0gZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgXHR0aGlzLml0ZXJhdGlvbnMuZm9yRWFjaCggZnVuY3Rpb24gKCBpICkgeyByZXR1cm4gaS5kZXN0cm95ZWQoKTsgfSApO1xuICB9O1xuXG4gIFJlcGVhdGVkRnJhZ21lbnQucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIGRldGFjaCAoKSB7XG4gIFx0dmFyIGRvY0ZyYWcgPSBjcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIFx0dGhpcy5pdGVyYXRpb25zLmZvckVhY2goIGZ1bmN0aW9uICggZnJhZ21lbnQgKSB7IHJldHVybiBkb2NGcmFnLmFwcGVuZENoaWxkKCBmcmFnbWVudC5kZXRhY2goKSApOyB9ICk7XG4gIFx0cmV0dXJuIGRvY0ZyYWc7XG4gIH07XG5cbiAgUmVwZWF0ZWRGcmFnbWVudC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIGZpbmQgKCBzZWxlY3RvciApIHtcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dmFyIGxlbiA9IHRoaXMuaXRlcmF0aW9ucy5sZW5ndGg7XG4gIFx0dmFyIGk7XG5cbiAgXHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuICBcdFx0dmFyIGZvdW5kID0gdGhpcyQxLml0ZXJhdGlvbnNbaV0uZmluZCggc2VsZWN0b3IgKTtcbiAgXHRcdGlmICggZm91bmQgKSByZXR1cm4gZm91bmQ7XG4gIFx0fVxuICB9O1xuXG4gIFJlcGVhdGVkRnJhZ21lbnQucHJvdG90eXBlLmZpbmRBbGwgPSBmdW5jdGlvbiBmaW5kQWxsICggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHR2YXIgbGVuID0gdGhpcy5pdGVyYXRpb25zLmxlbmd0aDtcbiAgXHR2YXIgaTtcblxuICBcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG4gIFx0XHR0aGlzJDEuaXRlcmF0aW9uc1tpXS5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcbiAgXHR9XG4gIH07XG5cbiAgUmVwZWF0ZWRGcmFnbWVudC5wcm90b3R5cGUuZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIGZpbmRDb21wb25lbnQgKCBuYW1lICkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHR2YXIgbGVuID0gdGhpcy5pdGVyYXRpb25zLmxlbmd0aDtcbiAgXHR2YXIgaTtcblxuICBcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG4gIFx0XHR2YXIgZm91bmQgPSB0aGlzJDEuaXRlcmF0aW9uc1tpXS5maW5kQ29tcG9uZW50KCBuYW1lICk7XG4gIFx0XHRpZiAoIGZvdW5kICkgcmV0dXJuIGZvdW5kO1xuICBcdH1cbiAgfTtcblxuICBSZXBlYXRlZEZyYWdtZW50LnByb3RvdHlwZS5maW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGZpbmRBbGxDb21wb25lbnRzICggbmFtZSwgcXVlcnkgKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHZhciBsZW4gPSB0aGlzLml0ZXJhdGlvbnMubGVuZ3RoO1xuICBcdHZhciBpO1xuXG4gIFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcbiAgXHRcdHRoaXMkMS5pdGVyYXRpb25zW2ldLmZpbmRBbGxDb21wb25lbnRzKCBuYW1lLCBxdWVyeSApO1xuICBcdH1cbiAgfTtcblxuICBSZXBlYXRlZEZyYWdtZW50LnByb3RvdHlwZS5maW5kTmV4dE5vZGUgPSBmdW5jdGlvbiBmaW5kTmV4dE5vZGUgKCBpdGVyYXRpb24gKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdGlmICggaXRlcmF0aW9uLmluZGV4IDwgdGhpcy5pdGVyYXRpb25zLmxlbmd0aCAtIDEgKSB7XG4gIFx0XHRmb3IgKCB2YXIgaSA9IGl0ZXJhdGlvbi5pbmRleCArIDE7IGkgPCB0aGlzJDEuaXRlcmF0aW9ucy5sZW5ndGg7IGkrKyApIHtcbiAgXHRcdFx0dmFyIG5vZGUgPSB0aGlzJDEuaXRlcmF0aW9uc1sgaSBdLmZpcnN0Tm9kZSggdHJ1ZSApO1xuICBcdFx0XHRpZiAoIG5vZGUgKSByZXR1cm4gbm9kZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcy5vd25lci5maW5kTmV4dE5vZGUoKTtcbiAgfTtcblxuICBSZXBlYXRlZEZyYWdtZW50LnByb3RvdHlwZS5maXJzdE5vZGUgPSBmdW5jdGlvbiBmaXJzdE5vZGUgKCBza2lwUGFyZW50ICkge1xuICBcdHJldHVybiB0aGlzLml0ZXJhdGlvbnNbMF0gPyB0aGlzLml0ZXJhdGlvbnNbMF0uZmlyc3ROb2RlKCBza2lwUGFyZW50ICkgOiBudWxsO1xuICB9O1xuXG4gIFJlcGVhdGVkRnJhZ21lbnQucHJvdG90eXBlLnJlYmluZGluZyA9IGZ1bmN0aW9uIHJlYmluZGluZyAoIG5leHQgKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHRoaXMuY29udGV4dCA9IG5leHQ7XG4gIFx0dGhpcy5pdGVyYXRpb25zLmZvckVhY2goIGZ1bmN0aW9uICggZnJhZ21lbnQgKSB7XG4gIFx0XHR2YXIgbW9kZWwgPSBuZXh0ID8gbmV4dC5qb2luS2V5KCBmcmFnbWVudC5rZXkgfHwgZnJhZ21lbnQuaW5kZXggKSA6IHVuZGVmaW5lZDtcbiAgXHRcdGZyYWdtZW50LmNvbnRleHQgPSBtb2RlbDtcbiAgXHRcdGlmICggdGhpcyQxLm93bmVyLnRlbXBsYXRlLnogKSB7XG4gIFx0XHRcdGZyYWdtZW50LmFsaWFzZXMgPSB7fTtcbiAgXHRcdFx0ZnJhZ21lbnQuYWxpYXNlc1sgdGhpcyQxLm93bmVyLnRlbXBsYXRlLnpbMF0ubiBdID0gbW9kZWw7XG4gIFx0XHR9XG4gIFx0fSk7XG4gIH07XG5cbiAgUmVwZWF0ZWRGcmFnbWVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICggdGFyZ2V0LCBvY2N1cGFudHMgKSB7XG4gIFx0Ly8gVE9ETyB1c2UgZG9jRnJhZy5jbG9uZU5vZGUuLi5cblxuICBcdGlmICggdGhpcy5pdGVyYXRpb25zICkge1xuICBcdFx0dGhpcy5pdGVyYXRpb25zLmZvckVhY2goIGZ1bmN0aW9uICggZnJhZ21lbnQgKSB7IHJldHVybiBmcmFnbWVudC5yZW5kZXIoIHRhcmdldCwgb2NjdXBhbnRzICk7IH0gKTtcbiAgXHR9XG5cbiAgXHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgfTtcblxuICBSZXBlYXRlZEZyYWdtZW50LnByb3RvdHlwZS5zaHVmZmxlID0gZnVuY3Rpb24gc2h1ZmZsZSAoIG5ld0luZGljZXMgKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdGlmICggIXRoaXMucGVuZGluZ05ld0luZGljZXMgKSB0aGlzLnByZXZpb3VzSXRlcmF0aW9ucyA9IHRoaXMuaXRlcmF0aW9ucy5zbGljZSgpO1xuXG4gIFx0aWYgKCAhdGhpcy5wZW5kaW5nTmV3SW5kaWNlcyApIHRoaXMucGVuZGluZ05ld0luZGljZXMgPSBbXTtcblxuICBcdHRoaXMucGVuZGluZ05ld0luZGljZXMucHVzaCggbmV3SW5kaWNlcyApO1xuXG4gIFx0dmFyIGl0ZXJhdGlvbnMgPSBbXTtcblxuICBcdG5ld0luZGljZXMuZm9yRWFjaCggZnVuY3Rpb24gKCBuZXdJbmRleCwgb2xkSW5kZXggKSB7XG4gIFx0XHRpZiAoIG5ld0luZGV4ID09PSAtMSApIHJldHVybjtcblxuICBcdFx0dmFyIGZyYWdtZW50ID0gdGhpcyQxLml0ZXJhdGlvbnNbIG9sZEluZGV4IF07XG4gIFx0XHRpdGVyYXRpb25zWyBuZXdJbmRleCBdID0gZnJhZ21lbnQ7XG5cbiAgXHRcdGlmICggbmV3SW5kZXggIT09IG9sZEluZGV4ICYmIGZyYWdtZW50ICkgZnJhZ21lbnQuZGlydHkgPSB0cnVlO1xuICBcdH0pO1xuXG4gIFx0dGhpcy5pdGVyYXRpb25zID0gaXRlcmF0aW9ucztcblxuICBcdHRoaXMuYnViYmxlKCk7XG4gIH07XG5cbiAgUmVwZWF0ZWRGcmFnbWVudC5wcm90b3R5cGUuc2h1ZmZsZWQgPSBmdW5jdGlvbiBzaHVmZmxlZCAoKSB7XG4gIFx0dGhpcy5pdGVyYXRpb25zLmZvckVhY2goIGZ1bmN0aW9uICggaSApIHsgcmV0dXJuIGkuc2h1ZmZsZWQoKTsgfSApO1xuICB9O1xuXG4gIFJlcGVhdGVkRnJhZ21lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmckMSQkICggZXNjYXBlICkge1xuICBcdHJldHVybiB0aGlzLml0ZXJhdGlvbnMgP1xuICBcdFx0dGhpcy5pdGVyYXRpb25zLm1hcCggZXNjYXBlID8gdG9Fc2NhcGVkU3RyaW5nIDogdG9TdHJpbmckMSApLmpvaW4oICcnICkgOlxuICBcdFx0Jyc7XG4gIH07XG5cbiAgUmVwZWF0ZWRGcmFnbWVudC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gdW5iaW5kJDEgKCkge1xuICBcdHRoaXMuaXRlcmF0aW9ucy5mb3JFYWNoKCB1bmJpbmQgKTtcbiAgXHRyZXR1cm4gdGhpcztcbiAgfTtcblxuICBSZXBlYXRlZEZyYWdtZW50LnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uIHVucmVuZGVyJDEgKCBzaG91bGREZXN0cm95ICkge1xuICBcdHRoaXMuaXRlcmF0aW9ucy5mb3JFYWNoKCBzaG91bGREZXN0cm95ID8gdW5yZW5kZXJBbmREZXN0cm95IDogdW5yZW5kZXIgKTtcbiAgXHRpZiAoIHRoaXMucGVuZGluZ05ld0luZGljZXMgJiYgdGhpcy5wcmV2aW91c0l0ZXJhdGlvbnMgKSB7XG4gIFx0XHR0aGlzLnByZXZpb3VzSXRlcmF0aW9ucy5mb3JFYWNoKCBmdW5jdGlvbiAoIGZyYWdtZW50ICkge1xuICBcdFx0XHRpZiAoIGZyYWdtZW50LnJlbmRlcmVkICkgc2hvdWxkRGVzdHJveSA/IHVucmVuZGVyQW5kRGVzdHJveSggZnJhZ21lbnQgKSA6IHVucmVuZGVyKCBmcmFnbWVudCApO1xuICBcdFx0fSk7XG4gIFx0fVxuICBcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgfTtcblxuICAvLyBUT0RPIHNtYXJ0IHVwZGF0ZVxuICBSZXBlYXRlZEZyYWdtZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUkMSAoKSB7XG4gIFx0Ly8gc2tpcCBkaXJ0eSBjaGVjaywgc2luY2UgdGhpcyBpcyBiYXNpY2FsbHkganVzdCBhIGZhY2FkZVxuXG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdGlmICggdGhpcy5wZW5kaW5nTmV3SW5kaWNlcyApIHtcbiAgXHRcdHRoaXMudXBkYXRlUG9zdFNodWZmbGUoKTtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHRpZiAoIHRoaXMudXBkYXRpbmcgKSByZXR1cm47XG4gIFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cbiAgXHR2YXIgdmFsdWUgPSB0aGlzLmNvbnRleHQuZ2V0KCksXG4gIFx0XHRcdCAgd2FzQXJyYXkgPSB0aGlzLmlzQXJyYXk7XG5cbiAgXHR2YXIgdG9SZW1vdmU7XG4gIFx0dmFyIG9sZEtleXM7XG4gIFx0dmFyIHJlc2V0ID0gdHJ1ZTtcbiAgXHR2YXIgaTtcblxuICBcdGlmICggdGhpcy5pc0FycmF5ID0gaXNBcnJheSggdmFsdWUgKSApIHtcbiAgXHRcdGlmICggd2FzQXJyYXkgKSB7XG4gIFx0XHRcdHJlc2V0ID0gZmFsc2U7XG4gIFx0XHRcdGlmICggdGhpcy5pdGVyYXRpb25zLmxlbmd0aCA+IHZhbHVlLmxlbmd0aCApIHtcbiAgXHRcdFx0XHR0b1JlbW92ZSA9IHRoaXMuaXRlcmF0aW9ucy5zcGxpY2UoIHZhbHVlLmxlbmd0aCApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fSBlbHNlIGlmICggaXNPYmplY3QoIHZhbHVlICkgJiYgIXdhc0FycmF5ICkge1xuICBcdFx0cmVzZXQgPSBmYWxzZTtcbiAgXHRcdHRvUmVtb3ZlID0gW107XG4gIFx0XHRvbGRLZXlzID0ge307XG4gIFx0XHRpID0gdGhpcy5pdGVyYXRpb25zLmxlbmd0aDtcblxuICBcdFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRcdHZhciBmcmFnbWVudCQxID0gdGhpcyQxLml0ZXJhdGlvbnNbaV07XG4gIFx0XHRcdGlmICggZnJhZ21lbnQkMS5rZXkgaW4gdmFsdWUgKSB7XG4gIFx0XHRcdFx0b2xkS2V5c1sgZnJhZ21lbnQkMS5rZXkgXSA9IHRydWU7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0dGhpcyQxLml0ZXJhdGlvbnMuc3BsaWNlKCBpLCAxICk7XG4gIFx0XHRcdFx0dG9SZW1vdmUucHVzaCggZnJhZ21lbnQkMSApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKCByZXNldCApIHtcbiAgXHRcdHRvUmVtb3ZlID0gdGhpcy5pdGVyYXRpb25zO1xuICBcdFx0dGhpcy5pdGVyYXRpb25zID0gW107XG4gIFx0fVxuXG4gIFx0aWYgKCB0b1JlbW92ZSApIHtcbiAgXHRcdHRvUmVtb3ZlLmZvckVhY2goIGZ1bmN0aW9uICggZnJhZ21lbnQgKSB7XG4gIFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuICBcdFx0XHRmcmFnbWVudC51bnJlbmRlciggdHJ1ZSApO1xuICBcdFx0fSk7XG4gIFx0fVxuXG4gIFx0Ly8gdXBkYXRlIHRoZSByZW1haW5pbmcgb25lc1xuICBcdHRoaXMuaXRlcmF0aW9ucy5mb3JFYWNoKCB1cGRhdGUgKTtcblxuICBcdC8vIGFkZCBuZXcgaXRlcmF0aW9uc1xuICBcdHZhciBuZXdMZW5ndGggPSBpc0FycmF5KCB2YWx1ZSApID9cbiAgXHRcdHZhbHVlLmxlbmd0aCA6XG4gIFx0XHRpc09iamVjdCggdmFsdWUgKSA/XG4gIFx0XHRcdE9iamVjdC5rZXlzKCB2YWx1ZSApLmxlbmd0aCA6XG4gIFx0XHRcdDA7XG5cbiAgXHR2YXIgZG9jRnJhZztcbiAgXHR2YXIgZnJhZ21lbnQ7XG5cbiAgXHRpZiAoIG5ld0xlbmd0aCA+IHRoaXMuaXRlcmF0aW9ucy5sZW5ndGggKSB7XG4gIFx0XHRkb2NGcmFnID0gdGhpcy5yZW5kZXJlZCA/IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSA6IG51bGw7XG4gIFx0XHRpID0gdGhpcy5pdGVyYXRpb25zLmxlbmd0aDtcblxuICBcdFx0aWYgKCBpc0FycmF5KCB2YWx1ZSApICkge1xuICBcdFx0XHR3aGlsZSAoIGkgPCB2YWx1ZS5sZW5ndGggKSB7XG4gIFx0XHRcdFx0ZnJhZ21lbnQgPSB0aGlzJDEuY3JlYXRlSXRlcmF0aW9uKCBpLCBpICk7XG5cbiAgXHRcdFx0XHR0aGlzJDEuaXRlcmF0aW9ucy5wdXNoKCBmcmFnbWVudCApO1xuICBcdFx0XHRcdGlmICggdGhpcyQxLnJlbmRlcmVkICkgZnJhZ21lbnQucmVuZGVyKCBkb2NGcmFnICk7XG5cbiAgXHRcdFx0XHRpICs9IDE7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0ZWxzZSBpZiAoIGlzT2JqZWN0KCB2YWx1ZSApICkge1xuICBcdFx0XHQvLyBUT0RPIHRoaXMgaXMgYSBkcmVhZGZ1bCBoYWNrLiBUaGVyZSBtdXN0IGJlIGEgbmVhdGVyIHdheVxuICBcdFx0XHRpZiAoIHRoaXMuaW5kZXhSZWYgJiYgIXRoaXMua2V5UmVmICkge1xuICBcdFx0XHRcdHZhciByZWZzID0gdGhpcy5pbmRleFJlZi5zcGxpdCggJywnICk7XG4gIFx0XHRcdFx0dGhpcy5rZXlSZWYgPSByZWZzWzBdO1xuICBcdFx0XHRcdHRoaXMuaW5kZXhSZWYgPSByZWZzWzFdO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0T2JqZWN0LmtleXMoIHZhbHVlICkuZm9yRWFjaCggZnVuY3Rpb24gKCBrZXkgKSB7XG4gIFx0XHRcdFx0aWYgKCAhb2xkS2V5cyB8fCAhKCBrZXkgaW4gb2xkS2V5cyApICkge1xuICBcdFx0XHRcdFx0ZnJhZ21lbnQgPSB0aGlzJDEuY3JlYXRlSXRlcmF0aW9uKCBrZXksIGkgKTtcblxuICBcdFx0XHRcdFx0dGhpcyQxLml0ZXJhdGlvbnMucHVzaCggZnJhZ21lbnQgKTtcbiAgXHRcdFx0XHRcdGlmICggdGhpcyQxLnJlbmRlcmVkICkgZnJhZ21lbnQucmVuZGVyKCBkb2NGcmFnICk7XG5cbiAgXHRcdFx0XHRcdGkgKz0gMTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0pO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG4gIFx0XHRcdHZhciBwYXJlbnROb2RlID0gdGhpcy5wYXJlbnQuZmluZFBhcmVudE5vZGUoKTtcbiAgXHRcdFx0dmFyIGFuY2hvciA9IHRoaXMucGFyZW50LmZpbmROZXh0Tm9kZSggdGhpcy5vd25lciApO1xuXG4gIFx0XHRcdHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBkb2NGcmFnLCBhbmNob3IgKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG4gIH07XG5cbiAgUmVwZWF0ZWRGcmFnbWVudC5wcm90b3R5cGUudXBkYXRlUG9zdFNodWZmbGUgPSBmdW5jdGlvbiB1cGRhdGVQb3N0U2h1ZmZsZSAoKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHZhciBuZXdJbmRpY2VzID0gdGhpcy5wZW5kaW5nTmV3SW5kaWNlc1sgMCBdO1xuXG4gIFx0Ly8gbWFwIGZpcnN0IHNodWZmbGUgdGhyb3VnaFxuICBcdHRoaXMucGVuZGluZ05ld0luZGljZXMuc2xpY2UoIDEgKS5mb3JFYWNoKCBmdW5jdGlvbiAoIGluZGljZXMgKSB7XG4gIFx0XHRuZXdJbmRpY2VzLmZvckVhY2goIGZ1bmN0aW9uICggbmV3SW5kZXgsIG9sZEluZGV4ICkge1xuICBcdFx0XHRuZXdJbmRpY2VzWyBvbGRJbmRleCBdID0gaW5kaWNlc1sgbmV3SW5kZXggXTtcbiAgXHRcdH0pO1xuICBcdH0pO1xuXG4gIFx0Ly8gVGhpcyBhbGdvcml0aG0gKGZvciBkZXRhY2hpbmcgaW5jb3JyZWN0bHktb3JkZXJlZCBmcmFnbWVudHMgZnJvbSB0aGUgRE9NIGFuZFxuICBcdC8vIHN0b3JpbmcgdGhlbSBpbiBhIGRvY3VtZW50IGZyYWdtZW50IGZvciBsYXRlciByZWluc2VydGlvbikgc2VlbXMgYSBiaXQgaG9rZXksXG4gIFx0Ly8gYnV0IGl0IHNlZW1zIHRvIHdvcmsgZm9yIG5vd1xuICBcdHZhciBsZW4gPSB0aGlzLmNvbnRleHQuZ2V0KCkubGVuZ3RoLCBvbGRMZW4gPSB0aGlzLnByZXZpb3VzSXRlcmF0aW9ucy5sZW5ndGg7XG4gIFx0dmFyIGk7XG4gIFx0dmFyIHJlbW92ZWQgPSB7fTtcblxuICBcdG5ld0luZGljZXMuZm9yRWFjaCggZnVuY3Rpb24gKCBuZXdJbmRleCwgb2xkSW5kZXggKSB7XG4gIFx0XHR2YXIgZnJhZ21lbnQgPSB0aGlzJDEucHJldmlvdXNJdGVyYXRpb25zWyBvbGRJbmRleCBdO1xuICBcdFx0dGhpcyQxLnByZXZpb3VzSXRlcmF0aW9uc1sgb2xkSW5kZXggXSA9IG51bGw7XG5cbiAgXHRcdGlmICggbmV3SW5kZXggPT09IC0xICkge1xuICBcdFx0XHRyZW1vdmVkWyBvbGRJbmRleCBdID0gZnJhZ21lbnQ7XG4gIFx0XHR9IGVsc2UgaWYgKCBmcmFnbWVudC5pbmRleCAhPT0gbmV3SW5kZXggKSB7XG4gIFx0XHRcdHZhciBtb2RlbCA9IHRoaXMkMS5jb250ZXh0LmpvaW5LZXkoIG5ld0luZGV4ICk7XG4gIFx0XHRcdGZyYWdtZW50LmluZGV4ID0gbmV3SW5kZXg7XG4gIFx0XHRcdGZyYWdtZW50LmNvbnRleHQgPSBtb2RlbDtcbiAgXHRcdFx0aWYgKCB0aGlzJDEub3duZXIudGVtcGxhdGUueiApIHtcbiAgXHRcdFx0XHRmcmFnbWVudC5hbGlhc2VzID0ge307XG4gIFx0XHRcdFx0ZnJhZ21lbnQuYWxpYXNlc1sgdGhpcyQxLm93bmVyLnRlbXBsYXRlLnpbMF0ubiBdID0gbW9kZWw7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9KTtcblxuICBcdC8vIGlmIHRoZSBhcnJheSB3YXMgc3BsaWNlZCBvdXRzaWRlIG9mIHJhY3RpdmUsIHNvbWV0aW1lcyB0aGVyZSBhcmUgbGVmdG92ZXIgZnJhZ21lbnRzIG5vdCBpbiB0aGUgbmV3SW5kaWNlc1xuICBcdHRoaXMucHJldmlvdXNJdGVyYXRpb25zLmZvckVhY2goIGZ1bmN0aW9uICggZnJhZywgaSApIHtcbiAgXHRcdGlmICggZnJhZyApIHJlbW92ZWRbIGkgXSA9IGZyYWc7XG4gIFx0fSk7XG5cbiAgXHQvLyBjcmVhdGUgbmV3L21vdmUgZXhpc3RpbmcgaXRlcmF0aW9uc1xuICBcdHZhciBkb2NGcmFnID0gdGhpcy5yZW5kZXJlZCA/IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSA6IG51bGw7XG4gIFx0dmFyIHBhcmVudE5vZGUgPSB0aGlzLnJlbmRlcmVkID8gdGhpcy5wYXJlbnQuZmluZFBhcmVudE5vZGUoKSA6IG51bGw7XG5cbiAgXHR2YXIgY29udGlndW91cyA9ICdzdGFydEluZGV4JyBpbiBuZXdJbmRpY2VzO1xuICBcdGkgPSBjb250aWd1b3VzID8gbmV3SW5kaWNlcy5zdGFydEluZGV4IDogMDtcblxuICBcdGZvciAoIGk7IGkgPCBsZW47IGkrKyApIHtcbiAgXHRcdHZhciBmcmFnID0gdGhpcyQxLml0ZXJhdGlvbnNbaV07XG5cbiAgXHRcdGlmICggZnJhZyAmJiBjb250aWd1b3VzICkge1xuICBcdFx0XHQvLyBhdHRhY2ggYW55IGJ1aWx0LXVwIGl0ZXJhdGlvbnNcbiAgXHRcdFx0aWYgKCB0aGlzJDEucmVuZGVyZWQgKSB7XG4gIFx0XHRcdFx0aWYgKCByZW1vdmVkW2ldICkgZG9jRnJhZy5hcHBlbmRDaGlsZCggcmVtb3ZlZFtpXS5kZXRhY2goKSApO1xuICBcdFx0XHRcdGlmICggZG9jRnJhZy5jaGlsZE5vZGVzLmxlbmd0aCAgKSBwYXJlbnROb2RlLmluc2VydEJlZm9yZSggZG9jRnJhZywgZnJhZy5maXJzdE5vZGUoKSApO1xuICBcdFx0XHR9XG4gIFx0XHRcdGNvbnRpbnVlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoICFmcmFnICkgdGhpcyQxLml0ZXJhdGlvbnNbaV0gPSB0aGlzJDEuY3JlYXRlSXRlcmF0aW9uKCBpLCBpICk7XG5cbiAgXHRcdGlmICggdGhpcyQxLnJlbmRlcmVkICkge1xuICBcdFx0XHRpZiAoIHJlbW92ZWRbaV0gKSBkb2NGcmFnLmFwcGVuZENoaWxkKCByZW1vdmVkW2ldLmRldGFjaCgpICk7XG5cbiAgXHRcdFx0aWYgKCBmcmFnICkgZG9jRnJhZy5hcHBlbmRDaGlsZCggZnJhZy5kZXRhY2goKSApO1xuICBcdFx0XHRlbHNlIHtcbiAgXHRcdFx0XHR0aGlzJDEuaXRlcmF0aW9uc1tpXS5yZW5kZXIoIGRvY0ZyYWcgKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdC8vIGFwcGVuZCBhbnkgbGVmdG92ZXJzXG4gIFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuICBcdFx0Zm9yICggaSA9IGxlbjsgaSA8IG9sZExlbjsgaSsrICkge1xuICBcdFx0XHRpZiAoIHJlbW92ZWRbaV0gKSBkb2NGcmFnLmFwcGVuZENoaWxkKCByZW1vdmVkW2ldLmRldGFjaCgpICk7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICggZG9jRnJhZy5jaGlsZE5vZGVzLmxlbmd0aCApIHtcbiAgXHRcdFx0cGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGRvY0ZyYWcsIHRoaXMub3duZXIuZmluZE5leHROb2RlKCkgKTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHQvLyB0cmlnZ2VyIHJlbW92YWwgb24gb2xkIG5vZGVzXG4gIFx0T2JqZWN0LmtleXMoIHJlbW92ZWQgKS5mb3JFYWNoKCBmdW5jdGlvbiAoIGsgKSB7IHJldHVybiByZW1vdmVkW2tdLnVuYmluZCgpLnVucmVuZGVyKCB0cnVlICk7IH0gKTtcblxuICBcdHRoaXMuaXRlcmF0aW9ucy5mb3JFYWNoKCB1cGRhdGUgKTtcblxuICBcdHRoaXMucGVuZGluZ05ld0luZGljZXMgPSBudWxsO1xuXG4gIFx0dGhpcy5zaHVmZmxlZCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGlzRW1wdHkgKCB2YWx1ZSApIHtcbiAgXHRyZXR1cm4gIXZhbHVlIHx8XG4gIFx0ICAgICAgICggaXNBcnJheSggdmFsdWUgKSAmJiB2YWx1ZS5sZW5ndGggPT09IDAgKSB8fFxuICBcdFx0ICAgKCBpc09iamVjdCggdmFsdWUgKSAmJiBPYmplY3Qua2V5cyggdmFsdWUgKS5sZW5ndGggPT09IDAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFR5cGUgKCB2YWx1ZSwgaGFzSW5kZXhSZWYgKSB7XG4gIFx0aWYgKCBoYXNJbmRleFJlZiB8fCBpc0FycmF5KCB2YWx1ZSApICkgcmV0dXJuIFNFQ1RJT05fRUFDSDtcbiAgXHRpZiAoIGlzT2JqZWN0KCB2YWx1ZSApIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHJldHVybiBTRUNUSU9OX0lGX1dJVEg7XG4gIFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIG51bGw7XG4gIFx0cmV0dXJuIFNFQ1RJT05fSUY7XG4gIH1cblxuICB2YXIgU2VjdGlvbiA9IChmdW5jdGlvbiAoTXVzdGFjaGUpIHtcbiAgXHRmdW5jdGlvbiBTZWN0aW9uICggb3B0aW9ucyApIHtcbiAgXHRcdE11c3RhY2hlLmNhbGwoIHRoaXMsIG9wdGlvbnMgKTtcblxuICBcdFx0dGhpcy5zZWN0aW9uVHlwZSA9IG9wdGlvbnMudGVtcGxhdGUubiB8fCBudWxsO1xuICBcdFx0dGhpcy50ZW1wbGF0ZVNlY3Rpb25UeXBlID0gdGhpcy5zZWN0aW9uVHlwZTtcbiAgXHRcdHRoaXMuc3Vib3JkaW5hdGUgPSBvcHRpb25zLnRlbXBsYXRlLmwgPT09IDE7XG4gIFx0XHR0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgXHR9XG5cbiAgXHRTZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE11c3RhY2hlICYmIE11c3RhY2hlLnByb3RvdHlwZSApO1xuICBcdFNlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2VjdGlvbjtcblxuICBcdFNlY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiBiaW5kICgpIHtcbiAgXHRcdE11c3RhY2hlLnByb3RvdHlwZS5iaW5kLmNhbGwodGhpcyk7XG5cbiAgXHRcdGlmICggdGhpcy5zdWJvcmRpbmF0ZSApIHtcbiAgXHRcdFx0dGhpcy5zaWJsaW5nID0gdGhpcy5wYXJlbnRGcmFnbWVudC5pdGVtc1sgdGhpcy5wYXJlbnRGcmFnbWVudC5pdGVtcy5pbmRleE9mKCB0aGlzICkgLSAxIF07XG4gIFx0XHRcdHRoaXMuc2libGluZy5uZXh0U2libGluZyA9IHRoaXM7XG4gIFx0XHR9XG5cbiAgXHRcdC8vIGlmIHdlIG1hbmFnZWQgdG8gYmluZCwgd2UgbmVlZCB0byBjcmVhdGUgY2hpbGRyZW5cbiAgXHRcdGlmICggdGhpcy5tb2RlbCApIHtcbiAgXHRcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG4gIFx0XHRcdHRoaXMudXBkYXRlKCk7XG4gIFx0XHR9IGVsc2UgaWYgKCB0aGlzLnNlY3Rpb25UeXBlICYmIHRoaXMuc2VjdGlvblR5cGUgPT09IFNFQ1RJT05fVU5MRVNTICYmICggIXRoaXMuc2libGluZyB8fCAhdGhpcy5zaWJsaW5nLmlzVHJ1dGh5KCkgKSApIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCh7XG4gIFx0XHRcdFx0b3duZXI6IHRoaXMsXG4gIFx0XHRcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUuZlxuICBcdFx0XHR9KS5iaW5kKCk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdFNlY3Rpb24ucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIGRldGFjaCAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudCA/IHRoaXMuZnJhZ21lbnQuZGV0YWNoKCkgOiBjcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIFx0fTtcblxuICBcdFNlY3Rpb24ucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiBmaW5kICggc2VsZWN0b3IgKSB7XG4gIFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdFNlY3Rpb24ucHJvdG90eXBlLmZpbmRBbGwgPSBmdW5jdGlvbiBmaW5kQWxsICggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuICBcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRTZWN0aW9uLnByb3RvdHlwZS5maW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gZmluZENvbXBvbmVudCAoIG5hbWUgKSB7XG4gIFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG4gIFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoIG5hbWUgKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0U2VjdGlvbi5wcm90b3R5cGUuZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiBmaW5kQWxsQ29tcG9uZW50cyAoIG5hbWUsIHF1ZXJ5ICkge1xuICBcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBuYW1lLCBxdWVyeSApO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRTZWN0aW9uLnByb3RvdHlwZS5maXJzdE5vZGUgPSBmdW5jdGlvbiBmaXJzdE5vZGUgKCBza2lwUGFyZW50ICkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5mcmFnbWVudC5maXJzdE5vZGUoIHNraXBQYXJlbnQgKTtcbiAgXHR9O1xuXG4gIFx0U2VjdGlvbi5wcm90b3R5cGUuaXNUcnV0aHkgPSBmdW5jdGlvbiBpc1RydXRoeSAoKSB7XG4gIFx0XHRpZiAoIHRoaXMuc3Vib3JkaW5hdGUgJiYgdGhpcy5zaWJsaW5nLmlzVHJ1dGh5KCkgKSByZXR1cm4gdHJ1ZTtcbiAgXHRcdHZhciB2YWx1ZSA9ICF0aGlzLm1vZGVsID8gdW5kZWZpbmVkIDogdGhpcy5tb2RlbC5pc1Jvb3QgPyB0aGlzLm1vZGVsLnZhbHVlIDogdGhpcy5tb2RlbC5nZXQoKTtcbiAgXHRcdHJldHVybiAhIXZhbHVlICYmICggdGhpcy50ZW1wbGF0ZVNlY3Rpb25UeXBlID09PSBTRUNUSU9OX0lGX1dJVEggfHwgIWlzRW1wdHkoIHZhbHVlICkgKTtcbiAgXHR9O1xuXG4gIFx0U2VjdGlvbi5wcm90b3R5cGUucmViaW5kaW5nID0gZnVuY3Rpb24gcmViaW5kaW5nICggbmV4dCwgcHJldmlvdXMsIHNhZmUgKSB7XG4gIFx0XHRpZiAoIE11c3RhY2hlLnByb3RvdHlwZS5yZWJpbmRpbmcuY2FsbCggdGhpcywgbmV4dCwgcHJldmlvdXMsIHNhZmUgKSApIHtcbiAgXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICYmIHRoaXMuc2VjdGlvblR5cGUgIT09IFNFQ1RJT05fSUYgJiYgdGhpcy5zZWN0aW9uVHlwZSAhPT0gU0VDVElPTl9VTkxFU1MgKSB7XG4gIFx0XHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmRpbmcoIG5leHQsIHByZXZpb3VzICk7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0U2VjdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICggdGFyZ2V0LCBvY2N1cGFudHMgKSB7XG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHRoaXMuZnJhZ21lbnQucmVuZGVyKCB0YXJnZXQsIG9jY3VwYW50cyApO1xuICBcdH07XG5cbiAgXHRTZWN0aW9uLnByb3RvdHlwZS5zaHVmZmxlID0gZnVuY3Rpb24gc2h1ZmZsZSAoIG5ld0luZGljZXMgKSB7XG4gIFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5zZWN0aW9uVHlwZSA9PT0gU0VDVElPTl9FQUNIICkge1xuICBcdFx0XHR0aGlzLmZyYWdtZW50LnNodWZmbGUoIG5ld0luZGljZXMgKTtcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0U2VjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoIGVzY2FwZSApIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50ID8gdGhpcy5mcmFnbWVudC50b1N0cmluZyggZXNjYXBlICkgOiAnJztcbiAgXHR9O1xuXG4gIFx0U2VjdGlvbi5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gdW5iaW5kICgpIHtcbiAgXHRcdE11c3RhY2hlLnByb3RvdHlwZS51bmJpbmQuY2FsbCh0aGlzKTtcbiAgXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0fTtcblxuICBcdFNlY3Rpb24ucHJvdG90eXBlLnVucmVuZGVyID0gZnVuY3Rpb24gdW5yZW5kZXIgKCBzaG91bGREZXN0cm95ICkge1xuICBcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICYmIHRoaXMuZnJhZ21lbnQgKSB0aGlzLmZyYWdtZW50LnVucmVuZGVyKCBzaG91bGREZXN0cm95ICk7XG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gIFx0fTtcblxuICBcdFNlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIFx0XHRpZiAoICF0aGlzLmRpcnR5ICkgcmV0dXJuO1xuXG4gIFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5zZWN0aW9uVHlwZSAhPT0gU0VDVElPTl9JRiAmJiB0aGlzLnNlY3Rpb25UeXBlICE9PSBTRUNUSU9OX1VOTEVTUyApIHtcbiAgXHRcdFx0dGhpcy5mcmFnbWVudC5jb250ZXh0ID0gdGhpcy5tb2RlbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCAhdGhpcy5tb2RlbCAmJiB0aGlzLnNlY3Rpb25UeXBlICE9PSBTRUNUSU9OX1VOTEVTUyApIHJldHVybjtcblxuICBcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuXG4gIFx0XHR2YXIgdmFsdWUgPSAhdGhpcy5tb2RlbCA/IHVuZGVmaW5lZCA6IHRoaXMubW9kZWwuaXNSb290ID8gdGhpcy5tb2RlbC52YWx1ZSA6IHRoaXMubW9kZWwuZ2V0KCk7XG4gIFx0XHR2YXIgc2libGluZ0ZhbHNleSA9ICF0aGlzLnN1Ym9yZGluYXRlIHx8ICF0aGlzLnNpYmxpbmcuaXNUcnV0aHkoKTtcbiAgXHRcdHZhciBsYXN0VHlwZSA9IHRoaXMuc2VjdGlvblR5cGU7XG5cbiAgXHRcdC8vIHdhdGNoIGZvciBzd2l0Y2hpbmcgc2VjdGlvbiB0eXBlc1xuICBcdFx0aWYgKCB0aGlzLnNlY3Rpb25UeXBlID09PSBudWxsIHx8IHRoaXMudGVtcGxhdGVTZWN0aW9uVHlwZSA9PT0gbnVsbCApIHRoaXMuc2VjdGlvblR5cGUgPSBnZXRUeXBlKCB2YWx1ZSwgdGhpcy50ZW1wbGF0ZS5pICk7XG4gIFx0XHRpZiAoIGxhc3RUeXBlICYmIGxhc3RUeXBlICE9PSB0aGlzLnNlY3Rpb25UeXBlICYmIHRoaXMuZnJhZ21lbnQgKSB7XG4gIFx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcbiAgXHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpLnVucmVuZGVyKCB0cnVlICk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0dmFyIG5ld0ZyYWdtZW50O1xuXG4gIFx0XHR2YXIgZnJhZ21lbnRTaG91bGRFeGlzdCA9IHRoaXMuc2VjdGlvblR5cGUgPT09IFNFQ1RJT05fRUFDSCB8fCAvLyBlYWNoIGFsd2F5cyBnZXRzIGEgZnJhZ21lbnQsIHdoaWNoIG1heSBoYXZlIG5vIGl0ZXJhdGlvbnNcbiAgXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlY3Rpb25UeXBlID09PSBTRUNUSU9OX1dJVEggfHwgLy8gd2l0aCAocGFydGlhbCBjb250ZXh0KSBhbHdheXMgZ2V0cyBhIGZyYWdtZW50XG4gIFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBzaWJsaW5nRmFsc2V5ICYmICggdGhpcy5zZWN0aW9uVHlwZSA9PT0gU0VDVElPTl9VTkxFU1MgPyAhdGhpcy5pc1RydXRoeSgpIDogdGhpcy5pc1RydXRoeSgpICkgKTsgLy8gaWYsIHVubGVzcywgYW5kIGlmLXdpdGggZGVwZW5kIG9uIHNpYmxpbmdzIGFuZCB0aGUgY29uZGl0aW9uXG5cbiAgXHRcdGlmICggZnJhZ21lbnRTaG91bGRFeGlzdCApIHtcbiAgXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuICBcdFx0XHRcdHRoaXMuZnJhZ21lbnQudXBkYXRlKCk7XG4gIFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0aWYgKCB0aGlzLnNlY3Rpb25UeXBlID09PSBTRUNUSU9OX0VBQ0ggKSB7XG4gIFx0XHRcdFx0XHRuZXdGcmFnbWVudCA9IG5ldyBSZXBlYXRlZEZyYWdtZW50KHtcbiAgXHRcdFx0XHRcdFx0b3duZXI6IHRoaXMsXG4gIFx0XHRcdFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLmYsXG4gIFx0XHRcdFx0XHRcdGluZGV4UmVmOiB0aGlzLnRlbXBsYXRlLmlcbiAgXHRcdFx0XHRcdH0pLmJpbmQoIHRoaXMubW9kZWwgKTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdCBcdFx0XHRcdC8vIG9ubHkgd2l0aCBhbmQgaWYtd2l0aCBwcm92aWRlIGNvbnRleHQgLSBpZiBhbmQgdW5sZXNzIGRvIG5vdFxuICBcdFx0XHRcdFx0dmFyIGNvbnRleHQgPSB0aGlzLnNlY3Rpb25UeXBlICE9PSBTRUNUSU9OX0lGICYmIHRoaXMuc2VjdGlvblR5cGUgIT09IFNFQ1RJT05fVU5MRVNTID8gdGhpcy5tb2RlbCA6IG51bGw7XG4gIFx0XHRcdFx0XHRuZXdGcmFnbWVudCA9IG5ldyBGcmFnbWVudCh7XG4gIFx0XHRcdFx0XHRcdG93bmVyOiB0aGlzLFxuICBcdFx0XHRcdFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZS5mXG4gIFx0XHRcdFx0XHR9KS5iaW5kKCBjb250ZXh0ICk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5yZW5kZXJlZCApIHtcbiAgXHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpLnVucmVuZGVyKCB0cnVlICk7XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCBuZXdGcmFnbWVudCApIHtcbiAgXHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuICBcdFx0XHRcdHZhciBwYXJlbnROb2RlID0gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kUGFyZW50Tm9kZSgpO1xuICBcdFx0XHRcdHZhciBhbmNob3IgPSB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXG4gIFx0XHRcdFx0aWYgKCBhbmNob3IgKSB7XG4gIFx0XHRcdFx0XHR2YXIgZG9jRnJhZyA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgXHRcdFx0XHRcdG5ld0ZyYWdtZW50LnJlbmRlciggZG9jRnJhZyApO1xuXG4gIFx0XHRcdFx0XHQvLyB3ZSB1c2UgYW5jaG9yLnBhcmVudE5vZGUsIG5vdCBwYXJlbnROb2RlLCBiZWNhdXNlIHRoZSBzaWJsaW5nXG4gIFx0XHRcdFx0XHQvLyBtYXkgYmUgdGVtcG9yYXJpbHkgZGV0YWNoZWQgYXMgYSByZXN1bHQgb2YgYSBzaHVmZmxlXG4gIFx0XHRcdFx0XHRhbmNob3IucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGRvY0ZyYWcsIGFuY2hvciApO1xuICBcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRuZXdGcmFnbWVudC5yZW5kZXIoIHBhcmVudE5vZGUgKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cblxuICBcdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3RnJhZ21lbnQ7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICggdGhpcy5uZXh0U2libGluZyApIHtcbiAgXHRcdFx0dGhpcy5uZXh0U2libGluZy5kaXJ0eSA9IHRydWU7XG4gIFx0XHRcdHRoaXMubmV4dFNpYmxpbmcudXBkYXRlKCk7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdHJldHVybiBTZWN0aW9uO1xuICB9KE11c3RhY2hlKSk7XG5cbiAgZnVuY3Rpb24gdmFsdWVDb250YWlucyAoIHNlbGVjdFZhbHVlLCBvcHRpb25WYWx1ZSApIHtcbiAgXHR2YXIgaSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcbiAgXHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdGlmICggc2VsZWN0VmFsdWVbaV0gPT0gb3B0aW9uVmFsdWUgKSByZXR1cm4gdHJ1ZTtcbiAgXHR9XG4gIH1cblxuICB2YXIgU2VsZWN0ID0gKGZ1bmN0aW9uIChFbGVtZW50KSB7XG4gIFx0ZnVuY3Rpb24gU2VsZWN0ICggb3B0aW9ucyApIHtcbiAgXHRcdEVsZW1lbnQuY2FsbCggdGhpcywgb3B0aW9ucyApO1xuICBcdFx0dGhpcy5vcHRpb25zID0gW107XG4gIFx0fVxuXG4gIFx0U2VsZWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVsZW1lbnQgJiYgRWxlbWVudC5wcm90b3R5cGUgKTtcbiAgXHRTZWxlY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2VsZWN0O1xuXG4gIFx0U2VsZWN0LnByb3RvdHlwZS5mb3VuZE5vZGUgPSBmdW5jdGlvbiBmb3VuZE5vZGUgKCBub2RlICkge1xuICBcdFx0aWYgKCB0aGlzLmJpbmRpbmcgKSB7XG4gIFx0XHRcdHZhciBzZWxlY3RlZE9wdGlvbnMgPSBnZXRTZWxlY3RlZE9wdGlvbnMoIG5vZGUgKTtcblxuICBcdFx0XHRpZiAoIHNlbGVjdGVkT3B0aW9ucy5sZW5ndGggPiAwICkge1xuICBcdFx0XHRcdHRoaXMuc2VsZWN0ZWRPcHRpb25zID0gc2VsZWN0ZWRPcHRpb25zO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdFNlbGVjdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICggdGFyZ2V0LCBvY2N1cGFudHMgKSB7XG4gIFx0XHRFbGVtZW50LnByb3RvdHlwZS5yZW5kZXIuY2FsbCggdGhpcywgdGFyZ2V0LCBvY2N1cGFudHMgKTtcbiAgXHRcdHRoaXMuc3luYygpO1xuXG4gIFx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZTtcblxuICBcdFx0dmFyIGkgPSBub2RlLm9wdGlvbnMubGVuZ3RoO1xuICBcdFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHRcdG5vZGUub3B0aW9uc1tpXS5kZWZhdWx0U2VsZWN0ZWQgPSBub2RlLm9wdGlvbnNbaV0uc2VsZWN0ZWQ7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICBcdH07XG5cbiAgXHRTZWxlY3QucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbiBzeW5jICgpIHtcbiAgXHRcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHR2YXIgc2VsZWN0Tm9kZSA9IHRoaXMubm9kZTtcblxuICBcdFx0aWYgKCAhc2VsZWN0Tm9kZSApIHJldHVybjtcblxuICBcdFx0dmFyIG9wdGlvbnMgPSB0b0FycmF5KCBzZWxlY3ROb2RlLm9wdGlvbnMgKTtcblxuICBcdFx0aWYgKCB0aGlzLnNlbGVjdGVkT3B0aW9ucyApIHtcbiAgXHRcdFx0b3B0aW9ucy5mb3JFYWNoKCBmdW5jdGlvbiAoIG8gKSB7XG4gIFx0XHRcdFx0aWYgKCB0aGlzJDEuc2VsZWN0ZWRPcHRpb25zLmluZGV4T2YoIG8gKSA+PSAwICkgby5zZWxlY3RlZCA9IHRydWU7XG4gIFx0XHRcdFx0ZWxzZSBvLnNlbGVjdGVkID0gZmFsc2U7XG4gIFx0XHRcdH0pO1xuICBcdFx0XHR0aGlzLmJpbmRpbmcuc2V0RnJvbU5vZGUoIHNlbGVjdE5vZGUgKTtcbiAgXHRcdFx0ZGVsZXRlIHRoaXMuc2VsZWN0ZWRPcHRpb25zO1xuICBcdFx0XHRyZXR1cm47XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBzZWxlY3RWYWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG4gIFx0XHR2YXIgaXNNdWx0aXBsZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCAnbXVsdGlwbGUnICk7XG5cbiAgXHRcdC8vIElmIHRoZSA8c2VsZWN0PiBoYXMgYSBzcGVjaWZpZWQgdmFsdWUsIHRoYXQgc2hvdWxkIG92ZXJyaWRlXG4gIFx0XHQvLyB0aGVzZSBvcHRpb25zXG4gIFx0XHRpZiAoIHNlbGVjdFZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG4gIFx0XHRcdHZhciBvcHRpb25XYXNTZWxlY3RlZDtcblxuICBcdFx0XHRvcHRpb25zLmZvckVhY2goIGZ1bmN0aW9uICggbyApIHtcbiAgXHRcdFx0XHR2YXIgb3B0aW9uVmFsdWUgPSBvLl9yYWN0aXZlID8gby5fcmFjdGl2ZS52YWx1ZSA6IG8udmFsdWU7XG4gIFx0XHRcdFx0dmFyIHNob3VsZFNlbGVjdCA9IGlzTXVsdGlwbGUgPyB2YWx1ZUNvbnRhaW5zKCBzZWxlY3RWYWx1ZSwgb3B0aW9uVmFsdWUgKSA6IHNlbGVjdFZhbHVlID09IG9wdGlvblZhbHVlO1xuXG4gIFx0XHRcdFx0aWYgKCBzaG91bGRTZWxlY3QgKSB7XG4gIFx0XHRcdFx0XHRvcHRpb25XYXNTZWxlY3RlZCA9IHRydWU7XG4gIFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0by5zZWxlY3RlZCA9IHNob3VsZFNlbGVjdDtcbiAgXHRcdFx0fSk7XG5cbiAgXHRcdFx0aWYgKCAhb3B0aW9uV2FzU2VsZWN0ZWQgJiYgIWlzTXVsdGlwbGUgKSB7XG4gIFx0XHRcdFx0aWYgKCB0aGlzLmJpbmRpbmcgKSB7XG4gIFx0XHRcdFx0XHR0aGlzLmJpbmRpbmcuZm9yY2VVcGRhdGUoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gT3RoZXJ3aXNlIHRoZSB2YWx1ZSBzaG91bGQgYmUgaW5pdGlhbGlzZWQgYWNjb3JkaW5nIHRvIHdoaWNoXG4gIFx0XHQvLyA8b3B0aW9uPiBlbGVtZW50IGlzIHNlbGVjdGVkLCBpZiB0d293YXkgYmluZGluZyBpcyBpbiBlZmZlY3RcbiAgXHRcdGVsc2UgaWYgKCB0aGlzLmJpbmRpbmcgKSB7XG4gIFx0XHRcdHRoaXMuYmluZGluZy5mb3JjZVVwZGF0ZSgpO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRTZWxlY3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIFx0XHRFbGVtZW50LnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcbiAgXHRcdHRoaXMuc3luYygpO1xuICBcdH07XG5cbiAgXHRyZXR1cm4gU2VsZWN0O1xuICB9KEVsZW1lbnQpKTtcblxuICB2YXIgVGV4dGFyZWEgPSAoZnVuY3Rpb24gKElucHV0KSB7XG4gIFx0ZnVuY3Rpb24gVGV4dGFyZWEoIG9wdGlvbnMgKSB7XG4gIFx0XHR2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXG4gIFx0XHRvcHRpb25zLmRlZmVyQ29udGVudCA9IHRydWU7XG5cbiAgXHRcdElucHV0LmNhbGwoIHRoaXMsIG9wdGlvbnMgKTtcblxuICBcdFx0Ly8gY2hlY2sgZm9yIHNpbmdsZSBpbnRlcnBvbGF0b3IgYmluZGluZ1xuICBcdFx0aWYgKCAhdGhpcy5hdHRyaWJ1dGVCeU5hbWUudmFsdWUgKSB7XG4gIFx0XHRcdGlmICggdGVtcGxhdGUuZiAmJiBpc0JpbmRhYmxlKCB7IHRlbXBsYXRlOiB0ZW1wbGF0ZSB9ICkgKSB7XG4gIFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzLnB1c2goIGNyZWF0ZUl0ZW0oIHtcbiAgXHRcdFx0XHRcdG93bmVyOiB0aGlzLFxuICBcdFx0XHRcdFx0dGVtcGxhdGU6IHsgdDogQVRUUklCVVRFLCBmOiB0ZW1wbGF0ZS5mLCBuOiAndmFsdWUnIH0sXG4gIFx0XHRcdFx0XHRwYXJlbnRGcmFnbWVudDogdGhpcy5wYXJlbnRGcmFnbWVudFxuICBcdFx0XHRcdH0gKSApO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoeyBvd25lcjogdGhpcywgY3NzSWRzOiBudWxsLCB0ZW1wbGF0ZTogdGVtcGxhdGUuZiB9KTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdFRleHRhcmVhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIElucHV0ICYmIElucHV0LnByb3RvdHlwZSApO1xuICBcdFRleHRhcmVhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHRhcmVhO1xuXG4gIFx0VGV4dGFyZWEucHJvdG90eXBlLmJ1YmJsZSA9IGZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gIFx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0aWYgKCAhdGhpcy5kaXJ0eSApIHtcbiAgXHRcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgXHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICYmICF0aGlzLmJpbmRpbmcgJiYgdGhpcy5mcmFnbWVudCApIHtcbiAgXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0dGhpcyQxLmRpcnR5ID0gZmFsc2U7XG4gIFx0XHRcdFx0XHR0aGlzJDEubm9kZS52YWx1ZSA9IHRoaXMkMS5mcmFnbWVudC50b1N0cmluZygpO1xuICBcdFx0XHRcdH0pO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTsgLy8gZGVmYXVsdCBiZWhhdmlvdXJcbiAgXHRcdH1cbiAgXHR9O1xuXG4gIFx0cmV0dXJuIFRleHRhcmVhO1xuICB9KElucHV0KSk7XG5cbiAgdmFyIFRleHQgPSAoZnVuY3Rpb24gKEl0ZW0pIHtcbiAgXHRmdW5jdGlvbiBUZXh0ICggb3B0aW9ucyApIHtcbiAgXHRcdEl0ZW0uY2FsbCggdGhpcywgb3B0aW9ucyApO1xuICBcdFx0dGhpcy50eXBlID0gVEVYVDtcbiAgXHR9XG5cbiAgXHRUZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEl0ZW0gJiYgSXRlbS5wcm90b3R5cGUgKTtcbiAgXHRUZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHQ7XG5cbiAgXHRUZXh0LnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gYmluZCAoKSB7XG4gIFx0XHQvLyBub29wXG4gIFx0fTtcblxuICBcdFRleHQucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIGRldGFjaCAoKSB7XG4gIFx0XHRyZXR1cm4gZGV0YWNoTm9kZSggdGhpcy5ub2RlICk7XG4gIFx0fTtcblxuICBcdFRleHQucHJvdG90eXBlLmZpcnN0Tm9kZSA9IGZ1bmN0aW9uIGZpcnN0Tm9kZSAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuICBcdH07XG5cbiAgXHRUZXh0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKCB0YXJnZXQsIG9jY3VwYW50cyApIHtcbiAgXHRcdGlmICggaW5BdHRyaWJ1dGVzKCkgKSByZXR1cm47XG4gIFx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblxuICBcdFx0aWYgKCBvY2N1cGFudHMgKSB7XG4gIFx0XHRcdHZhciBuID0gb2NjdXBhbnRzWzBdO1xuICBcdFx0XHRpZiAoIG4gJiYgbi5ub2RlVHlwZSA9PT0gMyApIHtcbiAgXHRcdFx0XHRvY2N1cGFudHMuc2hpZnQoKTtcbiAgXHRcdFx0XHRpZiAoIG4ubm9kZVZhbHVlICE9PSB0aGlzLnRlbXBsYXRlICkge1xuICBcdFx0XHRcdFx0bi5ub2RlVmFsdWUgPSB0aGlzLnRlbXBsYXRlO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRuID0gdGhpcy5ub2RlID0gZG9jLmNyZWF0ZVRleHROb2RlKCB0aGlzLnRlbXBsYXRlICk7XG4gIFx0XHRcdFx0aWYgKCBvY2N1cGFudHNbMF0gKSB7XG4gIFx0XHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBuLCBvY2N1cGFudHNbMF0gKTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBuICk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG5cbiAgXHRcdFx0dGhpcy5ub2RlID0gbjtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdHRoaXMubm9kZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZSggdGhpcy50ZW1wbGF0ZSApO1xuICBcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIHRoaXMubm9kZSApO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRUZXh0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICggZXNjYXBlICkge1xuICBcdFx0cmV0dXJuIGVzY2FwZSA/IGVzY2FwZUh0bWwoIHRoaXMudGVtcGxhdGUgKSA6IHRoaXMudGVtcGxhdGU7XG4gIFx0fTtcblxuICBcdFRleHQucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uIHVuYmluZCAoKSB7XG4gIFx0XHQvLyBub29wXG4gIFx0fTtcblxuICBcdFRleHQucHJvdG90eXBlLnVucmVuZGVyID0gZnVuY3Rpb24gdW5yZW5kZXIgKCBzaG91bGREZXN0cm95ICkge1xuICBcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICYmIHNob3VsZERlc3Ryb3kgKSB0aGlzLmRldGFjaCgpO1xuICBcdFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICBcdH07XG5cbiAgXHRUZXh0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICBcdFx0Ly8gbm9vcFxuICBcdH07XG5cbiAgXHRUZXh0LnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gdmFsdWVPZiAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy50ZW1wbGF0ZTtcbiAgXHR9O1xuXG4gIFx0cmV0dXJuIFRleHQ7XG4gIH0oSXRlbSkpO1xuXG4gIHZhciBwcmVmaXg7XG5cbiAgaWYgKCAhaXNDbGllbnQgKSB7XG4gIFx0cHJlZml4ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHR2YXIgcHJlZml4Q2FjaGUgPSB7fTtcbiAgXHR2YXIgdGVzdFN0eWxlID0gY3JlYXRlRWxlbWVudCggJ2RpdicgKS5zdHlsZTtcblxuICBcdHByZWZpeCA9IGZ1bmN0aW9uICggcHJvcCApIHtcbiAgXHRcdHByb3AgPSBjYW1lbENhc2UoIHByb3AgKTtcblxuICBcdFx0aWYgKCAhcHJlZml4Q2FjaGVbIHByb3AgXSApIHtcbiAgXHRcdFx0aWYgKCB0ZXN0U3R5bGVbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuICBcdFx0XHRcdHByZWZpeENhY2hlWyBwcm9wIF0gPSBwcm9wO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0ZWxzZSB7XG4gIFx0XHRcdFx0Ly8gdGVzdCB2ZW5kb3JzLi4uXG4gIFx0XHRcdFx0dmFyIGNhcHBlZCA9IHByb3AuY2hhckF0KCAwICkudG9VcHBlckNhc2UoKSArIHByb3Auc3Vic3RyaW5nKCAxICk7XG5cbiAgXHRcdFx0XHR2YXIgaSA9IHZlbmRvcnMubGVuZ3RoO1xuICBcdFx0XHRcdHdoaWxlICggaS0tICkge1xuICBcdFx0XHRcdFx0dmFyIHZlbmRvciA9IHZlbmRvcnNbaV07XG4gIFx0XHRcdFx0XHRpZiAoIHRlc3RTdHlsZVsgdmVuZG9yICsgY2FwcGVkIF0gIT09IHVuZGVmaW5lZCApIHtcbiAgXHRcdFx0XHRcdFx0cHJlZml4Q2FjaGVbIHByb3AgXSA9IHZlbmRvciArIGNhcHBlZDtcbiAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBwcmVmaXhDYWNoZVsgcHJvcCBdO1xuICBcdH07XG4gIH1cblxuICB2YXIgcHJlZml4JDEgPSBwcmVmaXg7XG5cbiAgdmFyIHZpc2libGU7XG4gIHZhciBoaWRkZW4gPSAnaGlkZGVuJztcblxuICBpZiAoIGRvYyApIHtcbiAgXHR2YXIgcHJlZml4JDI7XG5cbiAgXHRpZiAoIGhpZGRlbiBpbiBkb2MgKSB7XG4gIFx0XHRwcmVmaXgkMiA9ICcnO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR2YXIgaSQxID0gdmVuZG9ycy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoIGkkMS0tICkge1xuICBcdFx0XHR2YXIgdmVuZG9yID0gdmVuZG9yc1tpJDFdO1xuICBcdFx0XHRoaWRkZW4gPSB2ZW5kb3IgKyAnSGlkZGVuJztcblxuICBcdFx0XHRpZiAoIGhpZGRlbiBpbiBkb2MgKSB7XG4gIFx0XHRcdFx0cHJlZml4JDIgPSB2ZW5kb3I7XG4gIFx0XHRcdFx0YnJlYWs7XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoIHByZWZpeCQyICE9PSB1bmRlZmluZWQgKSB7XG4gIFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggcHJlZml4JDIgKyAndmlzaWJpbGl0eWNoYW5nZScsIG9uQ2hhbmdlICk7XG4gIFx0XHRvbkNoYW5nZSgpO1xuICBcdH0gZWxzZSB7XG4gIFx0XHQvLyBnYWgsIHdlJ3JlIGluIGFuIG9sZCBicm93c2VyXG4gIFx0XHRpZiAoICdvbmZvY3Vzb3V0JyBpbiBkb2MgKSB7XG4gIFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCAnZm9jdXNvdXQnLCBvbkhpZGUgKTtcbiAgXHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoICdmb2N1c2luJywgb25TaG93ICk7XG4gIFx0XHR9XG5cbiAgXHRcdGVsc2Uge1xuICBcdFx0XHR3aW4uYWRkRXZlbnRMaXN0ZW5lciggJ3BhZ2VoaWRlJywgb25IaWRlICk7XG4gIFx0XHRcdHdpbi5hZGRFdmVudExpc3RlbmVyKCAnYmx1cicsIG9uSGlkZSApO1xuXG4gIFx0XHRcdHdpbi5hZGRFdmVudExpc3RlbmVyKCAncGFnZXNob3cnLCBvblNob3cgKTtcbiAgXHRcdFx0d2luLmFkZEV2ZW50TGlzdGVuZXIoICdmb2N1cycsIG9uU2hvdyApO1xuICBcdFx0fVxuXG4gIFx0XHR2aXNpYmxlID0gdHJ1ZTsgLy8gdW50aWwgcHJvdmVuIG90aGVyd2lzZS4gTm90IGlkZWFsIGJ1dCBoZXlcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNoYW5nZSAoKSB7XG4gIFx0dmlzaWJsZSA9ICFkb2NbIGhpZGRlbiBdO1xuICB9XG5cbiAgZnVuY3Rpb24gb25IaWRlICgpIHtcbiAgXHR2aXNpYmxlID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBvblNob3cgKCkge1xuICBcdHZpc2libGUgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHVucHJlZml4UGF0dGVybiA9IG5ldyBSZWdFeHAoICdeLSg/OicgKyB2ZW5kb3JzLmpvaW4oICd8JyApICsgJyktJyApO1xuXG4gIGZ1bmN0aW9uIHVucHJlZml4ICggcHJvcCApIHtcbiAgXHRyZXR1cm4gcHJvcC5yZXBsYWNlKCB1bnByZWZpeFBhdHRlcm4sICcnICk7XG4gIH1cblxuICB2YXIgdmVuZG9yUGF0dGVybiA9IG5ldyBSZWdFeHAoICdeKD86JyArIHZlbmRvcnMuam9pbiggJ3wnICkgKyAnKShbQS1aXSknICk7XG5cbiAgZnVuY3Rpb24gaHlwaGVuYXRlICggc3RyICkge1xuICBcdGlmICggIXN0ciApIHJldHVybiAnJzsgLy8gZWRnZSBjYXNlXG5cbiAgXHRpZiAoIHZlbmRvclBhdHRlcm4udGVzdCggc3RyICkgKSBzdHIgPSAnLScgKyBzdHI7XG5cbiAgXHRyZXR1cm4gc3RyLnJlcGxhY2UoIC9bQS1aXS9nLCBmdW5jdGlvbiAoIG1hdGNoICkgeyByZXR1cm4gJy0nICsgbWF0Y2gudG9Mb3dlckNhc2UoKTsgfSApO1xuICB9XG5cbiAgdmFyIGNyZWF0ZVRyYW5zaXRpb25zO1xuXG4gIGlmICggIWlzQ2xpZW50ICkge1xuICBcdGNyZWF0ZVRyYW5zaXRpb25zID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgXHR2YXIgdGVzdFN0eWxlJDEgPSBjcmVhdGVFbGVtZW50KCAnZGl2JyApLnN0eWxlO1xuICBcdHZhciBsaW5lYXIkMSA9IGZ1bmN0aW9uICggeCApIHsgcmV0dXJuIHg7IH07XG5cbiAgXHR2YXIgY2FuVXNlQ3NzVHJhbnNpdGlvbnMgPSB7fTtcbiAgXHR2YXIgY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnMgPSB7fTtcblxuICBcdC8vIGRldGVybWluZSBzb21lIGZhY3RzIGFib3V0IG91ciBlbnZpcm9ubWVudFxuICBcdHZhciBUUkFOU0lUSU9OJDE7XG4gIFx0dmFyIFRSQU5TSVRJT05FTkQ7XG4gIFx0dmFyIENTU19UUkFOU0lUSU9OU19FTkFCTEVEO1xuICBcdHZhciBUUkFOU0lUSU9OX0RVUkFUSU9OO1xuICBcdHZhciBUUkFOU0lUSU9OX1BST1BFUlRZO1xuICBcdHZhciBUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTjtcblxuICBcdGlmICggdGVzdFN0eWxlJDEudHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuICBcdFx0VFJBTlNJVElPTiQxID0gJ3RyYW5zaXRpb24nO1xuICBcdFx0VFJBTlNJVElPTkVORCA9ICd0cmFuc2l0aW9uZW5kJztcbiAgXHRcdENTU19UUkFOU0lUSU9OU19FTkFCTEVEID0gdHJ1ZTtcbiAgXHR9IGVsc2UgaWYgKCB0ZXN0U3R5bGUkMS53ZWJraXRUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG4gIFx0XHRUUkFOU0lUSU9OJDEgPSAnd2Via2l0VHJhbnNpdGlvbic7XG4gIFx0XHRUUkFOU0lUSU9ORU5EID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICBcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSB0cnVlO1xuICBcdH0gZWxzZSB7XG4gIFx0XHRDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCA9IGZhbHNlO1xuICBcdH1cblxuICBcdGlmICggVFJBTlNJVElPTiQxICkge1xuICBcdFx0VFJBTlNJVElPTl9EVVJBVElPTiA9IFRSQU5TSVRJT04kMSArICdEdXJhdGlvbic7XG4gIFx0XHRUUkFOU0lUSU9OX1BST1BFUlRZID0gVFJBTlNJVElPTiQxICsgJ1Byb3BlcnR5JztcbiAgXHRcdFRSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OID0gVFJBTlNJVElPTiQxICsgJ1RpbWluZ0Z1bmN0aW9uJztcbiAgXHR9XG5cbiAgXHRjcmVhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uICggdCwgdG8sIG9wdGlvbnMsIGNoYW5nZWRQcm9wZXJ0aWVzLCByZXNvbHZlICkge1xuXG4gIFx0XHQvLyBXYWl0IGEgYmVhdCAob3RoZXJ3aXNlIHRoZSB0YXJnZXQgc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBpbW1lZGlhdGVseSlcbiAgXHRcdC8vIFRPRE8gdXNlIGEgZmFzdGRvbS1zdHlsZSBtZWNoYW5pc20/XG4gIFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdHZhciBqc1RyYW5zaXRpb25zQ29tcGxldGU7XG4gIFx0XHRcdHZhciBjc3NUcmFuc2l0aW9uc0NvbXBsZXRlO1xuICBcdFx0XHR2YXIgY3NzVGltZW91dDtcblxuICBcdFx0XHRmdW5jdGlvbiB0cmFuc2l0aW9uRG9uZSAoKSB7IGNsZWFyVGltZW91dCggY3NzVGltZW91dCApOyB9XG5cbiAgXHRcdFx0ZnVuY3Rpb24gY2hlY2tDb21wbGV0ZSAoKSB7XG4gIFx0XHRcdFx0aWYgKCBqc1RyYW5zaXRpb25zQ29tcGxldGUgJiYgY3NzVHJhbnNpdGlvbnNDb21wbGV0ZSApIHtcbiAgXHRcdFx0XHRcdHQudW5yZWdpc3RlckNvbXBsZXRlSGFuZGxlciggdHJhbnNpdGlvbkRvbmUgKTtcbiAgXHRcdFx0XHRcdC8vIHdpbGwgY2hhbmdlcyB0byBldmVudHMgYW5kIGZpcmUgaGF2ZSBhbiB1bmV4cGVjdGVkIGNvbnNlcXVlbmNlIGhlcmU/XG4gIFx0XHRcdFx0XHR0LnJhY3RpdmUuZmlyZSggdC5uYW1lICsgJzplbmQnLCB0Lm5vZGUsIHQuaXNJbnRybyApO1xuICBcdFx0XHRcdFx0cmVzb2x2ZSgpO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuXG4gIFx0XHRcdC8vIHRoaXMgaXMgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIGVsZW1lbnRzIGNhbiB1c2UgQ1NTIHRvIGFuaW1hdGVcbiAgXHRcdFx0Ly8gd2hpY2ggcHJvcGVydGllc1xuICBcdFx0XHR2YXIgaGFzaFByZWZpeCA9ICggdC5ub2RlLm5hbWVzcGFjZVVSSSB8fCAnJyApICsgdC5ub2RlLnRhZ05hbWU7XG5cbiAgXHRcdFx0Ly8gbmVlZCB0byByZXNldCB0cmFuc2l0aW9uIHByb3BlcnRpZXNcbiAgXHRcdFx0dmFyIHN0eWxlID0gdC5ub2RlLnN0eWxlO1xuICBcdFx0XHR2YXIgcHJldmlvdXMgPSB7XG4gIFx0XHRcdFx0cHJvcGVydHk6IHN0eWxlWyBUUkFOU0lUSU9OX1BST1BFUlRZIF0sXG4gIFx0XHRcdFx0dGltaW5nOiBzdHlsZVsgVFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT04gXSxcbiAgXHRcdFx0XHRkdXJhdGlvbjogc3R5bGVbIFRSQU5TSVRJT05fRFVSQVRJT04gXVxuICBcdFx0XHR9O1xuXG4gIFx0XHRcdHN0eWxlWyBUUkFOU0lUSU9OX1BST1BFUlRZIF0gPSBjaGFuZ2VkUHJvcGVydGllcy5tYXAoIHByZWZpeCQxICkubWFwKCBoeXBoZW5hdGUgKS5qb2luKCAnLCcgKTtcbiAgXHRcdFx0c3R5bGVbIFRSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OIF0gPSBoeXBoZW5hdGUoIG9wdGlvbnMuZWFzaW5nIHx8ICdsaW5lYXInICk7XG4gIFx0XHRcdHN0eWxlWyBUUkFOU0lUSU9OX0RVUkFUSU9OIF0gPSAoIG9wdGlvbnMuZHVyYXRpb24gLyAxMDAwICkgKyAncyc7XG5cbiAgXHRcdFx0ZnVuY3Rpb24gdHJhbnNpdGlvbkVuZEhhbmRsZXIgKCBldmVudCApIHtcbiAgXHRcdFx0XHR2YXIgaW5kZXggPSBjaGFuZ2VkUHJvcGVydGllcy5pbmRleE9mKCBjYW1lbENhc2UoIHVucHJlZml4KCBldmVudC5wcm9wZXJ0eU5hbWUgKSApICk7XG5cbiAgXHRcdFx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcbiAgXHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzLnNwbGljZSggaW5kZXgsIDEgKTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoIGNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCApIHtcbiAgXHRcdFx0XHRcdC8vIHN0aWxsIHRyYW5zaXRpb25pbmcuLi5cbiAgXHRcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRjbGVhclRpbWVvdXQoIGNzc1RpbWVvdXQgKTtcbiAgXHRcdFx0XHRjc3NUcmFuc2l0aW9uc0RvbmUoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGZ1bmN0aW9uIGNzc1RyYW5zaXRpb25zRG9uZSAoKSB7XG4gIFx0XHRcdFx0c3R5bGVbIFRSQU5TSVRJT05fUFJPUEVSVFkgXSA9IHByZXZpb3VzLnByb3BlcnR5O1xuICBcdFx0XHRcdHN0eWxlWyBUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTiBdID0gcHJldmlvdXMuZHVyYXRpb247XG4gIFx0XHRcdFx0c3R5bGVbIFRSQU5TSVRJT05fRFVSQVRJT04gXSA9IHByZXZpb3VzLnRpbWluZztcblxuICBcdFx0XHRcdHQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCBUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UgKTtcblxuICBcdFx0XHRcdGNzc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuICBcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdHQubm9kZS5hZGRFdmVudExpc3RlbmVyKCBUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UgKTtcblxuICBcdFx0XHQvLyBzYWZldHkgbmV0IGluIGNhc2UgdHJhbnNpdGlvbmVuZCBuZXZlciBmaXJlc1xuICBcdFx0XHRjc3NUaW1lb3V0ID0gc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzID0gW107XG4gIFx0XHRcdFx0Y3NzVHJhbnNpdGlvbnNEb25lKCk7XG4gIFx0XHRcdH0sIG9wdGlvbnMuZHVyYXRpb24gKyAoIG9wdGlvbnMuZGVsYXkgfHwgMCApICsgNTAgKTtcbiAgXHRcdFx0dC5yZWdpc3RlckNvbXBsZXRlSGFuZGxlciggdHJhbnNpdGlvbkRvbmUgKTtcblxuICBcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG4gIFx0XHRcdFx0dmFyIGkgPSBjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGg7XG4gIFx0XHRcdFx0dmFyIGhhc2g7XG4gIFx0XHRcdFx0dmFyIG9yaWdpbmFsVmFsdWU7XG4gIFx0XHRcdFx0dmFyIGluZGV4O1xuICBcdFx0XHRcdHZhciBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5KcyA9IFtdO1xuICBcdFx0XHRcdHZhciBwcm9wO1xuICBcdFx0XHRcdHZhciBzdWZmaXg7XG4gIFx0XHRcdFx0dmFyIGludGVycG9sYXRvcjtcblxuICBcdFx0XHRcdHdoaWxlICggaS0tICkge1xuICBcdFx0XHRcdFx0cHJvcCA9IGNoYW5nZWRQcm9wZXJ0aWVzW2ldO1xuICBcdFx0XHRcdFx0aGFzaCA9IGhhc2hQcmVmaXggKyBwcm9wO1xuXG4gIFx0XHRcdFx0XHRpZiAoIENTU19UUkFOU0lUSU9OU19FTkFCTEVEICYmICFjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdICkge1xuICBcdFx0XHRcdFx0XHRzdHlsZVsgcHJlZml4JDEoIHByb3AgKSBdID0gdG9bIHByb3AgXTtcblxuICBcdFx0XHRcdFx0XHQvLyBJZiB3ZSdyZSBub3Qgc3VyZSBpZiBDU1MgdHJhbnNpdGlvbnMgYXJlIHN1cHBvcnRlZCBmb3JcbiAgXHRcdFx0XHRcdFx0Ly8gdGhpcyB0YWcvcHJvcGVydHkgY29tYm8sIGZpbmQgb3V0IG5vd1xuICBcdFx0XHRcdFx0XHRpZiAoICFjYW5Vc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdICkge1xuICBcdFx0XHRcdFx0XHRcdG9yaWdpbmFsVmFsdWUgPSB0LmdldFN0eWxlKCBwcm9wICk7XG5cbiAgXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGlzIHByb3BlcnR5IGlzIHRyYW5zaXRpb25hYmxlIGluIHRoaXMgYnJvd3NlcixcbiAgXHRcdFx0XHRcdFx0XHQvLyB0aGUgY3VycmVudCBzdHlsZSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIHRoZSB0YXJnZXQgc3R5bGVcbiAgXHRcdFx0XHRcdFx0XHRjYW5Vc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdID0gKCB0LmdldFN0eWxlKCBwcm9wICkgIT0gdG9bIHByb3AgXSApO1xuICBcdFx0XHRcdFx0XHRcdGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF0gPSAhY2FuVXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXTtcblxuICBcdFx0XHRcdFx0XHRcdC8vIFJlc2V0LCBpZiB3ZSdyZSBnb2luZyB0byB1c2UgdGltZXJzIGFmdGVyIGFsbFxuICBcdFx0XHRcdFx0XHRcdGlmICggY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSApIHtcbiAgXHRcdFx0XHRcdFx0XHRcdHN0eWxlWyBwcmVmaXgkMSggcHJvcCApIF0gPSBvcmlnaW5hbFZhbHVlO1xuICBcdFx0XHRcdFx0XHRcdH1cbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHRpZiAoICFDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCB8fCBjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdICkge1xuICBcdFx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGZhbGwgYmFjayB0byB0aW1lci1iYXNlZCBzdHVmZlxuICBcdFx0XHRcdFx0XHRpZiAoIG9yaWdpbmFsVmFsdWUgPT09IHVuZGVmaW5lZCApIHtcbiAgXHRcdFx0XHRcdFx0XHRvcmlnaW5hbFZhbHVlID0gdC5nZXRTdHlsZSggcHJvcCApO1xuICBcdFx0XHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRcdFx0Ly8gbmVlZCB0byByZW1vdmUgdGhpcyBmcm9tIGNoYW5nZWRQcm9wZXJ0aWVzLCBvdGhlcndpc2UgdHJhbnNpdGlvbkVuZEhhbmRsZXJcbiAgXHRcdFx0XHRcdFx0Ly8gd2lsbCBnZXQgY29uZnVzZWRcbiAgXHRcdFx0XHRcdFx0aW5kZXggPSBjaGFuZ2VkUHJvcGVydGllcy5pbmRleE9mKCBwcm9wICk7XG4gIFx0XHRcdFx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuICBcdFx0XHRcdFx0XHRcdHdhcm5JZkRlYnVnKCAnU29tZXRoaW5nIHZlcnkgc3RyYW5nZSBoYXBwZW5lZCB3aXRoIHRyYW5zaXRpb25zLiBQbGVhc2UgcmFpc2UgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3VlcyAtIHRoYW5rcyEnLCB7IG5vZGU6IHQubm9kZSB9KTtcbiAgXHRcdFx0XHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5zcGxpY2UoIGluZGV4LCAxICk7XG4gIFx0XHRcdFx0XHRcdH1cblxuICBcdFx0XHRcdFx0XHQvLyBUT0RPIERldGVybWluZSB3aGV0aGVyIHRoaXMgcHJvcGVydHkgaXMgYW5pbWF0YWJsZSBhdCBhbGxcblxuICBcdFx0XHRcdFx0XHRzdWZmaXggPSAvW15cXGRdKiQvLmV4ZWMoIHRvWyBwcm9wIF0gKVswXTtcbiAgXHRcdFx0XHRcdFx0aW50ZXJwb2xhdG9yID0gaW50ZXJwb2xhdGUoIHBhcnNlRmxvYXQoIG9yaWdpbmFsVmFsdWUgKSwgcGFyc2VGbG9hdCggdG9bIHByb3AgXSApICkgfHwgKCBmdW5jdGlvbiAoKSB7IHJldHVybiB0b1sgcHJvcCBdOyB9ICk7XG5cbiAgXHRcdFx0XHRcdFx0Ly8gLi4udGhlbiBraWNrIG9mZiBhIHRpbWVyLWJhc2VkIHRyYW5zaXRpb25cbiAgXHRcdFx0XHRcdFx0cHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMucHVzaCh7XG4gIFx0XHRcdFx0XHRcdFx0bmFtZTogcHJlZml4JDEoIHByb3AgKSxcbiAgXHRcdFx0XHRcdFx0XHRpbnRlcnBvbGF0b3I6IGludGVycG9sYXRvcixcbiAgXHRcdFx0XHRcdFx0XHRzdWZmaXg6IHN1ZmZpeFxuICBcdFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHRcdH1cbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHQvLyBqYXZhc2NyaXB0IHRyYW5zaXRpb25zXG4gIFx0XHRcdFx0aWYgKCBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5sZW5ndGggKSB7XG4gIFx0XHRcdFx0XHR2YXIgZWFzaW5nO1xuXG4gIFx0XHRcdFx0XHRpZiAoIHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gJ3N0cmluZycgKSB7XG4gIFx0XHRcdFx0XHRcdGVhc2luZyA9IHQucmFjdGl2ZS5lYXNpbmdbIG9wdGlvbnMuZWFzaW5nIF07XG5cbiAgXHRcdFx0XHRcdFx0aWYgKCAhZWFzaW5nICkge1xuICBcdFx0XHRcdFx0XHRcdHdhcm5PbmNlSWZEZWJ1ZyggbWlzc2luZ1BsdWdpbiggb3B0aW9ucy5lYXNpbmcsICdlYXNpbmcnICkgKTtcbiAgXHRcdFx0XHRcdFx0XHRlYXNpbmcgPSBsaW5lYXIkMTtcbiAgXHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIG9wdGlvbnMuZWFzaW5nID09PSAnZnVuY3Rpb24nICkge1xuICBcdFx0XHRcdFx0XHRlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcbiAgXHRcdFx0XHRcdH0gZWxzZSB7XG4gIFx0XHRcdFx0XHRcdGVhc2luZyA9IGxpbmVhciQxO1xuICBcdFx0XHRcdFx0fVxuXG4gIFx0XHRcdFx0XHRuZXcgVGlja2VyKHtcbiAgXHRcdFx0XHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gIFx0XHRcdFx0XHRcdGVhc2luZzogZWFzaW5nLFxuICBcdFx0XHRcdFx0XHRzdGVwOiBmdW5jdGlvbiAoIHBvcyApIHtcbiAgXHRcdFx0XHRcdFx0XHR2YXIgaSA9IHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzLmxlbmd0aDtcbiAgXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdFx0XHRcdFx0XHRcdHZhciBwcm9wID0gcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnNbaV07XG4gIFx0XHRcdFx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIHByb3AubmFtZSBdID0gcHJvcC5pbnRlcnBvbGF0b3IoIHBvcyApICsgcHJvcC5zdWZmaXg7XG4gIFx0XHRcdFx0XHRcdFx0fVxuICBcdFx0XHRcdFx0XHR9LFxuICBcdFx0XHRcdFx0XHRjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICBcdFx0XHRcdFx0XHRcdGpzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG4gIFx0XHRcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuICBcdFx0XHRcdFx0XHR9XG4gIFx0XHRcdFx0XHR9KTtcbiAgXHRcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdFx0anNUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcbiAgXHRcdFx0XHR9XG5cbiAgXHRcdFx0XHRpZiAoICFjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGggKSB7XG4gIFx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGFuZCBkZWFsIHdpdGhcbiAgXHRcdFx0XHRcdC8vIHRoZSBmYWN0IHRoYXQgaXQgd2lsbCBuZXZlciBmaXJlXG4gIFx0XHRcdFx0XHR0Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggVFJBTlNJVElPTkVORCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGZhbHNlICk7XG4gIFx0XHRcdFx0XHRjc3NUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcbiAgXHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0sIDAgKTtcbiAgXHRcdH0sIG9wdGlvbnMuZGVsYXkgfHwgMCApO1xuICBcdH07XG4gIH1cblxuICB2YXIgY3JlYXRlVHJhbnNpdGlvbnMkMSA9IGNyZWF0ZVRyYW5zaXRpb25zO1xuXG4gIGZ1bmN0aW9uIHJlc2V0U3R5bGUgKCBub2RlLCBzdHlsZSApIHtcbiAgXHRpZiAoIHN0eWxlICkge1xuICBcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoICdzdHlsZScsIHN0eWxlICk7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdC8vIE5leHQgbGluZSBpcyBuZWNlc3NhcnksIHRvIHJlbW92ZSBlbXB0eSBzdHlsZSBhdHRyaWJ1dGUhXG4gIFx0XHQvLyBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzE2NzU1M1xuICBcdFx0bm9kZS5nZXRBdHRyaWJ1dGUoICdzdHlsZScgKTtcbiAgXHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKCAnc3R5bGUnICk7XG4gIFx0fVxuICB9XG5cbiAgdmFyIGdldENvbXB1dGVkU3R5bGUgPSB3aW4gJiYgKCB3aW4uZ2V0Q29tcHV0ZWRTdHlsZSB8fCBsZWdhY3kuZ2V0Q29tcHV0ZWRTdHlsZSApO1xuICB2YXIgcmVzb2x2ZWQgPSBQcm9taXNlJDEucmVzb2x2ZSgpO1xuXG4gIHZhciBuYW1lcyA9IHtcbiAgXHR0MDogJ2ludHJvLW91dHJvJyxcbiAgXHR0MTogJ2ludHJvJyxcbiAgXHR0MjogJ291dHJvJ1xuICB9O1xuXG4gIHZhciBUcmFuc2l0aW9uID0gZnVuY3Rpb24gVHJhbnNpdGlvbiAoIG9wdGlvbnMgKSB7XG4gIFx0dGhpcy5vd25lciA9IG9wdGlvbnMub3duZXIgfHwgb3B0aW9ucy5wYXJlbnRGcmFnbWVudC5vd25lciB8fCBmaW5kRWxlbWVudCggb3B0aW9ucy5wYXJlbnRGcmFnbWVudCApO1xuICBcdHRoaXMuZWxlbWVudCA9IHRoaXMub3duZXIuYXR0cmlidXRlQnlOYW1lID8gdGhpcy5vd25lciA6IGZpbmRFbGVtZW50KCBvcHRpb25zLnBhcmVudEZyYWdtZW50ICk7XG4gIFx0dGhpcy5yYWN0aXZlID0gdGhpcy5vd25lci5yYWN0aXZlO1xuICBcdHRoaXMudGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICBcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuICBcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIFx0dGhpcy5vbkNvbXBsZXRlID0gW107XG4gIH07XG5cbiAgVHJhbnNpdGlvbi5wcm90b3R5cGUuYW5pbWF0ZVN0eWxlID0gZnVuY3Rpb24gYW5pbWF0ZVN0eWxlICggc3R5bGUsIHZhbHVlLCBvcHRpb25zICkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDQgKSB7XG4gIFx0XHR0aHJvdyBuZXcgRXJyb3IoICd0LmFuaW1hdGVTdHlsZSgpIHJldHVybnMgYSBwcm9taXNlIC0gdXNlIC50aGVuKCkgaW5zdGVhZCBvZiBwYXNzaW5nIGEgY2FsbGJhY2snICk7XG4gIFx0fVxuXG4gIFx0Ly8gU3BlY2lhbCBjYXNlIC0gcGFnZSBpc24ndCB2aXNpYmxlLiBEb24ndCBhbmltYXRlIGFueXRoaW5nLCBiZWNhdXNlXG4gIFx0Ly8gdGhhdCB3YXkgeW91J2xsIG5ldmVyIGdldCBDU1MgdHJhbnNpdGlvbmVuZCBldmVudHNcbiAgXHRpZiAoICF2aXNpYmxlICkge1xuICBcdFx0dGhpcy5zZXRTdHlsZSggc3R5bGUsIHZhbHVlICk7XG4gIFx0XHRyZXR1cm4gcmVzb2x2ZWQ7XG4gIFx0fVxuXG4gIFx0dmFyIHRvO1xuXG4gIFx0aWYgKCB0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnICkge1xuICBcdFx0dG8gPSB7fTtcbiAgXHRcdHRvWyBzdHlsZSBdID0gdmFsdWU7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdHRvID0gc3R5bGU7XG5cbiAgXHRcdC8vIHNodWZmbGUgYXJndW1lbnRzXG4gIFx0XHRvcHRpb25zID0gdmFsdWU7XG4gIFx0fVxuXG4gIFx0Ly8gQXMgb2YgMC4zLjksIHRyYW5zaXRpb24gYXV0aG9ycyBzaG91bGQgc3VwcGx5IGFuIGBvcHRpb25gIG9iamVjdCB3aXRoXG4gIFx0Ly8gYGR1cmF0aW9uYCBhbmQgYGVhc2luZ2AgcHJvcGVydGllcyAoYW5kIG9wdGlvbmFsIGBkZWxheWApLCBwbHVzIGFcbiAgXHQvLyBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGFmdGVyIHRoZSBhbmltYXRpb24gY29tcGxldGVzXG5cbiAgXHQvLyBUT0RPIHJlbW92ZSB0aGlzIGNoZWNrIGluIGEgZnV0dXJlIHZlcnNpb25cbiAgXHRpZiAoICFvcHRpb25zICkge1xuICBcdFx0d2Fybk9uY2VJZkRlYnVnKCAnVGhlIFwiJXNcIiB0cmFuc2l0aW9uIGRvZXMgbm90IHN1cHBseSBhbiBvcHRpb25zIG9iamVjdCB0byBgdC5hbmltYXRlU3R5bGUoKWAuIFRoaXMgd2lsbCBicmVhayBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJhY3RpdmUuIEZvciBtb3JlIGluZm8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMvMzQwJywgdGhpcy5uYW1lICk7XG4gIFx0XHRvcHRpb25zID0gdGhpcztcbiAgXHR9XG5cbiAgXHRyZXR1cm4gbmV3IFByb21pc2UkMSggZnVuY3Rpb24gKCBmdWxmaWwgKSB7XG4gIFx0XHQvLyBFZGdlIGNhc2UgLSBpZiBkdXJhdGlvbiBpcyB6ZXJvLCBzZXQgc3R5bGUgc3luY2hyb25vdXNseSBhbmQgY29tcGxldGVcbiAgXHRcdGlmICggIW9wdGlvbnMuZHVyYXRpb24gKSB7XG4gIFx0XHRcdHRoaXMkMS5zZXRTdHlsZSggdG8gKTtcbiAgXHRcdFx0ZnVsZmlsKCk7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0Ly8gR2V0IGEgbGlzdCBvZiB0aGUgcHJvcGVydGllcyB3ZSdyZSBhbmltYXRpbmdcbiAgXHRcdHZhciBwcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmtleXMoIHRvICk7XG4gIFx0XHR2YXIgY2hhbmdlZFByb3BlcnRpZXMgPSBbXTtcblxuICBcdFx0Ly8gU3RvcmUgdGhlIGN1cnJlbnQgc3R5bGVzXG4gIFx0XHR2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoIHRoaXMkMS5vd25lci5ub2RlICk7XG5cbiAgXHRcdHZhciBpID0gcHJvcGVydHlOYW1lcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdFx0dmFyIHByb3AgPSBwcm9wZXJ0eU5hbWVzW2ldO1xuICBcdFx0XHR2YXIgY3VycmVudCA9IGNvbXB1dGVkU3R5bGVbIHByZWZpeCQxKCBwcm9wICkgXTtcblxuICBcdFx0XHRpZiAoIGN1cnJlbnQgPT09ICcwcHgnICkgY3VycmVudCA9IDA7XG5cbiAgXHRcdFx0Ly8gd2UgbmVlZCB0byBrbm93IGlmIHdlJ3JlIGFjdHVhbGx5IGNoYW5naW5nIGFueXRoaW5nXG4gIFx0XHRcdGlmICggY3VycmVudCAhPSB0b1sgcHJvcCBdICkgeyAvLyB1c2UgIT0gaW5zdGVhZCBvZiAhPT0sIHNvIHdlIGNhbiBjb21wYXJlIHN0cmluZ3Mgd2l0aCBudW1iZXJzXG4gIFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMucHVzaCggcHJvcCApO1xuXG4gIFx0XHRcdFx0Ly8gbWFrZSB0aGUgY29tcHV0ZWQgc3R5bGUgZXhwbGljaXQsIHNvIHdlIGNhbiBhbmltYXRlIHdoZXJlXG4gIFx0XHRcdFx0Ly8gZS5nLiBoZWlnaHQ9J2F1dG8nXG4gIFx0XHRcdFx0dGhpcyQxLm93bmVyLm5vZGUuc3R5bGVbIHByZWZpeCQxKCBwcm9wICkgXSA9IGN1cnJlbnQ7XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0Ly8gSWYgd2UncmUgbm90IGFjdHVhbGx5IGNoYW5naW5nIGFueXRoaW5nLCB0aGUgdHJhbnNpdGlvbmVuZCBldmVudFxuICBcdFx0Ly8gd2lsbCBuZXZlciBmaXJlISBTbyB3ZSBjb21wbGV0ZSBlYXJseVxuICBcdFx0aWYgKCAhY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoICkge1xuICBcdFx0XHRmdWxmaWwoKTtcbiAgXHRcdFx0cmV0dXJuO1xuICBcdFx0fVxuXG4gIFx0XHRjcmVhdGVUcmFuc2l0aW9ucyQxKCB0aGlzJDEsIHRvLCBvcHRpb25zLCBjaGFuZ2VkUHJvcGVydGllcywgZnVsZmlsICk7XG4gIFx0fSk7XG4gIH07XG5cbiAgVHJhbnNpdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIGJpbmQgKCkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgXHRpZiAoIG9wdGlvbnMudGVtcGxhdGUgKSB7XG4gIFx0XHRpZiAoIG9wdGlvbnMudGVtcGxhdGUudiA9PT0gJ3QwJyB8fCBvcHRpb25zLnRlbXBsYXRlLnYgPT0gJ3QxJyApIHRoaXMuZWxlbWVudC5faW50cm9UcmFuc2l0aW9uID0gdGhpcztcbiAgXHRcdGlmICggb3B0aW9ucy50ZW1wbGF0ZS52ID09PSAndDAnIHx8IG9wdGlvbnMudGVtcGxhdGUudiA9PSAndDInICkgdGhpcy5lbGVtZW50Ll9vdXRyb1RyYW5zaXRpb24gPSB0aGlzO1xuICBcdFx0dGhpcy5ldmVudE5hbWUgPSBuYW1lc1sgb3B0aW9ucy50ZW1wbGF0ZS52IF07XG4gIFx0fVxuXG4gIFx0dmFyIHJhY3RpdmUgPSB0aGlzLm93bmVyLnJhY3RpdmU7XG5cbiAgXHRpZiAoIG9wdGlvbnMubmFtZSApIHtcbiAgXHRcdHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0dmFyIG5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLmY7XG4gIFx0XHRpZiAoIHR5cGVvZiBuYW1lLm4gPT09ICdzdHJpbmcnICkgbmFtZSA9IG5hbWUubjtcblxuICBcdFx0aWYgKCB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgKSB7XG4gIFx0XHRcdHZhciBmcmFnbWVudCA9IG5ldyBGcmFnbWVudCh7XG4gIFx0XHRcdFx0b3duZXI6IHRoaXMub3duZXIsXG4gIFx0XHRcdFx0dGVtcGxhdGU6IG5hbWUublxuICBcdFx0XHR9KS5iaW5kKCk7IC8vIFRPRE8gbmVlZCBhIHdheSB0byBjYXB0dXJlIHZhbHVlcyB3aXRob3V0IGJpbmQoKVxuXG4gIFx0XHRcdG5hbWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuICBcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblxuICBcdFx0XHRpZiAoIG5hbWUgPT09ICcnICkge1xuICBcdFx0XHRcdC8vIGVtcHR5IHN0cmluZyBva2F5LCBqdXN0IG5vIHRyYW5zaXRpb25cbiAgXHRcdFx0XHRyZXR1cm47XG4gIFx0XHRcdH1cbiAgXHRcdH1cblxuICBcdFx0dGhpcy5uYW1lID0gbmFtZTtcbiAgXHR9XG5cbiAgXHRpZiAoIG9wdGlvbnMucGFyYW1zICkge1xuICBcdFx0dGhpcy5wYXJhbXMgPSBvcHRpb25zLnBhcmFtcztcbiAgXHR9IGVsc2Uge1xuICBcdFx0aWYgKCBvcHRpb25zLnRlbXBsYXRlLmYuYSAmJiAhb3B0aW9ucy50ZW1wbGF0ZS5mLmEucyApIHtcbiAgXHRcdFx0dGhpcy5wYXJhbXMgPSBvcHRpb25zLnRlbXBsYXRlLmYuYTtcbiAgXHRcdH1cblxuICBcdFx0ZWxzZSBpZiAoIG9wdGlvbnMudGVtcGxhdGUuZi5kICkge1xuICBcdFx0XHQvLyBUT0RPIGlzIHRoZXJlIGEgd2F5IHRvIGludGVycHJldCBkeW5hbWljIGFyZ3VtZW50cyB3aXRob3V0IGFsbCB0aGVcbiAgXHRcdFx0Ly8gJ2RlcGVuZGVuY3kgdGhyYXNoaW5nJz9cbiAgXHRcdFx0dmFyIGZyYWdtZW50JDEgPSBuZXcgRnJhZ21lbnQoe1xuICBcdFx0XHRcdG93bmVyOiB0aGlzLm93bmVyLFxuICBcdFx0XHRcdHRlbXBsYXRlOiBvcHRpb25zLnRlbXBsYXRlLmYuZFxuICBcdFx0XHR9KS5iaW5kKCk7XG5cbiAgXHRcdFx0dGhpcy5wYXJhbXMgPSBmcmFnbWVudCQxLmdldEFyZ3NMaXN0KCk7XG4gIFx0XHRcdGZyYWdtZW50JDEudW5iaW5kKCk7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0aWYgKCB0eXBlb2YgdGhpcy5uYW1lID09PSAnZnVuY3Rpb24nICkge1xuICBcdFx0dGhpcy5fZm4gPSB0aGlzLm5hbWU7XG4gIFx0XHR0aGlzLm5hbWUgPSB0aGlzLl9mbi5uYW1lO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR0aGlzLl9mbiA9IGZpbmRJblZpZXdIaWVyYXJjaHkoICd0cmFuc2l0aW9ucycsIHJhY3RpdmUsIHRoaXMubmFtZSApO1xuICBcdH1cblxuICBcdGlmICggIXRoaXMuX2ZuICkge1xuICBcdFx0d2Fybk9uY2VJZkRlYnVnKCBtaXNzaW5nUGx1Z2luKCB0aGlzLm5hbWUsICd0cmFuc2l0aW9uJyApLCB7IHJhY3RpdmU6IHJhY3RpdmUgfSk7XG4gIFx0fVxuXG4gIFx0Ly8gVE9ETzogZHJ5IHVwIGFmdGVyIGRlcHJlY2F0aW9uIGlzIGRvbmVcbiAgXHRpZiAoIG9wdGlvbnMudGVtcGxhdGUgJiYgdGhpcy50ZW1wbGF0ZS5mLmEgJiYgdGhpcy50ZW1wbGF0ZS5mLmEucyApIHtcbiAgXHRcdHRoaXMucmVzb2x2ZXJzID0gW107XG4gIFx0XHR0aGlzLm1vZGVscyA9IHRoaXMudGVtcGxhdGUuZi5hLnIubWFwKCBmdW5jdGlvbiAoIHJlZiwgaSApIHtcbiAgXHRcdFx0dmFyIHJlc29sdmVyO1xuICBcdFx0XHR2YXIgbW9kZWwgPSByZXNvbHZlUmVmZXJlbmNlKCB0aGlzJDEucGFyZW50RnJhZ21lbnQsIHJlZiApO1xuICBcdFx0XHRpZiAoICFtb2RlbCApIHtcbiAgXHRcdFx0XHRyZXNvbHZlciA9IHRoaXMkMS5wYXJlbnRGcmFnbWVudC5yZXNvbHZlKCByZWYsIGZ1bmN0aW9uICggbW9kZWwgKSB7XG4gIFx0XHRcdFx0XHR0aGlzJDEubW9kZWxzW2ldID0gbW9kZWw7XG4gIFx0XHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMkMS5yZXNvbHZlcnMsIHJlc29sdmVyICk7XG4gIFx0XHRcdFx0XHRtb2RlbC5yZWdpc3RlciggdGhpcyQxICk7XG4gIFx0XHRcdFx0fSk7XG5cbiAgXHRcdFx0XHR0aGlzJDEucmVzb2x2ZXJzLnB1c2goIHJlc29sdmVyICk7XG4gIFx0XHRcdH0gZWxzZSBtb2RlbC5yZWdpc3RlciggdGhpcyQxICk7XG5cbiAgXHRcdFx0cmV0dXJuIG1vZGVsO1xuICBcdFx0fSk7XG4gIFx0XHR0aGlzLmFyZ3NGbiA9IGdldEZ1bmN0aW9uKCB0aGlzLnRlbXBsYXRlLmYuYS5zLCB0aGlzLnRlbXBsYXRlLmYuYS5yLmxlbmd0aCApO1xuICBcdH1cbiAgfTtcblxuICBUcmFuc2l0aW9uLnByb3RvdHlwZS5kZXN0cm95ZWQgPSBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge307XG5cbiAgVHJhbnNpdGlvbi5wcm90b3R5cGUuZ2V0U3R5bGUgPSBmdW5jdGlvbiBnZXRTdHlsZSAoIHByb3BzICkge1xuICBcdHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggdGhpcy5vd25lci5ub2RlICk7XG5cbiAgXHRpZiAoIHR5cGVvZiBwcm9wcyA9PT0gJ3N0cmluZycgKSB7XG4gIFx0XHR2YXIgdmFsdWUgPSBjb21wdXRlZFN0eWxlWyBwcmVmaXgkMSggcHJvcHMgKSBdO1xuICBcdFx0cmV0dXJuIHZhbHVlID09PSAnMHB4JyA/IDAgOiB2YWx1ZTtcbiAgXHR9XG5cbiAgXHRpZiAoICFpc0FycmF5KCBwcm9wcyApICkge1xuICBcdFx0dGhyb3cgbmV3IEVycm9yKCAnVHJhbnNpdGlvbiRnZXRTdHlsZSBtdXN0IGJlIHBhc3NlZCBhIHN0cmluZywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgQ1NTIHByb3BlcnRpZXMnICk7XG4gIFx0fVxuXG4gIFx0dmFyIHN0eWxlcyA9IHt9O1xuXG4gIFx0dmFyIGkgPSBwcm9wcy5sZW5ndGg7XG4gIFx0d2hpbGUgKCBpLS0gKSB7XG4gIFx0XHR2YXIgcHJvcCA9IHByb3BzW2ldO1xuICBcdFx0dmFyIHZhbHVlJDEgPSBjb21wdXRlZFN0eWxlWyBwcmVmaXgkMSggcHJvcCApIF07XG5cbiAgXHRcdGlmICggdmFsdWUkMSA9PT0gJzBweCcgKSB2YWx1ZSQxID0gMDtcbiAgXHRcdHN0eWxlc1sgcHJvcCBdID0gdmFsdWUkMTtcbiAgXHR9XG5cbiAgXHRyZXR1cm4gc3R5bGVzO1xuICB9O1xuXG4gIFRyYW5zaXRpb24ucHJvdG90eXBlLnByb2Nlc3NQYXJhbXMgPSBmdW5jdGlvbiBwcm9jZXNzUGFyYW1zICggcGFyYW1zLCBkZWZhdWx0cyApIHtcbiAgXHRpZiAoIHR5cGVvZiBwYXJhbXMgPT09ICdudW1iZXInICkge1xuICBcdFx0cGFyYW1zID0geyBkdXJhdGlvbjogcGFyYW1zIH07XG4gIFx0fVxuXG4gIFx0ZWxzZSBpZiAoIHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnICkge1xuICBcdFx0aWYgKCBwYXJhbXMgPT09ICdzbG93JyApIHtcbiAgXHRcdFx0cGFyYW1zID0geyBkdXJhdGlvbjogNjAwIH07XG4gIFx0XHR9IGVsc2UgaWYgKCBwYXJhbXMgPT09ICdmYXN0JyApIHtcbiAgXHRcdFx0cGFyYW1zID0geyBkdXJhdGlvbjogMjAwIH07XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRwYXJhbXMgPSB7IGR1cmF0aW9uOiA0MDAgfTtcbiAgXHRcdH1cbiAgXHR9IGVsc2UgaWYgKCAhcGFyYW1zICkge1xuICBcdFx0cGFyYW1zID0ge307XG4gIFx0fVxuXG4gIFx0cmV0dXJuIGV4dGVuZE9iaigge30sIGRlZmF1bHRzLCBwYXJhbXMgKTtcbiAgfTtcblxuICBUcmFuc2l0aW9uLnByb3RvdHlwZS5yZWJpbmRpbmcgPSBmdW5jdGlvbiByZWJpbmRpbmcgKCBuZXh0LCBwcmV2aW91cyApIHtcbiAgXHR2YXIgaWR4ID0gdGhpcy5tb2RlbHMuaW5kZXhPZiggcHJldmlvdXMgKTtcbiAgXHRpZiAoICF+aWR4ICkgcmV0dXJuO1xuXG4gIFx0bmV4dCA9IHJlYmluZE1hdGNoKCB0aGlzLnRlbXBsYXRlLmYuYS5yWyBpZHggXSwgbmV4dCwgcHJldmlvdXMgKTtcbiAgXHRpZiAoIG5leHQgPT09IHByZXZpb3VzICkgcmV0dXJuO1xuXG4gIFx0cHJldmlvdXMudW5yZWdpc3RlciggdGhpcyApO1xuICBcdHRoaXMubW9kZWxzLnNwbGljZSggaWR4LCAxLCBuZXh0ICk7XG4gIFx0aWYgKCBuZXh0ICkgbmV4dC5hZGRTaHVmZmxlUmVnaXN0ZXIoIHRoaXMsICdtYXJrJyApO1xuICB9O1xuXG4gIFRyYW5zaXRpb24ucHJvdG90eXBlLnJlZ2lzdGVyQ29tcGxldGVIYW5kbGVyID0gZnVuY3Rpb24gcmVnaXN0ZXJDb21wbGV0ZUhhbmRsZXIgKCBmbiApIHtcbiAgXHRhZGRUb0FycmF5KCB0aGlzLm9uQ29tcGxldGUsIGZuICk7XG4gIH07XG5cbiAgVHJhbnNpdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICgpIHt9O1xuXG4gIFRyYW5zaXRpb24ucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24gc2V0U3R5bGUgKCBzdHlsZSwgdmFsdWUgKSB7XG4gIFx0aWYgKCB0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnICkge1xuICBcdFx0dGhpcy5vd25lci5ub2RlLnN0eWxlWyBwcmVmaXgkMSggc3R5bGUgKSBdID0gdmFsdWU7XG4gIFx0fVxuXG4gIFx0ZWxzZSB7XG4gIFx0XHR2YXIgcHJvcDtcbiAgXHRcdGZvciAoIHByb3AgaW4gc3R5bGUgKSB7XG4gIFx0XHRcdGlmICggc3R5bGUuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHtcbiAgXHRcdFx0XHR0aGlzLm93bmVyLm5vZGUuc3R5bGVbIHByZWZpeCQxKCBwcm9wICkgXSA9IHN0eWxlWyBwcm9wIF07XG4gIFx0XHRcdH1cbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gdGhpcztcbiAgfTtcblxuICBUcmFuc2l0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0ICgpIHtcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dmFyIG5vZGUgPSB0aGlzLm5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcbiAgXHR2YXIgb3JpZ2luYWxTdHlsZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCAnc3R5bGUnICk7XG5cbiAgXHR2YXIgY29tcGxldGVkO1xuICBcdHZhciBhcmdzID0gdGhpcy5wYXJhbXM7XG5cbiAgXHQvLyBjcmVhdGUgdC5jb21wbGV0ZSgpIC0gd2UgZG9uJ3Qgd2FudCB0aGlzIG9uIHRoZSBwcm90b3R5cGUsXG4gIFx0Ly8gYmVjYXVzZSB3ZSBkb24ndCB3YW50IGB0aGlzYCBzaWxsaW5lc3Mgd2hlbiBwYXNzaW5nIGl0IGFzXG4gIFx0Ly8gYW4gYXJndW1lbnRcbiAgXHR0aGlzLmNvbXBsZXRlID0gZnVuY3Rpb24gKCBub1Jlc2V0ICkge1xuICBcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG4gIFx0XHRcdHJldHVybjtcbiAgXHRcdH1cblxuICBcdFx0dGhpcyQxLm9uQ29tcGxldGUuZm9yRWFjaCggZnVuY3Rpb24gKCBmbiApIHsgcmV0dXJuIGZuKCk7IH0gKTtcbiAgXHRcdGlmICggIW5vUmVzZXQgJiYgdGhpcyQxLmlzSW50cm8gKSB7XG4gIFx0XHRcdHJlc2V0U3R5bGUoIG5vZGUsIG9yaWdpbmFsU3R5bGUpO1xuICBcdFx0fVxuXG4gIFx0XHR0aGlzJDEuX21hbmFnZXIucmVtb3ZlKCB0aGlzJDEgKTtcblxuICBcdFx0Y29tcGxldGVkID0gdHJ1ZTtcbiAgXHR9O1xuXG4gIFx0Ly8gSWYgdGhlIHRyYW5zaXRpb24gZnVuY3Rpb24gZG9lc24ndCBleGlzdCwgYWJvcnRcbiAgXHRpZiAoICF0aGlzLl9mbiApIHtcbiAgXHRcdHRoaXMuY29tcGxldGUoKTtcbiAgXHRcdHJldHVybjtcbiAgXHR9XG5cbiAgXHQvLyBnZXQgZXhwcmVzc2lvbiBhcmdzIGlmIHN1cHBsaWVkXG4gIFx0aWYgKCB0aGlzLmFyZ3NGbiApIHtcbiAgXHRcdHZhciB2YWx1ZXMgPSB0aGlzLm1vZGVscy5tYXAoIGZ1bmN0aW9uICggbW9kZWwgKSB7XG4gIFx0XHRcdGlmICggIW1vZGVsICkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICBcdFx0XHRyZXR1cm4gbW9kZWwuZ2V0KCk7XG4gIFx0XHR9KTtcbiAgXHRcdGFyZ3MgPSB0aGlzLmFyZ3NGbi5hcHBseSggdGhpcy5yYWN0aXZlLCB2YWx1ZXMgKTtcbiAgXHR9XG5cbiAgXHR2YXIgcHJvbWlzZSA9IHRoaXMuX2ZuLmFwcGx5KCB0aGlzLnJhY3RpdmUsIFsgdGhpcyBdLmNvbmNhdCggYXJncyApICk7XG4gIFx0aWYgKCBwcm9taXNlICkgcHJvbWlzZS50aGVuKCB0aGlzLmNvbXBsZXRlICk7XG4gIH07XG5cbiAgVHJhbnNpdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7IHJldHVybiAnJzsgfTtcblxuICBUcmFuc2l0aW9uLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiB1bmJpbmQkMSAoKSB7XG4gIFx0aWYgKCB0aGlzLnJlc29sdmVycyApIHRoaXMucmVzb2x2ZXJzLmZvckVhY2goIHVuYmluZCApO1xuICB9O1xuXG4gIFRyYW5zaXRpb24ucHJvdG90eXBlLnVucmVnaXN0ZXJDb21wbGV0ZUhhbmRsZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyQ29tcGxldGVIYW5kbGVyICggZm4gKSB7XG4gIFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLm9uQ29tcGxldGUsIGZuICk7XG4gIH07XG5cbiAgVHJhbnNpdGlvbi5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiB1bnJlbmRlciAoKSB7fTtcblxuICBUcmFuc2l0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge307XG5cbiAgdmFyIGVsZW1lbnRDYWNoZSA9IHt9O1xuXG4gIHZhciBpZUJ1ZztcbiAgdmFyIGllQmxhY2tsaXN0O1xuXG4gIHRyeSB7XG4gIFx0Y3JlYXRlRWxlbWVudCggJ3RhYmxlJyApLmlubmVySFRNTCA9ICdmb28nO1xuICB9IGNhdGNoICggZXJyICkge1xuICBcdGllQnVnID0gdHJ1ZTtcblxuICBcdGllQmxhY2tsaXN0ID0ge1xuICBcdFx0VEFCTEU6ICBbICc8dGFibGUgY2xhc3M9XCJ4XCI+JywgJzwvdGFibGU+JyBdLFxuICBcdFx0VEhFQUQ6ICBbICc8dGFibGU+PHRoZWFkIGNsYXNzPVwieFwiPicsICc8L3RoZWFkPjwvdGFibGU+JyBdLFxuICBcdFx0VEJPRFk6ICBbICc8dGFibGU+PHRib2R5IGNsYXNzPVwieFwiPicsICc8L3Rib2R5PjwvdGFibGU+JyBdLFxuICBcdFx0VFI6ICAgICBbICc8dGFibGU+PHRyIGNsYXNzPVwieFwiPicsICc8L3RyPjwvdGFibGU+JyBdLFxuICBcdFx0U0VMRUNUOiBbICc8c2VsZWN0IGNsYXNzPVwieFwiPicsICc8L3NlbGVjdD4nIF1cbiAgXHR9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0SHRtbCAoIGh0bWwsIG5vZGUsIGRvY0ZyYWcgKSB7XG4gIFx0dmFyIG5vZGVzID0gW107XG5cbiAgXHQvLyByZW5kZXIgMCBhbmQgZmFsc2VcbiAgXHRpZiAoIGh0bWwgPT0gbnVsbCB8fCBodG1sID09PSAnJyApIHJldHVybiBub2RlcztcblxuICBcdHZhciBjb250YWluZXI7XG4gIFx0dmFyIHdyYXBwZXI7XG4gIFx0dmFyIHNlbGVjdGVkT3B0aW9uO1xuXG4gIFx0aWYgKCBpZUJ1ZyAmJiAoIHdyYXBwZXIgPSBpZUJsYWNrbGlzdFsgbm9kZS50YWdOYW1lIF0gKSApIHtcbiAgXHRcdGNvbnRhaW5lciA9IGVsZW1lbnQoICdESVYnICk7XG4gIFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gd3JhcHBlclswXSArIGh0bWwgKyB3cmFwcGVyWzFdO1xuICBcdFx0Y29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoICcueCcgKTtcblxuICBcdFx0aWYgKCBjb250YWluZXIudGFnTmFtZSA9PT0gJ1NFTEVDVCcgKSB7XG4gIFx0XHRcdHNlbGVjdGVkT3B0aW9uID0gY29udGFpbmVyLm9wdGlvbnNbIGNvbnRhaW5lci5zZWxlY3RlZEluZGV4IF07XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0ZWxzZSBpZiAoIG5vZGUubmFtZXNwYWNlVVJJID09PSBzdmckMSApIHtcbiAgXHRcdGNvbnRhaW5lciA9IGVsZW1lbnQoICdESVYnICk7XG4gIFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmcgY2xhc3M9XCJ4XCI+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgXHRcdGNvbnRhaW5lciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCAnLngnICk7XG4gIFx0fVxuXG4gIFx0ZWxzZSBpZiAoIG5vZGUudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyApIHtcbiAgXHRcdGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cbiAgXHRcdGlmICggdHlwZW9mIGNvbnRhaW5lci50ZXh0Q29udGVudCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gIFx0XHRcdGNvbnRhaW5lci50ZXh0Q29udGVudCA9IGh0bWw7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRlbHNlIHtcbiAgXHRcdGNvbnRhaW5lciA9IGVsZW1lbnQoIG5vZGUudGFnTmFtZSApO1xuICBcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgXHRcdGlmICggY29udGFpbmVyLnRhZ05hbWUgPT09ICdTRUxFQ1QnICkge1xuICBcdFx0XHRzZWxlY3RlZE9wdGlvbiA9IGNvbnRhaW5lci5vcHRpb25zWyBjb250YWluZXIuc2VsZWN0ZWRJbmRleCBdO1xuICBcdFx0fVxuICBcdH1cblxuICBcdHZhciBjaGlsZDtcbiAgXHR3aGlsZSAoIGNoaWxkID0gY29udGFpbmVyLmZpcnN0Q2hpbGQgKSB7XG4gIFx0XHRub2Rlcy5wdXNoKCBjaGlsZCApO1xuICBcdFx0ZG9jRnJhZy5hcHBlbmRDaGlsZCggY2hpbGQgKTtcbiAgXHR9XG5cbiAgXHQvLyBUaGlzIGlzIHJlYWxseSBhbm5veWluZy4gRXh0cmFjdGluZyA8b3B0aW9uPiBub2RlcyBmcm9tIHRoZVxuICBcdC8vIHRlbXBvcmFyeSBjb250YWluZXIgPHNlbGVjdD4gY2F1c2VzIHRoZSByZW1haW5pbmcgb25lcyB0b1xuICBcdC8vIGJlY29tZSBzZWxlY3RlZC4gU28gbm93IHdlIGhhdmUgdG8gZGVzZWxlY3QgdGhlbS4gSUU4LCB5b3VcbiAgXHQvLyBhbWF6ZSBtZS4gWW91IHJlYWxseSBkb1xuICBcdC8vIC4uLmFuZCBub3cgQ2hyb21lIHRvb1xuICBcdHZhciBpO1xuICBcdGlmICggbm9kZS50YWdOYW1lID09PSAnU0VMRUNUJyApIHtcbiAgXHRcdGkgPSBub2Rlcy5sZW5ndGg7XG4gIFx0XHR3aGlsZSAoIGktLSApIHtcbiAgXHRcdFx0aWYgKCBub2Rlc1tpXSAhPT0gc2VsZWN0ZWRPcHRpb24gKSB7XG4gIFx0XHRcdFx0bm9kZXNbaV0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBub2RlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGVsZW1lbnQgKCB0YWdOYW1lICkge1xuICBcdHJldHVybiBlbGVtZW50Q2FjaGVbIHRhZ05hbWUgXSB8fCAoIGVsZW1lbnRDYWNoZVsgdGFnTmFtZSBdID0gY3JlYXRlRWxlbWVudCggdGFnTmFtZSApICk7XG4gIH1cblxuICB2YXIgVHJpcGxlID0gKGZ1bmN0aW9uIChNdXN0YWNoZSkge1xuICBcdGZ1bmN0aW9uIFRyaXBsZSAoIG9wdGlvbnMgKSB7XG4gIFx0XHRNdXN0YWNoZS5jYWxsKCB0aGlzLCBvcHRpb25zICk7XG4gIFx0fVxuXG4gIFx0VHJpcGxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE11c3RhY2hlICYmIE11c3RhY2hlLnByb3RvdHlwZSApO1xuICBcdFRyaXBsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmlwbGU7XG5cbiAgXHRUcmlwbGUucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIGRldGFjaCAoKSB7XG4gIFx0XHR2YXIgZG9jRnJhZyA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgXHRcdHRoaXMubm9kZXMuZm9yRWFjaCggZnVuY3Rpb24gKCBub2RlICkgeyByZXR1cm4gZG9jRnJhZy5hcHBlbmRDaGlsZCggbm9kZSApOyB9ICk7XG4gIFx0XHRyZXR1cm4gZG9jRnJhZztcbiAgXHR9O1xuXG4gIFx0VHJpcGxlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gZmluZCAoIHNlbGVjdG9yICkge1xuICBcdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHZhciBsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgXHRcdHZhciBpO1xuXG4gIFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuICBcdFx0XHR2YXIgbm9kZSA9IHRoaXMkMS5ub2Rlc1tpXTtcblxuICBcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuICBcdFx0XHRpZiAoIG1hdGNoZXMoIG5vZGUsIHNlbGVjdG9yICkgKSByZXR1cm4gbm9kZTtcblxuICBcdFx0XHR2YXIgcXVlcnlSZXN1bHQgPSBub2RlLnF1ZXJ5U2VsZWN0b3IoIHNlbGVjdG9yICk7XG4gIFx0XHRcdGlmICggcXVlcnlSZXN1bHQgKSByZXR1cm4gcXVlcnlSZXN1bHQ7XG4gIFx0XHR9XG5cbiAgXHRcdHJldHVybiBudWxsO1xuICBcdH07XG5cbiAgXHRUcmlwbGUucHJvdG90eXBlLmZpbmRBbGwgPSBmdW5jdGlvbiBmaW5kQWxsICggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuICBcdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdHZhciBsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgXHRcdHZhciBpO1xuXG4gIFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuICBcdFx0XHR2YXIgbm9kZSA9IHRoaXMkMS5ub2Rlc1tpXTtcblxuICBcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuICBcdFx0XHRpZiAoIHF1ZXJ5LnRlc3QoIG5vZGUgKSApIHF1ZXJ5LmFkZCggbm9kZSApO1xuXG4gIFx0XHRcdHZhciBxdWVyeUFsbFJlc3VsdCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCggc2VsZWN0b3IgKTtcbiAgXHRcdFx0aWYgKCBxdWVyeUFsbFJlc3VsdCApIHtcbiAgXHRcdFx0XHR2YXIgbnVtTm9kZXMgPSBxdWVyeUFsbFJlc3VsdC5sZW5ndGg7XG4gIFx0XHRcdFx0dmFyIGo7XG5cbiAgXHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IG51bU5vZGVzOyBqICs9IDEgKSB7XG4gIFx0XHRcdFx0XHRxdWVyeS5hZGQoIHF1ZXJ5QWxsUmVzdWx0W2pdICk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdFRyaXBsZS5wcm90b3R5cGUuZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIGZpbmRDb21wb25lbnQgKCkge1xuICBcdFx0cmV0dXJuIG51bGw7XG4gIFx0fTtcblxuICBcdFRyaXBsZS5wcm90b3R5cGUuZmlyc3ROb2RlID0gZnVuY3Rpb24gZmlyc3ROb2RlICgpIHtcbiAgXHRcdHJldHVybiB0aGlzLm5vZGVzWzBdO1xuICBcdH07XG5cbiAgXHRUcmlwbGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAoIHRhcmdldCApIHtcbiAgXHRcdHZhciBodG1sID0gdGhpcy5tb2RlbCA/IHRoaXMubW9kZWwuZ2V0KCkgOiAnJztcbiAgXHRcdHRoaXMubm9kZXMgPSBpbnNlcnRIdG1sKCBodG1sLCB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmRQYXJlbnROb2RlKCksIHRhcmdldCApO1xuICBcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gIFx0fTtcblxuICBcdFRyaXBsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5tb2RlbCAmJiB0aGlzLm1vZGVsLmdldCgpICE9IG51bGwgPyBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKCAnJyArIHRoaXMubW9kZWwuZ2V0KCkgKSA6ICcnO1xuICBcdH07XG5cbiAgXHRUcmlwbGUucHJvdG90eXBlLnVucmVuZGVyID0gZnVuY3Rpb24gdW5yZW5kZXIgKCkge1xuICBcdFx0aWYgKCB0aGlzLm5vZGVzICkgdGhpcy5ub2Rlcy5mb3JFYWNoKCBmdW5jdGlvbiAoIG5vZGUgKSB7IHJldHVybiBkZXRhY2hOb2RlKCBub2RlICk7IH0gKTtcbiAgXHRcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgXHR9O1xuXG4gIFx0VHJpcGxlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICBcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICYmIHRoaXMuZGlydHkgKSB7XG4gIFx0XHRcdHRoaXMuZGlydHkgPSBmYWxzZTtcblxuICBcdFx0XHR0aGlzLnVucmVuZGVyKCk7XG4gIFx0XHRcdHZhciBkb2NGcmFnID0gY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBcdFx0XHR0aGlzLnJlbmRlciggZG9jRnJhZyApO1xuXG4gIFx0XHRcdHZhciBwYXJlbnROb2RlID0gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kUGFyZW50Tm9kZSgpO1xuICBcdFx0XHR2YXIgYW5jaG9yID0gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblxuICBcdFx0XHRwYXJlbnROb2RlLmluc2VydEJlZm9yZSggZG9jRnJhZywgYW5jaG9yICk7XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHQvLyBtYWtlIHN1cmUgdG8gcmVzZXQgdGhlIGRpcnR5IGZsYWcgZXZlbiBpZiBub3QgcmVuZGVyZWRcbiAgXHRcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuICBcdFx0fVxuICBcdH07XG5cbiAgXHRyZXR1cm4gVHJpcGxlO1xuICB9KE11c3RhY2hlKSk7XG5cbiAgdmFyIFlpZWxkZXIgPSAoZnVuY3Rpb24gKEl0ZW0pIHtcbiAgXHRmdW5jdGlvbiBZaWVsZGVyICggb3B0aW9ucyApIHtcbiAgXHRcdEl0ZW0uY2FsbCggdGhpcywgb3B0aW9ucyApO1xuXG4gIFx0XHR0aGlzLmNvbnRhaW5lciA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQucmFjdGl2ZTtcbiAgXHRcdHRoaXMuY29tcG9uZW50ID0gdGhpcy5jb250YWluZXIuY29tcG9uZW50O1xuXG4gIFx0XHR0aGlzLmNvbnRhaW5lckZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcbiAgXHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSB0aGlzLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblxuICBcdFx0Ly8ge3t5aWVsZH19IGlzIGVxdWl2YWxlbnQgdG8ge3t5aWVsZCBjb250ZW50fX1cbiAgXHRcdHRoaXMubmFtZSA9IG9wdGlvbnMudGVtcGxhdGUubiB8fCAnJztcbiAgXHR9XG5cbiAgXHRZaWVsZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEl0ZW0gJiYgSXRlbS5wcm90b3R5cGUgKTtcbiAgXHRZaWVsZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFlpZWxkZXI7XG5cbiAgXHRZaWVsZGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gYmluZCAoKSB7XG4gIFx0XHR2YXIgbmFtZSA9IHRoaXMubmFtZTtcblxuICBcdFx0KCB0aGlzLmNvbXBvbmVudC55aWVsZGVyc1sgbmFtZSBdIHx8ICggdGhpcy5jb21wb25lbnQueWllbGRlcnNbIG5hbWUgXSA9IFtdICkgKS5wdXNoKCB0aGlzICk7XG5cbiAgXHRcdC8vIFRPRE8gZG9uJ3QgcGFyc2UgaGVyZVxuICBcdFx0dmFyIHRlbXBsYXRlID0gdGhpcy5jb250YWluZXIuX2lubGluZVBhcnRpYWxzWyBuYW1lIHx8ICdjb250ZW50JyBdO1xuXG4gIFx0XHRpZiAoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKSB7XG4gIFx0XHRcdHRlbXBsYXRlID0gcGFyc2UoIHRlbXBsYXRlICkudDtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCAhdGVtcGxhdGUgKSB7XG4gIFx0XHRcdHdhcm5JZkRlYnVnKCAoXCJDb3VsZCBub3QgZmluZCB0ZW1wbGF0ZSBmb3IgcGFydGlhbCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIpLCB7IHJhY3RpdmU6IHRoaXMucmFjdGl2ZSB9KTtcbiAgXHRcdFx0dGVtcGxhdGUgPSBbXTtcbiAgXHRcdH1cblxuICBcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCh7XG4gIFx0XHRcdG93bmVyOiB0aGlzLFxuICBcdFx0XHRyYWN0aXZlOiB0aGlzLmNvbnRhaW5lci5wYXJlbnQsXG4gIFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZVxuICBcdFx0fSkuYmluZCgpO1xuICBcdH07XG5cbiAgXHRZaWVsZGVyLnByb3RvdHlwZS5idWJibGUgPSBmdW5jdGlvbiBidWJibGUgKCkge1xuICBcdFx0aWYgKCAhdGhpcy5kaXJ0eSApIHtcbiAgXHRcdFx0dGhpcy5jb250YWluZXJGcmFnbWVudC5idWJibGUoKTtcbiAgXHRcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG4gIFx0XHR9XG4gIFx0fTtcblxuICBcdFlpZWxkZXIucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIGRldGFjaCAoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcbiAgXHR9O1xuXG4gIFx0WWllbGRlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIGZpbmQgKCBzZWxlY3RvciApIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG4gIFx0fTtcblxuICBcdFlpZWxkZXIucHJvdG90eXBlLmZpbmRBbGwgPSBmdW5jdGlvbiBmaW5kQWxsICggc2VsZWN0b3IsIHF1ZXJ5UmVzdWx0ICkge1xuICBcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnlSZXN1bHQgKTtcbiAgXHR9O1xuXG4gIFx0WWllbGRlci5wcm90b3R5cGUuZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIGZpbmRDb21wb25lbnQgKCBuYW1lICkge1xuICBcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudCggbmFtZSApO1xuICBcdH07XG5cbiAgXHRZaWVsZGVyLnByb3RvdHlwZS5maW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGZpbmRBbGxDb21wb25lbnRzICggbmFtZSwgcXVlcnlSZXN1bHQgKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBuYW1lLCBxdWVyeVJlc3VsdCApO1xuICBcdH07XG5cbiAgXHRZaWVsZGVyLnByb3RvdHlwZS5maW5kTmV4dE5vZGUgPSBmdW5jdGlvbiBmaW5kTmV4dE5vZGUoKSB7XG4gIFx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcbiAgXHR9O1xuXG4gIFx0WWllbGRlci5wcm90b3R5cGUuZmlyc3ROb2RlID0gZnVuY3Rpb24gZmlyc3ROb2RlICggc2tpcFBhcmVudCApIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpcnN0Tm9kZSggc2tpcFBhcmVudCApO1xuICBcdH07XG5cbiAgXHRZaWVsZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKCB0YXJnZXQsIG9jY3VwYW50cyApIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnJlbmRlciggdGFyZ2V0LCBvY2N1cGFudHMgKTtcbiAgXHR9O1xuXG4gIFx0WWllbGRlci5wcm90b3R5cGUuc2V0VGVtcGxhdGUgPSBmdW5jdGlvbiBzZXRUZW1wbGF0ZSAoIG5hbWUgKSB7XG4gIFx0XHR2YXIgdGVtcGxhdGUgPSB0aGlzLnBhcmVudEZyYWdtZW50LnJhY3RpdmUucGFydGlhbHNbIG5hbWUgXTtcblxuICBcdFx0aWYgKCB0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnICkge1xuICBcdFx0XHR0ZW1wbGF0ZSA9IHBhcnNlKCB0ZW1wbGF0ZSApLnQ7XG4gIFx0XHR9XG5cbiAgXHRcdHRoaXMucGFydGlhbFRlbXBsYXRlID0gdGVtcGxhdGUgfHwgW107IC8vIFRPRE8gd2FybiBvbiBtaXNzaW5nIHBhcnRpYWxcbiAgXHR9O1xuXG4gIFx0WWllbGRlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoIGVzY2FwZSApIHtcbiAgXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCBlc2NhcGUgKTtcbiAgXHR9O1xuXG4gIFx0WWllbGRlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gdW5iaW5kICgpIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuY29tcG9uZW50LnlpZWxkZXJzWyB0aGlzLm5hbWUgXSwgdGhpcyApO1xuICBcdH07XG5cbiAgXHRZaWVsZGVyLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uIHVucmVuZGVyICggc2hvdWxkRGVzdHJveSApIHtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKTtcbiAgXHR9O1xuXG4gIFx0WWllbGRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgXHRcdHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgXHRcdHRoaXMuZnJhZ21lbnQudXBkYXRlKCk7XG4gIFx0fTtcblxuICBcdHJldHVybiBZaWVsZGVyO1xuICB9KEl0ZW0pKTtcblxuICAvLyBmaW5kcyB0aGUgY29tcG9uZW50IGNvbnN0cnVjdG9yIGluIHRoZSByZWdpc3RyeSBvciB2aWV3IGhpZXJhcmNoeSByZWdpc3RyaWVzXG4gIGZ1bmN0aW9uIGdldENvbXBvbmVudENvbnN0cnVjdG9yICggcmFjdGl2ZSwgbmFtZSApIHtcbiAgXHR2YXIgaW5zdGFuY2UgPSBmaW5kSW5zdGFuY2UoICdjb21wb25lbnRzJywgcmFjdGl2ZSwgbmFtZSApO1xuICBcdHZhciBDb21wb25lbnQ7XG5cbiAgXHRpZiAoIGluc3RhbmNlICkge1xuICBcdFx0Q29tcG9uZW50ID0gaW5zdGFuY2UuY29tcG9uZW50c1sgbmFtZSBdO1xuXG4gIFx0XHQvLyBiZXN0IHRlc3Qgd2UgaGF2ZSBmb3Igbm90IFJhY3RpdmUuZXh0ZW5kXG4gIFx0XHRpZiAoICFDb21wb25lbnQuX1BhcmVudCApIHtcbiAgXHRcdFx0Ly8gZnVuY3Rpb24gb3B0aW9uLCBleGVjdXRlIGFuZCBzdG9yZSBmb3IgcmVzZXRcbiAgXHRcdFx0dmFyIGZuID0gQ29tcG9uZW50LmJpbmQoIGluc3RhbmNlICk7XG4gIFx0XHRcdGZuLmlzT3duZXIgPSBpbnN0YW5jZS5jb21wb25lbnRzLmhhc093blByb3BlcnR5KCBuYW1lICk7XG4gIFx0XHRcdENvbXBvbmVudCA9IGZuKCk7XG5cbiAgXHRcdFx0aWYgKCAhQ29tcG9uZW50ICkge1xuICBcdFx0XHRcdHdhcm5JZkRlYnVnKCBub1JlZ2lzdHJ5RnVuY3Rpb25SZXR1cm4sIG5hbWUsICdjb21wb25lbnQnLCAnY29tcG9uZW50JywgeyByYWN0aXZlOiByYWN0aXZlIH0pO1xuICBcdFx0XHRcdHJldHVybjtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdGlmICggdHlwZW9mIENvbXBvbmVudCA9PT0gJ3N0cmluZycgKSB7XG4gIFx0XHRcdFx0Ly8gYWxsb3cgc3RyaW5nIGxvb2t1cFxuICBcdFx0XHRcdENvbXBvbmVudCA9IGdldENvbXBvbmVudENvbnN0cnVjdG9yKCByYWN0aXZlLCBDb21wb25lbnQgKTtcbiAgXHRcdFx0fVxuXG4gIFx0XHRcdENvbXBvbmVudC5fZm4gPSBmbjtcbiAgXHRcdFx0aW5zdGFuY2UuY29tcG9uZW50c1sgbmFtZSBdID0gQ29tcG9uZW50O1xuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBDb21wb25lbnQ7XG4gIH1cblxuICB2YXIgY29uc3RydWN0b3JzID0ge307XG4gIGNvbnN0cnVjdG9yc1sgQUxJQVMgXSA9IEFsaWFzO1xuICBjb25zdHJ1Y3RvcnNbIERPQ1RZUEUgXSA9IERvY3R5cGU7XG4gIGNvbnN0cnVjdG9yc1sgSU5URVJQT0xBVE9SIF0gPSBJbnRlcnBvbGF0b3I7XG4gIGNvbnN0cnVjdG9yc1sgUEFSVElBTCBdID0gUGFydGlhbDtcbiAgY29uc3RydWN0b3JzWyBTRUNUSU9OIF0gPSBTZWN0aW9uO1xuICBjb25zdHJ1Y3RvcnNbIFRSSVBMRSBdID0gVHJpcGxlO1xuICBjb25zdHJ1Y3RvcnNbIFlJRUxERVIgXSA9IFlpZWxkZXI7XG5cbiAgY29uc3RydWN0b3JzWyBBVFRSSUJVVEUgXSA9IEF0dHJpYnV0ZTtcbiAgY29uc3RydWN0b3JzWyBCSU5ESU5HX0ZMQUcgXSA9IEJpbmRpbmdGbGFnO1xuICBjb25zdHJ1Y3RvcnNbIERFQ09SQVRPUiBdID0gRGVjb3JhdG9yO1xuICBjb25zdHJ1Y3RvcnNbIEVWRU5UIF0gPSBFdmVudERpcmVjdGl2ZTtcbiAgY29uc3RydWN0b3JzWyBUUkFOU0lUSU9OIF0gPSBUcmFuc2l0aW9uO1xuXG4gIHZhciBzcGVjaWFsRWxlbWVudHMgPSB7XG4gIFx0ZG9jdHlwZTogRG9jdHlwZSxcbiAgXHRmb3JtOiBGb3JtLFxuICBcdGlucHV0OiBJbnB1dCxcbiAgXHRvcHRpb246IE9wdGlvbixcbiAgXHRzZWxlY3Q6IFNlbGVjdCxcbiAgXHR0ZXh0YXJlYTogVGV4dGFyZWFcbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVJdGVtICggb3B0aW9ucyApIHtcbiAgXHRpZiAoIHR5cGVvZiBvcHRpb25zLnRlbXBsYXRlID09PSAnc3RyaW5nJyApIHtcbiAgXHRcdHJldHVybiBuZXcgVGV4dCggb3B0aW9ucyApO1xuICBcdH1cblxuICBcdGlmICggb3B0aW9ucy50ZW1wbGF0ZS50ID09PSBFTEVNRU5UICkge1xuICBcdFx0Ly8gY291bGQgYmUgY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgXHRcdHZhciBDb21wb25lbnRDb25zdHJ1Y3RvciA9IGdldENvbXBvbmVudENvbnN0cnVjdG9yKCBvcHRpb25zLnBhcmVudEZyYWdtZW50LnJhY3RpdmUsIG9wdGlvbnMudGVtcGxhdGUuZSApO1xuICBcdFx0aWYgKCBDb21wb25lbnRDb25zdHJ1Y3RvciApIHtcbiAgXHRcdFx0cmV0dXJuIG5ldyBDb21wb25lbnQoIG9wdGlvbnMsIENvbXBvbmVudENvbnN0cnVjdG9yICk7XG4gIFx0XHR9XG5cbiAgXHRcdHZhciB0YWdOYW1lID0gb3B0aW9ucy50ZW1wbGF0ZS5lLnRvTG93ZXJDYXNlKCk7XG5cbiAgXHRcdHZhciBFbGVtZW50Q29uc3RydWN0b3IgPSBzcGVjaWFsRWxlbWVudHNbIHRhZ05hbWUgXSB8fCBFbGVtZW50O1xuICBcdFx0cmV0dXJuIG5ldyBFbGVtZW50Q29uc3RydWN0b3IoIG9wdGlvbnMgKTtcbiAgXHR9XG5cbiAgXHR2YXIgSXRlbTtcblxuICBcdC8vIGNvbXBvbmVudCBtYXBwaW5ncyBhcmUgYSBzcGVjaWFsIGNhc2Ugb2YgYXR0cmlidXRlXG4gIFx0aWYgKCBvcHRpb25zLnRlbXBsYXRlLnQgPT09IEFUVFJJQlVURSApIHtcbiAgXHRcdHZhciBlbCA9IG9wdGlvbnMub3duZXI7XG4gIFx0XHRpZiAoICFlbCB8fCAoIGVsLnR5cGUgIT09IENPTVBPTkVOVCAmJiBlbC50eXBlICE9PSBFTEVNRU5UICkgKSB7XG4gIFx0XHRcdGVsID0gZmluZEVsZW1lbnQoIG9wdGlvbnMucGFyZW50RnJhZ21lbnQgKTtcbiAgXHRcdH1cbiAgXHRcdG9wdGlvbnMuZWxlbWVudCA9IGVsO1xuXG4gIFx0XHRJdGVtID0gZWwudHlwZSA9PT0gQ09NUE9ORU5UID8gTWFwcGluZyA6IEF0dHJpYnV0ZTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0SXRlbSA9IGNvbnN0cnVjdG9yc1sgb3B0aW9ucy50ZW1wbGF0ZS50IF07XG4gIFx0fVxuXG4gIFx0aWYgKCAhSXRlbSApIHRocm93IG5ldyBFcnJvciggKFwiVW5yZWNvZ25pc2VkIGl0ZW0gdHlwZSBcIiArIChvcHRpb25zLnRlbXBsYXRlLnQpKSApO1xuXG4gIFx0cmV0dXJuIG5ldyBJdGVtKCBvcHRpb25zICk7XG4gIH1cblxuICAvLyBUT0RPIGFsbCB0aGlzIGNvZGUgbmVlZHMgdG8gZGllXG4gIGZ1bmN0aW9uIHByb2Nlc3NJdGVtcyAoIGl0ZW1zLCB2YWx1ZXMsIGd1aWQsIGNvdW50ZXIgKSB7XG4gIFx0aWYgKCBjb3VudGVyID09PSB2b2lkIDAgKSBjb3VudGVyID0gMDtcblxuICBcdHJldHVybiBpdGVtcy5tYXAoIGZ1bmN0aW9uICggaXRlbSApIHtcbiAgXHRcdGlmICggaXRlbS50eXBlID09PSBURVhUICkge1xuICBcdFx0XHRyZXR1cm4gaXRlbS50ZW1wbGF0ZTtcbiAgXHRcdH1cblxuICBcdFx0aWYgKCBpdGVtLmZyYWdtZW50ICkge1xuICBcdFx0XHRpZiAoIGl0ZW0uZnJhZ21lbnQuaXRlcmF0aW9ucyApIHtcbiAgXHRcdFx0XHRyZXR1cm4gaXRlbS5mcmFnbWVudC5pdGVyYXRpb25zLm1hcCggZnVuY3Rpb24gKCBmcmFnbWVudCApIHtcbiAgXHRcdFx0XHRcdHJldHVybiBwcm9jZXNzSXRlbXMoIGZyYWdtZW50Lml0ZW1zLCB2YWx1ZXMsIGd1aWQsIGNvdW50ZXIgKTtcbiAgXHRcdFx0XHR9KS5qb2luKCAnJyApO1xuICBcdFx0XHR9IGVsc2Uge1xuICBcdFx0XHRcdHJldHVybiBwcm9jZXNzSXRlbXMoIGl0ZW0uZnJhZ21lbnQuaXRlbXMsIHZhbHVlcywgZ3VpZCwgY291bnRlciApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG5cbiAgXHRcdHZhciBwbGFjZWhvbGRlcklkID0gXCJcIiArIGd1aWQgKyBcIi1cIiArIChjb3VudGVyKyspO1xuICBcdFx0dmFyIG1vZGVsID0gaXRlbS5tb2RlbCB8fCBpdGVtLm5ld01vZGVsO1xuXG4gIFx0XHR2YWx1ZXNbIHBsYWNlaG9sZGVySWQgXSA9IG1vZGVsID9cbiAgXHRcdFx0bW9kZWwud3JhcHBlciA/XG4gIFx0XHRcdFx0bW9kZWwud3JhcHBlclZhbHVlIDpcbiAgXHRcdFx0XHRtb2RlbC5nZXQoKSA6XG4gIFx0XHRcdHVuZGVmaW5lZDtcblxuICBcdFx0cmV0dXJuICckeycgKyBwbGFjZWhvbGRlcklkICsgJ30nO1xuICBcdH0pLmpvaW4oICcnICk7XG4gIH1cblxuICBmdW5jdGlvbiB1bnJlbmRlckFuZERlc3Ryb3kkMSAoIGl0ZW0gKSB7XG4gIFx0aXRlbS51bnJlbmRlciggdHJ1ZSApO1xuICB9XG5cbiAgdmFyIEZyYWdtZW50ID0gZnVuY3Rpb24gRnJhZ21lbnQgKCBvcHRpb25zICkge1xuICBcdHRoaXMub3duZXIgPSBvcHRpb25zLm93bmVyOyAvLyBUaGUgaXRlbSB0aGF0IG93bnMgdGhpcyBmcmFnbWVudCAtIGFuIGVsZW1lbnQsIHNlY3Rpb24sIHBhcnRpYWwsIG9yIGF0dHJpYnV0ZVxuXG4gIFx0dGhpcy5pc1Jvb3QgPSAhb3B0aW9ucy5vd25lci5wYXJlbnRGcmFnbWVudDtcbiAgXHR0aGlzLnBhcmVudCA9IHRoaXMuaXNSb290ID8gbnVsbCA6IHRoaXMub3duZXIucGFyZW50RnJhZ21lbnQ7XG4gIFx0dGhpcy5yYWN0aXZlID0gb3B0aW9ucy5yYWN0aXZlIHx8ICggdGhpcy5pc1Jvb3QgPyBvcHRpb25zLm93bmVyIDogdGhpcy5wYXJlbnQucmFjdGl2ZSApO1xuXG4gIFx0dGhpcy5jb21wb25lbnRQYXJlbnQgPSAoIHRoaXMuaXNSb290ICYmIHRoaXMucmFjdGl2ZS5jb21wb25lbnQgKSA/IHRoaXMucmFjdGl2ZS5jb21wb25lbnQucGFyZW50RnJhZ21lbnQgOiBudWxsO1xuXG4gIFx0dGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgXHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG5cbiAgXHQvLyBlbmNhcHN1bGF0ZWQgc3R5bGVzIHNob3VsZCBiZSBpbmhlcml0ZWQgdW50aWwgdGhleSBnZXQgYXBwbGllZCBieSBhbiBlbGVtZW50XG4gIFx0dGhpcy5jc3NJZHMgPSAnY3NzSWRzJyBpbiBvcHRpb25zID8gb3B0aW9ucy5jc3NJZHMgOiAoIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuY3NzSWRzIDogbnVsbCApO1xuXG4gIFx0dGhpcy5yZXNvbHZlcnMgPSBbXTtcblxuICBcdHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgXHR0aGlzLmRpcnR5QXJncyA9IHRoaXMuZGlydHlWYWx1ZSA9IHRydWU7IC8vIFRPRE8gZ2V0QXJnc0xpc3QgaXMgbm9uc2Vuc2UgLSBzaG91bGQgZGVwcmVjYXRlIGxlZ2FjeSBkaXJlY3RpdmVzIHN0eWxlXG5cbiAgXHR0aGlzLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZSB8fCBbXTtcbiAgXHR0aGlzLmNyZWF0ZUl0ZW1zKCk7XG4gIH07XG5cbiAgRnJhZ21lbnQucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiBiaW5kJDEkJCAoIGNvbnRleHQgKSB7XG4gIFx0dGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgXHR0aGlzLml0ZW1zLmZvckVhY2goIGJpbmQkMSApO1xuICBcdHRoaXMuYm91bmQgPSB0cnVlO1xuXG4gIFx0Ly8gaW4gcmFyZSBjYXNlcywgYSBmb3JjZWQgcmVzb2x1dGlvbiAob3Igc2ltaWxhcikgd2lsbCBjYXVzZSB0aGVcbiAgXHQvLyBmcmFnbWVudCB0byBiZSBkaXJ0eSBiZWZvcmUgaXQncyBldmVuIGZpbmlzaGVkIGJpbmRpbmcuIEluIHRob3NlXG4gIFx0Ly8gY2FzZXMgd2UgdXBkYXRlIGltbWVkaWF0ZWx5XG4gIFx0aWYgKCB0aGlzLmRpcnR5ICkgdGhpcy51cGRhdGUoKTtcblxuICBcdHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEZyYWdtZW50LnByb3RvdHlwZS5idWJibGUgPSBmdW5jdGlvbiBidWJibGUgKCkge1xuICBcdHRoaXMuZGlydHlBcmdzID0gdGhpcy5kaXJ0eVZhbHVlID0gdHJ1ZTtcblxuICBcdGlmICggIXRoaXMuZGlydHkgKSB7XG4gIFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICBcdFx0aWYgKCB0aGlzLmlzUm9vdCApIHsgLy8gVE9ETyBlbmNhcHN1bGF0ZSAnaXMgY29tcG9uZW50IHJvb3QsIGJ1dCBub3Qgb3ZlcmFsbCByb290JyBjaGVjaz9cbiAgXHRcdFx0aWYgKCB0aGlzLnJhY3RpdmUuY29tcG9uZW50ICkge1xuICBcdFx0XHRcdHRoaXMucmFjdGl2ZS5jb21wb25lbnQuYnViYmxlKCk7XG4gIFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuYm91bmQgKSB7XG4gIFx0XHRcdFx0cnVubG9vcC5hZGRGcmFnbWVudCggdGhpcyApO1xuICBcdFx0XHR9XG4gIFx0XHR9IGVsc2Uge1xuICBcdFx0XHR0aGlzLm93bmVyLmJ1YmJsZSgpO1xuICBcdFx0fVxuICBcdH1cbiAgfTtcblxuICBGcmFnbWVudC5wcm90b3R5cGUuY3JlYXRlSXRlbXMgPSBmdW5jdGlvbiBjcmVhdGVJdGVtcyAoKSB7XG4gIFx0Ly8gdGhpcyBpcyBhIGhvdCBjb2RlIHBhdGhcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dmFyIG1heCA9IHRoaXMudGVtcGxhdGUubGVuZ3RoO1xuICBcdHRoaXMuaXRlbXMgPSBbXTtcbiAgXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtYXg7IGkrKyApIHtcbiAgXHRcdHRoaXMkMS5pdGVtc1tpXSA9IGNyZWF0ZUl0ZW0oeyBwYXJlbnRGcmFnbWVudDogdGhpcyQxLCB0ZW1wbGF0ZTogdGhpcyQxLnRlbXBsYXRlW2ldLCBpbmRleDogaSB9KTtcbiAgXHR9XG4gIH07XG5cbiAgRnJhZ21lbnQucHJvdG90eXBlLmRlc3Ryb3llZCA9IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gIFx0dGhpcy5pdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiAoIGkgKSB7IHJldHVybiBpLmRlc3Ryb3llZCgpOyB9ICk7XG4gIH07XG5cbiAgRnJhZ21lbnQucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIGRldGFjaCAoKSB7XG4gIFx0dmFyIGRvY0ZyYWcgPSBjcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIFx0dGhpcy5pdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiAoIGl0ZW0gKSB7IHJldHVybiBkb2NGcmFnLmFwcGVuZENoaWxkKCBpdGVtLmRldGFjaCgpICk7IH0gKTtcbiAgXHRyZXR1cm4gZG9jRnJhZztcbiAgfTtcblxuICBGcmFnbWVudC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIGZpbmQgKCBzZWxlY3RvciApIHtcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dmFyIGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICBcdHZhciBpO1xuXG4gIFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcbiAgXHRcdHZhciBmb3VuZCA9IHRoaXMkMS5pdGVtc1tpXS5maW5kKCBzZWxlY3RvciApO1xuICBcdFx0aWYgKCBmb3VuZCApIHJldHVybiBmb3VuZDtcbiAgXHR9XG4gIH07XG5cbiAgRnJhZ21lbnQucHJvdG90eXBlLmZpbmRBbGwgPSBmdW5jdGlvbiBmaW5kQWxsICggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHRpZiAoIHRoaXMuaXRlbXMgKSB7XG4gIFx0XHR2YXIgbGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gIFx0XHR2YXIgaTtcblxuICBcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcbiAgXHRcdFx0dmFyIGl0ZW0gPSB0aGlzJDEuaXRlbXNbaV07XG5cbiAgXHRcdFx0aWYgKCBpdGVtLmZpbmRBbGwgKSB7XG4gIFx0XHRcdFx0aXRlbS5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBxdWVyeTtcbiAgfTtcblxuICBGcmFnbWVudC5wcm90b3R5cGUuZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIGZpbmRDb21wb25lbnQgKCBuYW1lICkge1xuICBcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIFx0XHR2YXIgbGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gIFx0dmFyIGk7XG5cbiAgXHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuICBcdFx0dmFyIGZvdW5kID0gdGhpcyQxLml0ZW1zW2ldLmZpbmRDb21wb25lbnQoIG5hbWUgKTtcbiAgXHRcdGlmICggZm91bmQgKSByZXR1cm4gZm91bmQ7XG4gIFx0fVxuICB9O1xuXG4gIEZyYWdtZW50LnByb3RvdHlwZS5maW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGZpbmRBbGxDb21wb25lbnRzICggbmFtZSwgcXVlcnkgKSB7XG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdGlmICggdGhpcy5pdGVtcyApIHtcbiAgXHRcdHZhciBsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgXHRcdHZhciBpO1xuXG4gIFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuICBcdFx0XHR2YXIgaXRlbSA9IHRoaXMkMS5pdGVtc1tpXTtcblxuICBcdFx0XHRpZiAoIGl0ZW0uZmluZEFsbENvbXBvbmVudHMgKSB7XG4gIFx0XHRcdFx0aXRlbS5maW5kQWxsQ29tcG9uZW50cyggbmFtZSwgcXVlcnkgKTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cblxuICBcdHJldHVybiBxdWVyeTtcbiAgfTtcblxuICBGcmFnbWVudC5wcm90b3R5cGUuZmluZENvbnRleHQgPSBmdW5jdGlvbiBmaW5kQ29udGV4dCAoKSB7XG4gIFx0dmFyIGZyYWdtZW50ID0gdGhpcztcbiAgXHR3aGlsZSAoIGZyYWdtZW50ICYmICFmcmFnbWVudC5jb250ZXh0ICkgZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQ7XG4gIFx0aWYgKCAhZnJhZ21lbnQgKSByZXR1cm4gdGhpcy5yYWN0aXZlLnZpZXdtb2RlbDtcbiAgXHRlbHNlIHJldHVybiBmcmFnbWVudC5jb250ZXh0O1xuICB9O1xuXG4gIEZyYWdtZW50LnByb3RvdHlwZS5maW5kTmV4dE5vZGUgPSBmdW5jdGlvbiBmaW5kTmV4dE5vZGUgKCBpdGVtICkge1xuICBcdC8vIHNlYXJjaCBmb3IgdGhlIG5leHQgbm9kZSBnb2luZyBmb3J3YXJkXG4gIFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgXHRcdGlmICggaXRlbSApIHtcbiAgXHRcdGZvciAoIHZhciBpID0gaXRlbS5pbmRleCArIDE7IGkgPCB0aGlzJDEuaXRlbXMubGVuZ3RoOyBpKysgKSB7XG4gIFx0XHRcdGlmICggIXRoaXMkMS5pdGVtc1sgaSBdICkgY29udGludWU7XG5cbiAgXHRcdFx0dmFyIG5vZGUgPSB0aGlzJDEuaXRlbXNbIGkgXS5maXJzdE5vZGUoIHRydWUgKTtcbiAgXHRcdFx0aWYgKCBub2RlICkgcmV0dXJuIG5vZGU7XG4gIFx0XHR9XG4gIFx0fVxuXG4gIFx0Ly8gaWYgdGhpcyBpcyB0aGUgcm9vdCBmcmFnbWVudCwgYW5kIHRoZXJlIGFyZSBubyBtb3JlIGl0ZW1zLFxuICBcdC8vIGl0IG1lYW5zIHdlJ3JlIGF0IHRoZSBlbmQuLi5cbiAgXHRpZiAoIHRoaXMuaXNSb290ICkge1xuICBcdFx0aWYgKCB0aGlzLnJhY3RpdmUuY29tcG9uZW50ICkge1xuICBcdFx0XHRyZXR1cm4gdGhpcy5yYWN0aXZlLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMucmFjdGl2ZS5jb21wb25lbnQgKTtcbiAgXHRcdH1cblxuICBcdFx0Ly8gVE9ETyBwb3NzaWJsZSBlZGdlIGNhc2Ugd2l0aCBvdGhlciBjb250ZW50XG4gIFx0XHQvLyBhcHBlbmRlZCB0byB0aGlzLnJhY3RpdmUuZWw/XG4gIFx0XHRyZXR1cm4gbnVsbDtcbiAgXHR9XG5cbiAgXHRpZiAoIHRoaXMucGFyZW50ICkgcmV0dXJuIHRoaXMub3duZXIuZmluZE5leHROb2RlKCB0aGlzICk7IC8vIHRoZSBhcmd1bWVudCBpcyBpbiBjYXNlIHRoZSBwYXJlbnQgaXMgYSBSZXBlYXRlZEZyYWdtZW50XG4gIH07XG5cbiAgRnJhZ21lbnQucHJvdG90eXBlLmZpbmRQYXJlbnROb2RlID0gZnVuY3Rpb24gZmluZFBhcmVudE5vZGUgKCkge1xuICBcdHZhciBmcmFnbWVudCA9IHRoaXM7XG5cbiAgXHRkbyB7XG4gIFx0XHRpZiAoIGZyYWdtZW50Lm93bmVyLnR5cGUgPT09IEVMRU1FTlQgKSB7XG4gIFx0XHRcdHJldHVybiBmcmFnbWVudC5vd25lci5ub2RlO1xuICBcdFx0fVxuXG4gIFx0XHRpZiAoIGZyYWdtZW50LmlzUm9vdCAmJiAhZnJhZ21lbnQucmFjdGl2ZS5jb21wb25lbnQgKSB7IC8vIFRPRE8gZW5jYXBzdWxhdGUgY2hlY2tcbiAgXHRcdFx0cmV0dXJuIGZyYWdtZW50LnJhY3RpdmUuZWw7XG4gIFx0XHR9XG5cbiAgXHRcdGlmICggZnJhZ21lbnQub3duZXIudHlwZSA9PT0gWUlFTERFUiApIHtcbiAgXHRcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5vd25lci5jb250YWluZXJGcmFnbWVudDtcbiAgXHRcdH0gZWxzZSB7XG4gIFx0XHRcdGZyYWdtZW50ID0gZnJhZ21lbnQuY29tcG9uZW50UGFyZW50IHx8IGZyYWdtZW50LnBhcmVudDsgLy8gVE9ETyB1Z2hcbiAgXHRcdH1cbiAgXHR9IHdoaWxlICggZnJhZ21lbnQgKTtcblxuICBcdHRocm93IG5ldyBFcnJvciggJ0NvdWxkIG5vdCBmaW5kIHBhcmVudCBub2RlJyApOyAvLyBUT0RPIGxpbmsgdG8gaXNzdWUgdHJhY2tlclxuICB9O1xuXG4gIEZyYWdtZW50LnByb3RvdHlwZS5maW5kUmVwZWF0aW5nRnJhZ21lbnQgPSBmdW5jdGlvbiBmaW5kUmVwZWF0aW5nRnJhZ21lbnQgKCkge1xuICBcdHZhciBmcmFnbWVudCA9IHRoaXM7XG4gIFx0Ly8gVE9ETyBiZXR0ZXIgY2hlY2sgdGhhbiBmcmFnbWVudC5wYXJlbnQuaXRlcmF0aW9uc1xuICBcdHdoaWxlICggKCBmcmFnbWVudC5wYXJlbnQgfHwgZnJhZ21lbnQuY29tcG9uZW50UGFyZW50ICkgJiYgIWZyYWdtZW50LmlzSXRlcmF0aW9uICkge1xuICBcdFx0ZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQgfHwgZnJhZ21lbnQuY29tcG9uZW50UGFyZW50O1xuICBcdH1cblxuICBcdHJldHVybiBmcmFnbWVudDtcbiAgfTtcblxuICBGcmFnbWVudC5wcm90b3R5cGUuZmlyc3ROb2RlID0gZnVuY3Rpb24gZmlyc3ROb2RlICggc2tpcFBhcmVudCApIHtcbiAgXHR2YXIgdGhpcyQxID0gdGhpcztcblxuICBcdFx0dmFyIG5vZGU7XG4gIFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcyQxLml0ZW1zLmxlbmd0aDsgaSsrICkge1xuICBcdFx0bm9kZSA9IHRoaXMkMS5pdGVtc1tpXS5maXJzdE5vZGUoIHRydWUgKTtcblxuICBcdFx0aWYgKCBub2RlICkge1xuICBcdFx0XHRyZXR1cm4gbm9kZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRpZiAoIHNraXBQYXJlbnQgKSByZXR1cm4gbnVsbDtcblxuICBcdHJldHVybiB0aGlzLnBhcmVudC5maW5kTmV4dE5vZGUoIHRoaXMub3duZXIgKTtcbiAgfTtcblxuICAvLyBUT0RPIGlkZWFsbHksIHRoaXMgd291bGQgYmUgZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2YgYW5cbiAgLy8gZXhwcmVzc2lvbi1saWtlIGFwcHJvYWNoXG4gIEZyYWdtZW50LnByb3RvdHlwZS5nZXRBcmdzTGlzdCA9IGZ1bmN0aW9uIGdldEFyZ3NMaXN0ICgpIHtcbiAgXHRpZiAoIHRoaXMuZGlydHlBcmdzICkge1xuICBcdFx0dmFyIHZhbHVlcyA9IHt9O1xuICBcdFx0dmFyIHNvdXJjZSA9IHByb2Nlc3NJdGVtcyggdGhpcy5pdGVtcywgdmFsdWVzLCB0aGlzLnJhY3RpdmUuX2d1aWQgKTtcbiAgXHRcdHZhciBwYXJzZWQgPSBwYXJzZUpTT04oICdbJyArIHNvdXJjZSArICddJywgdmFsdWVzICk7XG5cbiAgXHRcdHRoaXMuYXJnc0xpc3QgPSBwYXJzZWQgP1xuICBcdFx0XHRwYXJzZWQudmFsdWUgOlxuICBcdFx0XHRbIHRoaXMudG9TdHJpbmcoKSBdO1xuXG4gIFx0XHR0aGlzLmRpcnR5QXJncyA9IGZhbHNlO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLmFyZ3NMaXN0O1xuICB9O1xuXG4gIEZyYWdtZW50LnByb3RvdHlwZS5yZWJpbmRpbmcgPSBmdW5jdGlvbiByZWJpbmRpbmcgKCBuZXh0ICkge1xuICBcdHRoaXMuY29udGV4dCA9IG5leHQ7XG4gIH07XG5cbiAgRnJhZ21lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAoIHRhcmdldCwgb2NjdXBhbnRzICkge1xuICBcdGlmICggdGhpcy5yZW5kZXJlZCApIHRocm93IG5ldyBFcnJvciggJ0ZyYWdtZW50IGlzIGFscmVhZHkgcmVuZGVyZWQhJyApO1xuICBcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXG4gIFx0dGhpcy5pdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiAoIGl0ZW0gKSB7IHJldHVybiBpdGVtLnJlbmRlciggdGFyZ2V0LCBvY2N1cGFudHMgKTsgfSApO1xuICB9O1xuXG4gIEZyYWdtZW50LnByb3RvdHlwZS5yZXNldFRlbXBsYXRlID0gZnVuY3Rpb24gcmVzZXRUZW1wbGF0ZSAoIHRlbXBsYXRlICkge1xuICBcdHZhciB3YXNCb3VuZCA9IHRoaXMuYm91bmQ7XG4gIFx0dmFyIHdhc1JlbmRlcmVkID0gdGhpcy5yZW5kZXJlZDtcblxuICBcdC8vIFRPRE8gZW5zdXJlIHRyYW5zaXRpb25zIGFyZSBkaXNhYmxlZCBnbG9iYWxseSBkdXJpbmcgcmVzZXRcblxuICBcdGlmICggd2FzQm91bmQgKSB7XG4gIFx0XHRpZiAoIHdhc1JlbmRlcmVkICkgdGhpcy51bnJlbmRlciggdHJ1ZSApO1xuICBcdFx0dGhpcy51bmJpbmQoKTtcbiAgXHR9XG5cbiAgXHR0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gIFx0dGhpcy5jcmVhdGVJdGVtcygpO1xuXG4gIFx0aWYgKCB3YXNCb3VuZCApIHtcbiAgXHRcdHRoaXMuYmluZCggdGhpcy5jb250ZXh0ICk7XG5cbiAgXHRcdGlmICggd2FzUmVuZGVyZWQgKSB7XG4gIFx0XHRcdHZhciBwYXJlbnROb2RlID0gdGhpcy5maW5kUGFyZW50Tm9kZSgpO1xuICBcdFx0XHR2YXIgYW5jaG9yID0gdGhpcy5maW5kTmV4dE5vZGUoKTtcblxuICBcdFx0XHRpZiAoIGFuY2hvciApIHtcbiAgXHRcdFx0XHR2YXIgZG9jRnJhZyA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgXHRcdFx0XHR0aGlzLnJlbmRlciggZG9jRnJhZyApO1xuICBcdFx0XHRcdHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBkb2NGcmFnLCBhbmNob3IgKTtcbiAgXHRcdFx0fSBlbHNlIHtcbiAgXHRcdFx0XHR0aGlzLnJlbmRlciggcGFyZW50Tm9kZSApO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICB9O1xuXG4gIEZyYWdtZW50LnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSAoIHRlbXBsYXRlLCBjYWxsYmFjayApIHtcbiAgXHRpZiAoICF0aGlzLmNvbnRleHQgJiYgdGhpcy5wYXJlbnQucmVzb2x2ZSApIHtcbiAgXHRcdHJldHVybiB0aGlzLnBhcmVudC5yZXNvbHZlKCB0ZW1wbGF0ZSwgY2FsbGJhY2sgKTtcbiAgXHR9XG5cbiAgXHR2YXIgcmVzb2x2ZXIgPSBuZXcgUmVmZXJlbmNlUmVzb2x2ZXIoIHRoaXMsIHRlbXBsYXRlLCBjYWxsYmFjayApO1xuICBcdHRoaXMucmVzb2x2ZXJzLnB1c2goIHJlc29sdmVyICk7XG5cbiAgXHRyZXR1cm4gcmVzb2x2ZXI7IC8vIHNvIHdlIGNhbiBlLmcuIGZvcmNlIHJlc29sdXRpb25cbiAgfTtcblxuICBGcmFnbWVudC5wcm90b3R5cGUuc2h1ZmZsZWQgPSBmdW5jdGlvbiBzaHVmZmxlZCAoKSB7XG4gIFx0dGhpcy5pdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiAoIGkgKSB7IHJldHVybiBpLnNodWZmbGVkKCk7IH0gKTtcbiAgfTtcblxuICBGcmFnbWVudC5wcm90b3R5cGUudG9IdG1sID0gZnVuY3Rpb24gdG9IdG1sICgpIHtcbiAgXHRyZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIEZyYWdtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nJDEkJCAoIGVzY2FwZSApIHtcbiAgXHRyZXR1cm4gdGhpcy5pdGVtcy5tYXAoIGVzY2FwZSA/IHRvRXNjYXBlZFN0cmluZyA6IHRvU3RyaW5nJDEgKS5qb2luKCAnJyApO1xuICB9O1xuXG4gIEZyYWdtZW50LnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiB1bmJpbmQkMSAoKSB7XG4gIFx0dGhpcy5pdGVtcy5mb3JFYWNoKCB1bmJpbmQgKTtcbiAgXHR0aGlzLmJvdW5kID0gZmFsc2U7XG5cbiAgXHRyZXR1cm4gdGhpcztcbiAgfTtcblxuICBGcmFnbWVudC5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiB1bnJlbmRlciQxICggc2hvdWxkRGVzdHJveSApIHtcbiAgXHR0aGlzLml0ZW1zLmZvckVhY2goIHNob3VsZERlc3Ryb3kgPyB1bnJlbmRlckFuZERlc3Ryb3kkMSA6IHVucmVuZGVyICk7XG4gIFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICB9O1xuXG4gIEZyYWdtZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUkMSAoKSB7XG4gIFx0aWYgKCB0aGlzLmRpcnR5ICkge1xuICBcdFx0aWYgKCAhdGhpcy51cGRhdGluZyApIHtcbiAgXHRcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuICBcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcbiAgXHRcdFx0dGhpcy5pdGVtcy5mb3JFYWNoKCB1cGRhdGUgKTtcbiAgXHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuICBcdFx0fSBlbHNlIGlmICggdGhpcy5pc1Jvb3QgKSB7XG4gIFx0XHRcdHJ1bmxvb3AuYWRkRnJhZ21lbnRUb1Jvb3QoIHRoaXMgKTtcbiAgXHRcdH1cbiAgXHR9XG4gIH07XG5cbiAgRnJhZ21lbnQucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiB2YWx1ZU9mICgpIHtcbiAgXHRpZiAoIHRoaXMuaXRlbXMubGVuZ3RoID09PSAxICkge1xuICBcdFx0cmV0dXJuIHRoaXMuaXRlbXNbMF0udmFsdWVPZigpO1xuICBcdH1cblxuICBcdGlmICggdGhpcy5kaXJ0eVZhbHVlICkge1xuICBcdFx0dmFyIHZhbHVlcyA9IHt9O1xuICBcdFx0dmFyIHNvdXJjZSA9IHByb2Nlc3NJdGVtcyggdGhpcy5pdGVtcywgdmFsdWVzLCB0aGlzLnJhY3RpdmUuX2d1aWQgKTtcbiAgXHRcdHZhciBwYXJzZWQgPSBwYXJzZUpTT04oIHNvdXJjZSwgdmFsdWVzICk7XG5cbiAgXHRcdHRoaXMudmFsdWUgPSBwYXJzZWQgP1xuICBcdFx0XHRwYXJzZWQudmFsdWUgOlxuICBcdFx0XHR0aGlzLnRvU3RyaW5nKCk7XG5cbiAgXHRcdHRoaXMuZGlydHlWYWx1ZSA9IGZhbHNlO1xuICBcdH1cblxuICBcdHJldHVybiB0aGlzLnZhbHVlO1xuICB9O1xuXG4gIC8vIFRPRE8gc2hvdWxkIHJlc2V0VGVtcGxhdGUgYmUgYXN5bmNocm9ub3VzPyBpLmUuIHNob3VsZCBpdCBiZSBhIGNhc2VcbiAgLy8gb2Ygb3V0cm8sIHVwZGF0ZSB0ZW1wbGF0ZSwgaW50cm8/IEkgcmVja29uIHByb2JhYmx5IG5vdCwgc2luY2UgdGhhdFxuICAvLyBjb3VsZCBiZSBhY2hpZXZlZCB3aXRoIHVucmVuZGVyLXJlc2V0VGVtcGxhdGUtcmVuZGVyLiBBbHNvLCBpdCBzaG91bGRcbiAgLy8gY29uY2VwdHVhbGx5IGJlIHNpbWlsYXIgdG8gcmVzZXRQYXJ0aWFsLCB3aGljaCBjb3VsZG4ndCBiZSBhc3luY1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkcmVzZXRUZW1wbGF0ZSAoIHRlbXBsYXRlICkge1xuICBcdHRlbXBsYXRlQ29uZmlndXJhdG9yLmluaXQoIG51bGwsIHRoaXMsIHsgdGVtcGxhdGU6IHRlbXBsYXRlIH0pO1xuXG4gIFx0dmFyIHRyYW5zaXRpb25zRW5hYmxlZCA9IHRoaXMudHJhbnNpdGlvbnNFbmFibGVkO1xuICBcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gZmFsc2U7XG5cbiAgXHQvLyBJcyB0aGlzIGlzIGEgY29tcG9uZW50LCB3ZSBuZWVkIHRvIHNldCB0aGUgYHNob3VsZERlc3Ryb3lgXG4gIFx0Ly8gZmxhZywgb3RoZXJ3aXNlIGl0IHdpbGwgYXNzdW1lIGJ5IGRlZmF1bHQgdGhhdCBhIHBhcmVudCBub2RlXG4gIFx0Ly8gd2lsbCBiZSBkZXRhY2hlZCwgYW5kIHRoZXJlZm9yZSBpdCBkb2Vzbid0IG5lZWQgdG8gYm90aGVyXG4gIFx0Ly8gZGV0YWNoaW5nIGl0cyBvd24gbm9kZXNcbiAgXHR2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gIFx0aWYgKCBjb21wb25lbnQgKSBjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IHRydWU7XG4gIFx0dGhpcy51bnJlbmRlcigpO1xuICBcdGlmICggY29tcG9uZW50ICkgY29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSBmYWxzZTtcblxuICBcdC8vIHJlbW92ZSBleGlzdGluZyBmcmFnbWVudCBhbmQgY3JlYXRlIG5ldyBvbmVcbiAgXHR0aGlzLmZyYWdtZW50LnVuYmluZCgpLnVucmVuZGVyKCB0cnVlICk7XG5cbiAgXHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KHtcbiAgXHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuICBcdFx0cm9vdDogdGhpcyxcbiAgXHRcdG93bmVyOiB0aGlzXG4gIFx0fSk7XG5cbiAgXHR2YXIgZG9jRnJhZyA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgXHR0aGlzLmZyYWdtZW50LmJpbmQoIHRoaXMudmlld21vZGVsICkucmVuZGVyKCBkb2NGcmFnICk7XG5cbiAgXHQvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50LCBpdHMgZWwgbWF5IG5vdCBiZSB2YWxpZCwgc28gZmluZCBhXG4gIFx0Ly8gdGFyZ2V0IGJhc2VkIG9uIHRoZSBjb21wb25lbnQgY29udGFpbmVyXG4gIFx0aWYgKCBjb21wb25lbnQgKSB7XG4gIFx0XHR0aGlzLmZyYWdtZW50LmZpbmRQYXJlbnROb2RlKCkuaW5zZXJ0QmVmb3JlKCBkb2NGcmFnLCBjb21wb25lbnQuZmluZE5leHROb2RlKCkgKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0dGhpcy5lbC5pbnNlcnRCZWZvcmUoIGRvY0ZyYWcsIHRoaXMuYW5jaG9yICk7XG4gIFx0fVxuXG4gIFx0dGhpcy50cmFuc2l0aW9uc0VuYWJsZWQgPSB0cmFuc2l0aW9uc0VuYWJsZWQ7XG4gIH1cblxuICB2YXIgcmV2ZXJzZSQxID0gbWFrZUFycmF5TWV0aG9kKCAncmV2ZXJzZScgKS5wYXRoO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkc2V0ICgga2V5cGF0aCwgdmFsdWUgKSB7XG4gIFx0dmFyIHJhY3RpdmUgPSB0aGlzO1xuXG4gIFx0cmV0dXJuIHNldCggcmFjdGl2ZSwgYnVpbGQoIHJhY3RpdmUsIGtleXBhdGgsIHZhbHVlICkgKTtcbiAgfVxuXG4gIHZhciBzaGlmdCQxID0gbWFrZUFycmF5TWV0aG9kKCAnc2hpZnQnICkucGF0aDtcblxuICB2YXIgc29ydCQxID0gbWFrZUFycmF5TWV0aG9kKCAnc29ydCcgKS5wYXRoO1xuXG4gIHZhciBzcGxpY2UkMSA9IG1ha2VBcnJheU1ldGhvZCggJ3NwbGljZScgKS5wYXRoO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkc3VidHJhY3QgKCBrZXlwYXRoLCBkICkge1xuICBcdHJldHVybiBhZGQoIHRoaXMsIGtleXBhdGgsICggZCA9PT0gdW5kZWZpbmVkID8gLTEgOiAtZCApICk7XG4gIH1cblxuICB2YXIgdGVhcmRvd25Ib29rJDEgPSBuZXcgSG9vayggJ3RlYXJkb3duJyApO1xuXG4gIC8vIFRlYXJkb3duLiBUaGlzIGdvZXMgdGhyb3VnaCB0aGUgcm9vdCBmcmFnbWVudCBhbmQgYWxsIGl0cyBjaGlsZHJlbiwgcmVtb3Zpbmcgb2JzZXJ2ZXJzXG4gIC8vIGFuZCBnZW5lcmFsbHkgY2xlYW5pbmcgdXAgYWZ0ZXIgaXRzZWxmXG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSR0ZWFyZG93biAoKSB7XG4gIFx0aWYgKCB0aGlzLnRvcm5kb3duICkge1xuICBcdFx0d2FybklmRGVidWcoICdyYWN0aXZlLnRlYXJkb3duKCkgd2FzIGNhbGxlZCBvbiBhIFJhY3RpdmUgaW5zdGFuY2UgdGhhdCB3YXMgYWxyZWFkeSB0b3JuIGRvd24nICk7XG4gIFx0XHRyZXR1cm4gUHJvbWlzZSQxLnJlc29sdmUoKTtcbiAgXHR9XG5cbiAgXHR0aGlzLnRvcm5kb3duID0gdHJ1ZTtcbiAgXHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuICBcdHRoaXMudmlld21vZGVsLnRlYXJkb3duKCk7XG5cbiAgXHR0aGlzLl9vYnNlcnZlcnMuZm9yRWFjaCggY2FuY2VsICk7XG5cbiAgXHRpZiAoIHRoaXMuZnJhZ21lbnQucmVuZGVyZWQgJiYgdGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gKSB7XG4gIFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzICk7XG4gIFx0fVxuXG4gIFx0dGhpcy5zaG91bGREZXN0cm95ID0gdHJ1ZTtcbiAgXHR2YXIgcHJvbWlzZSA9ICggdGhpcy5mcmFnbWVudC5yZW5kZXJlZCA/IHRoaXMudW5yZW5kZXIoKSA6IFByb21pc2UkMS5yZXNvbHZlKCkgKTtcblxuICBcdHRlYXJkb3duSG9vayQxLmZpcmUoIHRoaXMgKTtcblxuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSR0b2dnbGUgKCBrZXlwYXRoICkge1xuICBcdGlmICggdHlwZW9mIGtleXBhdGggIT09ICdzdHJpbmcnICkge1xuICBcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggYmFkQXJndW1lbnRzICk7XG4gIFx0fVxuXG4gIFx0cmV0dXJuIHNldCggdGhpcywgZ2F0aGVyKCB0aGlzLCBrZXlwYXRoICkubWFwKCBmdW5jdGlvbiAoIG0gKSB7IHJldHVybiBbIG0sICFtLmdldCgpIF07IH0gKSApO1xuICB9XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSR0b0NTUygpIHtcbiAgXHR2YXIgY3NzSWRzID0gWyB0aGlzLmNzc0lkIF0uY29uY2F0KCB0aGlzLmZpbmRBbGxDb21wb25lbnRzKCkubWFwKCBmdW5jdGlvbiAoIGMgKSB7IHJldHVybiBjLmNzc0lkOyB9ICkgKTtcbiAgXHR2YXIgdW5pcXVlQ3NzSWRzID0gT2JqZWN0LmtleXMoY3NzSWRzLnJlZHVjZSggZnVuY3Rpb24gKCBpZHMsIGlkICkgeyByZXR1cm4gKGlkc1tpZF0gPSB0cnVlLCBpZHMpOyB9LCB7fSkpO1xuICBcdHJldHVybiBnZXRDU1MoIHVuaXF1ZUNzc0lkcyApO1xuICB9XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSR0b0hUTUwgKCkge1xuICBcdHJldHVybiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCB0cnVlICk7XG4gIH1cblxuICBmdW5jdGlvbiB0b1RleHQgKCkge1xuICBcdHJldHVybiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCBmYWxzZSApO1xuICB9XG5cbiAgZnVuY3Rpb24gUmFjdGl2ZSR0cmFuc2l0aW9uICggbmFtZSwgbm9kZSwgcGFyYW1zICkge1xuXG4gIFx0aWYgKCBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgKSB7XG4gIFx0XHQvLyBnb29kIHRvIGdvXG4gIFx0fVxuICBcdGVsc2UgaWYgKCBpc09iamVjdCggbm9kZSApICkge1xuICBcdFx0Ly8gb21pdHRlZCwgdXNlIGV2ZW50IG5vZGVcbiAgXHRcdHBhcmFtcyA9IG5vZGU7XG4gIFx0fVxuXG4gIFx0Ly8gaWYgd2UgYWxsb3cgcXVlcnkgc2VsZWN0b3IsIHRoZW4gaXQgd29uJ3Qgd29ya1xuICBcdC8vIHNpbXBsZSBwYXJhbXMgbGlrZSBcImZhc3RcIlxuXG4gIFx0Ly8gZWxzZSBpZiAoIHR5cGVvZiBub2RlID09PSAnc3RyaW5nJyApIHtcbiAgXHQvLyBcdC8vIHF1ZXJ5IHNlbGVjdG9yXG4gIFx0Ly8gXHRub2RlID0gdGhpcy5maW5kKCBub2RlIClcbiAgXHQvLyB9XG5cbiAgXHRub2RlID0gbm9kZSB8fCB0aGlzLmV2ZW50Lm5vZGU7XG5cbiAgXHRpZiAoICFub2RlIHx8ICFub2RlLl9yYWN0aXZlICkge1xuICBcdFx0ZmF0YWwoIChcIk5vIG5vZGUgd2FzIHN1cHBsaWVkIGZvciB0cmFuc2l0aW9uIFwiICsgbmFtZSkgKTtcbiAgXHR9XG5cbiAgXHRwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIFx0dmFyIG93bmVyID0gbm9kZS5fcmFjdGl2ZS5wcm94eTtcbiAgXHR2YXIgdHJhbnNpdGlvbiA9IG5ldyBUcmFuc2l0aW9uKHsgb3duZXI6IG93bmVyLCBwYXJlbnRGcmFnbWVudDogb3duZXIucGFyZW50RnJhZ21lbnQsIG5hbWU6IG5hbWUsIHBhcmFtczogcGFyYW1zIH0pO1xuICBcdHRyYW5zaXRpb24uYmluZCgpO1xuXG4gIFx0dmFyIHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLCB0cnVlICk7XG4gIFx0cnVubG9vcC5yZWdpc3RlclRyYW5zaXRpb24oIHRyYW5zaXRpb24gKTtcbiAgXHRydW5sb29wLmVuZCgpO1xuXG4gIFx0cHJvbWlzZS50aGVuKCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFuc2l0aW9uLnVuYmluZCgpOyB9ICk7XG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiB1bmxpbmskMSggaGVyZSApIHtcbiAgXHR2YXIgcHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoKTtcbiAgXHR0aGlzLnZpZXdtb2RlbC5qb2luQWxsKCBzcGxpdEtleXBhdGhJKCBoZXJlICksIHsgbGFzdExpbms6IGZhbHNlIH0gKS51bmxpbmsoKTtcbiAgXHRydW5sb29wLmVuZCgpO1xuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgdmFyIHVucmVuZGVySG9vayQxID0gbmV3IEhvb2soICd1bnJlbmRlcicgKTtcblxuICBmdW5jdGlvbiBSYWN0aXZlJHVucmVuZGVyICgpIHtcbiAgXHRpZiAoICF0aGlzLmZyYWdtZW50LnJlbmRlcmVkICkge1xuICBcdFx0d2FybklmRGVidWcoICdyYWN0aXZlLnVucmVuZGVyKCkgd2FzIGNhbGxlZCBvbiBhIFJhY3RpdmUgaW5zdGFuY2UgdGhhdCB3YXMgbm90IHJlbmRlcmVkJyApO1xuICBcdFx0cmV0dXJuIFByb21pc2UkMS5yZXNvbHZlKCk7XG4gIFx0fVxuXG4gIFx0dmFyIHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLCB0cnVlICk7XG5cbiAgXHQvLyBJZiB0aGlzIGlzIGEgY29tcG9uZW50LCBhbmQgdGhlIGNvbXBvbmVudCBpc24ndCBtYXJrZWQgZm9yIGRlc3RydWN0aW9uLFxuICBcdC8vIGRvbid0IGRldGFjaCBub2RlcyBmcm9tIHRoZSBET00gdW5uZWNlc3NhcmlseVxuICBcdHZhciBzaG91bGREZXN0cm95ID0gIXRoaXMuY29tcG9uZW50IHx8IHRoaXMuY29tcG9uZW50LnNob3VsZERlc3Ryb3kgfHwgdGhpcy5zaG91bGREZXN0cm95O1xuICBcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKTtcblxuICBcdHJlbW92ZUZyb21BcnJheSggdGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18sIHRoaXMgKTtcblxuICBcdHVucmVuZGVySG9vayQxLmZpcmUoIHRoaXMgKTtcblxuICBcdHJ1bmxvb3AuZW5kKCk7XG4gIFx0cmV0dXJuIHByb21pc2U7XG4gIH1cblxuICB2YXIgdW5zaGlmdCQxID0gbWFrZUFycmF5TWV0aG9kKCAndW5zaGlmdCcgKS5wYXRoO1xuXG4gIGZ1bmN0aW9uIFJhY3RpdmUkdXBkYXRlTW9kZWwgKCBrZXlwYXRoLCBjYXNjYWRlICkge1xuICBcdHZhciBwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXG4gIFx0aWYgKCAha2V5cGF0aCApIHtcbiAgXHRcdHRoaXMudmlld21vZGVsLnVwZGF0ZUZyb21CaW5kaW5ncyggdHJ1ZSApO1xuICBcdH0gZWxzZSB7XG4gIFx0XHR0aGlzLnZpZXdtb2RlbC5qb2luQWxsKCBzcGxpdEtleXBhdGhJKCBrZXlwYXRoICkgKS51cGRhdGVGcm9tQmluZGluZ3MoIGNhc2NhZGUgIT09IGZhbHNlICk7XG4gIFx0fVxuXG4gIFx0cnVubG9vcC5lbmQoKTtcblxuICBcdHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgdmFyIHByb3RvID0ge1xuICBcdGFkZDogUmFjdGl2ZSRhZGQsXG4gIFx0YW5pbWF0ZTogUmFjdGl2ZSRhbmltYXRlLFxuICBcdGRldGFjaDogUmFjdGl2ZSRkZXRhY2gsXG4gIFx0ZmluZDogUmFjdGl2ZSRmaW5kLFxuICBcdGZpbmRBbGw6IFJhY3RpdmUkZmluZEFsbCxcbiAgXHRmaW5kQWxsQ29tcG9uZW50czogUmFjdGl2ZSRmaW5kQWxsQ29tcG9uZW50cyxcbiAgXHRmaW5kQ29tcG9uZW50OiBSYWN0aXZlJGZpbmRDb21wb25lbnQsXG4gIFx0ZmluZENvbnRhaW5lcjogUmFjdGl2ZSRmaW5kQ29udGFpbmVyLFxuICBcdGZpbmRQYXJlbnQ6IFJhY3RpdmUkZmluZFBhcmVudCxcbiAgXHRmaXJlOiBSYWN0aXZlJGZpcmUsXG4gIFx0Z2V0OiBSYWN0aXZlJGdldCxcbiAgXHRnZXROb2RlSW5mbzogZ2V0Tm9kZUluZm8sXG4gIFx0aW5zZXJ0OiBSYWN0aXZlJGluc2VydCxcbiAgXHRsaW5rOiBsaW5rJDEsXG4gIFx0bWVyZ2U6IHRoaXNSYWN0aXZlJG1lcmdlLFxuICBcdG9ic2VydmU6IG9ic2VydmUsXG4gIFx0b2JzZXJ2ZUxpc3Q6IG9ic2VydmVMaXN0LFxuICBcdG9ic2VydmVPbmNlOiBvYnNlcnZlT25jZSxcbiAgXHQvLyBUT0RPIHJlaW5zdGF0ZSB0aGVzZVxuICBcdC8vIG9ic2VydmVMaXN0T25jZSxcbiAgXHRvZmY6IFJhY3RpdmUkb2ZmLFxuICBcdG9uOiBSYWN0aXZlJG9uLFxuICBcdG9uY2U6IFJhY3RpdmUkb25jZSxcbiAgXHRwb3A6IHBvcCQxLFxuICBcdHB1c2g6IHB1c2gkMSxcbiAgXHRyZW5kZXI6IFJhY3RpdmUkcmVuZGVyLFxuICBcdHJlc2V0OiBSYWN0aXZlJHJlc2V0LFxuICBcdHJlc2V0UGFydGlhbDogcmVzZXRQYXJ0aWFsLFxuICBcdHJlc2V0VGVtcGxhdGU6IFJhY3RpdmUkcmVzZXRUZW1wbGF0ZSxcbiAgXHRyZXZlcnNlOiByZXZlcnNlJDEsXG4gIFx0c2V0OiBSYWN0aXZlJHNldCxcbiAgXHRzaGlmdDogc2hpZnQkMSxcbiAgXHRzb3J0OiBzb3J0JDEsXG4gIFx0c3BsaWNlOiBzcGxpY2UkMSxcbiAgXHRzdWJ0cmFjdDogUmFjdGl2ZSRzdWJ0cmFjdCxcbiAgXHR0ZWFyZG93bjogUmFjdGl2ZSR0ZWFyZG93bixcbiAgXHR0b2dnbGU6IFJhY3RpdmUkdG9nZ2xlLFxuICBcdHRvQ1NTOiBSYWN0aXZlJHRvQ1NTLFxuICBcdHRvQ3NzOiBSYWN0aXZlJHRvQ1NTLFxuICBcdHRvSFRNTDogUmFjdGl2ZSR0b0hUTUwsXG4gIFx0dG9IdG1sOiBSYWN0aXZlJHRvSFRNTCxcbiAgXHR0b1RleHQ6IHRvVGV4dCxcbiAgXHR0cmFuc2l0aW9uOiBSYWN0aXZlJHRyYW5zaXRpb24sXG4gIFx0dW5saW5rOiB1bmxpbmskMSxcbiAgXHR1bnJlbmRlcjogUmFjdGl2ZSR1bnJlbmRlcixcbiAgXHR1bnNoaWZ0OiB1bnNoaWZ0JDEsXG4gIFx0dXBkYXRlOiBSYWN0aXZlJHVwZGF0ZSxcbiAgXHR1cGRhdGVNb2RlbDogUmFjdGl2ZSR1cGRhdGVNb2RlbFxuICB9O1xuXG4gIGZ1bmN0aW9uIHdyYXAkMSAoIG1ldGhvZCwgc3VwZXJNZXRob2QsIGZvcmNlICkge1xuXG4gIFx0aWYgKCBmb3JjZSB8fCBuZWVkc1N1cGVyKCBtZXRob2QsIHN1cGVyTWV0aG9kICkgKSAge1xuXG4gIFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG4gIFx0XHRcdHZhciBoYXNTdXBlciA9ICggJ19zdXBlcicgaW4gdGhpcyApLCBfc3VwZXIgPSB0aGlzLl9zdXBlciwgcmVzdWx0O1xuXG4gIFx0XHRcdHRoaXMuX3N1cGVyID0gc3VwZXJNZXRob2Q7XG5cbiAgXHRcdFx0cmVzdWx0ID0gbWV0aG9kLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuICBcdFx0XHRpZiAoIGhhc1N1cGVyICkge1xuICBcdFx0XHRcdHRoaXMuX3N1cGVyID0gX3N1cGVyO1xuICBcdFx0XHR9XG5cbiAgXHRcdFx0cmV0dXJuIHJlc3VsdDtcbiAgXHRcdH07XG4gIFx0fVxuXG4gIFx0ZWxzZSB7XG4gIFx0XHRyZXR1cm4gbWV0aG9kO1xuICBcdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5lZWRzU3VwZXIgKCBtZXRob2QsIHN1cGVyTWV0aG9kICkge1xuICBcdHJldHVybiB0eXBlb2Ygc3VwZXJNZXRob2QgPT09ICdmdW5jdGlvbicgJiYgL19zdXBlci8udGVzdCggbWV0aG9kICk7XG4gIH1cblxuICBmdW5jdGlvbiB1bndyYXAgKCBDaGlsZCApIHtcbiAgXHR2YXIgb3B0aW9ucyA9IHt9O1xuXG4gIFx0d2hpbGUgKCBDaGlsZCApIHtcbiAgXHRcdGFkZFJlZ2lzdHJpZXMoIENoaWxkLCBvcHRpb25zICk7XG4gIFx0XHRhZGRPdGhlck9wdGlvbnMoIENoaWxkLCBvcHRpb25zICk7XG5cbiAgXHRcdGlmICggQ2hpbGQuX1BhcmVudCAhPT0gUmFjdGl2ZSApIHtcbiAgXHRcdFx0Q2hpbGQgPSBDaGlsZC5fUGFyZW50O1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0Q2hpbGQgPSBmYWxzZTtcbiAgXHRcdH1cbiAgXHR9XG5cbiAgXHRyZXR1cm4gb3B0aW9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFJlZ2lzdHJpZXMgKCBDaGlsZCwgb3B0aW9ucyApIHtcbiAgXHRyZWdpc3RyaWVzLmZvckVhY2goIGZ1bmN0aW9uICggciApIHtcbiAgXHRcdGFkZFJlZ2lzdHJ5KFxuICBcdFx0XHRyLnVzZURlZmF1bHRzID8gQ2hpbGQucHJvdG90eXBlIDogQ2hpbGQsXG4gIFx0XHRcdG9wdGlvbnMsIHIubmFtZSApO1xuICBcdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkUmVnaXN0cnkgKCB0YXJnZXQsIG9wdGlvbnMsIG5hbWUgKSB7XG4gIFx0dmFyIHJlZ2lzdHJ5LCBrZXlzID0gT2JqZWN0LmtleXMoIHRhcmdldFsgbmFtZSBdICk7XG5cbiAgXHRpZiAoICFrZXlzLmxlbmd0aCApIHsgcmV0dXJuOyB9XG5cbiAgXHRpZiAoICEoIHJlZ2lzdHJ5ID0gb3B0aW9uc1sgbmFtZSBdICkgKSB7XG4gIFx0XHRyZWdpc3RyeSA9IG9wdGlvbnNbIG5hbWUgXSA9IHt9O1xuICBcdH1cblxuICBcdGtleXNcbiAgXHRcdC5maWx0ZXIoIGZ1bmN0aW9uICgga2V5ICkgeyByZXR1cm4gISgga2V5IGluIHJlZ2lzdHJ5ICk7IH0gKVxuICBcdFx0LmZvckVhY2goIGZ1bmN0aW9uICgga2V5ICkgeyByZXR1cm4gcmVnaXN0cnlbIGtleSBdID0gdGFyZ2V0WyBuYW1lIF1bIGtleSBdOyB9ICk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRPdGhlck9wdGlvbnMgKCBDaGlsZCwgb3B0aW9ucyApIHtcbiAgXHRPYmplY3Qua2V5cyggQ2hpbGQucHJvdG90eXBlICkuZm9yRWFjaCggZnVuY3Rpb24gKCBrZXkgKSB7XG4gIFx0XHRpZiAoIGtleSA9PT0gJ2NvbXB1dGVkJyApIHsgcmV0dXJuOyB9XG5cbiAgXHRcdHZhciB2YWx1ZSA9IENoaWxkLnByb3RvdHlwZVsga2V5IF07XG5cbiAgXHRcdGlmICggISgga2V5IGluIG9wdGlvbnMgKSApIHtcbiAgXHRcdFx0b3B0aW9uc1sga2V5IF0gPSB2YWx1ZS5fbWV0aG9kID8gdmFsdWUuX21ldGhvZCA6IHZhbHVlO1xuICBcdFx0fVxuXG4gIFx0XHQvLyBpcyBpdCBhIHdyYXBwZWQgZnVuY3Rpb24/XG4gIFx0XHRlbHNlIGlmICggdHlwZW9mIG9wdGlvbnNbIGtleSBdID09PSAnZnVuY3Rpb24nXG4gIFx0XHRcdFx0JiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nXG4gIFx0XHRcdFx0JiYgb3B0aW9uc1sga2V5IF0uX21ldGhvZCApIHtcblxuICBcdFx0XHR2YXIgcmVzdWx0LCBuZWVkc1N1cGVyID0gdmFsdWUuX21ldGhvZDtcblxuICBcdFx0XHRpZiAoIG5lZWRzU3VwZXIgKSB7IHZhbHVlID0gdmFsdWUuX21ldGhvZDsgfVxuXG4gIFx0XHRcdC8vIHJld3JhcCBib3VuZCBkaXJlY3RseSB0byBwYXJlbnQgZm5cbiAgXHRcdFx0cmVzdWx0ID0gd3JhcCQxKCBvcHRpb25zWyBrZXkgXS5fbWV0aG9kLCB2YWx1ZSApO1xuXG4gIFx0XHRcdGlmICggbmVlZHNTdXBlciApIHsgcmVzdWx0Ll9tZXRob2QgPSByZXN1bHQ7IH1cblxuICBcdFx0XHRvcHRpb25zWyBrZXkgXSA9IHJlc3VsdDtcbiAgXHRcdH1cbiAgXHR9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZCAoKSB7XG4gIFx0dmFyIG9wdGlvbnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgXHR3aGlsZSAoIGxlbi0tICkgb3B0aW9uc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gIFx0aWYoICFvcHRpb25zLmxlbmd0aCApIHtcbiAgXHRcdHJldHVybiBleHRlbmRPbmUoIHRoaXMgKTtcbiAgXHR9IGVsc2Uge1xuICBcdFx0cmV0dXJuIG9wdGlvbnMucmVkdWNlKCBleHRlbmRPbmUsIHRoaXMgKTtcbiAgXHR9XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmRPbmUgKCBQYXJlbnQsIG9wdGlvbnMgKSB7XG4gIFx0aWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgXHR2YXIgQ2hpbGQsIHByb3RvO1xuXG4gIFx0Ly8gaWYgd2UncmUgZXh0ZW5kaW5nIHdpdGggYW5vdGhlciBSYWN0aXZlIGluc3RhbmNlLi4uXG4gIFx0Ly9cbiAgXHQvLyAgIHZhciBIdW1hbiA9IFJhY3RpdmUuZXh0ZW5kKC4uLiksIFNwaWRlciA9IFJhY3RpdmUuZXh0ZW5kKC4uLik7XG4gIFx0Ly8gICB2YXIgU3BpZGVybWFuID0gSHVtYW4uZXh0ZW5kKCBTcGlkZXIgKTtcbiAgXHQvL1xuICBcdC8vIC4uLmluaGVyaXQgcHJvdG90eXBlIG1ldGhvZHMgYW5kIGRlZmF1bHQgb3B0aW9ucyBhcyB3ZWxsXG4gIFx0aWYgKCBvcHRpb25zLnByb3RvdHlwZSBpbnN0YW5jZW9mIFJhY3RpdmUgKSB7XG4gIFx0XHRvcHRpb25zID0gdW53cmFwKCBvcHRpb25zICk7XG4gIFx0fVxuXG4gIFx0Q2hpbGQgPSBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XG4gIFx0XHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBDaGlsZCApICkgcmV0dXJuIG5ldyBDaGlsZCggb3B0aW9ucyApO1xuXG4gIFx0XHRjb25zdHJ1Y3QoIHRoaXMsIG9wdGlvbnMgfHwge30gKTtcbiAgXHRcdGluaXRpYWxpc2UoIHRoaXMsIG9wdGlvbnMgfHwge30sIHt9ICk7XG4gIFx0fTtcblxuICBcdHByb3RvID0gY3JlYXRlKCBQYXJlbnQucHJvdG90eXBlICk7XG4gIFx0cHJvdG8uY29uc3RydWN0b3IgPSBDaGlsZDtcblxuICBcdC8vIFN0YXRpYyBwcm9wZXJ0aWVzXG4gIFx0ZGVmaW5lUHJvcGVydGllcyggQ2hpbGQsIHtcbiAgXHRcdC8vIGFsaWFzIHByb3RvdHlwZSBhcyBkZWZhdWx0c1xuICBcdFx0ZGVmYXVsdHM6IHsgdmFsdWU6IHByb3RvIH0sXG5cbiAgXHRcdC8vIGV4dGVuZGFibGVcbiAgXHRcdGV4dGVuZDogeyB2YWx1ZTogZXh0ZW5kLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0sXG5cbiAgXHRcdC8vIFBhcmVudCAtIGZvciBJRTgsIGNhbid0IHVzZSBPYmplY3QuZ2V0UHJvdG90eXBlT2ZcbiAgXHRcdF9QYXJlbnQ6IHsgdmFsdWU6IFBhcmVudCB9XG4gIFx0fSk7XG5cbiAgXHQvLyBleHRlbmQgY29uZmlndXJhdGlvblxuICBcdGNvbmZpZy5leHRlbmQoIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKTtcblxuICBcdGRhdGFDb25maWd1cmF0b3IuZXh0ZW5kKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICk7XG5cbiAgXHRpZiAoIG9wdGlvbnMuY29tcHV0ZWQgKSB7XG4gIFx0XHRwcm90by5jb21wdXRlZCA9IGV4dGVuZE9iaiggY3JlYXRlKCBQYXJlbnQucHJvdG90eXBlLmNvbXB1dGVkICksIG9wdGlvbnMuY29tcHV0ZWQgKTtcbiAgXHR9XG5cbiAgXHRDaGlsZC5wcm90b3R5cGUgPSBwcm90bztcblxuICBcdHJldHVybiBDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGpvaW5LZXlzICgpIHtcbiAgXHR2YXIga2V5cyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICBcdHdoaWxlICggbGVuLS0gKSBrZXlzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgXHRyZXR1cm4ga2V5cy5tYXAoIGVzY2FwZUtleSApLmpvaW4oICcuJyApO1xuICB9XG5cbiAgZnVuY3Rpb24gc3BsaXRLZXlwYXRoICgga2V5cGF0aCApIHtcbiAgXHRyZXR1cm4gc3BsaXRLZXlwYXRoSSgga2V5cGF0aCApLm1hcCggdW5lc2NhcGVLZXkgKTtcbiAgfVxuXG4gIC8vIFJhY3RpdmUuanMgbWFrZXMgbGliZXJhbCB1c2Ugb2YgdGhpbmdzIGxpa2UgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuIEluXG4gIC8vIG9sZGVyIGJyb3dzZXJzLCB0aGVzZSBhcmUgbWFkZSBhdmFpbGFibGUgdmlhIGEgc2hpbSAtIGhlcmUsIHdlIGRvIGEgcXVpY2tcbiAgLy8gcHJlLWZsaWdodCBjaGVjayB0byBtYWtlIHN1cmUgdGhhdCBlaXRoZXIgYSkgd2UncmUgbm90IGluIGEgc2hpdCBicm93c2VyLFxuICAvLyBvciBiKSB3ZSdyZSB1c2luZyBhIFJhY3RpdmUtbGVnYWN5LmpzIGJ1aWxkXG4gIHZhciBGVU5DVElPTiA9ICdmdW5jdGlvbic7XG5cbiAgaWYgKFxuICBcdHR5cGVvZiBEYXRlLm5vdyAhPT0gRlVOQ1RJT04gICAgICAgICAgICAgICAgIHx8XG4gIFx0dHlwZW9mIFN0cmluZy5wcm90b3R5cGUudHJpbSAhPT0gRlVOQ1RJT04gICAgfHxcbiAgXHR0eXBlb2YgT2JqZWN0LmtleXMgIT09IEZVTkNUSU9OICAgICAgICAgICAgICB8fFxuICBcdHR5cGVvZiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAhPT0gRlVOQ1RJT04gIHx8XG4gIFx0dHlwZW9mIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoICE9PSBGVU5DVElPTiAgfHxcbiAgXHR0eXBlb2YgQXJyYXkucHJvdG90eXBlLm1hcCAhPT0gRlVOQ1RJT04gICAgICB8fFxuICBcdHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZmlsdGVyICE9PSBGVU5DVElPTiAgIHx8XG4gIFx0KCB3aW4gJiYgdHlwZW9mIHdpbi5hZGRFdmVudExpc3RlbmVyICE9PSBGVU5DVElPTiApXG4gICkge1xuICBcdHRocm93IG5ldyBFcnJvciggJ0l0IGxvb2tzIGxpa2UgeW91XFwncmUgYXR0ZW1wdGluZyB0byB1c2UgUmFjdGl2ZS5qcyBpbiBhbiBvbGRlciBicm93c2VyLiBZb3VcXCdsbCBuZWVkIHRvIHVzZSBvbmUgb2YgdGhlIFxcJ2xlZ2FjeSBidWlsZHNcXCcgaW4gb3JkZXIgdG8gY29udGludWUgLSBzZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvbGVnYWN5LWJ1aWxkcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nICk7XG4gIH1cblxuICBmdW5jdGlvbiBSYWN0aXZlICggb3B0aW9ucyApIHtcbiAgXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBSYWN0aXZlICkgKSByZXR1cm4gbmV3IFJhY3RpdmUoIG9wdGlvbnMgKTtcblxuICBcdGNvbnN0cnVjdCggdGhpcywgb3B0aW9ucyB8fCB7fSApO1xuICBcdGluaXRpYWxpc2UoIHRoaXMsIG9wdGlvbnMgfHwge30sIHt9ICk7XG4gIH1cblxuICBleHRlbmRPYmooIFJhY3RpdmUucHJvdG90eXBlLCBwcm90bywgZGVmYXVsdHMgKTtcbiAgUmFjdGl2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYWN0aXZlO1xuXG4gIC8vIGFsaWFzIHByb3RvdHlwZSBhcyBgZGVmYXVsdHNgXG4gIFJhY3RpdmUuZGVmYXVsdHMgPSBSYWN0aXZlLnByb3RvdHlwZTtcblxuICAvLyBzdGF0aWMgcHJvcGVydGllc1xuICBkZWZpbmVQcm9wZXJ0aWVzKCBSYWN0aXZlLCB7XG5cbiAgXHQvLyBkZWJ1ZyBmbGFnXG4gIFx0REVCVUc6ICAgICAgICAgIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0cnVlIH0sXG4gIFx0REVCVUdfUFJPTUlTRVM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB0cnVlIH0sXG5cbiAgXHQvLyBzdGF0aWMgbWV0aG9kczpcbiAgXHRleHRlbmQ6ICAgICAgICAgeyB2YWx1ZTogZXh0ZW5kIH0sXG4gIFx0ZXNjYXBlS2V5OiAgICAgIHsgdmFsdWU6IGVzY2FwZUtleSB9LFxuICBcdGdldE5vZGVJbmZvOiAgICB7IHZhbHVlOiBzdGF0aWNJbmZvIH0sXG4gIFx0am9pbktleXM6ICAgICAgIHsgdmFsdWU6IGpvaW5LZXlzIH0sXG4gIFx0cGFyc2U6ICAgICAgICAgIHsgdmFsdWU6IHBhcnNlIH0sXG4gIFx0c3BsaXRLZXlwYXRoOiAgIHsgdmFsdWU6IHNwbGl0S2V5cGF0aCB9LFxuICBcdHVuZXNjYXBlS2V5OiAgICB7IHZhbHVlOiB1bmVzY2FwZUtleSB9LFxuICBcdGdldENTUzogICAgICAgICB7IHZhbHVlOiBnZXRDU1MgfSxcblxuICBcdC8vIG5hbWVzcGFjZWQgY29uc3RydWN0b3JzXG4gIFx0UHJvbWlzZTogICAgICAgIHsgdmFsdWU6IFByb21pc2UkMSB9LFxuXG4gIFx0Ly8gc3VwcG9ydFxuICBcdGVuaGFuY2U6ICAgICAgICB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogZmFsc2UgfSxcbiAgXHRzdmc6ICAgICAgICAgICAgeyB2YWx1ZTogc3ZnIH0sXG4gIFx0bWFnaWM6ICAgICAgICAgIHsgdmFsdWU6IG1hZ2ljU3VwcG9ydGVkIH0sXG5cbiAgXHQvLyB2ZXJzaW9uXG4gIFx0VkVSU0lPTjogICAgICAgIHsgdmFsdWU6ICcwLjguNScgfSxcblxuICBcdC8vIHBsdWdpbnNcbiAgXHRhZGFwdG9yczogICAgICAgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0Y29tcG9uZW50czogICAgIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuICBcdGRlY29yYXRvcnM6ICAgICB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcbiAgXHRlYXNpbmc6ICAgICAgICAgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGVhc2luZyB9LFxuICBcdGV2ZW50czogICAgICAgICB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcbiAgXHRpbnRlcnBvbGF0b3JzOiAgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGludGVycG9sYXRvcnMgfSxcbiAgXHRwYXJ0aWFsczogICAgICAgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG4gIFx0dHJhbnNpdGlvbnM6ICAgIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9XG4gIH0pO1xuXG4gIHJldHVybiBSYWN0aXZlO1xuXG59KSk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICBpbnZva2UgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIgfHxcbiAgICAgICAgICAgICAgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiICYmIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIC8vIEEgcmV0dXJuIG9yIHRocm93ICh3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gdGhyb3dcbiAgICAgICAgICAgIC8vIG1ldGhvZCkgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICAgIHZhciByZXR1cm5NZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5NZXRob2QpIHtcbiAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKHJldHVybk1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJldHVybiBtZXRob2QgdGhyZXcgYW4gZXhjZXB0aW9uLCBsZXQgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiBwcmV2YWlsIG92ZXIgdGhlIG9yaWdpbmFsIHJldHVybiBvciB0aHJvdy5cbiAgICAgICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIG91dGVyIHJldHVybiwgbm93IHRoYXQgdGhlIGRlbGVnYXRlXG4gICAgICAgICAgICAgIC8vIGl0ZXJhdG9yIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0sXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvcixcbiAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIExpa2UgcmV0dXJuaW5nIGdlbmVyYXRvci50aHJvdyh1bmNhdWdodCksIGJ1dCB3aXRob3V0IHRoZVxuICAgICAgICAgICAgLy8gb3ZlcmhlYWQgb2YgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5kZWxlZ2F0ZSAmJiBtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjo0LFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcImhlYWRlclwiLFwibVwiOlt7XCJuXCI6XCJoZWFkZXJJZFwiLFwiZlwiOlwiaGVhZGVyLWhvbWVwYWdlXCIsXCJ0XCI6MTN9XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJuYXZiYXJcIn0sXCIgXCIse1widFwiOjQsXCJmXCI6W3tcInRcIjo3LFwiZVwiOlwibmV3c2xldHRlckZvcm1cIn1dLFwiclwiOlwibmV3c2xldHRlckZvcm0uc2hvd1wifV19IiwibW9kdWxlLmV4cG9ydHM9e1widlwiOjQsXCJ0XCI6W3tcInRcIjo3LFwiZVwiOlwiZGl2XCIsXCJtXCI6W3tcIm5cIjpcImNsYXNzXCIsXCJmXCI6XCJoZWFkZXJcIixcInRcIjoxM31dLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcImgxXCIsXCJtXCI6W3tcIm5cIjpcImlkXCIsXCJmXCI6W3tcInRcIjoyLFwiclwiOlwiaGVhZGVySWRcIn1dLFwidFwiOjEzfV0sXCJmXCI6W3tcInRcIjoyLFwiclwiOlwiaTE4bi5oZWFkZXIudGV4dFwifV19XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjo0LFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwibVwiOlt7XCJuXCI6XCJjbGFzc1wiLFwiZlwiOlwibmF2YmFyXCIsXCJ0XCI6MTN9XSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJpbnB1dFwiLFwibVwiOlt7XCJuXCI6XCJ0eXBlXCIsXCJmXCI6XCJidXR0b25cIixcInRcIjoxM30se1wiblwiOlwiY2xpY2tcIixcImZcIjpcInNob3dOZXdzbGV0dGVyRm9ybVwiLFwidFwiOjcwfSx7XCJuXCI6XCJ2YWx1ZVwiLFwiZlwiOlt7XCJ0XCI6MixcInJcIjpcImkxOG4ubmF2YmFyLm5ld3NsZXR0ZXJCdXR0b25cIn1dLFwidFwiOjEzfV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwic2VsZWN0XCIsXCJtXCI6W3tcIm5cIjpcImNoYW5nZVwiLFwiZlwiOlwic2V0TGFuZ3VhZ2VcIixcInRcIjo3MH1dLFwiZlwiOlt7XCJ0XCI6NyxcImVcIjpcIm9wdGlvblwiLFwibVwiOlt7XCJuXCI6XCJpZFwiLFwiZlwiOlwiZW5cIixcInRcIjoxM31dLFwiZlwiOltcIkVuZ2xpc2hcIl19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwib3B0aW9uXCIsXCJtXCI6W3tcIm5cIjpcImlkXCIsXCJmXCI6XCJkZVwiLFwidFwiOjEzfV0sXCJmXCI6W1wiRGV1dHNjaFwiXX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJvcHRpb25cIixcIm1cIjpbe1wiblwiOlwiaWRcIixcImZcIjpcIm5sXCIsXCJ0XCI6MTN9XSxcImZcIjpbXCJOZWRlcmxhbmRzXCJdfV19XX1dfSIsIm1vZHVsZS5leHBvcnRzPXtcInZcIjo0LFwidFwiOlt7XCJ0XCI6NyxcImVcIjpcImRpdlwiLFwibVwiOlt7XCJuXCI6XCJjbGFzc1wiLFwiZlwiOlwibmV3c2xldHRlci1mb3JtXCIsXCJ0XCI6MTN9XSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJkaXZcIixcIm1cIjpbe1wiblwiOlwiY2xhc3NcIixcImZcIjpcIm5ld3NsZXR0ZXItZm9ybS10ZXh0XCIsXCJ0XCI6MTN9XSxcImZcIjpbe1widFwiOjIsXCJyXCI6XCJpMThuLm5ld3NsZXR0ZXJGb3JtLmJvZHlcIn1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImZvcm1cIixcIm1cIjpbe1wiblwiOlwiY2xhc3NcIixcImZcIjpcInB1cmUtZm9ybS1zdGFja2VkXCIsXCJ0XCI6MTN9XSxcImZcIjpbe1widFwiOjcsXCJlXCI6XCJsYWJlbFwiLFwiZlwiOlt7XCJ0XCI6MixcInJcIjpcImkxOG4ubmV3c2xldHRlckZvcm0udGl0bGVFbWFpbFwifSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImlucHV0XCIsXCJtXCI6W3tcIm5cIjpcInR5cGVcIixcImZcIjpcImVtYWlsXCIsXCJ0XCI6MTN9LHtcIm5cIjpcInBsYWNlaG9sZGVyXCIsXCJmXCI6XCJcIixcInRcIjoxM31dfV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwibGFiZWxcIixcImZcIjpbe1widFwiOjIsXCJyXCI6XCJpMThuLm5ld3NsZXR0ZXJGb3JtLnRpdGxlRmlyc3ROYW1lXCJ9LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiaW5wdXRcIixcIm1cIjpbe1wiblwiOlwidHlwZVwiLFwiZlwiOlwidGV4dFwiLFwidFwiOjEzfSx7XCJuXCI6XCJwbGFjZWhvbGRlclwiLFwiZlwiOlwiXCIsXCJ0XCI6MTN9XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxhYmVsXCIsXCJmXCI6W3tcInRcIjoyLFwiclwiOlwiaTE4bi5uZXdzbGV0dGVyRm9ybS50aXRsZUxhc3ROYW1lXCJ9LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiaW5wdXRcIixcIm1cIjpbe1wiblwiOlwidHlwZVwiLFwiZlwiOlwidGV4dFwiLFwidFwiOjEzfSx7XCJuXCI6XCJwbGFjZWhvbGRlclwiLFwiZlwiOlwiXCIsXCJ0XCI6MTN9XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxhYmVsXCIsXCJmXCI6W3tcInRcIjoyLFwiclwiOlwiaTE4bi5uZXdzbGV0dGVyRm9ybS50aXRsZUxhbmd1YWdlXCJ9XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJsYWJlbFwiLFwiZlwiOlt7XCJ0XCI6MixcInJcIjpcImkxOG4ubmV3c2xldHRlckZvcm0ubGFuZ3VhZ2VzLmRlXCJ9LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiaW5wdXRcIixcIm1cIjpbe1wiblwiOlwidHlwZVwiLFwiZlwiOlwicmFkaW9cIixcInRcIjoxM31dfV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwibGFiZWxcIixcImZcIjpbe1widFwiOjIsXCJyXCI6XCJpMThuLm5ld3NsZXR0ZXJGb3JtLmxhbmd1YWdlcy5lblwifSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImlucHV0XCIsXCJtXCI6W3tcIm5cIjpcInR5cGVcIixcImZcIjpcInJhZGlvXCIsXCJ0XCI6MTN9XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxhYmVsXCIsXCJmXCI6W3tcInRcIjoyLFwiclwiOlwiaTE4bi5uZXdzbGV0dGVyRm9ybS5sYW5ndWFnZXMubmxcIn0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJpbnB1dFwiLFwibVwiOlt7XCJuXCI6XCJ0eXBlXCIsXCJmXCI6XCJyYWRpb1wiLFwidFwiOjEzfV19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJsYWJlbFwiLFwiZlwiOlt7XCJ0XCI6MixcInJcIjpcImkxOG4ubmV3c2xldHRlckZvcm0ubGFuZ3VhZ2VzLmVzXCJ9LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwiaW5wdXRcIixcIm1cIjpbe1wiblwiOlwidHlwZVwiLFwiZlwiOlwicmFkaW9cIixcInRcIjoxM31dfV19LFwiIFwiLHtcInRcIjo3LFwiZVwiOlwibGFiZWxcIixcImZcIjpbe1widFwiOjIsXCJyXCI6XCJpMThuLm5ld3NsZXR0ZXJGb3JtLmxhbmd1YWdlcy5mclwifSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImlucHV0XCIsXCJtXCI6W3tcIm5cIjpcInR5cGVcIixcImZcIjpcInJhZGlvXCIsXCJ0XCI6MTN9XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxhYmVsXCIsXCJmXCI6W3tcInRcIjoyLFwiclwiOlwiaTE4bi5uZXdzbGV0dGVyRm9ybS50aXRsZUNvdW50cnlcIn0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJpbnB1dFwiLFwibVwiOlt7XCJuXCI6XCJ0eXBlXCIsXCJmXCI6XCJpbnB1dFwiLFwidFwiOjEzfV19XX0sXCIgXCIse1widFwiOjcsXCJlXCI6XCJsYWJlbFwiLFwiZlwiOlt7XCJ0XCI6MixcInJcIjpcImkxOG4ubmV3c2xldHRlckZvcm0udGl0bGVHZW5kZXJcIn1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxhYmVsXCIsXCJmXCI6W3tcInRcIjoyLFwiclwiOlwiaTE4bi5uZXdzbGV0dGVyRm9ybS5nZW5kZXIubVwifSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImlucHV0XCIsXCJtXCI6W3tcIm5cIjpcInR5cGVcIixcImZcIjpcInJhZGlvXCIsXCJ0XCI6MTN9XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImxhYmVsXCIsXCJmXCI6W3tcInRcIjoyLFwiclwiOlwiaTE4bi5uZXdzbGV0dGVyRm9ybS5nZW5kZXIuZlwifSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImlucHV0XCIsXCJtXCI6W3tcIm5cIjpcInR5cGVcIixcImZcIjpcInJhZGlvXCIsXCJ0XCI6MTN9XX1dfSxcIiBcIix7XCJ0XCI6NyxcImVcIjpcImlucHV0XCIsXCJtXCI6W3tcIm5cIjpcInR5cGVcIixcImZcIjpcImJ1dHRvblwiLFwidFwiOjEzfSx7XCJuXCI6XCJjbGlja1wiLFwiZlwiOlwidmFsaWRhdGVGb3JtXCIsXCJ0XCI6NzB9LHtcIm5cIjpcInZhbHVlXCIsXCJmXCI6W3tcInRcIjoyLFwiclwiOlwiaTE4bi5uZXdzbGV0dGVyRm9ybS5idXR0b25TdWJtaXRcIn1dLFwidFwiOjEzfV19XX1dfV19Il19
